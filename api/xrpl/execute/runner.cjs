#!/usr/bin/env node
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) =>
  function __require() {
    return (
      mod ||
        (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod),
      mod.exports
    );
  };
var __copyProps = (to, from, except, desc) => {
  if ((from && typeof from === "object") || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, {
          get: () => from[key],
          enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable,
        });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (
  (target = mod != null ? __create(__getProtoOf(mod)) : {}),
  __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule
      ? __defProp(target, "default", { value: mod, enumerable: true })
      : target,
    mod
  )
);

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports2, module2) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {}
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once),
        evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        (emitter._events[evt] = listener), emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      var names = [],
        events,
        name;
      if (this._eventsCount === 0) return names;
      for (name in (events = this._events)) {
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event,
        handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event,
        listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt],
        len = arguments.length,
        args,
        i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return (
              listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true
            );
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length,
          j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter.prototype.removeListener = function removeListener(
      event,
      fn,
      context,
      once
    ) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (
          listeners.fn === fn &&
          (!once || listeners.once) &&
          (!context || listeners.context === context)
        ) {
          clearEvent(this, evt);
        }
      } else {
        for (
          var i = 0, events = [], length = listeners.length;
          i < length;
          i++
        ) {
          if (
            listeners[i].fn !== fn ||
            (once && !listeners[i].once) ||
            (context && listeners[i].context !== context)
          ) {
            events.push(listeners[i]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(
      event
    ) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.addListener = EventEmitter.prototype.on;
    EventEmitter.prefixed = prefix;
    EventEmitter.EventEmitter = EventEmitter;
    if ("undefined" !== typeof module2) {
      module2.exports = EventEmitter;
    }
  },
});

// node_modules/xrpl/dist/npm/errors.js
var require_errors = __commonJS({
  "node_modules/xrpl/dist/npm/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.XRPLFaucetError =
      exports2.NotFoundError =
      exports2.ValidationError =
      exports2.ResponseFormatError =
      exports2.TimeoutError =
      exports2.RippledNotInitializedError =
      exports2.DisconnectedError =
      exports2.NotConnectedError =
      exports2.RippledError =
      exports2.ConnectionError =
      exports2.UnexpectedError =
      exports2.XrplError =
        void 0;
    var XrplError = class extends Error {
      constructor(message = "", data) {
        super(message);
        this.name = this.constructor.name;
        this.message = message;
        this.data = data;
        if (Error.captureStackTrace != null) {
          Error.captureStackTrace(this, this.constructor);
        }
      }
      toString() {
        let result = `[${this.name}(${this.message}`;
        if (this.data) {
          result += `, ${JSON.stringify(this.data)}`;
        }
        result += ")]";
        return result;
      }
      inspect() {
        return this.toString();
      }
    };
    exports2.XrplError = XrplError;
    var RippledError = class extends XrplError {};
    exports2.RippledError = RippledError;
    var UnexpectedError = class extends XrplError {};
    exports2.UnexpectedError = UnexpectedError;
    var ConnectionError = class extends XrplError {};
    exports2.ConnectionError = ConnectionError;
    var NotConnectedError = class extends ConnectionError {};
    exports2.NotConnectedError = NotConnectedError;
    var DisconnectedError = class extends ConnectionError {};
    exports2.DisconnectedError = DisconnectedError;
    var RippledNotInitializedError = class extends ConnectionError {};
    exports2.RippledNotInitializedError = RippledNotInitializedError;
    var TimeoutError = class extends ConnectionError {};
    exports2.TimeoutError = TimeoutError;
    var ResponseFormatError = class extends ConnectionError {};
    exports2.ResponseFormatError = ResponseFormatError;
    var ValidationError = class extends XrplError {};
    exports2.ValidationError = ValidationError;
    var XRPLFaucetError = class extends XrplError {};
    exports2.XRPLFaucetError = XRPLFaucetError;
    var NotFoundError = class extends XrplError {
      constructor(message = "Not found") {
        super(message);
      }
    };
    exports2.NotFoundError = NotFoundError;
  },
});

// node_modules/xrpl/dist/npm/models/ledger/AccountRoot.js
var require_AccountRoot = __commonJS({
  "node_modules/xrpl/dist/npm/models/ledger/AccountRoot.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AccountRootFlags = void 0;
    var AccountRootFlags;
    (function (AccountRootFlags2) {
      AccountRootFlags2[(AccountRootFlags2["lsfPasswordSpent"] = 65536)] =
        "lsfPasswordSpent";
      AccountRootFlags2[(AccountRootFlags2["lsfRequireDestTag"] = 131072)] =
        "lsfRequireDestTag";
      AccountRootFlags2[(AccountRootFlags2["lsfRequireAuth"] = 262144)] =
        "lsfRequireAuth";
      AccountRootFlags2[(AccountRootFlags2["lsfDisallowXRP"] = 524288)] =
        "lsfDisallowXRP";
      AccountRootFlags2[(AccountRootFlags2["lsfDisableMaster"] = 1048576)] =
        "lsfDisableMaster";
      AccountRootFlags2[(AccountRootFlags2["lsfNoFreeze"] = 2097152)] =
        "lsfNoFreeze";
      AccountRootFlags2[(AccountRootFlags2["lsfGlobalFreeze"] = 4194304)] =
        "lsfGlobalFreeze";
      AccountRootFlags2[(AccountRootFlags2["lsfDefaultRipple"] = 8388608)] =
        "lsfDefaultRipple";
      AccountRootFlags2[(AccountRootFlags2["lsfDepositAuth"] = 16777216)] =
        "lsfDepositAuth";
      AccountRootFlags2[(AccountRootFlags2["lsfAMM"] = 33554432)] = "lsfAMM";
      AccountRootFlags2[
        (AccountRootFlags2["lsfDisallowIncomingNFTokenOffer"] = 67108864)
      ] = "lsfDisallowIncomingNFTokenOffer";
      AccountRootFlags2[
        (AccountRootFlags2["lsfDisallowIncomingCheck"] = 134217728)
      ] = "lsfDisallowIncomingCheck";
      AccountRootFlags2[
        (AccountRootFlags2["lsfDisallowIncomingPayChan"] = 268435456)
      ] = "lsfDisallowIncomingPayChan";
      AccountRootFlags2[
        (AccountRootFlags2["lsfDisallowIncomingTrustline"] = 536870912)
      ] = "lsfDisallowIncomingTrustline";
      AccountRootFlags2[
        (AccountRootFlags2["lsfAllowTrustLineClawback"] = 2147483648)
      ] = "lsfAllowTrustLineClawback";
    })(AccountRootFlags || (exports2.AccountRootFlags = AccountRootFlags = {}));
  },
});

// node_modules/@noble/hashes/cryptoNode.js
var require_cryptoNode = __commonJS({
  "node_modules/@noble/hashes/cryptoNode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.crypto = void 0;
    var nc = require("node:crypto");
    exports2.crypto =
      nc && typeof nc === "object" && "webcrypto" in nc
        ? nc.webcrypto
        : nc && typeof nc === "object" && "randomBytes" in nc
        ? nc
        : void 0;
  },
});

// node_modules/@noble/hashes/utils.js
var require_utils = __commonJS({
  "node_modules/@noble/hashes/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.wrapXOFConstructorWithOpts =
      exports2.wrapConstructorWithOpts =
      exports2.wrapConstructor =
      exports2.Hash =
      exports2.nextTick =
      exports2.swap32IfBE =
      exports2.byteSwapIfBE =
      exports2.swap8IfBE =
      exports2.isLE =
        void 0;
    exports2.isBytes = isBytes;
    exports2.anumber = anumber;
    exports2.abytes = abytes;
    exports2.ahash = ahash;
    exports2.aexists = aexists;
    exports2.aoutput = aoutput;
    exports2.u8 = u8;
    exports2.u32 = u32;
    exports2.clean = clean;
    exports2.createView = createView;
    exports2.rotr = rotr;
    exports2.rotl = rotl;
    exports2.byteSwap = byteSwap;
    exports2.byteSwap32 = byteSwap32;
    exports2.bytesToHex = bytesToHex;
    exports2.hexToBytes = hexToBytes;
    exports2.asyncLoop = asyncLoop;
    exports2.utf8ToBytes = utf8ToBytes;
    exports2.bytesToUtf8 = bytesToUtf8;
    exports2.toBytes = toBytes;
    exports2.kdfInputToBytes = kdfInputToBytes;
    exports2.concatBytes = concatBytes;
    exports2.checkOpts = checkOpts;
    exports2.createHasher = createHasher;
    exports2.createOptHasher = createOptHasher;
    exports2.createXOFer = createXOFer;
    exports2.randomBytes = randomBytes;
    var crypto_1 = require_cryptoNode();
    function isBytes(a) {
      return (
        a instanceof Uint8Array ||
        (ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array")
      );
    }
    function anumber(n) {
      if (!Number.isSafeInteger(n) || n < 0)
        throw new Error("positive integer expected, got " + n);
    }
    function abytes(b, ...lengths) {
      if (!isBytes(b)) throw new Error("Uint8Array expected");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error(
          "Uint8Array expected of length " +
            lengths +
            ", got length=" +
            b.length
        );
    }
    function ahash(h) {
      if (typeof h !== "function" || typeof h.create !== "function")
        throw new Error("Hash should be wrapped by utils.createHasher");
      anumber(h.outputLen);
      anumber(h.blockLen);
    }
    function aexists(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    function aoutput(out, instance) {
      abytes(out);
      const min = instance.outputLen;
      if (out.length < min) {
        throw new Error(
          "digestInto() expects output buffer of length at least " + min
        );
      }
    }
    function u8(arr) {
      return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    }
    function u32(arr) {
      return new Uint32Array(
        arr.buffer,
        arr.byteOffset,
        Math.floor(arr.byteLength / 4)
      );
    }
    function clean(...arrays) {
      for (let i = 0; i < arrays.length; i++) {
        arrays[i].fill(0);
      }
    }
    function createView(arr) {
      return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    }
    function rotr(word, shift) {
      return (word << (32 - shift)) | (word >>> shift);
    }
    function rotl(word, shift) {
      return (word << shift) | ((word >>> (32 - shift)) >>> 0);
    }
    exports2.isLE = (() =>
      new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
    function byteSwap(word) {
      return (
        ((word << 24) & 4278190080) |
        ((word << 8) & 16711680) |
        ((word >>> 8) & 65280) |
        ((word >>> 24) & 255)
      );
    }
    exports2.swap8IfBE = exports2.isLE ? (n) => n : (n) => byteSwap(n);
    exports2.byteSwapIfBE = exports2.swap8IfBE;
    function byteSwap32(arr) {
      for (let i = 0; i < arr.length; i++) {
        arr[i] = byteSwap(arr[i]);
      }
      return arr;
    }
    exports2.swap32IfBE = exports2.isLE ? (u) => u : byteSwap32;
    var hasHexBuiltin = /* @__PURE__ */ (() =>
      // @ts-ignore
      typeof Uint8Array.from([]).toHex === "function" &&
      typeof Uint8Array.fromHex === "function")();
    var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>
      i.toString(16).padStart(2, "0")
    );
    function bytesToHex(bytes) {
      abytes(bytes);
      if (hasHexBuiltin) return bytes.toHex();
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
    function asciiToBase16(ch) {
      if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0;
      if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10);
      if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10);
      return;
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      if (hasHexBuiltin) return Uint8Array.fromHex(hex);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2)
        throw new Error(
          "hex string expected, got unpadded hex of length " + hl
        );
      const array = new Uint8Array(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n2 === void 0) {
          const char = hex[hi] + hex[hi + 1];
          throw new Error(
            'hex string expected, got non-hex character "' +
              char +
              '" at index ' +
              hi
          );
        }
        array[ai] = n1 * 16 + n2;
      }
      return array;
    }
    var nextTick = async () => {};
    exports2.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i = 0; i < iters; i++) {
        cb(i);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick) continue;
        await (0, exports2.nextTick)();
        ts += diff;
      }
    }
    function utf8ToBytes(str) {
      if (typeof str !== "string") throw new Error("string expected");
      return new Uint8Array(new TextEncoder().encode(str));
    }
    function bytesToUtf8(bytes) {
      return new TextDecoder().decode(bytes);
    }
    function toBytes(data) {
      if (typeof data === "string") data = utf8ToBytes(data);
      abytes(data);
      return data;
    }
    function kdfInputToBytes(data) {
      if (typeof data === "string") data = utf8ToBytes(data);
      abytes(data);
      return data;
    }
    function concatBytes(...arrays) {
      let sum = 0;
      for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        abytes(a);
        sum += a.length;
      }
      const res = new Uint8Array(sum);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
      }
      return res;
    }
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && {}.toString.call(opts) !== "[object Object]")
        throw new Error("options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    var Hash = class {};
    exports2.Hash = Hash;
    function createHasher(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
    }
    function createOptHasher(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    function createXOFer(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports2.wrapConstructor = createHasher;
    exports2.wrapConstructorWithOpts = createOptHasher;
    exports2.wrapXOFConstructorWithOpts = createXOFer;
    function randomBytes(bytesLength = 32) {
      if (
        crypto_1.crypto &&
        typeof crypto_1.crypto.getRandomValues === "function"
      ) {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      if (
        crypto_1.crypto &&
        typeof crypto_1.crypto.randomBytes === "function"
      ) {
        return Uint8Array.from(crypto_1.crypto.randomBytes(bytesLength));
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
  },
});

// node_modules/@xrplf/isomorphic/dist/utils/shared.js
var require_shared = __commonJS({
  "node_modules/@xrplf/isomorphic/dist/utils/shared.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.equal = exports2.concat = exports2.HEX_REGEX = void 0;
    var utils_1 = require_utils();
    exports2.HEX_REGEX = /^[A-F0-9]*$/iu;
    function concat(views) {
      return (0, utils_1.concatBytes)(...views);
    }
    exports2.concat = concat;
    function equal(buf1, buf2) {
      if (buf1.byteLength !== buf2.byteLength) {
        return false;
      }
      const dv1 = new Int8Array(buf1);
      const dv2 = new Int8Array(buf2);
      for (let i = 0; i !== buf1.byteLength; i++) {
        if (dv1[i] !== dv2[i]) {
          return false;
        }
      }
      return true;
    }
    exports2.equal = equal;
  },
});

// node_modules/@xrplf/isomorphic/dist/utils/index.js
var require_utils2 = __commonJS({
  "node_modules/@xrplf/isomorphic/dist/utils/index.js"(exports2) {
    "use strict";
    var __createBinding =
      (exports2 && exports2.__createBinding) ||
      (Object.create
        ? function (o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);
            if (
              !desc ||
              ("get" in desc
                ? !m.__esModule
                : desc.writable || desc.configurable)
            ) {
              desc = {
                enumerable: true,
                get: function () {
                  return m[k];
                },
              };
            }
            Object.defineProperty(o, k2, desc);
          }
        : function (o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            o[k2] = m[k];
          });
    var __exportStar =
      (exports2 && exports2.__exportStar) ||
      function (m, exports3) {
        for (var p in m)
          if (
            p !== "default" &&
            !Object.prototype.hasOwnProperty.call(exports3, p)
          )
            __createBinding(exports3, m, p);
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.stringToHex =
      exports2.hexToString =
      exports2.randomBytes =
      exports2.hexToBytes =
      exports2.bytesToHex =
        void 0;
    var crypto_1 = require("crypto");
    var shared_1 = require_shared();
    var OriginalBuffer = Symbol("OriginalBuffer");
    function toUint8Array(buffer) {
      const u8Array = new Uint8Array(
        buffer.buffer.slice(
          buffer.byteOffset,
          buffer.byteOffset + buffer.byteLength
        )
      );
      u8Array[OriginalBuffer] = buffer;
      return u8Array;
    }
    var bytesToHex = (bytes) => {
      const buf = Buffer.from(bytes);
      return buf.toString("hex").toUpperCase();
    };
    exports2.bytesToHex = bytesToHex;
    var hexToBytes = (hex) => {
      if (!shared_1.HEX_REGEX.test(hex)) {
        throw new Error("Invalid hex string");
      }
      return toUint8Array(Buffer.from(hex, "hex"));
    };
    exports2.hexToBytes = hexToBytes;
    var randomBytes = (size) => {
      return toUint8Array((0, crypto_1.randomBytes)(size));
    };
    exports2.randomBytes = randomBytes;
    var hexToString = (hex, encoding = "utf8") => {
      if (!shared_1.HEX_REGEX.test(hex)) {
        throw new Error("Invalid hex string");
      }
      return new TextDecoder(encoding).decode((0, exports2.hexToBytes)(hex));
    };
    exports2.hexToString = hexToString;
    var stringToHex = (string) => {
      return (0, exports2.bytesToHex)(new TextEncoder().encode(string));
    };
    exports2.stringToHex = stringToHex;
    __exportStar(require_shared(), exports2);
  },
});

// node_modules/@scure/base/lib/index.js
var require_lib = __commonJS({
  "node_modules/@scure/base/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bytes =
      exports2.stringToBytes =
      exports2.str =
      exports2.bytesToString =
      exports2.hex =
      exports2.utf8 =
      exports2.bech32m =
      exports2.bech32 =
      exports2.base58check =
      exports2.createBase58check =
      exports2.base58xmr =
      exports2.base58xrp =
      exports2.base58flickr =
      exports2.base58 =
      exports2.base64urlnopad =
      exports2.base64url =
      exports2.base64nopad =
      exports2.base64 =
      exports2.base32crockford =
      exports2.base32hexnopad =
      exports2.base32hex =
      exports2.base32nopad =
      exports2.base32 =
      exports2.base16 =
      exports2.utils =
        void 0;
    function isBytes(a) {
      return (
        a instanceof Uint8Array ||
        (ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array")
      );
    }
    function abytes(b, ...lengths) {
      if (!isBytes(b)) throw new Error("Uint8Array expected");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error(
          "Uint8Array expected of length " +
            lengths +
            ", got length=" +
            b.length
        );
    }
    function isArrayOf(isString, arr) {
      if (!Array.isArray(arr)) return false;
      if (arr.length === 0) return true;
      if (isString) {
        return arr.every((item) => typeof item === "string");
      } else {
        return arr.every((item) => Number.isSafeInteger(item));
      }
    }
    function afn(input) {
      if (typeof input !== "function") throw new Error("function expected");
      return true;
    }
    function astr(label, input) {
      if (typeof input !== "string")
        throw new Error(`${label}: string expected`);
      return true;
    }
    function anumber(n) {
      if (!Number.isSafeInteger(n)) throw new Error(`invalid integer: ${n}`);
    }
    function aArr(input) {
      if (!Array.isArray(input)) throw new Error("array expected");
    }
    function astrArr(label, input) {
      if (!isArrayOf(true, input))
        throw new Error(`${label}: array of strings expected`);
    }
    function anumArr(label, input) {
      if (!isArrayOf(false, input))
        throw new Error(`${label}: array of numbers expected`);
    }
    // @__NO_SIDE_EFFECTS__
    function chain(...args) {
      const id = (a) => a;
      const wrap = (a, b) => (c) => a(b(c));
      const encode = args.map((x) => x.encode).reduceRight(wrap, id);
      const decode = args.map((x) => x.decode).reduce(wrap, id);
      return { encode, decode };
    }
    // @__NO_SIDE_EFFECTS__
    function alphabet(letters) {
      const lettersA =
        typeof letters === "string" ? letters.split("") : letters;
      const len = lettersA.length;
      astrArr("alphabet", lettersA);
      const indexes = new Map(lettersA.map((l, i) => [l, i]));
      return {
        encode: (digits) => {
          aArr(digits);
          return digits.map((i) => {
            if (!Number.isSafeInteger(i) || i < 0 || i >= len)
              throw new Error(
                `alphabet.encode: digit index outside alphabet "${i}". Allowed: ${letters}`
              );
            return lettersA[i];
          });
        },
        decode: (input) => {
          aArr(input);
          return input.map((letter) => {
            astr("alphabet.decode", letter);
            const i = indexes.get(letter);
            if (i === void 0)
              throw new Error(
                `Unknown letter: "${letter}". Allowed: ${letters}`
              );
            return i;
          });
        },
      };
    }
    // @__NO_SIDE_EFFECTS__
    function join(separator = "") {
      astr("join", separator);
      return {
        encode: (from) => {
          astrArr("join.decode", from);
          return from.join(separator);
        },
        decode: (to) => {
          astr("join.decode", to);
          return to.split(separator);
        },
      };
    }
    // @__NO_SIDE_EFFECTS__
    function padding(bits, chr = "=") {
      anumber(bits);
      astr("padding", chr);
      return {
        encode(data) {
          astrArr("padding.encode", data);
          while ((data.length * bits) % 8) data.push(chr);
          return data;
        },
        decode(input) {
          astrArr("padding.decode", input);
          let end = input.length;
          if ((end * bits) % 8)
            throw new Error(
              "padding: invalid, string should have whole number of bytes"
            );
          for (; end > 0 && input[end - 1] === chr; end--) {
            const last = end - 1;
            const byte = last * bits;
            if (byte % 8 === 0)
              throw new Error("padding: invalid, string has too much padding");
          }
          return input.slice(0, end);
        },
      };
    }
    // @__NO_SIDE_EFFECTS__
    function normalize(fn) {
      afn(fn);
      return { encode: (from) => from, decode: (to) => fn(to) };
    }
    function convertRadix(data, from, to) {
      if (from < 2)
        throw new Error(
          `convertRadix: invalid from=${from}, base cannot be less than 2`
        );
      if (to < 2)
        throw new Error(
          `convertRadix: invalid to=${to}, base cannot be less than 2`
        );
      aArr(data);
      if (!data.length) return [];
      let pos = 0;
      const res = [];
      const digits = Array.from(data, (d) => {
        anumber(d);
        if (d < 0 || d >= from) throw new Error(`invalid integer: ${d}`);
        return d;
      });
      const dlen = digits.length;
      while (true) {
        let carry = 0;
        let done = true;
        for (let i = pos; i < dlen; i++) {
          const digit = digits[i];
          const fromCarry = from * carry;
          const digitBase = fromCarry + digit;
          if (
            !Number.isSafeInteger(digitBase) ||
            fromCarry / from !== carry ||
            digitBase - digit !== fromCarry
          ) {
            throw new Error("convertRadix: carry overflow");
          }
          const div = digitBase / to;
          carry = digitBase % to;
          const rounded = Math.floor(div);
          digits[i] = rounded;
          if (
            !Number.isSafeInteger(rounded) ||
            rounded * to + carry !== digitBase
          )
            throw new Error("convertRadix: carry overflow");
          if (!done) continue;
          else if (!rounded) pos = i;
          else done = false;
        }
        res.push(carry);
        if (done) break;
      }
      for (let i = 0; i < data.length - 1 && data[i] === 0; i++) res.push(0);
      return res.reverse();
    }
    var gcd = (a, b) => (b === 0 ? a : gcd(b, a % b));
    var radix2carry = /* @__NO_SIDE_EFFECTS__ */ (from, to) =>
      from + (to - gcd(from, to));
    var powers = /* @__PURE__ */ (() => {
      let res = [];
      for (let i = 0; i < 40; i++) res.push(2 ** i);
      return res;
    })();
    function convertRadix2(data, from, to, padding2) {
      aArr(data);
      if (from <= 0 || from > 32)
        throw new Error(`convertRadix2: wrong from=${from}`);
      if (to <= 0 || to > 32) throw new Error(`convertRadix2: wrong to=${to}`);
      if (/* @__PURE__ */ radix2carry(from, to) > 32) {
        throw new Error(
          `convertRadix2: carry overflow from=${from} to=${to} carryBits=${
            /* @__PURE__ */ radix2carry(from, to)
          }`
        );
      }
      let carry = 0;
      let pos = 0;
      const max = powers[from];
      const mask = powers[to] - 1;
      const res = [];
      for (const n of data) {
        anumber(n);
        if (n >= max)
          throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);
        carry = (carry << from) | n;
        if (pos + from > 32)
          throw new Error(
            `convertRadix2: carry overflow pos=${pos} from=${from}`
          );
        pos += from;
        for (; pos >= to; pos -= to)
          res.push(((carry >> (pos - to)) & mask) >>> 0);
        const pow = powers[pos];
        if (pow === void 0) throw new Error("invalid carry");
        carry &= pow - 1;
      }
      carry = (carry << (to - pos)) & mask;
      if (!padding2 && pos >= from) throw new Error("Excess padding");
      if (!padding2 && carry > 0) throw new Error(`Non-zero padding: ${carry}`);
      if (padding2 && pos > 0) res.push(carry >>> 0);
      return res;
    }
    // @__NO_SIDE_EFFECTS__
    function radix(num) {
      anumber(num);
      const _256 = 2 ** 8;
      return {
        encode: (bytes) => {
          if (!isBytes(bytes))
            throw new Error("radix.encode input should be Uint8Array");
          return convertRadix(Array.from(bytes), _256, num);
        },
        decode: (digits) => {
          anumArr("radix.decode", digits);
          return Uint8Array.from(convertRadix(digits, num, _256));
        },
      };
    }
    // @__NO_SIDE_EFFECTS__
    function radix2(bits, revPadding = false) {
      anumber(bits);
      if (bits <= 0 || bits > 32)
        throw new Error("radix2: bits should be in (0..32]");
      if (
        /* @__PURE__ */ radix2carry(8, bits) > 32 ||
        /* @__PURE__ */ radix2carry(bits, 8) > 32
      )
        throw new Error("radix2: carry overflow");
      return {
        encode: (bytes) => {
          if (!isBytes(bytes))
            throw new Error("radix2.encode input should be Uint8Array");
          return convertRadix2(Array.from(bytes), 8, bits, !revPadding);
        },
        decode: (digits) => {
          anumArr("radix2.decode", digits);
          return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
        },
      };
    }
    function unsafeWrapper(fn) {
      afn(fn);
      return function (...args) {
        try {
          return fn.apply(null, args);
        } catch (e) {}
      };
    }
    function checksum(len, fn) {
      anumber(len);
      afn(fn);
      return {
        encode(data) {
          if (!isBytes(data))
            throw new Error("checksum.encode: input should be Uint8Array");
          const sum = fn(data).slice(0, len);
          const res = new Uint8Array(data.length + len);
          res.set(data);
          res.set(sum, data.length);
          return res;
        },
        decode(data) {
          if (!isBytes(data))
            throw new Error("checksum.decode: input should be Uint8Array");
          const payload = data.slice(0, -len);
          const oldChecksum = data.slice(-len);
          const newChecksum = fn(payload).slice(0, len);
          for (let i = 0; i < len; i++)
            if (newChecksum[i] !== oldChecksum[i])
              throw new Error("Invalid checksum");
          return payload;
        },
      };
    }
    exports2.utils = {
      alphabet,
      chain,
      checksum,
      convertRadix,
      convertRadix2,
      radix,
      radix2,
      join,
      padding,
    };
    exports2.base16 = /* @__PURE__ */ chain(
      /* @__PURE__ */ radix2(4),
      /* @__PURE__ */ alphabet("0123456789ABCDEF"),
      /* @__PURE__ */ join("")
    );
    exports2.base32 = /* @__PURE__ */ chain(
      /* @__PURE__ */ radix2(5),
      /* @__PURE__ */ alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"),
      /* @__PURE__ */ padding(5),
      /* @__PURE__ */ join("")
    );
    exports2.base32nopad = /* @__PURE__ */ chain(
      /* @__PURE__ */ radix2(5),
      /* @__PURE__ */ alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"),
      /* @__PURE__ */ join("")
    );
    exports2.base32hex = /* @__PURE__ */ chain(
      /* @__PURE__ */ radix2(5),
      /* @__PURE__ */ alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"),
      /* @__PURE__ */ padding(5),
      /* @__PURE__ */ join("")
    );
    exports2.base32hexnopad = /* @__PURE__ */ chain(
      /* @__PURE__ */ radix2(5),
      /* @__PURE__ */ alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"),
      /* @__PURE__ */ join("")
    );
    exports2.base32crockford = /* @__PURE__ */ chain(
      /* @__PURE__ */ radix2(5),
      /* @__PURE__ */ alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"),
      /* @__PURE__ */ join(""),
      /* @__PURE__ */ normalize((s) =>
        s.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")
      )
    );
    var hasBase64Builtin = /* @__PURE__ */ (() =>
      typeof Uint8Array.from([]).toBase64 === "function" &&
      typeof Uint8Array.fromBase64 === "function")();
    var decodeBase64Builtin = (s, isUrl) => {
      astr("base64", s);
      const re = isUrl ? /^[A-Za-z0-9=_-]+$/ : /^[A-Za-z0-9=+/]+$/;
      const alphabet2 = isUrl ? "base64url" : "base64";
      if (s.length > 0 && !re.test(s)) throw new Error("invalid base64");
      return Uint8Array.fromBase64(s, {
        alphabet: alphabet2,
        lastChunkHandling: "strict",
      });
    };
    exports2.base64 = hasBase64Builtin
      ? {
          encode(b) {
            abytes(b);
            return b.toBase64();
          },
          decode(s) {
            return decodeBase64Builtin(s, false);
          },
        }
      : /* @__PURE__ */ chain(
          /* @__PURE__ */ radix2(6),
          /* @__PURE__ */ alphabet(
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
          ),
          /* @__PURE__ */ padding(6),
          /* @__PURE__ */ join("")
        );
    exports2.base64nopad = /* @__PURE__ */ chain(
      /* @__PURE__ */ radix2(6),
      /* @__PURE__ */ alphabet(
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
      ),
      /* @__PURE__ */ join("")
    );
    exports2.base64url = hasBase64Builtin
      ? {
          encode(b) {
            abytes(b);
            return b.toBase64({ alphabet: "base64url" });
          },
          decode(s) {
            return decodeBase64Builtin(s, true);
          },
        }
      : /* @__PURE__ */ chain(
          /* @__PURE__ */ radix2(6),
          /* @__PURE__ */ alphabet(
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
          ),
          /* @__PURE__ */ padding(6),
          /* @__PURE__ */ join("")
        );
    exports2.base64urlnopad = /* @__PURE__ */ chain(
      /* @__PURE__ */ radix2(6),
      /* @__PURE__ */ alphabet(
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
      ),
      /* @__PURE__ */ join("")
    );
    var genBase58 = /* @__NO_SIDE_EFFECTS__ */ (abc) =>
      /* @__PURE__ */ chain(
        /* @__PURE__ */ radix(58),
        /* @__PURE__ */ alphabet(abc),
        /* @__PURE__ */ join("")
      );
    exports2.base58 = /* @__PURE__ */ genBase58(
      "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    );
    exports2.base58flickr = /* @__PURE__ */ genBase58(
      "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
    );
    exports2.base58xrp = /* @__PURE__ */ genBase58(
      "rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz"
    );
    var XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];
    exports2.base58xmr = {
      encode(data) {
        let res = "";
        for (let i = 0; i < data.length; i += 8) {
          const block = data.subarray(i, i + 8);
          res += exports2.base58
            .encode(block)
            .padStart(XMR_BLOCK_LEN[block.length], "1");
        }
        return res;
      },
      decode(str) {
        let res = [];
        for (let i = 0; i < str.length; i += 11) {
          const slice = str.slice(i, i + 11);
          const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);
          const block = exports2.base58.decode(slice);
          for (let j = 0; j < block.length - blockLen; j++) {
            if (block[j] !== 0) throw new Error("base58xmr: wrong padding");
          }
          res = res.concat(Array.from(block.slice(block.length - blockLen)));
        }
        return Uint8Array.from(res);
      },
    };
    var createBase58check = (sha256) =>
      /* @__PURE__ */ chain(
        checksum(4, (data) => sha256(sha256(data))),
        exports2.base58
      );
    exports2.createBase58check = createBase58check;
    exports2.base58check = exports2.createBase58check;
    var BECH_ALPHABET = /* @__PURE__ */ chain(
      /* @__PURE__ */ alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"),
      /* @__PURE__ */ join("")
    );
    var POLYMOD_GENERATORS = [
      996825010, 642813549, 513874426, 1027748829, 705979059,
    ];
    function bech32Polymod(pre) {
      const b = pre >> 25;
      let chk = (pre & 33554431) << 5;
      for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {
        if (((b >> i) & 1) === 1) chk ^= POLYMOD_GENERATORS[i];
      }
      return chk;
    }
    function bechChecksum(prefix, words, encodingConst = 1) {
      const len = prefix.length;
      let chk = 1;
      for (let i = 0; i < len; i++) {
        const c = prefix.charCodeAt(i);
        if (c < 33 || c > 126) throw new Error(`Invalid prefix (${prefix})`);
        chk = bech32Polymod(chk) ^ (c >> 5);
      }
      chk = bech32Polymod(chk);
      for (let i = 0; i < len; i++)
        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 31);
      for (let v of words) chk = bech32Polymod(chk) ^ v;
      for (let i = 0; i < 6; i++) chk = bech32Polymod(chk);
      chk ^= encodingConst;
      return BECH_ALPHABET.encode(
        convertRadix2([chk % powers[30]], 30, 5, false)
      );
    }
    // @__NO_SIDE_EFFECTS__
    function genBech32(encoding) {
      const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
      const _words = /* @__PURE__ */ radix2(5);
      const fromWords = _words.decode;
      const toWords = _words.encode;
      const fromWordsUnsafe = unsafeWrapper(fromWords);
      function encode(prefix, words, limit = 90) {
        astr("bech32.encode prefix", prefix);
        if (isBytes(words)) words = Array.from(words);
        anumArr("bech32.encode", words);
        const plen = prefix.length;
        if (plen === 0) throw new TypeError(`Invalid prefix length ${plen}`);
        const actualLength = plen + 7 + words.length;
        if (limit !== false && actualLength > limit)
          throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
        const lowered = prefix.toLowerCase();
        const sum = bechChecksum(lowered, words, ENCODING_CONST);
        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;
      }
      function decode(str, limit = 90) {
        astr("bech32.decode input", str);
        const slen = str.length;
        if (slen < 8 || (limit !== false && slen > limit))
          throw new TypeError(
            `invalid string length: ${slen} (${str}). Expected (8..${limit})`
          );
        const lowered = str.toLowerCase();
        if (str !== lowered && str !== str.toUpperCase())
          throw new Error(`String must be lowercase or uppercase`);
        const sepIndex = lowered.lastIndexOf("1");
        if (sepIndex === 0 || sepIndex === -1)
          throw new Error(
            `Letter "1" must be present between prefix and data only`
          );
        const prefix = lowered.slice(0, sepIndex);
        const data = lowered.slice(sepIndex + 1);
        if (data.length < 6)
          throw new Error("Data must be at least 6 characters long");
        const words = BECH_ALPHABET.decode(data).slice(0, -6);
        const sum = bechChecksum(prefix, words, ENCODING_CONST);
        if (!data.endsWith(sum))
          throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
        return { prefix, words };
      }
      const decodeUnsafe = unsafeWrapper(decode);
      function decodeToBytes(str) {
        const { prefix, words } = decode(str, false);
        return { prefix, words, bytes: fromWords(words) };
      }
      function encodeFromBytes(prefix, bytes) {
        return encode(prefix, toWords(bytes));
      }
      return {
        encode,
        decode,
        encodeFromBytes,
        decodeToBytes,
        decodeUnsafe,
        fromWords,
        fromWordsUnsafe,
        toWords,
      };
    }
    exports2.bech32 = /* @__PURE__ */ genBech32("bech32");
    exports2.bech32m = /* @__PURE__ */ genBech32("bech32m");
    exports2.utf8 = {
      encode: (data) => new TextDecoder().decode(data),
      decode: (str) => new TextEncoder().encode(str),
    };
    var hasHexBuiltin = /* @__PURE__ */ (() =>
      typeof Uint8Array.from([]).toHex === "function" &&
      typeof Uint8Array.fromHex === "function")();
    var hexBuiltin = {
      encode(data) {
        abytes(data);
        return data.toHex();
      },
      decode(s) {
        astr("hex", s);
        return Uint8Array.fromHex(s);
      },
    };
    exports2.hex = hasHexBuiltin
      ? hexBuiltin
      : /* @__PURE__ */ chain(
          /* @__PURE__ */ radix2(4),
          /* @__PURE__ */ alphabet("0123456789abcdef"),
          /* @__PURE__ */ join(""),
          /* @__PURE__ */ normalize((s) => {
            if (typeof s !== "string" || s.length % 2 !== 0)
              throw new TypeError(
                `hex.decode: expected string, got ${typeof s} with length ${
                  s.length
                }`
              );
            return s.toLowerCase();
          })
        );
    var CODERS = {
      utf8: exports2.utf8,
      hex: exports2.hex,
      base16: exports2.base16,
      base32: exports2.base32,
      base64: exports2.base64,
      base64url: exports2.base64url,
      base58: exports2.base58,
      base58xmr: exports2.base58xmr,
    };
    var coderTypeError =
      "Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr";
    var bytesToString = (type, bytes) => {
      if (typeof type !== "string" || !CODERS.hasOwnProperty(type))
        throw new TypeError(coderTypeError);
      if (!isBytes(bytes))
        throw new TypeError("bytesToString() expects Uint8Array");
      return CODERS[type].encode(bytes);
    };
    exports2.bytesToString = bytesToString;
    exports2.str = exports2.bytesToString;
    var stringToBytes = (type, str) => {
      if (!CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);
      if (typeof str !== "string")
        throw new TypeError("stringToBytes() expects string");
      return CODERS[type].decode(str);
    };
    exports2.stringToBytes = stringToBytes;
    exports2.bytes = exports2.stringToBytes;
  },
});

// node_modules/@xrplf/isomorphic/dist/internal/normalizeInput.js
var require_normalizeInput = __commonJS({
  "node_modules/@xrplf/isomorphic/dist/internal/normalizeInput.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function normalizeInput(input) {
      return Array.isArray(input) ? new Uint8Array(input) : input;
    }
    exports2.default = normalizeInput;
  },
});

// node_modules/@xrplf/isomorphic/dist/internal/wrapCryptoCreateHash.js
var require_wrapCryptoCreateHash = __commonJS({
  "node_modules/@xrplf/isomorphic/dist/internal/wrapCryptoCreateHash.js"(
    exports2
  ) {
    "use strict";
    var __importDefault =
      (exports2 && exports2.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var normalizeInput_1 = __importDefault(require_normalizeInput());
    function wrapCryptoCreateHash(type, fn) {
      function hashFn(input) {
        return fn(type)
          .update((0, normalizeInput_1.default)(input))
          .digest();
      }
      hashFn.create = () => {
        const hash = fn(type);
        return {
          update(input) {
            hash.update((0, normalizeInput_1.default)(input));
            return this;
          },
          digest() {
            return hash.digest();
          },
        };
      };
      return hashFn;
    }
    exports2.default = wrapCryptoCreateHash;
  },
});

// node_modules/@xrplf/isomorphic/dist/sha256/index.js
var require_sha256 = __commonJS({
  "node_modules/@xrplf/isomorphic/dist/sha256/index.js"(exports2) {
    "use strict";
    var __importDefault =
      (exports2 && exports2.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sha256 = void 0;
    var crypto_1 = require("crypto");
    var wrapCryptoCreateHash_1 = __importDefault(
      require_wrapCryptoCreateHash()
    );
    exports2.sha256 = (0, wrapCryptoCreateHash_1.default)(
      "sha256",
      crypto_1.createHash
    );
  },
});

// node_modules/ripple-address-codec/dist/utils.js
var require_utils3 = __commonJS({
  "node_modules/ripple-address-codec/dist/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.concatArgs = exports2.arrayEqual = void 0;
    function arrayEqual(arr1, arr2) {
      if (arr1.length !== arr2.length) {
        return false;
      }
      return arr1.every((value, index) => value === arr2[index]);
    }
    exports2.arrayEqual = arrayEqual;
    function isScalar(val) {
      return typeof val === "number";
    }
    function concatArgs(...args) {
      return args.flatMap((arg) => {
        return isScalar(arg) ? [arg] : Array.from(arg);
      });
    }
    exports2.concatArgs = concatArgs;
  },
});

// node_modules/ripple-address-codec/dist/xrp-codec.js
var require_xrp_codec = __commonJS({
  "node_modules/ripple-address-codec/dist/xrp-codec.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isValidClassicAddress =
      exports2.decodeAccountPublic =
      exports2.encodeAccountPublic =
      exports2.encodeNodePublic =
      exports2.decodeNodePublic =
      exports2.decodeAddress =
      exports2.decodeAccountID =
      exports2.encodeAddress =
      exports2.encodeAccountID =
      exports2.decodeSeed =
      exports2.encodeSeed =
      exports2.codec =
        void 0;
    var base_1 = require_lib();
    var sha256_1 = require_sha256();
    var utils_1 = require_utils3();
    var Codec = class {
      constructor(options) {
        this._sha256 = options.sha256;
        this._codec = base_1.base58xrp;
      }
      /**
       * Encoder.
       *
       * @param bytes - Uint8Array of data to encode.
       * @param opts - Options object including the version bytes and the expected length of the data to encode.
       */
      encode(bytes, opts) {
        const versions = opts.versions;
        return this._encodeVersioned(bytes, versions, opts.expectedLength);
      }
      /**
       * Decoder.
       *
       * @param base58string - Base58Check-encoded string to decode.
       * @param opts - Options object including the version byte(s) and the expected length of the data after decoding.
       */
      /* eslint-disable max-lines-per-function --
       * TODO refactor */
      decode(base58string, opts) {
        var _a;
        const versions = opts.versions;
        const types = opts.versionTypes;
        const withoutSum = this.decodeChecked(base58string);
        if (versions.length > 1 && !opts.expectedLength) {
          throw new Error(
            "expectedLength is required because there are >= 2 possible versions"
          );
        }
        const versionLengthGuess =
          typeof versions[0] === "number" ? 1 : versions[0].length;
        const payloadLength =
          (_a = opts.expectedLength) !== null && _a !== void 0
            ? _a
            : withoutSum.length - versionLengthGuess;
        const versionBytes = withoutSum.slice(0, -payloadLength);
        const payload = withoutSum.slice(-payloadLength);
        for (let i = 0; i < versions.length; i++) {
          const version = Array.isArray(versions[i])
            ? versions[i]
            : [versions[i]];
          if ((0, utils_1.arrayEqual)(versionBytes, version)) {
            return {
              version,
              bytes: payload,
              type: types ? types[i] : null,
            };
          }
        }
        throw new Error(
          "version_invalid: version bytes do not match any of the provided version(s)"
        );
      }
      encodeChecked(bytes) {
        const check = this._sha256(this._sha256(bytes)).slice(0, 4);
        return this._encodeRaw(
          Uint8Array.from((0, utils_1.concatArgs)(bytes, check))
        );
      }
      decodeChecked(base58string) {
        const intArray = this._decodeRaw(base58string);
        if (intArray.byteLength < 5) {
          throw new Error(
            "invalid_input_size: decoded data must have length >= 5"
          );
        }
        if (!this._verifyCheckSum(intArray)) {
          throw new Error("checksum_invalid");
        }
        return intArray.slice(0, -4);
      }
      _encodeVersioned(bytes, versions, expectedLength) {
        if (!checkByteLength(bytes, expectedLength)) {
          throw new Error(
            "unexpected_payload_length: bytes.length does not match expectedLength. Ensure that the bytes are a Uint8Array."
          );
        }
        return this.encodeChecked((0, utils_1.concatArgs)(versions, bytes));
      }
      _encodeRaw(bytes) {
        return this._codec.encode(Uint8Array.from(bytes));
      }
      /* eslint-enable max-lines-per-function */
      _decodeRaw(base58string) {
        return this._codec.decode(base58string);
      }
      _verifyCheckSum(bytes) {
        const computed = this._sha256(this._sha256(bytes.slice(0, -4))).slice(
          0,
          4
        );
        const checksum = bytes.slice(-4);
        return (0, utils_1.arrayEqual)(computed, checksum);
      }
    };
    var ACCOUNT_ID = 0;
    var ACCOUNT_PUBLIC_KEY = 35;
    var FAMILY_SEED = 33;
    var NODE_PUBLIC = 28;
    var ED25519_SEED = [1, 225, 75];
    var codecOptions = {
      sha256: sha256_1.sha256,
    };
    var codecWithXrpAlphabet = new Codec(codecOptions);
    exports2.codec = codecWithXrpAlphabet;
    function encodeSeed(entropy, type) {
      if (!checkByteLength(entropy, 16)) {
        throw new Error("entropy must have length 16");
      }
      const opts = {
        expectedLength: 16,
        // for secp256k1, use `FAMILY_SEED`
        versions: type === "ed25519" ? ED25519_SEED : [FAMILY_SEED],
      };
      return codecWithXrpAlphabet.encode(entropy, opts);
    }
    exports2.encodeSeed = encodeSeed;
    function decodeSeed(
      seed,
      opts = {
        versionTypes: ["ed25519", "secp256k1"],
        versions: [ED25519_SEED, FAMILY_SEED],
        expectedLength: 16,
      }
    ) {
      return codecWithXrpAlphabet.decode(seed, opts);
    }
    exports2.decodeSeed = decodeSeed;
    function encodeAccountID(bytes) {
      const opts = { versions: [ACCOUNT_ID], expectedLength: 20 };
      return codecWithXrpAlphabet.encode(bytes, opts);
    }
    exports2.encodeAccountID = encodeAccountID;
    exports2.encodeAddress = encodeAccountID;
    function decodeAccountID(accountId) {
      const opts = { versions: [ACCOUNT_ID], expectedLength: 20 };
      return codecWithXrpAlphabet.decode(accountId, opts).bytes;
    }
    exports2.decodeAccountID = decodeAccountID;
    exports2.decodeAddress = decodeAccountID;
    function decodeNodePublic(base58string) {
      const opts = { versions: [NODE_PUBLIC], expectedLength: 33 };
      return codecWithXrpAlphabet.decode(base58string, opts).bytes;
    }
    exports2.decodeNodePublic = decodeNodePublic;
    function encodeNodePublic(bytes) {
      const opts = { versions: [NODE_PUBLIC], expectedLength: 33 };
      return codecWithXrpAlphabet.encode(bytes, opts);
    }
    exports2.encodeNodePublic = encodeNodePublic;
    function encodeAccountPublic(bytes) {
      const opts = { versions: [ACCOUNT_PUBLIC_KEY], expectedLength: 33 };
      return codecWithXrpAlphabet.encode(bytes, opts);
    }
    exports2.encodeAccountPublic = encodeAccountPublic;
    function decodeAccountPublic(base58string) {
      const opts = { versions: [ACCOUNT_PUBLIC_KEY], expectedLength: 33 };
      return codecWithXrpAlphabet.decode(base58string, opts).bytes;
    }
    exports2.decodeAccountPublic = decodeAccountPublic;
    function isValidClassicAddress(address) {
      try {
        decodeAccountID(address);
      } catch (_error) {
        return false;
      }
      return true;
    }
    exports2.isValidClassicAddress = isValidClassicAddress;
    function checkByteLength(bytes, expectedLength) {
      return "byteLength" in bytes
        ? bytes.byteLength === expectedLength
        : bytes.length === expectedLength;
    }
  },
});

// node_modules/ripple-address-codec/dist/index.js
var require_dist = __commonJS({
  "node_modules/ripple-address-codec/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isValidXAddress =
      exports2.decodeXAddress =
      exports2.xAddressToClassicAddress =
      exports2.encodeXAddress =
      exports2.classicAddressToXAddress =
      exports2.isValidClassicAddress =
      exports2.decodeAccountPublic =
      exports2.encodeAccountPublic =
      exports2.decodeNodePublic =
      exports2.encodeNodePublic =
      exports2.decodeAccountID =
      exports2.encodeAccountID =
      exports2.decodeSeed =
      exports2.encodeSeed =
      exports2.codec =
        void 0;
    var utils_1 = require_utils2();
    var xrp_codec_1 = require_xrp_codec();
    Object.defineProperty(exports2, "codec", {
      enumerable: true,
      get: function () {
        return xrp_codec_1.codec;
      },
    });
    Object.defineProperty(exports2, "encodeSeed", {
      enumerable: true,
      get: function () {
        return xrp_codec_1.encodeSeed;
      },
    });
    Object.defineProperty(exports2, "decodeSeed", {
      enumerable: true,
      get: function () {
        return xrp_codec_1.decodeSeed;
      },
    });
    Object.defineProperty(exports2, "encodeAccountID", {
      enumerable: true,
      get: function () {
        return xrp_codec_1.encodeAccountID;
      },
    });
    Object.defineProperty(exports2, "decodeAccountID", {
      enumerable: true,
      get: function () {
        return xrp_codec_1.decodeAccountID;
      },
    });
    Object.defineProperty(exports2, "encodeNodePublic", {
      enumerable: true,
      get: function () {
        return xrp_codec_1.encodeNodePublic;
      },
    });
    Object.defineProperty(exports2, "decodeNodePublic", {
      enumerable: true,
      get: function () {
        return xrp_codec_1.decodeNodePublic;
      },
    });
    Object.defineProperty(exports2, "encodeAccountPublic", {
      enumerable: true,
      get: function () {
        return xrp_codec_1.encodeAccountPublic;
      },
    });
    Object.defineProperty(exports2, "decodeAccountPublic", {
      enumerable: true,
      get: function () {
        return xrp_codec_1.decodeAccountPublic;
      },
    });
    Object.defineProperty(exports2, "isValidClassicAddress", {
      enumerable: true,
      get: function () {
        return xrp_codec_1.isValidClassicAddress;
      },
    });
    var PREFIX_BYTES = {
      // 5, 68
      main: Uint8Array.from([5, 68]),
      // 4, 147
      test: Uint8Array.from([4, 147]),
    };
    var MAX_32_BIT_UNSIGNED_INT = 4294967295;
    function classicAddressToXAddress(classicAddress, tag, test) {
      const accountId = (0, xrp_codec_1.decodeAccountID)(classicAddress);
      return encodeXAddress(accountId, tag, test);
    }
    exports2.classicAddressToXAddress = classicAddressToXAddress;
    function encodeXAddress(accountId, tag, test) {
      if (accountId.length !== 20) {
        throw new Error("Account ID must be 20 bytes");
      }
      if (tag !== false && tag > MAX_32_BIT_UNSIGNED_INT) {
        throw new Error("Invalid tag");
      }
      const theTag = tag || 0;
      const flag = tag === false || tag == null ? 0 : 1;
      const bytes = (0, utils_1.concat)([
        test ? PREFIX_BYTES.test : PREFIX_BYTES.main,
        accountId,
        Uint8Array.from([
          // 0x00 if no tag, 0x01 if 32-bit tag
          flag,
          // first byte
          theTag & 255,
          // second byte
          (theTag >> 8) & 255,
          // third byte
          (theTag >> 16) & 255,
          // fourth byte
          (theTag >> 24) & 255,
          0,
          0,
          0,
          // four zero bytes (reserved for 64-bit tags)
          0,
        ]),
      ]);
      return xrp_codec_1.codec.encodeChecked(bytes);
    }
    exports2.encodeXAddress = encodeXAddress;
    function xAddressToClassicAddress(xAddress) {
      const { accountId, tag, test } = decodeXAddress(xAddress);
      const classicAddress = (0, xrp_codec_1.encodeAccountID)(accountId);
      return {
        classicAddress,
        tag,
        test,
      };
    }
    exports2.xAddressToClassicAddress = xAddressToClassicAddress;
    function decodeXAddress(xAddress) {
      const decoded = xrp_codec_1.codec.decodeChecked(xAddress);
      const test = isUint8ArrayForTestAddress(decoded);
      const accountId = decoded.slice(2, 22);
      const tag = tagFromUint8Array(decoded);
      return {
        accountId,
        tag,
        test,
      };
    }
    exports2.decodeXAddress = decodeXAddress;
    function isUint8ArrayForTestAddress(buf) {
      const decodedPrefix = buf.slice(0, 2);
      if ((0, utils_1.equal)(PREFIX_BYTES.main, decodedPrefix)) {
        return false;
      }
      if ((0, utils_1.equal)(PREFIX_BYTES.test, decodedPrefix)) {
        return true;
      }
      throw new Error("Invalid X-address: bad prefix");
    }
    function tagFromUint8Array(buf) {
      const flag = buf[22];
      if (flag >= 2) {
        throw new Error("Unsupported X-address");
      }
      if (flag === 1) {
        return buf[23] + buf[24] * 256 + buf[25] * 65536 + buf[26] * 16777216;
      }
      if (flag !== 0) {
        throw new Error("flag must be zero to indicate no tag");
      }
      if (
        !(0, utils_1.equal)(
          (0, utils_1.hexToBytes)("0000000000000000"),
          buf.slice(23, 23 + 8)
        )
      ) {
        throw new Error("remaining bytes must be zero");
      }
      return false;
    }
    function isValidXAddress(xAddress) {
      try {
        decodeXAddress(xAddress);
      } catch (_error) {
        return false;
      }
      return true;
    }
    exports2.isValidXAddress = isValidXAddress;
  },
});

// node_modules/ripple-binary-codec/dist/enums/definitions.json
var require_definitions = __commonJS({
  "node_modules/ripple-binary-codec/dist/enums/definitions.json"(
    exports2,
    module2
  ) {
    module2.exports = {
      FIELDS: [
        [
          "Generic",
          {
            isSerialized: false,
            isSigningField: false,
            isVLEncoded: false,
            nth: 0,
            type: "Unknown",
          },
        ],
        [
          "Invalid",
          {
            isSerialized: false,
            isSigningField: false,
            isVLEncoded: false,
            nth: -1,
            type: "Unknown",
          },
        ],
        [
          "ObjectEndMarker",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 1,
            type: "STObject",
          },
        ],
        [
          "ArrayEndMarker",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 1,
            type: "STArray",
          },
        ],
        [
          "taker_gets_funded",
          {
            isSerialized: false,
            isSigningField: false,
            isVLEncoded: false,
            nth: 258,
            type: "Amount",
          },
        ],
        [
          "taker_pays_funded",
          {
            isSerialized: false,
            isSigningField: false,
            isVLEncoded: false,
            nth: 259,
            type: "Amount",
          },
        ],
        [
          "LedgerEntryType",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 1,
            type: "UInt16",
          },
        ],
        [
          "TransactionType",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 2,
            type: "UInt16",
          },
        ],
        [
          "SignerWeight",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 3,
            type: "UInt16",
          },
        ],
        [
          "TransferFee",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 4,
            type: "UInt16",
          },
        ],
        [
          "TradingFee",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 5,
            type: "UInt16",
          },
        ],
        [
          "DiscountedFee",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 6,
            type: "UInt16",
          },
        ],
        [
          "Version",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 16,
            type: "UInt16",
          },
        ],
        [
          "HookStateChangeCount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 17,
            type: "UInt16",
          },
        ],
        [
          "HookEmitCount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 18,
            type: "UInt16",
          },
        ],
        [
          "HookExecutionIndex",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 19,
            type: "UInt16",
          },
        ],
        [
          "HookApiVersion",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 20,
            type: "UInt16",
          },
        ],
        [
          "LedgerFixType",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 21,
            type: "UInt16",
          },
        ],
        [
          "NetworkID",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 1,
            type: "UInt32",
          },
        ],
        [
          "Flags",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 2,
            type: "UInt32",
          },
        ],
        [
          "SourceTag",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 3,
            type: "UInt32",
          },
        ],
        [
          "Sequence",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 4,
            type: "UInt32",
          },
        ],
        [
          "PreviousTxnLgrSeq",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 5,
            type: "UInt32",
          },
        ],
        [
          "LedgerSequence",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 6,
            type: "UInt32",
          },
        ],
        [
          "CloseTime",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 7,
            type: "UInt32",
          },
        ],
        [
          "ParentCloseTime",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 8,
            type: "UInt32",
          },
        ],
        [
          "SigningTime",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 9,
            type: "UInt32",
          },
        ],
        [
          "Expiration",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 10,
            type: "UInt32",
          },
        ],
        [
          "TransferRate",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 11,
            type: "UInt32",
          },
        ],
        [
          "WalletSize",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 12,
            type: "UInt32",
          },
        ],
        [
          "OwnerCount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 13,
            type: "UInt32",
          },
        ],
        [
          "DestinationTag",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 14,
            type: "UInt32",
          },
        ],
        [
          "LastUpdateTime",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 15,
            type: "UInt32",
          },
        ],
        [
          "HighQualityIn",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 16,
            type: "UInt32",
          },
        ],
        [
          "HighQualityOut",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 17,
            type: "UInt32",
          },
        ],
        [
          "LowQualityIn",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 18,
            type: "UInt32",
          },
        ],
        [
          "LowQualityOut",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 19,
            type: "UInt32",
          },
        ],
        [
          "QualityIn",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 20,
            type: "UInt32",
          },
        ],
        [
          "QualityOut",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 21,
            type: "UInt32",
          },
        ],
        [
          "StampEscrow",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 22,
            type: "UInt32",
          },
        ],
        [
          "BondAmount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 23,
            type: "UInt32",
          },
        ],
        [
          "LoadFee",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 24,
            type: "UInt32",
          },
        ],
        [
          "OfferSequence",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 25,
            type: "UInt32",
          },
        ],
        [
          "FirstLedgerSequence",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 26,
            type: "UInt32",
          },
        ],
        [
          "LastLedgerSequence",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 27,
            type: "UInt32",
          },
        ],
        [
          "TransactionIndex",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 28,
            type: "UInt32",
          },
        ],
        [
          "OperationLimit",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 29,
            type: "UInt32",
          },
        ],
        [
          "ReferenceFeeUnits",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 30,
            type: "UInt32",
          },
        ],
        [
          "ReserveBase",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 31,
            type: "UInt32",
          },
        ],
        [
          "ReserveIncrement",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 32,
            type: "UInt32",
          },
        ],
        [
          "SetFlag",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 33,
            type: "UInt32",
          },
        ],
        [
          "ClearFlag",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 34,
            type: "UInt32",
          },
        ],
        [
          "SignerQuorum",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 35,
            type: "UInt32",
          },
        ],
        [
          "CancelAfter",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 36,
            type: "UInt32",
          },
        ],
        [
          "FinishAfter",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 37,
            type: "UInt32",
          },
        ],
        [
          "SignerListID",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 38,
            type: "UInt32",
          },
        ],
        [
          "SettleDelay",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 39,
            type: "UInt32",
          },
        ],
        [
          "TicketCount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 40,
            type: "UInt32",
          },
        ],
        [
          "TicketSequence",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 41,
            type: "UInt32",
          },
        ],
        [
          "NFTokenTaxon",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 42,
            type: "UInt32",
          },
        ],
        [
          "MintedNFTokens",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 43,
            type: "UInt32",
          },
        ],
        [
          "BurnedNFTokens",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 44,
            type: "UInt32",
          },
        ],
        [
          "HookStateCount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 45,
            type: "UInt32",
          },
        ],
        [
          "EmitGeneration",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 46,
            type: "UInt32",
          },
        ],
        [
          "VoteWeight",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 48,
            type: "UInt32",
          },
        ],
        [
          "FirstNFTokenSequence",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 50,
            type: "UInt32",
          },
        ],
        [
          "OracleDocumentID",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 51,
            type: "UInt32",
          },
        ],
        [
          "PermissionValue",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 52,
            type: "UInt32",
          },
        ],
        [
          "IndexNext",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 1,
            type: "UInt64",
          },
        ],
        [
          "IndexPrevious",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 2,
            type: "UInt64",
          },
        ],
        [
          "BookNode",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 3,
            type: "UInt64",
          },
        ],
        [
          "OwnerNode",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 4,
            type: "UInt64",
          },
        ],
        [
          "BaseFee",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 5,
            type: "UInt64",
          },
        ],
        [
          "ExchangeRate",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 6,
            type: "UInt64",
          },
        ],
        [
          "LowNode",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 7,
            type: "UInt64",
          },
        ],
        [
          "HighNode",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 8,
            type: "UInt64",
          },
        ],
        [
          "DestinationNode",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 9,
            type: "UInt64",
          },
        ],
        [
          "Cookie",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 10,
            type: "UInt64",
          },
        ],
        [
          "ServerVersion",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 11,
            type: "UInt64",
          },
        ],
        [
          "NFTokenOfferNode",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 12,
            type: "UInt64",
          },
        ],
        [
          "EmitBurden",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 13,
            type: "UInt64",
          },
        ],
        [
          "HookOn",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 16,
            type: "UInt64",
          },
        ],
        [
          "HookInstructionCount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 17,
            type: "UInt64",
          },
        ],
        [
          "HookReturnCode",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 18,
            type: "UInt64",
          },
        ],
        [
          "ReferenceCount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 19,
            type: "UInt64",
          },
        ],
        [
          "XChainClaimID",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 20,
            type: "UInt64",
          },
        ],
        [
          "XChainAccountCreateCount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 21,
            type: "UInt64",
          },
        ],
        [
          "XChainAccountClaimCount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 22,
            type: "UInt64",
          },
        ],
        [
          "AssetPrice",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 23,
            type: "UInt64",
          },
        ],
        [
          "MaximumAmount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 24,
            type: "UInt64",
          },
        ],
        [
          "OutstandingAmount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 25,
            type: "UInt64",
          },
        ],
        [
          "MPTAmount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 26,
            type: "UInt64",
          },
        ],
        [
          "IssuerNode",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 27,
            type: "UInt64",
          },
        ],
        [
          "SubjectNode",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 28,
            type: "UInt64",
          },
        ],
        [
          "LockedAmount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 29,
            type: "UInt64",
          },
        ],
        [
          "EmailHash",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 1,
            type: "Hash128",
          },
        ],
        [
          "LedgerHash",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 1,
            type: "Hash256",
          },
        ],
        [
          "ParentHash",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 2,
            type: "Hash256",
          },
        ],
        [
          "TransactionHash",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 3,
            type: "Hash256",
          },
        ],
        [
          "AccountHash",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 4,
            type: "Hash256",
          },
        ],
        [
          "PreviousTxnID",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 5,
            type: "Hash256",
          },
        ],
        [
          "LedgerIndex",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 6,
            type: "Hash256",
          },
        ],
        [
          "WalletLocator",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 7,
            type: "Hash256",
          },
        ],
        [
          "RootIndex",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 8,
            type: "Hash256",
          },
        ],
        [
          "AccountTxnID",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 9,
            type: "Hash256",
          },
        ],
        [
          "NFTokenID",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 10,
            type: "Hash256",
          },
        ],
        [
          "EmitParentTxnID",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 11,
            type: "Hash256",
          },
        ],
        [
          "EmitNonce",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 12,
            type: "Hash256",
          },
        ],
        [
          "EmitHookHash",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 13,
            type: "Hash256",
          },
        ],
        [
          "AMMID",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 14,
            type: "Hash256",
          },
        ],
        [
          "BookDirectory",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 16,
            type: "Hash256",
          },
        ],
        [
          "InvoiceID",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 17,
            type: "Hash256",
          },
        ],
        [
          "Nickname",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 18,
            type: "Hash256",
          },
        ],
        [
          "Amendment",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 19,
            type: "Hash256",
          },
        ],
        [
          "Digest",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 21,
            type: "Hash256",
          },
        ],
        [
          "Channel",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 22,
            type: "Hash256",
          },
        ],
        [
          "ConsensusHash",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 23,
            type: "Hash256",
          },
        ],
        [
          "CheckID",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 24,
            type: "Hash256",
          },
        ],
        [
          "ValidatedHash",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 25,
            type: "Hash256",
          },
        ],
        [
          "PreviousPageMin",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 26,
            type: "Hash256",
          },
        ],
        [
          "NextPageMin",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 27,
            type: "Hash256",
          },
        ],
        [
          "NFTokenBuyOffer",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 28,
            type: "Hash256",
          },
        ],
        [
          "NFTokenSellOffer",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 29,
            type: "Hash256",
          },
        ],
        [
          "HookStateKey",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 30,
            type: "Hash256",
          },
        ],
        [
          "HookHash",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 31,
            type: "Hash256",
          },
        ],
        [
          "HookNamespace",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 32,
            type: "Hash256",
          },
        ],
        [
          "HookSetTxnID",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 33,
            type: "Hash256",
          },
        ],
        [
          "DomainID",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 34,
            type: "Hash256",
          },
        ],
        [
          "VaultID",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 35,
            type: "Hash256",
          },
        ],
        [
          "ParentBatchID",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 36,
            type: "Hash256",
          },
        ],
        [
          "hash",
          {
            isSerialized: false,
            isSigningField: false,
            isVLEncoded: false,
            nth: 257,
            type: "Hash256",
          },
        ],
        [
          "index",
          {
            isSerialized: false,
            isSigningField: false,
            isVLEncoded: false,
            nth: 258,
            type: "Hash256",
          },
        ],
        [
          "Amount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 1,
            type: "Amount",
          },
        ],
        [
          "Balance",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 2,
            type: "Amount",
          },
        ],
        [
          "LimitAmount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 3,
            type: "Amount",
          },
        ],
        [
          "TakerPays",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 4,
            type: "Amount",
          },
        ],
        [
          "TakerGets",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 5,
            type: "Amount",
          },
        ],
        [
          "LowLimit",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 6,
            type: "Amount",
          },
        ],
        [
          "HighLimit",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 7,
            type: "Amount",
          },
        ],
        [
          "Fee",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 8,
            type: "Amount",
          },
        ],
        [
          "SendMax",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 9,
            type: "Amount",
          },
        ],
        [
          "DeliverMin",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 10,
            type: "Amount",
          },
        ],
        [
          "Amount2",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 11,
            type: "Amount",
          },
        ],
        [
          "BidMin",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 12,
            type: "Amount",
          },
        ],
        [
          "BidMax",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 13,
            type: "Amount",
          },
        ],
        [
          "MinimumOffer",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 16,
            type: "Amount",
          },
        ],
        [
          "RippleEscrow",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 17,
            type: "Amount",
          },
        ],
        [
          "DeliveredAmount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 18,
            type: "Amount",
          },
        ],
        [
          "NFTokenBrokerFee",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 19,
            type: "Amount",
          },
        ],
        [
          "BaseFeeDrops",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 22,
            type: "Amount",
          },
        ],
        [
          "ReserveBaseDrops",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 23,
            type: "Amount",
          },
        ],
        [
          "ReserveIncrementDrops",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 24,
            type: "Amount",
          },
        ],
        [
          "LPTokenOut",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 25,
            type: "Amount",
          },
        ],
        [
          "LPTokenIn",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 26,
            type: "Amount",
          },
        ],
        [
          "EPrice",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 27,
            type: "Amount",
          },
        ],
        [
          "Price",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 28,
            type: "Amount",
          },
        ],
        [
          "SignatureReward",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 29,
            type: "Amount",
          },
        ],
        [
          "MinAccountCreateAmount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 30,
            type: "Amount",
          },
        ],
        [
          "LPTokenBalance",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 31,
            type: "Amount",
          },
        ],
        [
          "PublicKey",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 1,
            type: "Blob",
          },
        ],
        [
          "MessageKey",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 2,
            type: "Blob",
          },
        ],
        [
          "SigningPubKey",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 3,
            type: "Blob",
          },
        ],
        [
          "TxnSignature",
          {
            isSerialized: true,
            isSigningField: false,
            isVLEncoded: true,
            nth: 4,
            type: "Blob",
          },
        ],
        [
          "URI",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 5,
            type: "Blob",
          },
        ],
        [
          "Signature",
          {
            isSerialized: true,
            isSigningField: false,
            isVLEncoded: true,
            nth: 6,
            type: "Blob",
          },
        ],
        [
          "Domain",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 7,
            type: "Blob",
          },
        ],
        [
          "FundCode",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 8,
            type: "Blob",
          },
        ],
        [
          "RemoveCode",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 9,
            type: "Blob",
          },
        ],
        [
          "ExpireCode",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 10,
            type: "Blob",
          },
        ],
        [
          "CreateCode",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 11,
            type: "Blob",
          },
        ],
        [
          "MemoType",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 12,
            type: "Blob",
          },
        ],
        [
          "MemoData",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 13,
            type: "Blob",
          },
        ],
        [
          "MemoFormat",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 14,
            type: "Blob",
          },
        ],
        [
          "Fulfillment",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 16,
            type: "Blob",
          },
        ],
        [
          "Condition",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 17,
            type: "Blob",
          },
        ],
        [
          "MasterSignature",
          {
            isSerialized: true,
            isSigningField: false,
            isVLEncoded: true,
            nth: 18,
            type: "Blob",
          },
        ],
        [
          "UNLModifyValidator",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 19,
            type: "Blob",
          },
        ],
        [
          "ValidatorToDisable",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 20,
            type: "Blob",
          },
        ],
        [
          "ValidatorToReEnable",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 21,
            type: "Blob",
          },
        ],
        [
          "HookStateData",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 22,
            type: "Blob",
          },
        ],
        [
          "HookReturnString",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 23,
            type: "Blob",
          },
        ],
        [
          "HookParameterName",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 24,
            type: "Blob",
          },
        ],
        [
          "HookParameterValue",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 25,
            type: "Blob",
          },
        ],
        [
          "DIDDocument",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 26,
            type: "Blob",
          },
        ],
        [
          "Data",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 27,
            type: "Blob",
          },
        ],
        [
          "AssetClass",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 28,
            type: "Blob",
          },
        ],
        [
          "Provider",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 29,
            type: "Blob",
          },
        ],
        [
          "MPTokenMetadata",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 30,
            type: "Blob",
          },
        ],
        [
          "CredentialType",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 31,
            type: "Blob",
          },
        ],
        [
          "Account",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 1,
            type: "AccountID",
          },
        ],
        [
          "Owner",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 2,
            type: "AccountID",
          },
        ],
        [
          "Destination",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 3,
            type: "AccountID",
          },
        ],
        [
          "Issuer",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 4,
            type: "AccountID",
          },
        ],
        [
          "Authorize",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 5,
            type: "AccountID",
          },
        ],
        [
          "Unauthorize",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 6,
            type: "AccountID",
          },
        ],
        [
          "RegularKey",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 8,
            type: "AccountID",
          },
        ],
        [
          "NFTokenMinter",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 9,
            type: "AccountID",
          },
        ],
        [
          "EmitCallback",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 10,
            type: "AccountID",
          },
        ],
        [
          "Holder",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 11,
            type: "AccountID",
          },
        ],
        [
          "Delegate",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 12,
            type: "AccountID",
          },
        ],
        [
          "HookAccount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 16,
            type: "AccountID",
          },
        ],
        [
          "OtherChainSource",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 18,
            type: "AccountID",
          },
        ],
        [
          "OtherChainDestination",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 19,
            type: "AccountID",
          },
        ],
        [
          "AttestationSignerAccount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 20,
            type: "AccountID",
          },
        ],
        [
          "AttestationRewardAccount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 21,
            type: "AccountID",
          },
        ],
        [
          "LockingChainDoor",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 22,
            type: "AccountID",
          },
        ],
        [
          "IssuingChainDoor",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 23,
            type: "AccountID",
          },
        ],
        [
          "Subject",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 24,
            type: "AccountID",
          },
        ],
        [
          "Number",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 1,
            type: "Number",
          },
        ],
        [
          "AssetsAvailable",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 2,
            type: "Number",
          },
        ],
        [
          "AssetsMaximum",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 3,
            type: "Number",
          },
        ],
        [
          "AssetsTotal",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 4,
            type: "Number",
          },
        ],
        [
          "LossUnrealized",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 5,
            type: "Number",
          },
        ],
        [
          "TransactionMetaData",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 2,
            type: "STObject",
          },
        ],
        [
          "CreatedNode",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 3,
            type: "STObject",
          },
        ],
        [
          "DeletedNode",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 4,
            type: "STObject",
          },
        ],
        [
          "ModifiedNode",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 5,
            type: "STObject",
          },
        ],
        [
          "PreviousFields",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 6,
            type: "STObject",
          },
        ],
        [
          "FinalFields",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 7,
            type: "STObject",
          },
        ],
        [
          "NewFields",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 8,
            type: "STObject",
          },
        ],
        [
          "TemplateEntry",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 9,
            type: "STObject",
          },
        ],
        [
          "Memo",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 10,
            type: "STObject",
          },
        ],
        [
          "SignerEntry",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 11,
            type: "STObject",
          },
        ],
        [
          "NFToken",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 12,
            type: "STObject",
          },
        ],
        [
          "EmitDetails",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 13,
            type: "STObject",
          },
        ],
        [
          "Hook",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 14,
            type: "STObject",
          },
        ],
        [
          "Permission",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 15,
            type: "STObject",
          },
        ],
        [
          "Signer",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 16,
            type: "STObject",
          },
        ],
        [
          "Majority",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 18,
            type: "STObject",
          },
        ],
        [
          "DisabledValidator",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 19,
            type: "STObject",
          },
        ],
        [
          "EmittedTxn",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 20,
            type: "STObject",
          },
        ],
        [
          "HookExecution",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 21,
            type: "STObject",
          },
        ],
        [
          "HookDefinition",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 22,
            type: "STObject",
          },
        ],
        [
          "HookParameter",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 23,
            type: "STObject",
          },
        ],
        [
          "HookGrant",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 24,
            type: "STObject",
          },
        ],
        [
          "VoteEntry",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 25,
            type: "STObject",
          },
        ],
        [
          "AuctionSlot",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 26,
            type: "STObject",
          },
        ],
        [
          "AuthAccount",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 27,
            type: "STObject",
          },
        ],
        [
          "XChainClaimProofSig",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 28,
            type: "STObject",
          },
        ],
        [
          "XChainCreateAccountProofSig",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 29,
            type: "STObject",
          },
        ],
        [
          "XChainClaimAttestationCollectionElement",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 30,
            type: "STObject",
          },
        ],
        [
          "XChainCreateAccountAttestationCollectionElement",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 31,
            type: "STObject",
          },
        ],
        [
          "PriceData",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 32,
            type: "STObject",
          },
        ],
        [
          "Credential",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 33,
            type: "STObject",
          },
        ],
        [
          "RawTransaction",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 34,
            type: "STObject",
          },
        ],
        [
          "BatchSigner",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 35,
            type: "STObject",
          },
        ],
        [
          "Book",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 36,
            type: "STObject",
          },
        ],
        [
          "Signers",
          {
            isSerialized: true,
            isSigningField: false,
            isVLEncoded: false,
            nth: 3,
            type: "STArray",
          },
        ],
        [
          "SignerEntries",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 4,
            type: "STArray",
          },
        ],
        [
          "Template",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 5,
            type: "STArray",
          },
        ],
        [
          "Necessary",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 6,
            type: "STArray",
          },
        ],
        [
          "Sufficient",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 7,
            type: "STArray",
          },
        ],
        [
          "AffectedNodes",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 8,
            type: "STArray",
          },
        ],
        [
          "Memos",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 9,
            type: "STArray",
          },
        ],
        [
          "NFTokens",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 10,
            type: "STArray",
          },
        ],
        [
          "Hooks",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 11,
            type: "STArray",
          },
        ],
        [
          "VoteSlots",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 12,
            type: "STArray",
          },
        ],
        [
          "AdditionalBooks",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 13,
            type: "STArray",
          },
        ],
        [
          "Majorities",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 16,
            type: "STArray",
          },
        ],
        [
          "DisabledValidators",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 17,
            type: "STArray",
          },
        ],
        [
          "HookExecutions",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 18,
            type: "STArray",
          },
        ],
        [
          "HookParameters",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 19,
            type: "STArray",
          },
        ],
        [
          "HookGrants",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 20,
            type: "STArray",
          },
        ],
        [
          "XChainClaimAttestations",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 21,
            type: "STArray",
          },
        ],
        [
          "XChainCreateAccountAttestations",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 22,
            type: "STArray",
          },
        ],
        [
          "PriceDataSeries",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 24,
            type: "STArray",
          },
        ],
        [
          "AuthAccounts",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 25,
            type: "STArray",
          },
        ],
        [
          "AuthorizeCredentials",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 26,
            type: "STArray",
          },
        ],
        [
          "UnauthorizeCredentials",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 27,
            type: "STArray",
          },
        ],
        [
          "AcceptedCredentials",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 28,
            type: "STArray",
          },
        ],
        [
          "Permissions",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 29,
            type: "STArray",
          },
        ],
        [
          "RawTransactions",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 30,
            type: "STArray",
          },
        ],
        [
          "BatchSigners",
          {
            isSerialized: true,
            isSigningField: false,
            isVLEncoded: false,
            nth: 31,
            type: "STArray",
          },
        ],
        [
          "CloseResolution",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 1,
            type: "UInt8",
          },
        ],
        [
          "Method",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 2,
            type: "UInt8",
          },
        ],
        [
          "TransactionResult",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 3,
            type: "UInt8",
          },
        ],
        [
          "Scale",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 4,
            type: "UInt8",
          },
        ],
        [
          "AssetScale",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 5,
            type: "UInt8",
          },
        ],
        [
          "TickSize",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 16,
            type: "UInt8",
          },
        ],
        [
          "UNLModifyDisabling",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 17,
            type: "UInt8",
          },
        ],
        [
          "HookResult",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 18,
            type: "UInt8",
          },
        ],
        [
          "WasLockingChainSend",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 19,
            type: "UInt8",
          },
        ],
        [
          "WithdrawalPolicy",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 20,
            type: "UInt8",
          },
        ],
        [
          "TakerPaysCurrency",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 1,
            type: "Hash160",
          },
        ],
        [
          "TakerPaysIssuer",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 2,
            type: "Hash160",
          },
        ],
        [
          "TakerGetsCurrency",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 3,
            type: "Hash160",
          },
        ],
        [
          "TakerGetsIssuer",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 4,
            type: "Hash160",
          },
        ],
        [
          "Paths",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 1,
            type: "PathSet",
          },
        ],
        [
          "Indexes",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 1,
            type: "Vector256",
          },
        ],
        [
          "Hashes",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 2,
            type: "Vector256",
          },
        ],
        [
          "Amendments",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 3,
            type: "Vector256",
          },
        ],
        [
          "NFTokenOffers",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 4,
            type: "Vector256",
          },
        ],
        [
          "CredentialIDs",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: true,
            nth: 5,
            type: "Vector256",
          },
        ],
        [
          "MPTokenIssuanceID",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 1,
            type: "Hash192",
          },
        ],
        [
          "ShareMPTID",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 2,
            type: "Hash192",
          },
        ],
        [
          "LockingChainIssue",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 1,
            type: "Issue",
          },
        ],
        [
          "IssuingChainIssue",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 2,
            type: "Issue",
          },
        ],
        [
          "Asset",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 3,
            type: "Issue",
          },
        ],
        [
          "Asset2",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 4,
            type: "Issue",
          },
        ],
        [
          "XChainBridge",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 1,
            type: "XChainBridge",
          },
        ],
        [
          "BaseAsset",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 1,
            type: "Currency",
          },
        ],
        [
          "QuoteAsset",
          {
            isSerialized: true,
            isSigningField: true,
            isVLEncoded: false,
            nth: 2,
            type: "Currency",
          },
        ],
        [
          "Transaction",
          {
            isSerialized: false,
            isSigningField: false,
            isVLEncoded: false,
            nth: 257,
            type: "Transaction",
          },
        ],
        [
          "LedgerEntry",
          {
            isSerialized: false,
            isSigningField: false,
            isVLEncoded: false,
            nth: 257,
            type: "LedgerEntry",
          },
        ],
        [
          "Validation",
          {
            isSerialized: false,
            isSigningField: false,
            isVLEncoded: false,
            nth: 257,
            type: "Validation",
          },
        ],
        [
          "Metadata",
          {
            isSerialized: false,
            isSigningField: false,
            isVLEncoded: false,
            nth: 257,
            type: "Metadata",
          },
        ],
      ],
      LEDGER_ENTRY_TYPES: {
        AMM: 121,
        AccountRoot: 97,
        Amendments: 102,
        Bridge: 105,
        Check: 67,
        Credential: 129,
        DID: 73,
        Delegate: 131,
        DepositPreauth: 112,
        DirectoryNode: 100,
        Escrow: 117,
        FeeSettings: 115,
        Invalid: -1,
        LedgerHashes: 104,
        MPToken: 127,
        MPTokenIssuance: 126,
        NFTokenOffer: 55,
        NFTokenPage: 80,
        NegativeUNL: 78,
        Offer: 111,
        Oracle: 128,
        PayChannel: 120,
        PermissionedDomain: 130,
        RippleState: 114,
        SignerList: 83,
        Ticket: 84,
        Vault: 132,
        XChainOwnedClaimID: 113,
        XChainOwnedCreateAccountClaimID: 116,
      },
      TRANSACTION_RESULTS: {
        tecAMM_ACCOUNT: 168,
        tecAMM_BALANCE: 163,
        tecAMM_EMPTY: 166,
        tecAMM_FAILED: 164,
        tecAMM_INVALID_TOKENS: 165,
        tecAMM_NOT_EMPTY: 167,
        tecARRAY_EMPTY: 190,
        tecARRAY_TOO_LARGE: 191,
        tecBAD_CREDENTIALS: 193,
        tecCANT_ACCEPT_OWN_NFTOKEN_OFFER: 158,
        tecCLAIM: 100,
        tecCRYPTOCONDITION_ERROR: 146,
        tecDIR_FULL: 121,
        tecDST_TAG_NEEDED: 143,
        tecDUPLICATE: 149,
        tecEMPTY_DID: 187,
        tecEXPIRED: 148,
        tecFAILED_PROCESSING: 105,
        tecFROZEN: 137,
        tecHAS_OBLIGATIONS: 151,
        tecHOOK_REJECTED: 153,
        tecINCOMPLETE: 169,
        tecINSUFFICIENT_FUNDS: 159,
        tecINSUFFICIENT_PAYMENT: 161,
        tecINSUFFICIENT_RESERVE: 141,
        tecINSUFF_FEE: 136,
        tecINSUF_RESERVE_LINE: 122,
        tecINSUF_RESERVE_OFFER: 123,
        tecINTERNAL: 144,
        tecINVALID_UPDATE_TIME: 188,
        tecINVARIANT_FAILED: 147,
        tecKILLED: 150,
        tecLIMIT_EXCEEDED: 195,
        tecLOCKED: 192,
        tecMAX_SEQUENCE_REACHED: 154,
        tecNEED_MASTER_KEY: 142,
        tecNFTOKEN_BUY_SELL_MISMATCH: 156,
        tecNFTOKEN_OFFER_TYPE_MISMATCH: 157,
        tecNO_ALTERNATIVE_KEY: 130,
        tecNO_AUTH: 134,
        tecNO_DELEGATE_PERMISSION: 198,
        tecNO_DST: 124,
        tecNO_DST_INSUF_XRP: 125,
        tecNO_ENTRY: 140,
        tecNO_ISSUER: 133,
        tecNO_LINE: 135,
        tecNO_LINE_INSUF_RESERVE: 126,
        tecNO_LINE_REDUNDANT: 127,
        tecNO_PERMISSION: 139,
        tecNO_REGULAR_KEY: 131,
        tecNO_SUITABLE_NFTOKEN_PAGE: 155,
        tecNO_TARGET: 138,
        tecOBJECT_NOT_FOUND: 160,
        tecOVERSIZE: 145,
        tecOWNERS: 132,
        tecPATH_DRY: 128,
        tecPATH_PARTIAL: 101,
        tecPRECISION_LOSS: 197,
        tecPSEUDO_ACCOUNT: 196,
        tecTOKEN_PAIR_NOT_FOUND: 189,
        tecTOO_SOON: 152,
        tecUNFUNDED: 129,
        tecUNFUNDED_ADD: 102,
        tecUNFUNDED_AMM: 162,
        tecUNFUNDED_OFFER: 103,
        tecUNFUNDED_PAYMENT: 104,
        tecWRONG_ASSET: 194,
        tecXCHAIN_ACCOUNT_CREATE_PAST: 181,
        tecXCHAIN_ACCOUNT_CREATE_TOO_MANY: 182,
        tecXCHAIN_BAD_CLAIM_ID: 172,
        tecXCHAIN_BAD_PUBLIC_KEY_ACCOUNT_PAIR: 185,
        tecXCHAIN_BAD_TRANSFER_ISSUE: 170,
        tecXCHAIN_CLAIM_NO_QUORUM: 173,
        tecXCHAIN_CREATE_ACCOUNT_DISABLED: 186,
        tecXCHAIN_CREATE_ACCOUNT_NONXRP_ISSUE: 175,
        tecXCHAIN_INSUFF_CREATE_AMOUNT: 180,
        tecXCHAIN_NO_CLAIM_ID: 171,
        tecXCHAIN_NO_SIGNERS_LIST: 178,
        tecXCHAIN_PAYMENT_FAILED: 183,
        tecXCHAIN_PROOF_UNKNOWN_KEY: 174,
        tecXCHAIN_REWARD_MISMATCH: 177,
        tecXCHAIN_SELF_COMMIT: 184,
        tecXCHAIN_SENDING_ACCOUNT_MISMATCH: 179,
        tecXCHAIN_WRONG_CHAIN: 176,
        tefALREADY: -198,
        tefBAD_ADD_AUTH: -197,
        tefBAD_AUTH: -196,
        tefBAD_AUTH_MASTER: -183,
        tefBAD_LEDGER: -195,
        tefBAD_QUORUM: -185,
        tefBAD_SIGNATURE: -186,
        tefCREATED: -194,
        tefEXCEPTION: -193,
        tefFAILURE: -199,
        tefINTERNAL: -192,
        tefINVALID_LEDGER_FIX_TYPE: -178,
        tefINVARIANT_FAILED: -182,
        tefMASTER_DISABLED: -188,
        tefMAX_LEDGER: -187,
        tefNFTOKEN_IS_NOT_TRANSFERABLE: -179,
        tefNOT_MULTI_SIGNING: -184,
        tefNO_AUTH_REQUIRED: -191,
        tefNO_TICKET: -180,
        tefPAST_SEQ: -190,
        tefTOO_BIG: -181,
        tefWRONG_PRIOR: -189,
        telBAD_DOMAIN: -398,
        telBAD_PATH_COUNT: -397,
        telBAD_PUBLIC_KEY: -396,
        telCAN_NOT_QUEUE: -392,
        telCAN_NOT_QUEUE_BALANCE: -391,
        telCAN_NOT_QUEUE_BLOCKED: -389,
        telCAN_NOT_QUEUE_BLOCKS: -390,
        telCAN_NOT_QUEUE_FEE: -388,
        telCAN_NOT_QUEUE_FULL: -387,
        telENV_RPC_FAILED: -383,
        telFAILED_PROCESSING: -395,
        telINSUF_FEE_P: -394,
        telLOCAL_ERROR: -399,
        telNETWORK_ID_MAKES_TX_NON_CANONICAL: -384,
        telNO_DST_PARTIAL: -393,
        telREQUIRES_NETWORK_ID: -385,
        telWRONG_NETWORK: -386,
        temARRAY_EMPTY: -253,
        temARRAY_TOO_LARGE: -252,
        temBAD_AMM_TOKENS: -261,
        temBAD_AMOUNT: -298,
        temBAD_CURRENCY: -297,
        temBAD_EXPIRATION: -296,
        temBAD_FEE: -295,
        temBAD_ISSUER: -294,
        temBAD_LIMIT: -293,
        temBAD_NFTOKEN_TRANSFER_FEE: -262,
        temBAD_OFFER: -292,
        temBAD_PATH: -291,
        temBAD_PATH_LOOP: -290,
        temBAD_QUORUM: -271,
        temBAD_REGKEY: -289,
        temBAD_SEND_XRP_LIMIT: -288,
        temBAD_SEND_XRP_MAX: -287,
        temBAD_SEND_XRP_NO_DIRECT: -286,
        temBAD_SEND_XRP_PARTIAL: -285,
        temBAD_SEND_XRP_PATHS: -284,
        temBAD_SEQUENCE: -283,
        temBAD_SIGNATURE: -282,
        temBAD_SIGNER: -272,
        temBAD_SRC_ACCOUNT: -281,
        temBAD_TICK_SIZE: -269,
        temBAD_TRANSFER_FEE: -251,
        temBAD_TRANSFER_RATE: -280,
        temBAD_WEIGHT: -270,
        temCANNOT_PREAUTH_SELF: -267,
        temDISABLED: -273,
        temDST_IS_SRC: -279,
        temDST_NEEDED: -278,
        temEMPTY_DID: -254,
        temINVALID: -277,
        temINVALID_ACCOUNT_ID: -268,
        temINVALID_COUNT: -266,
        temINVALID_FLAG: -276,
        temINVALID_INNER_BATCH: -250,
        temMALFORMED: -299,
        temREDUNDANT: -275,
        temRIPPLE_EMPTY: -274,
        temSEQ_AND_TICKET: -263,
        temUNCERTAIN: -265,
        temUNKNOWN: -264,
        temXCHAIN_BAD_PROOF: -259,
        temXCHAIN_BRIDGE_BAD_ISSUES: -258,
        temXCHAIN_BRIDGE_BAD_MIN_ACCOUNT_CREATE_AMOUNT: -256,
        temXCHAIN_BRIDGE_BAD_REWARD_AMOUNT: -255,
        temXCHAIN_BRIDGE_NONDOOR_OWNER: -257,
        temXCHAIN_EQUAL_DOOR_ACCOUNTS: -260,
        terADDRESS_COLLISION: -86,
        terFUNDS_SPENT: -98,
        terINSUF_FEE_B: -97,
        terLAST: -91,
        terNO_ACCOUNT: -96,
        terNO_AMM: -87,
        terNO_AUTH: -95,
        terNO_LINE: -94,
        terNO_RIPPLE: -90,
        terOWNERS: -93,
        terPRE_SEQ: -92,
        terPRE_TICKET: -88,
        terQUEUED: -89,
        terRETRY: -99,
        tesSUCCESS: 0,
      },
      TRANSACTION_TYPES: {
        AMMBid: 39,
        AMMClawback: 31,
        AMMCreate: 35,
        AMMDelete: 40,
        AMMDeposit: 36,
        AMMVote: 38,
        AMMWithdraw: 37,
        AccountDelete: 21,
        AccountSet: 3,
        Batch: 71,
        CheckCancel: 18,
        CheckCash: 17,
        CheckCreate: 16,
        Clawback: 30,
        CredentialAccept: 59,
        CredentialCreate: 58,
        CredentialDelete: 60,
        DIDDelete: 50,
        DIDSet: 49,
        DelegateSet: 64,
        DepositPreauth: 19,
        EnableAmendment: 100,
        EscrowCancel: 4,
        EscrowCreate: 1,
        EscrowFinish: 2,
        Invalid: -1,
        LedgerStateFix: 53,
        MPTokenAuthorize: 57,
        MPTokenIssuanceCreate: 54,
        MPTokenIssuanceDestroy: 55,
        MPTokenIssuanceSet: 56,
        NFTokenAcceptOffer: 29,
        NFTokenBurn: 26,
        NFTokenCancelOffer: 28,
        NFTokenCreateOffer: 27,
        NFTokenMint: 25,
        NFTokenModify: 61,
        OfferCancel: 8,
        OfferCreate: 7,
        OracleDelete: 52,
        OracleSet: 51,
        Payment: 0,
        PaymentChannelClaim: 15,
        PaymentChannelCreate: 13,
        PaymentChannelFund: 14,
        PermissionedDomainDelete: 63,
        PermissionedDomainSet: 62,
        SetFee: 101,
        SetRegularKey: 5,
        SignerListSet: 12,
        TicketCreate: 10,
        TrustSet: 20,
        UNLModify: 102,
        VaultClawback: 70,
        VaultCreate: 65,
        VaultDelete: 67,
        VaultDeposit: 68,
        VaultSet: 66,
        VaultWithdraw: 69,
        XChainAccountCreateCommit: 44,
        XChainAddAccountCreateAttestation: 46,
        XChainAddClaimAttestation: 45,
        XChainClaim: 43,
        XChainCommit: 42,
        XChainCreateBridge: 48,
        XChainCreateClaimID: 41,
        XChainModifyBridge: 47,
      },
      TYPES: {
        AccountID: 8,
        Amount: 6,
        Blob: 7,
        Currency: 26,
        Done: -1,
        Hash128: 4,
        Hash160: 17,
        Hash192: 21,
        Hash256: 5,
        Issue: 24,
        LedgerEntry: 10002,
        Metadata: 10004,
        NotPresent: 0,
        Number: 9,
        PathSet: 18,
        STArray: 15,
        STObject: 14,
        Transaction: 10001,
        UInt16: 1,
        UInt32: 2,
        UInt384: 22,
        UInt512: 23,
        UInt64: 3,
        UInt8: 16,
        UInt96: 20,
        Unknown: -2,
        Validation: 10003,
        Vector256: 19,
        XChainBridge: 25,
      },
    };
  },
});

// node_modules/ripple-binary-codec/dist/enums/bytes.js
var require_bytes = __commonJS({
  "node_modules/ripple-binary-codec/dist/enums/bytes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BytesLookup = exports2.Bytes = void 0;
    var Bytes = class {
      constructor(name, ordinal, ordinalWidth) {
        this.name = name;
        this.ordinal = ordinal;
        this.ordinalWidth = ordinalWidth;
        this.bytes = new Uint8Array(ordinalWidth);
        for (let i = 0; i < ordinalWidth; i++) {
          this.bytes[ordinalWidth - i - 1] = (ordinal >>> (i * 8)) & 255;
        }
      }
      toJSON() {
        return this.name;
      }
      toBytesSink(sink) {
        sink.put(this.bytes);
      }
      toBytes() {
        return this.bytes;
      }
    };
    exports2.Bytes = Bytes;
    var BytesLookup = class {
      constructor(types, ordinalWidth) {
        this.ordinalWidth = ordinalWidth;
        Object.entries(types).forEach(([k, v]) => {
          this.add(k, v);
        });
      }
      /**
       * Add a new name value pair to the BytesLookup.
       *
       * @param name - A human readable name for the field.
       * @param value - The numeric value for the field.
       * @throws if the name or value already exist in the lookup because it's unclear how to decode.
       */
      add(name, value) {
        if (this[name]) {
          throw new SyntaxError(
            `Attempted to add a value with a duplicate name "${name}". This is not allowed because it is unclear how to decode.`
          );
        }
        if (this[value.toString()]) {
          throw new SyntaxError(`Attempted to add a duplicate value under a different name (Given name: "${name}" and previous name: "${
            this[value.toString()]
          }. This is not allowed because it is unclear how to decode.
Given value: ${value.toString()}`);
        }
        this[name] = new Bytes(name, value, this.ordinalWidth);
        this[value.toString()] = this[name];
      }
      from(value) {
        return value instanceof Bytes ? value : this[value];
      }
      fromParser(parser) {
        return this.from(parser.readUIntN(this.ordinalWidth).toString());
      }
    };
    exports2.BytesLookup = BytesLookup;
  },
});

// node_modules/ripple-binary-codec/dist/serdes/binary-serializer.js
var require_binary_serializer = __commonJS({
  "node_modules/ripple-binary-codec/dist/serdes/binary-serializer.js"(
    exports2
  ) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BinarySerializer = exports2.BytesList = void 0;
    var utils_1 = require_utils2();
    var BytesList = class {
      constructor() {
        this.bytesArray = [];
      }
      /**
       * Get the total number of bytes in the BytesList
       *
       * @return the number of bytes
       */
      getLength() {
        return (0, utils_1.concat)(this.bytesArray).byteLength;
      }
      /**
       * Put bytes in the BytesList
       *
       * @param bytesArg A Uint8Array
       * @return this BytesList
       */
      put(bytesArg) {
        const bytes = Uint8Array.from(bytesArg);
        this.bytesArray.push(bytes);
        return this;
      }
      /**
       * Write this BytesList to the back of another bytes list
       *
       *  @param list The BytesList to write to
       */
      toBytesSink(list) {
        list.put(this.toBytes());
      }
      toBytes() {
        return (0, utils_1.concat)(this.bytesArray);
      }
      toHex() {
        return (0, utils_1.bytesToHex)(this.toBytes());
      }
    };
    exports2.BytesList = BytesList;
    var BinarySerializer = class {
      constructor(sink) {
        this.sink = new BytesList();
        this.sink = sink;
      }
      /**
       * Write a value to this BinarySerializer
       *
       * @param value a SerializedType value
       */
      write(value) {
        value.toBytesSink(this.sink);
      }
      /**
       * Write bytes to this BinarySerializer
       *
       * @param bytes the bytes to write
       */
      put(bytes) {
        this.sink.put(bytes);
      }
      /**
       * Write a value of a given type to this BinarySerializer
       *
       * @param type the type to write
       * @param value a value of that type
       */
      writeType(type, value) {
        this.write(type.from(value));
      }
      /**
       * Write BytesList to this BinarySerializer
       *
       * @param bl BytesList to write to BinarySerializer
       */
      writeBytesList(bl) {
        bl.toBytesSink(this.sink);
      }
      /**
       * Calculate the header of Variable Length encoded bytes
       *
       * @param length the length of the bytes
       */
      encodeVariableLength(length) {
        const lenBytes = new Uint8Array(3);
        if (length <= 192) {
          lenBytes[0] = length;
          return lenBytes.slice(0, 1);
        } else if (length <= 12480) {
          length -= 193;
          lenBytes[0] = 193 + (length >>> 8);
          lenBytes[1] = length & 255;
          return lenBytes.slice(0, 2);
        } else if (length <= 918744) {
          length -= 12481;
          lenBytes[0] = 241 + (length >>> 16);
          lenBytes[1] = (length >> 8) & 255;
          lenBytes[2] = length & 255;
          return lenBytes.slice(0, 3);
        }
        throw new Error("Overflow error");
      }
      /**
       * Write field and value to BinarySerializer
       *
       * @param field field to write to BinarySerializer
       * @param value value to write to BinarySerializer
       */
      writeFieldAndValue(field, value, isUnlModifyWorkaround = false) {
        const associatedValue = field.associatedType.from(value);
        if (associatedValue.toBytesSink === void 0 || field.name === void 0) {
          throw new Error();
        }
        this.sink.put(field.header);
        if (field.isVariableLengthEncoded) {
          this.writeLengthEncoded(associatedValue, isUnlModifyWorkaround);
        } else {
          associatedValue.toBytesSink(this.sink);
        }
      }
      /**
       * Write a variable length encoded value to the BinarySerializer
       *
       * @param value length encoded value to write to BytesList
       */
      writeLengthEncoded(value, isUnlModifyWorkaround = false) {
        const bytes = new BytesList();
        if (!isUnlModifyWorkaround) {
          value.toBytesSink(bytes);
        }
        this.put(this.encodeVariableLength(bytes.getLength()));
        this.writeBytesList(bytes);
      }
    };
    exports2.BinarySerializer = BinarySerializer;
  },
});

// node_modules/ripple-binary-codec/dist/types/serialized-type.js
var require_serialized_type = __commonJS({
  "node_modules/ripple-binary-codec/dist/types/serialized-type.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Comparable = exports2.SerializedType = void 0;
    var binary_serializer_1 = require_binary_serializer();
    var utils_1 = require_utils2();
    var SerializedType = class {
      constructor(bytes) {
        this.bytes = new Uint8Array(0);
        this.bytes =
          bytes !== null && bytes !== void 0 ? bytes : new Uint8Array(0);
      }
      static fromParser(parser, hint) {
        throw new Error("fromParser not implemented");
        return this.fromParser(parser, hint);
      }
      static from(value) {
        throw new Error("from not implemented");
        return this.from(value);
      }
      /**
       * Write the bytes representation of a SerializedType to a BytesList
       *
       * @param list The BytesList to write SerializedType bytes to
       */
      toBytesSink(list) {
        list.put(this.bytes);
      }
      /**
       * Get the hex representation of a SerializedType's bytes
       *
       * @returns hex String of this.bytes
       */
      toHex() {
        return (0, utils_1.bytesToHex)(this.toBytes());
      }
      /**
       * Get the bytes representation of a SerializedType
       *
       * @returns A Uint8Array of the bytes
       */
      toBytes() {
        if (this.bytes) {
          return this.bytes;
        }
        const bytes = new binary_serializer_1.BytesList();
        this.toBytesSink(bytes);
        return bytes.toBytes();
      }
      /**
       * Return the JSON representation of a SerializedType
       *
       * @param _definitions rippled definitions used to parse the values of transaction types and such.
       *                          Unused in default, but used in STObject, STArray
       *                          Can be customized for sidechains and amendments.
       * @returns any type, if not overloaded returns hexString representation of bytes
       */
      toJSON(_definitions, _fieldName) {
        return this.toHex();
      }
      /**
       * @returns hexString representation of this.bytes
       */
      toString() {
        return this.toHex();
      }
    };
    exports2.SerializedType = SerializedType;
    var Comparable = class extends SerializedType {
      lt(other) {
        return this.compareTo(other) < 0;
      }
      eq(other) {
        return this.compareTo(other) === 0;
      }
      gt(other) {
        return this.compareTo(other) > 0;
      }
      gte(other) {
        return this.compareTo(other) > -1;
      }
      lte(other) {
        return this.compareTo(other) < 1;
      }
      /**
       * Overload this method to define how two Comparable SerializedTypes are compared
       *
       * @param other The comparable object to compare this to
       * @returns A number denoting the relationship of this and other
       */
      compareTo(other) {
        throw new Error(
          `cannot compare ${this.toString()} and ${other.toString()}`
        );
      }
    };
    exports2.Comparable = Comparable;
  },
});

// node_modules/ripple-binary-codec/dist/enums/constants.js
var require_constants = __commonJS({
  "node_modules/ripple-binary-codec/dist/enums/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DELEGATABLE_PERMISSIONS_WIDTH =
      exports2.TRANSACTION_RESULT_WIDTH =
      exports2.TRANSACTION_TYPE_WIDTH =
      exports2.LEDGER_ENTRY_WIDTH =
      exports2.TYPE_WIDTH =
        void 0;
    exports2.TYPE_WIDTH = 2;
    exports2.LEDGER_ENTRY_WIDTH = 2;
    exports2.TRANSACTION_TYPE_WIDTH = 2;
    exports2.TRANSACTION_RESULT_WIDTH = 1;
    exports2.DELEGATABLE_PERMISSIONS_WIDTH = 4;
  },
});

// node_modules/ripple-binary-codec/dist/enums/field.js
var require_field = __commonJS({
  "node_modules/ripple-binary-codec/dist/enums/field.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FieldLookup = void 0;
    var bytes_1 = require_bytes();
    var serialized_type_1 = require_serialized_type();
    var constants_1 = require_constants();
    function fieldHeader(type, nth) {
      const header = [];
      if (type < 16) {
        if (nth < 16) {
          header.push((type << 4) | nth);
        } else {
          header.push(type << 4, nth);
        }
      } else if (nth < 16) {
        header.push(nth, type);
      } else {
        header.push(0, type, nth);
      }
      return Uint8Array.from(header);
    }
    function buildField([name, info], typeOrdinal) {
      const field = fieldHeader(typeOrdinal, info.nth);
      return {
        name,
        nth: info.nth,
        isVariableLengthEncoded: info.isVLEncoded,
        isSerialized: info.isSerialized,
        isSigningField: info.isSigningField,
        ordinal: (typeOrdinal << 16) | info.nth,
        type: new bytes_1.Bytes(info.type, typeOrdinal, constants_1.TYPE_WIDTH),
        header: field,
        associatedType: serialized_type_1.SerializedType,
        // For later assignment in ./types/index.js or Definitions.updateAll(...)
      };
    }
    var FieldLookup = class {
      constructor(fields, types) {
        fields.forEach(([name, field_info]) => {
          const typeOrdinal = types[field_info.type];
          this[name] = buildField([name, field_info], typeOrdinal);
          this[this[name].ordinal.toString()] = this[name];
        });
      }
      fromString(value) {
        return this[value];
      }
    };
    exports2.FieldLookup = FieldLookup;
  },
});

// node_modules/ripple-binary-codec/dist/enums/xrpl-definitions-base.js
var require_xrpl_definitions_base = __commonJS({
  "node_modules/ripple-binary-codec/dist/enums/xrpl-definitions-base.js"(
    exports2
  ) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BytesLookup =
      exports2.Bytes =
      exports2.FieldLookup =
      exports2.XrplDefinitionsBase =
        void 0;
    var bytes_1 = require_bytes();
    Object.defineProperty(exports2, "Bytes", {
      enumerable: true,
      get: function () {
        return bytes_1.Bytes;
      },
    });
    Object.defineProperty(exports2, "BytesLookup", {
      enumerable: true,
      get: function () {
        return bytes_1.BytesLookup;
      },
    });
    var field_1 = require_field();
    Object.defineProperty(exports2, "FieldLookup", {
      enumerable: true,
      get: function () {
        return field_1.FieldLookup;
      },
    });
    var constants_1 = require_constants();
    var XrplDefinitionsBase = class {
      /**
       * Present rippled types in a typed and updatable format.
       * For an example of the input format see `definitions.json`.
       * To generate a new definitions file from rippled source code, use the tool at
       * `packages/ripple-binary-codec/tools/generateDefinitions.js`.
       *
       * See the definitions.test.js file for examples of how to create your own updated definitions.json.
       *
       * @param enums - A json encoding of the core types, transaction types, transaction results, transaction names, and fields.
       * @param types - A list of type objects with the same name as the fields defined.
       *              You can use the coreTypes object if you are not adding new types.
       */
      constructor(enums, types) {
        this.type = new bytes_1.BytesLookup(
          enums.TYPES,
          constants_1.TYPE_WIDTH
        );
        this.ledgerEntryType = new bytes_1.BytesLookup(
          enums.LEDGER_ENTRY_TYPES,
          constants_1.LEDGER_ENTRY_WIDTH
        );
        this.transactionType = new bytes_1.BytesLookup(
          enums.TRANSACTION_TYPES,
          constants_1.TRANSACTION_TYPE_WIDTH
        );
        this.transactionResult = new bytes_1.BytesLookup(
          enums.TRANSACTION_RESULTS,
          constants_1.TRANSACTION_RESULT_WIDTH
        );
        this.field = new field_1.FieldLookup(enums.FIELDS, enums.TYPES);
        this.transactionNames = Object.entries(enums.TRANSACTION_TYPES)
          .filter(([_key, value]) => value >= 0)
          .map(([key, _value]) => key);
        this.dataTypes = {};
        this.associateTypes(types);
        this.granularPermissions = {
          TrustlineAuthorize: 65537,
          TrustlineFreeze: 65538,
          TrustlineUnfreeze: 65539,
          AccountDomainSet: 65540,
          AccountEmailHashSet: 65541,
          AccountMessageKeySet: 65542,
          AccountTransferRateSet: 65543,
          AccountTickSizeSet: 65544,
          PaymentMint: 65545,
          PaymentBurn: 65546,
          MPTokenIssuanceLock: 65547,
          MPTokenIssuanceUnlock: 65548,
        };
        const incrementedTransactionTypes = Object.fromEntries(
          Object.entries(enums.TRANSACTION_TYPES).map(([key, value]) => [
            key,
            value + 1,
          ])
        );
        const combinedPermissions = Object.assign(
          Object.assign({}, this.granularPermissions),
          incrementedTransactionTypes
        );
        this.delegatablePermissions = new bytes_1.BytesLookup(
          combinedPermissions,
          constants_1.DELEGATABLE_PERMISSIONS_WIDTH
        );
      }
      /**
       * Associates each Field to a corresponding class that TypeScript can recognize.
       *
       * @param types a list of type objects with the same name as the fields defined.
       *              Defaults to xrpl.js's core type definitions.
       */
      associateTypes(types) {
        this.dataTypes = Object.assign({}, this.dataTypes, types);
        Object.values(this.field).forEach((field) => {
          field.associatedType = this.dataTypes[field.type.name];
        });
        this.field["TransactionType"].associatedType = this.transactionType;
        this.field["TransactionResult"].associatedType = this.transactionResult;
        this.field["LedgerEntryType"].associatedType = this.ledgerEntryType;
        if (this.field["PermissionValue"]) {
          this.field["PermissionValue"].associatedType =
            this.delegatablePermissions;
        }
      }
      getAssociatedTypes() {
        return this.dataTypes;
      }
    };
    exports2.XrplDefinitionsBase = XrplDefinitionsBase;
  },
});

// node_modules/ripple-binary-codec/dist/enums/index.js
var require_enums = __commonJS({
  "node_modules/ripple-binary-codec/dist/enums/index.js"(exports2) {
    "use strict";
    var __importDefault =
      (exports2 && exports2.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TRANSACTION_TYPES =
      exports2.TransactionType =
      exports2.TransactionResult =
      exports2.LedgerEntryType =
      exports2.Type =
      exports2.Field =
      exports2.DEFAULT_DEFINITIONS =
      exports2.XrplDefinitionsBase =
      exports2.Bytes =
        void 0;
    var definitions_json_1 = __importDefault(require_definitions());
    var xrpl_definitions_base_1 = require_xrpl_definitions_base();
    Object.defineProperty(exports2, "XrplDefinitionsBase", {
      enumerable: true,
      get: function () {
        return xrpl_definitions_base_1.XrplDefinitionsBase;
      },
    });
    Object.defineProperty(exports2, "Bytes", {
      enumerable: true,
      get: function () {
        return xrpl_definitions_base_1.Bytes;
      },
    });
    var DEFAULT_DEFINITIONS = new xrpl_definitions_base_1.XrplDefinitionsBase(
      definitions_json_1.default,
      {}
    );
    exports2.DEFAULT_DEFINITIONS = DEFAULT_DEFINITIONS;
    var Type = DEFAULT_DEFINITIONS.type;
    exports2.Type = Type;
    var LedgerEntryType = DEFAULT_DEFINITIONS.ledgerEntryType;
    exports2.LedgerEntryType = LedgerEntryType;
    var TransactionType = DEFAULT_DEFINITIONS.transactionType;
    exports2.TransactionType = TransactionType;
    var TransactionResult = DEFAULT_DEFINITIONS.transactionResult;
    exports2.TransactionResult = TransactionResult;
    var Field = DEFAULT_DEFINITIONS.field;
    exports2.Field = Field;
    var TRANSACTION_TYPES = DEFAULT_DEFINITIONS.transactionNames;
    exports2.TRANSACTION_TYPES = TRANSACTION_TYPES;
  },
});

// node_modules/ripple-binary-codec/dist/utils.js
var require_utils4 = __commonJS({
  "node_modules/ripple-binary-codec/dist/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.compare =
      exports2.equal =
      exports2.readInt64BE =
      exports2.readInt32BE =
      exports2.readUInt32BE =
      exports2.readUInt16BE =
      exports2.writeInt64BE =
      exports2.writeInt32BE =
      exports2.writeUInt32BE =
      exports2.writeUInt16BE =
      exports2.writeUInt8 =
        void 0;
    function writeUInt8(array, value, offset) {
      value = Number(value);
      array[offset] = value;
    }
    exports2.writeUInt8 = writeUInt8;
    function writeUInt16BE(array, value, offset) {
      value = Number(value);
      array[offset] = value >>> 8;
      array[offset + 1] = value;
    }
    exports2.writeUInt16BE = writeUInt16BE;
    function writeUInt32BE(array, value, offset) {
      array[offset] = (value >>> 24) & 255;
      array[offset + 1] = (value >>> 16) & 255;
      array[offset + 2] = (value >>> 8) & 255;
      array[offset + 3] = value & 255;
    }
    exports2.writeUInt32BE = writeUInt32BE;
    function writeInt32BE(array, value, offset) {
      new DataView(array.buffer, array.byteOffset, array.byteLength).setInt32(
        offset,
        value,
        false
      );
    }
    exports2.writeInt32BE = writeInt32BE;
    function writeInt64BE(array, value, offset) {
      new DataView(
        array.buffer,
        array.byteOffset,
        array.byteLength
      ).setBigInt64(offset, value, false);
    }
    exports2.writeInt64BE = writeInt64BE;
    function readUInt16BE(array, offset) {
      return new DataView(array.buffer).getUint16(offset, false).toString(10);
    }
    exports2.readUInt16BE = readUInt16BE;
    function readUInt32BE(array, offset) {
      return new DataView(array.buffer).getUint32(offset, false).toString(10);
    }
    exports2.readUInt32BE = readUInt32BE;
    function readInt32BE(array, offset) {
      return new DataView(
        array.buffer,
        array.byteOffset,
        array.byteLength
      ).getInt32(offset, false);
    }
    exports2.readInt32BE = readInt32BE;
    function readInt64BE(array, offset) {
      return new DataView(
        array.buffer,
        array.byteOffset,
        array.byteLength
      ).getBigInt64(offset, false);
    }
    exports2.readInt64BE = readInt64BE;
    function equal(a, b) {
      const aUInt = a instanceof ArrayBuffer ? new Uint8Array(a, 0) : a;
      const bUInt = b instanceof ArrayBuffer ? new Uint8Array(b, 0) : b;
      if (aUInt.byteLength != bUInt.byteLength) return false;
      if (aligned32(aUInt) && aligned32(bUInt))
        return compare32(aUInt, bUInt) === 0;
      if (aligned16(aUInt) && aligned16(bUInt))
        return compare16(aUInt, bUInt) === 0;
      return compare8(aUInt, bUInt) === 0;
    }
    exports2.equal = equal;
    function compare8(a, b) {
      const ua = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
      const ub = new Uint8Array(b.buffer, b.byteOffset, b.byteLength);
      return compare(ua, ub);
    }
    function compare16(a, b) {
      const ua = new Uint16Array(a.buffer, a.byteOffset, a.byteLength / 2);
      const ub = new Uint16Array(b.buffer, b.byteOffset, b.byteLength / 2);
      return compare(ua, ub);
    }
    function compare32(a, b) {
      const ua = new Uint32Array(a.buffer, a.byteOffset, a.byteLength / 4);
      const ub = new Uint32Array(b.buffer, b.byteOffset, b.byteLength / 4);
      return compare(ua, ub);
    }
    function compare(a, b) {
      if (a.byteLength !== b.byteLength) {
        throw new Error("Cannot compare arrays of different length");
      }
      for (let i = 0; i < a.length - 1; i += 1) {
        if (a[i] > b[i]) return 1;
        if (a[i] < b[i]) return -1;
      }
      return 0;
    }
    exports2.compare = compare;
    function aligned16(array) {
      return array.byteOffset % 2 === 0 && array.byteLength % 2 === 0;
    }
    function aligned32(array) {
      return array.byteOffset % 4 === 0 && array.byteLength % 4 === 0;
    }
  },
});

// node_modules/ripple-binary-codec/dist/types/hash.js
var require_hash = __commonJS({
  "node_modules/ripple-binary-codec/dist/types/hash.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Hash = void 0;
    var serialized_type_1 = require_serialized_type();
    var utils_1 = require_utils2();
    var utils_2 = require_utils4();
    var Hash = class extends serialized_type_1.Comparable {
      constructor(bytes) {
        super(bytes);
        if (this.bytes.length !== this.constructor.width) {
          throw new Error(`Invalid Hash length ${this.bytes.byteLength}`);
        }
      }
      /**
       * Construct a Hash object from an existing Hash object or a hex-string
       *
       * @param value A hash object or hex-string of a hash
       */
      static from(value) {
        if (value instanceof this) {
          return value;
        }
        if (typeof value === "string") {
          if (!utils_1.HEX_REGEX.test(value)) {
            throw new Error(`Invalid hash string ${value}`);
          }
          return new this((0, utils_1.hexToBytes)(value));
        }
        throw new Error("Cannot construct Hash from given value");
      }
      /**
       * Read a Hash object from a BinaryParser
       *
       * @param parser BinaryParser to read the hash from
       * @param hint length of the bytes to read, optional
       */
      static fromParser(parser, hint) {
        return new this(
          parser.read(hint !== null && hint !== void 0 ? hint : this.width)
        );
      }
      /**
       * Overloaded operator for comparing two hash objects
       *
       * @param other The Hash to compare this to
       */
      compareTo(other) {
        return (0, utils_2.compare)(
          this.bytes,
          this.constructor.from(other).bytes
        );
      }
      /**
       * @returns the hex-string representation of this Hash
       */
      toString() {
        return this.toHex();
      }
      /**
       * Returns four bits at the specified depth within a hash
       *
       * @param depth The depth of the four bits
       * @returns The number represented by the four bits
       */
      nibblet(depth) {
        const byteIx = depth > 0 ? (depth / 2) | 0 : 0;
        let b = this.bytes[byteIx];
        if (depth % 2 === 0) {
          b = (b & 240) >>> 4;
        } else {
          b = b & 15;
        }
        return b;
      }
    };
    exports2.Hash = Hash;
  },
});

// node_modules/ripple-binary-codec/dist/types/hash-160.js
var require_hash_160 = __commonJS({
  "node_modules/ripple-binary-codec/dist/types/hash-160.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Hash160 = void 0;
    var hash_1 = require_hash();
    var Hash160 = class _Hash160 extends hash_1.Hash {
      constructor(bytes) {
        if (bytes && bytes.byteLength === 0) {
          bytes = _Hash160.ZERO_160.bytes;
        }
        super(
          bytes !== null && bytes !== void 0 ? bytes : _Hash160.ZERO_160.bytes
        );
      }
    };
    exports2.Hash160 = Hash160;
    Hash160.width = 20;
    Hash160.ZERO_160 = new Hash160(new Uint8Array(Hash160.width));
  },
});

// node_modules/ripple-binary-codec/dist/types/account-id.js
var require_account_id = __commonJS({
  "node_modules/ripple-binary-codec/dist/types/account-id.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AccountID = void 0;
    var ripple_address_codec_1 = require_dist();
    var hash_160_1 = require_hash_160();
    var utils_1 = require_utils2();
    var HEX_REGEX = /^[A-F0-9]{40}$/;
    var AccountID = class _AccountID extends hash_160_1.Hash160 {
      constructor(bytes) {
        super(
          bytes !== null && bytes !== void 0
            ? bytes
            : _AccountID.defaultAccountID.bytes
        );
      }
      /**
       * Defines how to construct an AccountID
       *
       * @param value either an existing AccountID, a hex-string, or a base58 r-Address
       * @returns an AccountID object
       */
      static from(value) {
        if (value instanceof _AccountID) {
          return value;
        }
        if (typeof value === "string") {
          if (value === "") {
            return new _AccountID();
          }
          return HEX_REGEX.test(value)
            ? new _AccountID((0, utils_1.hexToBytes)(value))
            : this.fromBase58(value);
        }
        throw new Error("Cannot construct AccountID from value given");
      }
      /**
       * Defines how to build an AccountID from a base58 r-Address
       *
       * @param value a base58 r-Address
       * @returns an AccountID object
       */
      static fromBase58(value) {
        if ((0, ripple_address_codec_1.isValidXAddress)(value)) {
          const classic = (0, ripple_address_codec_1.xAddressToClassicAddress)(
            value
          );
          if (classic.tag !== false)
            throw new Error(
              "Only allowed to have tag on Account or Destination"
            );
          value = classic.classicAddress;
        }
        return new _AccountID(
          Uint8Array.from((0, ripple_address_codec_1.decodeAccountID)(value))
        );
      }
      /**
       * Overload of toJSON
       *
       * @returns the base58 string for this AccountID
       */
      toJSON() {
        return this.toBase58();
      }
      /**
       * Defines how to encode AccountID into a base58 address
       *
       * @returns the base58 string defined by this.bytes
       */
      toBase58() {
        return (0, ripple_address_codec_1.encodeAccountID)(this.bytes);
      }
    };
    exports2.AccountID = AccountID;
    AccountID.defaultAccountID = new AccountID(new Uint8Array(20));
  },
});

// node_modules/ripple-binary-codec/dist/serdes/binary-parser.js
var require_binary_parser = __commonJS({
  "node_modules/ripple-binary-codec/dist/serdes/binary-parser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BinaryParser = void 0;
    var enums_1 = require_enums();
    var utils_1 = require_utils2();
    var BinaryParser = class {
      /**
       * Initialize bytes to a hex string
       *
       * @param hexBytes a hex string
       * @param definitions Rippled definitions used to parse the values of transaction types and such.
       *                          Can be customized for sidechains and amendments.
       */
      constructor(hexBytes, definitions = enums_1.DEFAULT_DEFINITIONS) {
        this.bytes = (0, utils_1.hexToBytes)(hexBytes);
        this.definitions = definitions;
      }
      /**
       * Peek the first byte of the BinaryParser
       *
       * @returns The first byte of the BinaryParser
       */
      peek() {
        if (this.bytes.byteLength === 0) {
          throw new Error();
        }
        return this.bytes[0];
      }
      /**
       * Consume the first n bytes of the BinaryParser
       *
       * @param n the number of bytes to skip
       */
      skip(n) {
        if (n > this.bytes.byteLength) {
          throw new Error();
        }
        this.bytes = this.bytes.slice(n);
      }
      /**
       * read the first n bytes from the BinaryParser
       *
       * @param n The number of bytes to read
       * @return The bytes
       */
      read(n) {
        if (n > this.bytes.byteLength) {
          throw new Error();
        }
        const slice = this.bytes.slice(0, n);
        this.skip(n);
        return slice;
      }
      /**
       * Read an integer of given size
       *
       * @param n The number of bytes to read
       * @return The number represented by those bytes
       */
      readUIntN(n) {
        if (0 >= n || n > 4) {
          throw new Error("invalid n");
        }
        return this.read(n).reduce((a, b) => (a << 8) | b) >>> 0;
      }
      readUInt8() {
        return this.readUIntN(1);
      }
      readUInt16() {
        return this.readUIntN(2);
      }
      readUInt32() {
        return this.readUIntN(4);
      }
      size() {
        return this.bytes.byteLength;
      }
      end(customEnd) {
        const length = this.bytes.byteLength;
        return length === 0 || (customEnd !== void 0 && length <= customEnd);
      }
      /**
       * Reads variable length encoded bytes
       *
       * @return The variable length bytes
       */
      readVariableLength() {
        return this.read(this.readVariableLengthLength());
      }
      /**
       * Reads the length of the variable length encoded bytes
       *
       * @return The length of the variable length encoded bytes
       */
      readVariableLengthLength() {
        const b1 = this.readUInt8();
        if (b1 <= 192) {
          return b1;
        } else if (b1 <= 240) {
          const b2 = this.readUInt8();
          return 193 + (b1 - 193) * 256 + b2;
        } else if (b1 <= 254) {
          const b2 = this.readUInt8();
          const b3 = this.readUInt8();
          return 12481 + (b1 - 241) * 65536 + b2 * 256 + b3;
        }
        throw new Error("Invalid variable length indicator");
      }
      /**
       * Reads the field ordinal from the BinaryParser
       *
       * @return Field ordinal
       */
      readFieldOrdinal() {
        let type = this.readUInt8();
        let nth = type & 15;
        type >>= 4;
        if (type === 0) {
          type = this.readUInt8();
          if (type === 0 || type < 16) {
            throw new Error(
              `Cannot read FieldOrdinal, type_code ${type} out of range`
            );
          }
        }
        if (nth === 0) {
          nth = this.readUInt8();
          if (nth === 0 || nth < 16) {
            throw new Error(
              `Cannot read FieldOrdinal, field_code ${nth} out of range`
            );
          }
        }
        return (type << 16) | nth;
      }
      /**
       * Read the field from the BinaryParser
       *
       * @return The field represented by the bytes at the head of the BinaryParser
       */
      readField() {
        return this.definitions.field.fromString(
          this.readFieldOrdinal().toString()
        );
      }
      /**
       * Read a given type from the BinaryParser
       *
       * @param type The type that you want to read from the BinaryParser
       * @return The instance of that type read from the BinaryParser
       */
      readType(type) {
        return type.fromParser(this);
      }
      /**
       * Get the type associated with a given field
       *
       * @param field The field that you wan to get the type of
       * @return The type associated with the given field
       */
      typeForField(field) {
        return field.associatedType;
      }
      /**
       * Read value of the type specified by field from the BinaryParser
       *
       * @param field The field that you want to get the associated value for
       * @return The value associated with the given field
       */
      readFieldValue(field) {
        const type = this.typeForField(field);
        if (!type) {
          throw new Error(`unsupported: (${field.name}, ${field.type.name})`);
        }
        const sizeHint = field.isVariableLengthEncoded
          ? this.readVariableLengthLength()
          : void 0;
        const value = type.fromParser(this, sizeHint);
        if (value === void 0) {
          throw new Error(
            `fromParser for (${field.name}, ${field.type.name}) -> undefined `
          );
        }
        return value;
      }
      /**
       * Get the next field and value from the BinaryParser
       *
       * @return The field and value
       */
      readFieldAndValue() {
        const field = this.readField();
        return [field, this.readFieldValue(field)];
      }
    };
    exports2.BinaryParser = BinaryParser;
  },
});

// node_modules/ripple-binary-codec/dist/types/currency.js
var require_currency = __commonJS({
  "node_modules/ripple-binary-codec/dist/types/currency.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Currency = void 0;
    var hash_160_1 = require_hash_160();
    var utils_1 = require_utils2();
    var XRP_HEX_REGEX = /^0{40}$/;
    var ISO_REGEX = /^[A-Z0-9a-z?!@#$%^&*(){}[\]|]{3}$/;
    var HEX_REGEX = /^[A-F0-9]{40}$/;
    var STANDARD_FORMAT_HEX_REGEX = /^0{24}[\x00-\x7F]{6}0{10}$/;
    function isoToBytes(iso) {
      const bytes = new Uint8Array(20);
      if (iso !== "XRP") {
        const isoBytes = iso.split("").map((c) => c.charCodeAt(0));
        bytes.set(isoBytes, 12);
      }
      return bytes;
    }
    function isIsoCode(iso) {
      return ISO_REGEX.test(iso);
    }
    function isoCodeFromHex(code) {
      const iso = (0, utils_1.hexToString)((0, utils_1.bytesToHex)(code));
      if (iso === "XRP") {
        return null;
      }
      if (isIsoCode(iso)) {
        return iso;
      }
      return null;
    }
    function isHex(hex) {
      return HEX_REGEX.test(hex);
    }
    function isStringRepresentation(input) {
      return input.length === 3 || isHex(input);
    }
    function isBytesArray(bytes) {
      return bytes.byteLength === 20;
    }
    function isValidRepresentation(input) {
      return input instanceof Uint8Array
        ? isBytesArray(input)
        : isStringRepresentation(input);
    }
    function bytesFromRepresentation(input) {
      if (!isValidRepresentation(input)) {
        throw new Error(`Unsupported Currency representation: ${input}`);
      }
      return input.length === 3
        ? isoToBytes(input)
        : (0, utils_1.hexToBytes)(input);
    }
    var Currency = class _Currency extends hash_160_1.Hash160 {
      constructor(byteBuf) {
        super(
          byteBuf !== null && byteBuf !== void 0 ? byteBuf : _Currency.XRP.bytes
        );
        const hex = (0, utils_1.bytesToHex)(this.bytes);
        if (XRP_HEX_REGEX.test(hex)) {
          this._iso = "XRP";
        } else if (STANDARD_FORMAT_HEX_REGEX.test(hex)) {
          this._iso = isoCodeFromHex(this.bytes.slice(12, 15));
        } else {
          this._iso = null;
        }
      }
      /**
       * Return the ISO code of this currency
       *
       * @returns ISO code if it exists, else null
       */
      iso() {
        return this._iso;
      }
      /**
       * Constructs a Currency object
       *
       * @param val Currency object or a string representation of a currency
       */
      static from(value) {
        if (value instanceof _Currency) {
          return value;
        }
        if (typeof value === "string") {
          return new _Currency(bytesFromRepresentation(value));
        }
        throw new Error("Cannot construct Currency from value given");
      }
      /**
       * Gets the JSON representation of a currency
       *
       * @returns JSON representation
       */
      toJSON() {
        const iso = this.iso();
        if (iso !== null) {
          return iso;
        }
        return (0, utils_1.bytesToHex)(this.bytes);
      }
    };
    exports2.Currency = Currency;
    Currency.XRP = new Currency(new Uint8Array(20));
  },
});

// node_modules/bignumber.js/bignumber.js
var require_bignumber = __commonJS({
  "node_modules/bignumber.js/bignumber.js"(exports2, module2) {
    (function (globalObject) {
      "use strict";
      var BigNumber,
        isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
        mathceil = Math.ceil,
        mathfloor = Math.floor,
        bignumberError = "[BigNumber Error] ",
        tooManyDigits =
          bignumberError +
          "Number primitive has more than 15 significant digits: ",
        BASE = 1e14,
        LOG_BASE = 14,
        MAX_SAFE_INTEGER = 9007199254740991,
        POWS_TEN = [
          1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13,
        ],
        SQRT_BASE = 1e7,
        MAX = 1e9;
      function clone(configObject) {
        var div,
          convertBase,
          parseNumeric,
          P = (BigNumber2.prototype = {
            constructor: BigNumber2,
            toString: null,
            valueOf: null,
          }),
          ONE = new BigNumber2(1),
          DECIMAL_PLACES = 20,
          ROUNDING_MODE = 4,
          TO_EXP_NEG = -7,
          TO_EXP_POS = 21,
          MIN_EXP = -1e7,
          MAX_EXP = 1e7,
          CRYPTO = false,
          MODULO_MODE = 1,
          POW_PRECISION = 0,
          FORMAT = {
            prefix: "",
            groupSize: 3,
            secondaryGroupSize: 0,
            groupSeparator: ",",
            decimalSeparator: ".",
            fractionGroupSize: 0,
            fractionGroupSeparator: "\xA0",
            // non-breaking space
            suffix: "",
          },
          ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz",
          alphabetHasNormalDecimalDigits = true;
        function BigNumber2(v, b) {
          var alphabet,
            c,
            caseChanged,
            e,
            i,
            isNum,
            len,
            str,
            x = this;
          if (!(x instanceof BigNumber2)) return new BigNumber2(v, b);
          if (b == null) {
            if (v && v._isBigNumber === true) {
              x.s = v.s;
              if (!v.c || v.e > MAX_EXP) {
                x.c = x.e = null;
              } else if (v.e < MIN_EXP) {
                x.c = [(x.e = 0)];
              } else {
                x.e = v.e;
                x.c = v.c.slice();
              }
              return;
            }
            if ((isNum = typeof v == "number") && v * 0 == 0) {
              x.s = 1 / v < 0 ? ((v = -v), -1) : 1;
              if (v === ~~v) {
                for (e = 0, i = v; i >= 10; i /= 10, e++);
                if (e > MAX_EXP) {
                  x.c = x.e = null;
                } else {
                  x.e = e;
                  x.c = [v];
                }
                return;
              }
              str = String(v);
            } else {
              if (!isNumeric.test((str = String(v))))
                return parseNumeric(x, str, isNum);
              x.s = str.charCodeAt(0) == 45 ? ((str = str.slice(1)), -1) : 1;
            }
            if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
            if ((i = str.search(/e/i)) > 0) {
              if (e < 0) e = i;
              e += +str.slice(i + 1);
              str = str.substring(0, i);
            } else if (e < 0) {
              e = str.length;
            }
          } else {
            intCheck(b, 2, ALPHABET.length, "Base");
            if (b == 10 && alphabetHasNormalDecimalDigits) {
              x = new BigNumber2(v);
              return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
            }
            str = String(v);
            if ((isNum = typeof v == "number")) {
              if (v * 0 != 0) return parseNumeric(x, str, isNum, b);
              x.s = 1 / v < 0 ? ((str = str.slice(1)), -1) : 1;
              if (
                BigNumber2.DEBUG &&
                str.replace(/^0\.0*|\./, "").length > 15
              ) {
                throw Error(tooManyDigits + v);
              }
            } else {
              x.s = str.charCodeAt(0) === 45 ? ((str = str.slice(1)), -1) : 1;
            }
            alphabet = ALPHABET.slice(0, b);
            e = i = 0;
            for (len = str.length; i < len; i++) {
              if (alphabet.indexOf((c = str.charAt(i))) < 0) {
                if (c == ".") {
                  if (i > e) {
                    e = len;
                    continue;
                  }
                } else if (!caseChanged) {
                  if (
                    (str == str.toUpperCase() && (str = str.toLowerCase())) ||
                    (str == str.toLowerCase() && (str = str.toUpperCase()))
                  ) {
                    caseChanged = true;
                    i = -1;
                    e = 0;
                    continue;
                  }
                }
                return parseNumeric(x, String(v), isNum, b);
              }
            }
            isNum = false;
            str = convertBase(str, b, 10, x.s);
            if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
            else e = str.length;
          }
          for (i = 0; str.charCodeAt(i) === 48; i++);
          for (len = str.length; str.charCodeAt(--len) === 48; );
          if ((str = str.slice(i, ++len))) {
            len -= i;
            if (
              isNum &&
              BigNumber2.DEBUG &&
              len > 15 &&
              (v > MAX_SAFE_INTEGER || v !== mathfloor(v))
            ) {
              throw Error(tooManyDigits + x.s * v);
            }
            if ((e = e - i - 1) > MAX_EXP) {
              x.c = x.e = null;
            } else if (e < MIN_EXP) {
              x.c = [(x.e = 0)];
            } else {
              x.e = e;
              x.c = [];
              i = (e + 1) % LOG_BASE;
              if (e < 0) i += LOG_BASE;
              if (i < len) {
                if (i) x.c.push(+str.slice(0, i));
                for (len -= LOG_BASE; i < len; ) {
                  x.c.push(+str.slice(i, (i += LOG_BASE)));
                }
                i = LOG_BASE - (str = str.slice(i)).length;
              } else {
                i -= len;
              }
              for (; i--; str += "0");
              x.c.push(+str);
            }
          } else {
            x.c = [(x.e = 0)];
          }
        }
        BigNumber2.clone = clone;
        BigNumber2.ROUND_UP = 0;
        BigNumber2.ROUND_DOWN = 1;
        BigNumber2.ROUND_CEIL = 2;
        BigNumber2.ROUND_FLOOR = 3;
        BigNumber2.ROUND_HALF_UP = 4;
        BigNumber2.ROUND_HALF_DOWN = 5;
        BigNumber2.ROUND_HALF_EVEN = 6;
        BigNumber2.ROUND_HALF_CEIL = 7;
        BigNumber2.ROUND_HALF_FLOOR = 8;
        BigNumber2.EUCLID = 9;
        BigNumber2.config = BigNumber2.set = function (obj) {
          var p, v;
          if (obj != null) {
            if (typeof obj == "object") {
              if (obj.hasOwnProperty((p = "DECIMAL_PLACES"))) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                DECIMAL_PLACES = v;
              }
              if (obj.hasOwnProperty((p = "ROUNDING_MODE"))) {
                v = obj[p];
                intCheck(v, 0, 8, p);
                ROUNDING_MODE = v;
              }
              if (obj.hasOwnProperty((p = "EXPONENTIAL_AT"))) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, 0, p);
                  intCheck(v[1], 0, MAX, p);
                  TO_EXP_NEG = v[0];
                  TO_EXP_POS = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
                }
              }
              if (obj.hasOwnProperty((p = "RANGE"))) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, -1, p);
                  intCheck(v[1], 1, MAX, p);
                  MIN_EXP = v[0];
                  MAX_EXP = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  if (v) {
                    MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                  } else {
                    throw Error(bignumberError + p + " cannot be zero: " + v);
                  }
                }
              }
              if (obj.hasOwnProperty((p = "CRYPTO"))) {
                v = obj[p];
                if (v === !!v) {
                  if (v) {
                    if (
                      typeof crypto != "undefined" &&
                      crypto &&
                      (crypto.getRandomValues || crypto.randomBytes)
                    ) {
                      CRYPTO = v;
                    } else {
                      CRYPTO = !v;
                      throw Error(bignumberError + "crypto unavailable");
                    }
                  } else {
                    CRYPTO = v;
                  }
                } else {
                  throw Error(bignumberError + p + " not true or false: " + v);
                }
              }
              if (obj.hasOwnProperty((p = "MODULO_MODE"))) {
                v = obj[p];
                intCheck(v, 0, 9, p);
                MODULO_MODE = v;
              }
              if (obj.hasOwnProperty((p = "POW_PRECISION"))) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                POW_PRECISION = v;
              }
              if (obj.hasOwnProperty((p = "FORMAT"))) {
                v = obj[p];
                if (typeof v == "object") FORMAT = v;
                else throw Error(bignumberError + p + " not an object: " + v);
              }
              if (obj.hasOwnProperty((p = "ALPHABET"))) {
                v = obj[p];
                if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
                  alphabetHasNormalDecimalDigits =
                    v.slice(0, 10) == "0123456789";
                  ALPHABET = v;
                } else {
                  throw Error(bignumberError + p + " invalid: " + v);
                }
              }
            } else {
              throw Error(bignumberError + "Object expected: " + obj);
            }
          }
          return {
            DECIMAL_PLACES,
            ROUNDING_MODE,
            EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
            RANGE: [MIN_EXP, MAX_EXP],
            CRYPTO,
            MODULO_MODE,
            POW_PRECISION,
            FORMAT,
            ALPHABET,
          };
        };
        BigNumber2.isBigNumber = function (v) {
          if (!v || v._isBigNumber !== true) return false;
          if (!BigNumber2.DEBUG) return true;
          var i,
            n,
            c = v.c,
            e = v.e,
            s = v.s;
          out: if ({}.toString.call(c) == "[object Array]") {
            if (
              (s === 1 || s === -1) &&
              e >= -MAX &&
              e <= MAX &&
              e === mathfloor(e)
            ) {
              if (c[0] === 0) {
                if (e === 0 && c.length === 1) return true;
                break out;
              }
              i = (e + 1) % LOG_BASE;
              if (i < 1) i += LOG_BASE;
              if (String(c[0]).length == i) {
                for (i = 0; i < c.length; i++) {
                  n = c[i];
                  if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
                }
                if (n !== 0) return true;
              }
            }
          } else if (
            c === null &&
            e === null &&
            (s === null || s === 1 || s === -1)
          ) {
            return true;
          }
          throw Error(bignumberError + "Invalid BigNumber: " + v);
        };
        BigNumber2.maximum = BigNumber2.max = function () {
          return maxOrMin(arguments, -1);
        };
        BigNumber2.minimum = BigNumber2.min = function () {
          return maxOrMin(arguments, 1);
        };
        BigNumber2.random = (function () {
          var pow2_53 = 9007199254740992;
          var random53bitInt =
            (Math.random() * pow2_53) & 2097151
              ? function () {
                  return mathfloor(Math.random() * pow2_53);
                }
              : function () {
                  return (
                    ((Math.random() * 1073741824) | 0) * 8388608 +
                    ((Math.random() * 8388608) | 0)
                  );
                };
          return function (dp) {
            var a,
              b,
              e,
              k,
              v,
              i = 0,
              c = [],
              rand = new BigNumber2(ONE);
            if (dp == null) dp = DECIMAL_PLACES;
            else intCheck(dp, 0, MAX);
            k = mathceil(dp / LOG_BASE);
            if (CRYPTO) {
              if (crypto.getRandomValues) {
                a = crypto.getRandomValues(new Uint32Array((k *= 2)));
                for (; i < k; ) {
                  v = a[i] * 131072 + (a[i + 1] >>> 11);
                  if (v >= 9e15) {
                    b = crypto.getRandomValues(new Uint32Array(2));
                    a[i] = b[0];
                    a[i + 1] = b[1];
                  } else {
                    c.push(v % 1e14);
                    i += 2;
                  }
                }
                i = k / 2;
              } else if (crypto.randomBytes) {
                a = crypto.randomBytes((k *= 7));
                for (; i < k; ) {
                  v =
                    (a[i] & 31) * 281474976710656 +
                    a[i + 1] * 1099511627776 +
                    a[i + 2] * 4294967296 +
                    a[i + 3] * 16777216 +
                    (a[i + 4] << 16) +
                    (a[i + 5] << 8) +
                    a[i + 6];
                  if (v >= 9e15) {
                    crypto.randomBytes(7).copy(a, i);
                  } else {
                    c.push(v % 1e14);
                    i += 7;
                  }
                }
                i = k / 7;
              } else {
                CRYPTO = false;
                throw Error(bignumberError + "crypto unavailable");
              }
            }
            if (!CRYPTO) {
              for (; i < k; ) {
                v = random53bitInt();
                if (v < 9e15) c[i++] = v % 1e14;
              }
            }
            k = c[--i];
            dp %= LOG_BASE;
            if (k && dp) {
              v = POWS_TEN[LOG_BASE - dp];
              c[i] = mathfloor(k / v) * v;
            }
            for (; c[i] === 0; c.pop(), i--);
            if (i < 0) {
              c = [(e = 0)];
            } else {
              for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);
              for (i = 1, v = c[0]; v >= 10; v /= 10, i++);
              if (i < LOG_BASE) e -= LOG_BASE - i;
            }
            rand.e = e;
            rand.c = c;
            return rand;
          };
        })();
        BigNumber2.sum = function () {
          var i = 1,
            args = arguments,
            sum = new BigNumber2(args[0]);
          for (; i < args.length; ) sum = sum.plus(args[i++]);
          return sum;
        };
        convertBase = /* @__PURE__ */ (function () {
          var decimal = "0123456789";
          function toBaseOut(str, baseIn, baseOut, alphabet) {
            var j,
              arr = [0],
              arrL,
              i = 0,
              len = str.length;
            for (; i < len; ) {
              for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);
              arr[0] += alphabet.indexOf(str.charAt(i++));
              for (j = 0; j < arr.length; j++) {
                if (arr[j] > baseOut - 1) {
                  if (arr[j + 1] == null) arr[j + 1] = 0;
                  arr[j + 1] += (arr[j] / baseOut) | 0;
                  arr[j] %= baseOut;
                }
              }
            }
            return arr.reverse();
          }
          return function (str, baseIn, baseOut, sign, callerIsToString) {
            var alphabet,
              d,
              e,
              k,
              r,
              x,
              xc,
              y,
              i = str.indexOf("."),
              dp = DECIMAL_PLACES,
              rm = ROUNDING_MODE;
            if (i >= 0) {
              k = POW_PRECISION;
              POW_PRECISION = 0;
              str = str.replace(".", "");
              y = new BigNumber2(baseIn);
              x = y.pow(str.length - i);
              POW_PRECISION = k;
              y.c = toBaseOut(
                toFixedPoint(coeffToString(x.c), x.e, "0"),
                10,
                baseOut,
                decimal
              );
              y.e = y.c.length;
            }
            xc = toBaseOut(
              str,
              baseIn,
              baseOut,
              callerIsToString
                ? ((alphabet = ALPHABET), decimal)
                : ((alphabet = decimal), ALPHABET)
            );
            e = k = xc.length;
            for (; xc[--k] == 0; xc.pop());
            if (!xc[0]) return alphabet.charAt(0);
            if (i < 0) {
              --e;
            } else {
              x.c = xc;
              x.e = e;
              x.s = sign;
              x = div(x, y, dp, rm, baseOut);
              xc = x.c;
              r = x.r;
              e = x.e;
            }
            d = e + dp + 1;
            i = xc[d];
            k = baseOut / 2;
            r = r || d < 0 || xc[d + 1] != null;
            r =
              rm < 4
                ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
                : i > k ||
                  (i == k &&
                    (rm == 4 ||
                      r ||
                      (rm == 6 && xc[d - 1] & 1) ||
                      rm == (x.s < 0 ? 8 : 7)));
            if (d < 1 || !xc[0]) {
              str = r
                ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0))
                : alphabet.charAt(0);
            } else {
              xc.length = d;
              if (r) {
                for (--baseOut; ++xc[--d] > baseOut; ) {
                  xc[d] = 0;
                  if (!d) {
                    ++e;
                    xc = [1].concat(xc);
                  }
                }
              }
              for (k = xc.length; !xc[--k]; );
              for (i = 0, str = ""; i <= k; str += alphabet.charAt(xc[i++]));
              str = toFixedPoint(str, e, alphabet.charAt(0));
            }
            return str;
          };
        })();
        div = /* @__PURE__ */ (function () {
          function multiply(x, k, base) {
            var m,
              temp,
              xlo,
              xhi,
              carry = 0,
              i = x.length,
              klo = k % SQRT_BASE,
              khi = (k / SQRT_BASE) | 0;
            for (x = x.slice(); i--; ) {
              xlo = x[i] % SQRT_BASE;
              xhi = (x[i] / SQRT_BASE) | 0;
              m = khi * xlo + xhi * klo;
              temp = klo * xlo + (m % SQRT_BASE) * SQRT_BASE + carry;
              carry = ((temp / base) | 0) + ((m / SQRT_BASE) | 0) + khi * xhi;
              x[i] = temp % base;
            }
            if (carry) x = [carry].concat(x);
            return x;
          }
          function compare2(a, b, aL, bL) {
            var i, cmp;
            if (aL != bL) {
              cmp = aL > bL ? 1 : -1;
            } else {
              for (i = cmp = 0; i < aL; i++) {
                if (a[i] != b[i]) {
                  cmp = a[i] > b[i] ? 1 : -1;
                  break;
                }
              }
            }
            return cmp;
          }
          function subtract(a, b, aL, base) {
            var i = 0;
            for (; aL--; ) {
              a[aL] -= i;
              i = a[aL] < b[aL] ? 1 : 0;
              a[aL] = i * base + a[aL] - b[aL];
            }
            for (; !a[0] && a.length > 1; a.splice(0, 1));
          }
          return function (x, y, dp, rm, base) {
            var cmp,
              e,
              i,
              more,
              n,
              prod,
              prodL,
              q,
              qc,
              rem,
              remL,
              rem0,
              xi,
              xL,
              yc0,
              yL,
              yz,
              s = x.s == y.s ? 1 : -1,
              xc = x.c,
              yc = y.c;
            if (!xc || !xc[0] || !yc || !yc[0]) {
              return new BigNumber2(
                // Return NaN if either NaN, or both Infinity or 0.
                !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc)
                  ? NaN
                  : // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
                  (xc && xc[0] == 0) || !yc
                  ? s * 0
                  : s / 0
              );
            }
            q = new BigNumber2(s);
            qc = q.c = [];
            e = x.e - y.e;
            s = dp + e + 1;
            if (!base) {
              base = BASE;
              e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
              s = (s / LOG_BASE) | 0;
            }
            for (i = 0; yc[i] == (xc[i] || 0); i++);
            if (yc[i] > (xc[i] || 0)) e--;
            if (s < 0) {
              qc.push(1);
              more = true;
            } else {
              xL = xc.length;
              yL = yc.length;
              i = 0;
              s += 2;
              n = mathfloor(base / (yc[0] + 1));
              if (n > 1) {
                yc = multiply(yc, n, base);
                xc = multiply(xc, n, base);
                yL = yc.length;
                xL = xc.length;
              }
              xi = yL;
              rem = xc.slice(0, yL);
              remL = rem.length;
              for (; remL < yL; rem[remL++] = 0);
              yz = yc.slice();
              yz = [0].concat(yz);
              yc0 = yc[0];
              if (yc[1] >= base / 2) yc0++;
              do {
                n = 0;
                cmp = compare2(yc, rem, yL, remL);
                if (cmp < 0) {
                  rem0 = rem[0];
                  if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);
                  n = mathfloor(rem0 / yc0);
                  if (n > 1) {
                    if (n >= base) n = base - 1;
                    prod = multiply(yc, n, base);
                    prodL = prod.length;
                    remL = rem.length;
                    while (compare2(prod, rem, prodL, remL) == 1) {
                      n--;
                      subtract(prod, yL < prodL ? yz : yc, prodL, base);
                      prodL = prod.length;
                      cmp = 1;
                    }
                  } else {
                    if (n == 0) {
                      cmp = n = 1;
                    }
                    prod = yc.slice();
                    prodL = prod.length;
                  }
                  if (prodL < remL) prod = [0].concat(prod);
                  subtract(rem, prod, remL, base);
                  remL = rem.length;
                  if (cmp == -1) {
                    while (compare2(yc, rem, yL, remL) < 1) {
                      n++;
                      subtract(rem, yL < remL ? yz : yc, remL, base);
                      remL = rem.length;
                    }
                  }
                } else if (cmp === 0) {
                  n++;
                  rem = [0];
                }
                qc[i++] = n;
                if (rem[0]) {
                  rem[remL++] = xc[xi] || 0;
                } else {
                  rem = [xc[xi]];
                  remL = 1;
                }
              } while ((xi++ < xL || rem[0] != null) && s--);
              more = rem[0] != null;
              if (!qc[0]) qc.splice(0, 1);
            }
            if (base == BASE) {
              for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);
              round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
            } else {
              q.e = e;
              q.r = +more;
            }
            return q;
          };
        })();
        function format(n, i, rm, id) {
          var c0, e, ne, len, str;
          if (rm == null) rm = ROUNDING_MODE;
          else intCheck(rm, 0, 8);
          if (!n.c) return n.toString();
          c0 = n.c[0];
          ne = n.e;
          if (i == null) {
            str = coeffToString(n.c);
            str =
              id == 1 || (id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS))
                ? toExponential(str, ne)
                : toFixedPoint(str, ne, "0");
          } else {
            n = round(new BigNumber2(n), i, rm);
            e = n.e;
            str = coeffToString(n.c);
            len = str.length;
            if (id == 1 || (id == 2 && (i <= e || e <= TO_EXP_NEG))) {
              for (; len < i; str += "0", len++);
              str = toExponential(str, e);
            } else {
              i -= ne + (id === 2 && e > ne);
              str = toFixedPoint(str, e, "0");
              if (e + 1 > len) {
                if (--i > 0) for (str += "."; i--; str += "0");
              } else {
                i += e - len;
                if (i > 0) {
                  if (e + 1 == len) str += ".";
                  for (; i--; str += "0");
                }
              }
            }
          }
          return n.s < 0 && c0 ? "-" + str : str;
        }
        function maxOrMin(args, n) {
          var k,
            y,
            i = 1,
            x = new BigNumber2(args[0]);
          for (; i < args.length; i++) {
            y = new BigNumber2(args[i]);
            if (!y.s || (k = compare(x, y)) === n || (k === 0 && x.s === n)) {
              x = y;
            }
          }
          return x;
        }
        function normalise(n, c, e) {
          var i = 1,
            j = c.length;
          for (; !c[--j]; c.pop());
          for (j = c[0]; j >= 10; j /= 10, i++);
          if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
            n.c = n.e = null;
          } else if (e < MIN_EXP) {
            n.c = [(n.e = 0)];
          } else {
            n.e = e;
            n.c = c;
          }
          return n;
        }
        parseNumeric = /* @__PURE__ */ (function () {
          var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
            dotAfter = /^([^.]+)\.$/,
            dotBefore = /^\.([^.]+)$/,
            isInfinityOrNaN = /^-?(Infinity|NaN)$/,
            whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
          return function (x, str, isNum, b) {
            var base,
              s = isNum ? str : str.replace(whitespaceOrPlus, "");
            if (isInfinityOrNaN.test(s)) {
              x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
            } else {
              if (!isNum) {
                s = s.replace(basePrefix, function (m, p1, p2) {
                  base =
                    (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                  return !b || b == base ? p1 : m;
                });
                if (b) {
                  base = b;
                  s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
                }
                if (str != s) return new BigNumber2(s, base);
              }
              if (BigNumber2.DEBUG) {
                throw Error(
                  bignumberError +
                    "Not a" +
                    (b ? " base " + b : "") +
                    " number: " +
                    str
                );
              }
              x.s = null;
            }
            x.c = x.e = null;
          };
        })();
        function round(x, sd, rm, r) {
          var d,
            i,
            j,
            k,
            n,
            ni,
            rd,
            xc = x.c,
            pows10 = POWS_TEN;
          if (xc) {
            out: {
              for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);
              i = sd - d;
              if (i < 0) {
                i += LOG_BASE;
                j = sd;
                n = xc[(ni = 0)];
                rd = mathfloor((n / pows10[d - j - 1]) % 10);
              } else {
                ni = mathceil((i + 1) / LOG_BASE);
                if (ni >= xc.length) {
                  if (r) {
                    for (; xc.length <= ni; xc.push(0));
                    n = rd = 0;
                    d = 1;
                    i %= LOG_BASE;
                    j = i - LOG_BASE + 1;
                  } else {
                    break out;
                  }
                } else {
                  n = k = xc[ni];
                  for (d = 1; k >= 10; k /= 10, d++);
                  i %= LOG_BASE;
                  j = i - LOG_BASE + d;
                  rd = j < 0 ? 0 : mathfloor((n / pows10[d - j - 1]) % 10);
                }
              }
              r =
                r ||
                sd < 0 || // Are there any non-zero digits after the rounding digit?
                // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
                // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
                xc[ni + 1] != null ||
                (j < 0 ? n : n % pows10[d - j - 1]);
              r =
                rm < 4
                  ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
                  : rd > 5 ||
                    (rd == 5 &&
                      (rm == 4 ||
                        r ||
                        (rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
                          (i > 0
                            ? j > 0
                              ? n / pows10[d - j]
                              : 0
                            : xc[ni - 1]) %
                            10 &
                            1) ||
                        rm == (x.s < 0 ? 8 : 7)));
              if (sd < 1 || !xc[0]) {
                xc.length = 0;
                if (r) {
                  sd -= x.e + 1;
                  xc[0] = pows10[(LOG_BASE - (sd % LOG_BASE)) % LOG_BASE];
                  x.e = -sd || 0;
                } else {
                  xc[0] = x.e = 0;
                }
                return x;
              }
              if (i == 0) {
                xc.length = ni;
                k = 1;
                ni--;
              } else {
                xc.length = ni + 1;
                k = pows10[LOG_BASE - i];
                xc[ni] =
                  j > 0 ? mathfloor((n / pows10[d - j]) % pows10[j]) * k : 0;
              }
              if (r) {
                for (;;) {
                  if (ni == 0) {
                    for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);
                    j = xc[0] += k;
                    for (k = 1; j >= 10; j /= 10, k++);
                    if (i != k) {
                      x.e++;
                      if (xc[0] == BASE) xc[0] = 1;
                    }
                    break;
                  } else {
                    xc[ni] += k;
                    if (xc[ni] != BASE) break;
                    xc[ni--] = 0;
                    k = 1;
                  }
                }
              }
              for (i = xc.length; xc[--i] === 0; xc.pop());
            }
            if (x.e > MAX_EXP) {
              x.c = x.e = null;
            } else if (x.e < MIN_EXP) {
              x.c = [(x.e = 0)];
            }
          }
          return x;
        }
        function valueOf(n) {
          var str,
            e = n.e;
          if (e === null) return n.toString();
          str = coeffToString(n.c);
          str =
            e <= TO_EXP_NEG || e >= TO_EXP_POS
              ? toExponential(str, e)
              : toFixedPoint(str, e, "0");
          return n.s < 0 ? "-" + str : str;
        }
        P.absoluteValue = P.abs = function () {
          var x = new BigNumber2(this);
          if (x.s < 0) x.s = 1;
          return x;
        };
        P.comparedTo = function (y, b) {
          return compare(this, new BigNumber2(y, b));
        };
        P.decimalPlaces = P.dp = function (dp, rm) {
          var c,
            n,
            v,
            x = this;
          if (dp != null) {
            intCheck(dp, 0, MAX);
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
            return round(new BigNumber2(x), dp + x.e + 1, rm);
          }
          if (!(c = x.c)) return null;
          n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
          if ((v = c[v])) for (; v % 10 == 0; v /= 10, n--);
          if (n < 0) n = 0;
          return n;
        };
        P.dividedBy = P.div = function (y, b) {
          return div(this, new BigNumber2(y, b), DECIMAL_PLACES, ROUNDING_MODE);
        };
        P.dividedToIntegerBy = P.idiv = function (y, b) {
          return div(this, new BigNumber2(y, b), 0, 1);
        };
        P.exponentiatedBy = P.pow = function (n, m) {
          var half,
            isModExp,
            i,
            k,
            more,
            nIsBig,
            nIsNeg,
            nIsOdd,
            y,
            x = this;
          n = new BigNumber2(n);
          if (n.c && !n.isInteger()) {
            throw Error(
              bignumberError + "Exponent not an integer: " + valueOf(n)
            );
          }
          if (m != null) m = new BigNumber2(m);
          nIsBig = n.e > 14;
          if (
            !x.c ||
            !x.c[0] ||
            (x.c[0] == 1 && !x.e && x.c.length == 1) ||
            !n.c ||
            !n.c[0]
          ) {
            y = new BigNumber2(
              Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n))
            );
            return m ? y.mod(m) : y;
          }
          nIsNeg = n.s < 0;
          if (m) {
            if (m.c ? !m.c[0] : !m.s) return new BigNumber2(NaN);
            isModExp = !nIsNeg && x.isInteger() && m.isInteger();
            if (isModExp) x = x.mod(m);
          } else if (
            n.e > 9 &&
            (x.e > 0 ||
              x.e < -1 ||
              (x.e == 0
                ? x.c[0] > 1 || (nIsBig && x.c[1] >= 24e7)
                : x.c[0] < 8e13 || (nIsBig && x.c[0] <= 9999975e7)))
          ) {
            k = x.s < 0 && isOdd(n) ? -0 : 0;
            if (x.e > -1) k = 1 / k;
            return new BigNumber2(nIsNeg ? 1 / k : k);
          } else if (POW_PRECISION) {
            k = mathceil(POW_PRECISION / LOG_BASE + 2);
          }
          if (nIsBig) {
            half = new BigNumber2(0.5);
            if (nIsNeg) n.s = 1;
            nIsOdd = isOdd(n);
          } else {
            i = Math.abs(+valueOf(n));
            nIsOdd = i % 2;
          }
          y = new BigNumber2(ONE);
          for (;;) {
            if (nIsOdd) {
              y = y.times(x);
              if (!y.c) break;
              if (k) {
                if (y.c.length > k) y.c.length = k;
              } else if (isModExp) {
                y = y.mod(m);
              }
            }
            if (i) {
              i = mathfloor(i / 2);
              if (i === 0) break;
              nIsOdd = i % 2;
            } else {
              n = n.times(half);
              round(n, n.e + 1, 1);
              if (n.e > 14) {
                nIsOdd = isOdd(n);
              } else {
                i = +valueOf(n);
                if (i === 0) break;
                nIsOdd = i % 2;
              }
            }
            x = x.times(x);
            if (k) {
              if (x.c && x.c.length > k) x.c.length = k;
            } else if (isModExp) {
              x = x.mod(m);
            }
          }
          if (isModExp) return y;
          if (nIsNeg) y = ONE.div(y);
          return m
            ? y.mod(m)
            : k
            ? round(y, POW_PRECISION, ROUNDING_MODE, more)
            : y;
        };
        P.integerValue = function (rm) {
          var n = new BigNumber2(this);
          if (rm == null) rm = ROUNDING_MODE;
          else intCheck(rm, 0, 8);
          return round(n, n.e + 1, rm);
        };
        P.isEqualTo = P.eq = function (y, b) {
          return compare(this, new BigNumber2(y, b)) === 0;
        };
        P.isFinite = function () {
          return !!this.c;
        };
        P.isGreaterThan = P.gt = function (y, b) {
          return compare(this, new BigNumber2(y, b)) > 0;
        };
        P.isGreaterThanOrEqualTo = P.gte = function (y, b) {
          return (b = compare(this, new BigNumber2(y, b))) === 1 || b === 0;
        };
        P.isInteger = function () {
          return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
        };
        P.isLessThan = P.lt = function (y, b) {
          return compare(this, new BigNumber2(y, b)) < 0;
        };
        P.isLessThanOrEqualTo = P.lte = function (y, b) {
          return (b = compare(this, new BigNumber2(y, b))) === -1 || b === 0;
        };
        P.isNaN = function () {
          return !this.s;
        };
        P.isNegative = function () {
          return this.s < 0;
        };
        P.isPositive = function () {
          return this.s > 0;
        };
        P.isZero = function () {
          return !!this.c && this.c[0] == 0;
        };
        P.minus = function (y, b) {
          var i,
            j,
            t,
            xLTy,
            x = this,
            a = x.s;
          y = new BigNumber2(y, b);
          b = y.s;
          if (!a || !b) return new BigNumber2(NaN);
          if (a != b) {
            y.s = -b;
            return x.plus(y);
          }
          var xe = x.e / LOG_BASE,
            ye = y.e / LOG_BASE,
            xc = x.c,
            yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc)
              return xc ? ((y.s = -b), y) : new BigNumber2(yc ? x : NaN);
            if (!xc[0] || !yc[0]) {
              return yc[0]
                ? ((y.s = -b), y)
                : new BigNumber2(
                    xc[0]
                      ? x
                      : // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                      ROUNDING_MODE == 3
                      ? -0
                      : 0
                  );
            }
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if ((a = xe - ye)) {
            if ((xLTy = a < 0)) {
              a = -a;
              t = xc;
            } else {
              ye = xe;
              t = yc;
            }
            t.reverse();
            for (b = a; b--; t.push(0));
            t.reverse();
          } else {
            j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
            for (a = b = 0; b < j; b++) {
              if (xc[b] != yc[b]) {
                xLTy = xc[b] < yc[b];
                break;
              }
            }
          }
          if (xLTy) {
            t = xc;
            xc = yc;
            yc = t;
            y.s = -y.s;
          }
          b = (j = yc.length) - (i = xc.length);
          if (b > 0) for (; b--; xc[i++] = 0);
          b = BASE - 1;
          for (; j > a; ) {
            if (xc[--j] < yc[j]) {
              for (i = j; i && !xc[--i]; xc[i] = b);
              --xc[i];
              xc[j] += BASE;
            }
            xc[j] -= yc[j];
          }
          for (; xc[0] == 0; xc.splice(0, 1), --ye);
          if (!xc[0]) {
            y.s = ROUNDING_MODE == 3 ? -1 : 1;
            y.c = [(y.e = 0)];
            return y;
          }
          return normalise(y, xc, ye);
        };
        P.modulo = P.mod = function (y, b) {
          var q,
            s,
            x = this;
          y = new BigNumber2(y, b);
          if (!x.c || !y.s || (y.c && !y.c[0])) {
            return new BigNumber2(NaN);
          } else if (!y.c || (x.c && !x.c[0])) {
            return new BigNumber2(x);
          }
          if (MODULO_MODE == 9) {
            s = y.s;
            y.s = 1;
            q = div(x, y, 0, 3);
            y.s = s;
            q.s *= s;
          } else {
            q = div(x, y, 0, MODULO_MODE);
          }
          y = x.minus(q.times(y));
          if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;
          return y;
        };
        P.multipliedBy = P.times = function (y, b) {
          var c,
            e,
            i,
            j,
            k,
            m,
            xcL,
            xlo,
            xhi,
            ycL,
            ylo,
            yhi,
            zc,
            base,
            sqrtBase,
            x = this,
            xc = x.c,
            yc = (y = new BigNumber2(y, b)).c;
          if (!xc || !yc || !xc[0] || !yc[0]) {
            if (
              !x.s ||
              !y.s ||
              (xc && !xc[0] && !yc) ||
              (yc && !yc[0] && !xc)
            ) {
              y.c = y.e = y.s = null;
            } else {
              y.s *= x.s;
              if (!xc || !yc) {
                y.c = y.e = null;
              } else {
                y.c = [0];
                y.e = 0;
              }
            }
            return y;
          }
          e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
          y.s *= x.s;
          xcL = xc.length;
          ycL = yc.length;
          if (xcL < ycL) {
            zc = xc;
            xc = yc;
            yc = zc;
            i = xcL;
            xcL = ycL;
            ycL = i;
          }
          for (i = xcL + ycL, zc = []; i--; zc.push(0));
          base = BASE;
          sqrtBase = SQRT_BASE;
          for (i = ycL; --i >= 0; ) {
            c = 0;
            ylo = yc[i] % sqrtBase;
            yhi = (yc[i] / sqrtBase) | 0;
            for (k = xcL, j = i + k; j > i; ) {
              xlo = xc[--k] % sqrtBase;
              xhi = (xc[k] / sqrtBase) | 0;
              m = yhi * xlo + xhi * ylo;
              xlo = ylo * xlo + (m % sqrtBase) * sqrtBase + zc[j] + c;
              c = ((xlo / base) | 0) + ((m / sqrtBase) | 0) + yhi * xhi;
              zc[j--] = xlo % base;
            }
            zc[j] = c;
          }
          if (c) {
            ++e;
          } else {
            zc.splice(0, 1);
          }
          return normalise(y, zc, e);
        };
        P.negated = function () {
          var x = new BigNumber2(this);
          x.s = -x.s || null;
          return x;
        };
        P.plus = function (y, b) {
          var t,
            x = this,
            a = x.s;
          y = new BigNumber2(y, b);
          b = y.s;
          if (!a || !b) return new BigNumber2(NaN);
          if (a != b) {
            y.s = -b;
            return x.minus(y);
          }
          var xe = x.e / LOG_BASE,
            ye = y.e / LOG_BASE,
            xc = x.c,
            yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc) return new BigNumber2(a / 0);
            if (!xc[0] || !yc[0])
              return yc[0] ? y : new BigNumber2(xc[0] ? x : a * 0);
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if ((a = xe - ye)) {
            if (a > 0) {
              ye = xe;
              t = yc;
            } else {
              a = -a;
              t = xc;
            }
            t.reverse();
            for (; a--; t.push(0));
            t.reverse();
          }
          a = xc.length;
          b = yc.length;
          if (a - b < 0) {
            t = yc;
            yc = xc;
            xc = t;
            b = a;
          }
          for (a = 0; b; ) {
            a = ((xc[--b] = xc[b] + yc[b] + a) / BASE) | 0;
            xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
          }
          if (a) {
            xc = [a].concat(xc);
            ++ye;
          }
          return normalise(y, xc, ye);
        };
        P.precision = P.sd = function (sd, rm) {
          var c,
            n,
            v,
            x = this;
          if (sd != null && sd !== !!sd) {
            intCheck(sd, 1, MAX);
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
            return round(new BigNumber2(x), sd, rm);
          }
          if (!(c = x.c)) return null;
          v = c.length - 1;
          n = v * LOG_BASE + 1;
          if ((v = c[v])) {
            for (; v % 10 == 0; v /= 10, n--);
            for (v = c[0]; v >= 10; v /= 10, n++);
          }
          if (sd && x.e + 1 > n) n = x.e + 1;
          return n;
        };
        P.shiftedBy = function (k) {
          intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
          return this.times("1e" + k);
        };
        P.squareRoot = P.sqrt = function () {
          var m,
            n,
            r,
            rep,
            t,
            x = this,
            c = x.c,
            s = x.s,
            e = x.e,
            dp = DECIMAL_PLACES + 4,
            half = new BigNumber2("0.5");
          if (s !== 1 || !c || !c[0]) {
            return new BigNumber2(
              !s || (s < 0 && (!c || c[0])) ? NaN : c ? x : 1 / 0
            );
          }
          s = Math.sqrt(+valueOf(x));
          if (s == 0 || s == 1 / 0) {
            n = coeffToString(c);
            if ((n.length + e) % 2 == 0) n += "0";
            s = Math.sqrt(+n);
            e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
            if (s == 1 / 0) {
              n = "5e" + e;
            } else {
              n = s.toExponential();
              n = n.slice(0, n.indexOf("e") + 1) + e;
            }
            r = new BigNumber2(n);
          } else {
            r = new BigNumber2(s + "");
          }
          if (r.c[0]) {
            e = r.e;
            s = e + dp;
            if (s < 3) s = 0;
            for (;;) {
              t = r;
              r = half.times(t.plus(div(x, t, dp, 1)));
              if (
                coeffToString(t.c).slice(0, s) ===
                (n = coeffToString(r.c)).slice(0, s)
              ) {
                if (r.e < e) --s;
                n = n.slice(s - 3, s + 1);
                if (n == "9999" || (!rep && n == "4999")) {
                  if (!rep) {
                    round(t, t.e + DECIMAL_PLACES + 2, 0);
                    if (t.times(t).eq(x)) {
                      r = t;
                      break;
                    }
                  }
                  dp += 4;
                  s += 4;
                  rep = 1;
                } else {
                  if (!+n || (!+n.slice(1) && n.charAt(0) == "5")) {
                    round(r, r.e + DECIMAL_PLACES + 2, 1);
                    m = !r.times(r).eq(x);
                  }
                  break;
                }
              }
            }
          }
          return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
        };
        P.toExponential = function (dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp++;
          }
          return format(this, dp, rm, 1);
        };
        P.toFixed = function (dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp = dp + this.e + 1;
          }
          return format(this, dp, rm);
        };
        P.toFormat = function (dp, rm, format2) {
          var str,
            x = this;
          if (format2 == null) {
            if (dp != null && rm && typeof rm == "object") {
              format2 = rm;
              rm = null;
            } else if (dp && typeof dp == "object") {
              format2 = dp;
              dp = rm = null;
            } else {
              format2 = FORMAT;
            }
          } else if (typeof format2 != "object") {
            throw Error(bignumberError + "Argument not an object: " + format2);
          }
          str = x.toFixed(dp, rm);
          if (x.c) {
            var i,
              arr = str.split("."),
              g1 = +format2.groupSize,
              g2 = +format2.secondaryGroupSize,
              groupSeparator = format2.groupSeparator || "",
              intPart = arr[0],
              fractionPart = arr[1],
              isNeg = x.s < 0,
              intDigits = isNeg ? intPart.slice(1) : intPart,
              len = intDigits.length;
            if (g2) {
              i = g1;
              g1 = g2;
              g2 = i;
              len -= i;
            }
            if (g1 > 0 && len > 0) {
              i = len % g1 || g1;
              intPart = intDigits.substr(0, i);
              for (; i < len; i += g1)
                intPart += groupSeparator + intDigits.substr(i, g1);
              if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
              if (isNeg) intPart = "-" + intPart;
            }
            str = fractionPart
              ? intPart +
                (format2.decimalSeparator || "") +
                ((g2 = +format2.fractionGroupSize)
                  ? fractionPart.replace(
                      new RegExp("\\d{" + g2 + "}\\B", "g"),
                      "$&" + (format2.fractionGroupSeparator || "")
                    )
                  : fractionPart)
              : intPart;
          }
          return (format2.prefix || "") + str + (format2.suffix || "");
        };
        P.toFraction = function (md) {
          var d,
            d0,
            d1,
            d2,
            e,
            exp,
            n,
            n0,
            n1,
            q,
            r,
            s,
            x = this,
            xc = x.c;
          if (md != null) {
            n = new BigNumber2(md);
            if ((!n.isInteger() && (n.c || n.s !== 1)) || n.lt(ONE)) {
              throw Error(
                bignumberError +
                  "Argument " +
                  (n.isInteger() ? "out of range: " : "not an integer: ") +
                  valueOf(n)
              );
            }
          }
          if (!xc) return new BigNumber2(x);
          d = new BigNumber2(ONE);
          n1 = d0 = new BigNumber2(ONE);
          d1 = n0 = new BigNumber2(ONE);
          s = coeffToString(xc);
          e = d.e = s.length - x.e - 1;
          d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
          md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;
          exp = MAX_EXP;
          MAX_EXP = 1 / 0;
          n = new BigNumber2(s);
          n0.c[0] = 0;
          for (;;) {
            q = div(n, d, 0, 1);
            d2 = d0.plus(q.times(d1));
            if (d2.comparedTo(md) == 1) break;
            d0 = d1;
            d1 = d2;
            n1 = n0.plus(q.times((d2 = n1)));
            n0 = d2;
            d = n.minus(q.times((d2 = d)));
            n = d2;
          }
          d2 = div(md.minus(d0), d1, 0, 1);
          n0 = n0.plus(d2.times(n1));
          d0 = d0.plus(d2.times(d1));
          n0.s = n1.s = x.s;
          e = e * 2;
          r =
            div(n1, d1, e, ROUNDING_MODE)
              .minus(x)
              .abs()
              .comparedTo(div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1
              ? [n1, d1]
              : [n0, d0];
          MAX_EXP = exp;
          return r;
        };
        P.toNumber = function () {
          return +valueOf(this);
        };
        P.toPrecision = function (sd, rm) {
          if (sd != null) intCheck(sd, 1, MAX);
          return format(this, sd, rm, 2);
        };
        P.toString = function (b) {
          var str,
            n = this,
            s = n.s,
            e = n.e;
          if (e === null) {
            if (s) {
              str = "Infinity";
              if (s < 0) str = "-" + str;
            } else {
              str = "NaN";
            }
          } else {
            if (b == null) {
              str =
                e <= TO_EXP_NEG || e >= TO_EXP_POS
                  ? toExponential(coeffToString(n.c), e)
                  : toFixedPoint(coeffToString(n.c), e, "0");
            } else if (b === 10 && alphabetHasNormalDecimalDigits) {
              n = round(
                new BigNumber2(n),
                DECIMAL_PLACES + e + 1,
                ROUNDING_MODE
              );
              str = toFixedPoint(coeffToString(n.c), n.e, "0");
            } else {
              intCheck(b, 2, ALPHABET.length, "Base");
              str = convertBase(
                toFixedPoint(coeffToString(n.c), e, "0"),
                10,
                b,
                s,
                true
              );
            }
            if (s < 0 && n.c[0]) str = "-" + str;
          }
          return str;
        };
        P.valueOf = P.toJSON = function () {
          return valueOf(this);
        };
        P._isBigNumber = true;
        if (configObject != null) BigNumber2.set(configObject);
        return BigNumber2;
      }
      function bitFloor(n) {
        var i = n | 0;
        return n > 0 || n === i ? i : i - 1;
      }
      function coeffToString(a) {
        var s,
          z,
          i = 1,
          j = a.length,
          r = a[0] + "";
        for (; i < j; ) {
          s = a[i++] + "";
          z = LOG_BASE - s.length;
          for (; z--; s = "0" + s);
          r += s;
        }
        for (j = r.length; r.charCodeAt(--j) === 48; );
        return r.slice(0, j + 1 || 1);
      }
      function compare(x, y) {
        var a,
          b,
          xc = x.c,
          yc = y.c,
          i = x.s,
          j = y.s,
          k = x.e,
          l = y.e;
        if (!i || !j) return null;
        a = xc && !xc[0];
        b = yc && !yc[0];
        if (a || b) return a ? (b ? 0 : -j) : i;
        if (i != j) return i;
        a = i < 0;
        b = k == l;
        if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;
        if (!b) return (k > l) ^ a ? 1 : -1;
        j = (k = xc.length) < (l = yc.length) ? k : l;
        for (i = 0; i < j; i++)
          if (xc[i] != yc[i]) return (xc[i] > yc[i]) ^ a ? 1 : -1;
        return k == l ? 0 : (k > l) ^ a ? 1 : -1;
      }
      function intCheck(n, min, max, name) {
        if (n < min || n > max || n !== mathfloor(n)) {
          throw Error(
            bignumberError +
              (name || "Argument") +
              (typeof n == "number"
                ? n < min || n > max
                  ? " out of range: "
                  : " not an integer: "
                : " not a primitive number: ") +
              String(n)
          );
        }
      }
      function isOdd(n) {
        var k = n.c.length - 1;
        return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
      }
      function toExponential(str, e) {
        return (
          (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) +
          (e < 0 ? "e" : "e+") +
          e
        );
      }
      function toFixedPoint(str, e, z) {
        var len, zs;
        if (e < 0) {
          for (zs = z + "."; ++e; zs += z);
          str = zs + str;
        } else {
          len = str.length;
          if (++e > len) {
            for (zs = z, e -= len; --e; zs += z);
            str += zs;
          } else if (e < len) {
            str = str.slice(0, e) + "." + str.slice(e);
          }
        }
        return str;
      }
      BigNumber = clone();
      BigNumber["default"] = BigNumber.BigNumber = BigNumber;
      if (typeof define == "function" && define.amd) {
        define(function () {
          return BigNumber;
        });
      } else if (typeof module2 != "undefined" && module2.exports) {
        module2.exports = BigNumber;
      } else {
        if (!globalObject) {
          globalObject = typeof self != "undefined" && self ? self : window;
        }
        globalObject.BigNumber = BigNumber;
      }
    })(exports2);
  },
});

// node_modules/ripple-binary-codec/dist/types/hash-192.js
var require_hash_192 = __commonJS({
  "node_modules/ripple-binary-codec/dist/types/hash-192.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Hash192 = void 0;
    var hash_1 = require_hash();
    var Hash192 = class _Hash192 extends hash_1.Hash {
      constructor(bytes) {
        if (bytes && bytes.byteLength === 0) {
          bytes = _Hash192.ZERO_192.bytes;
        }
        super(
          bytes !== null && bytes !== void 0 ? bytes : _Hash192.ZERO_192.bytes
        );
      }
    };
    exports2.Hash192 = Hash192;
    Hash192.width = 24;
    Hash192.ZERO_192 = new Hash192(new Uint8Array(Hash192.width));
  },
});

// node_modules/ripple-binary-codec/dist/types/amount.js
var require_amount = __commonJS({
  "node_modules/ripple-binary-codec/dist/types/amount.js"(exports2) {
    "use strict";
    var __importDefault =
      (exports2 && exports2.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Amount = void 0;
    var binary_parser_1 = require_binary_parser();
    var account_id_1 = require_account_id();
    var currency_1 = require_currency();
    var serialized_type_1 = require_serialized_type();
    var bignumber_js_1 = __importDefault(require_bignumber());
    var utils_1 = require_utils2();
    var utils_2 = require_utils4();
    var hash_192_1 = require_hash_192();
    var MIN_IOU_EXPONENT = -96;
    var MAX_IOU_EXPONENT = 80;
    var MAX_IOU_PRECISION = 16;
    var MAX_DROPS = new bignumber_js_1.default("1e17");
    var MIN_XRP = new bignumber_js_1.default("1e-6");
    var mask = BigInt(4294967295);
    var mptMask = BigInt(9223372036854776e3);
    bignumber_js_1.default.config({
      EXPONENTIAL_AT: [
        MIN_IOU_EXPONENT - MAX_IOU_PRECISION,
        MAX_IOU_EXPONENT + MAX_IOU_PRECISION,
      ],
    });
    function isAmountObjectIOU(arg) {
      const keys = Object.keys(arg).sort();
      return (
        keys.length === 3 &&
        keys[0] === "currency" &&
        keys[1] === "issuer" &&
        keys[2] === "value"
      );
    }
    function isAmountObjectMPT(arg) {
      const keys = Object.keys(arg).sort();
      return (
        keys.length === 2 &&
        keys[0] === "mpt_issuance_id" &&
        keys[1] === "value"
      );
    }
    var Amount = class _Amount extends serialized_type_1.SerializedType {
      constructor(bytes) {
        super(
          bytes !== null && bytes !== void 0
            ? bytes
            : _Amount.defaultAmount.bytes
        );
      }
      /**
       * Construct an amount from an IOU, MPT or string amount
       *
       * @param value An Amount, object representing an IOU, or a string
       *     representing an integer amount
       * @returns An Amount object
       */
      static from(value) {
        if (value instanceof _Amount) {
          return value;
        }
        let amount = new Uint8Array(8);
        if (typeof value === "string") {
          _Amount.assertXrpIsValid(value);
          const number = BigInt(value);
          const intBuf = [new Uint8Array(4), new Uint8Array(4)];
          (0, utils_2.writeUInt32BE)(
            intBuf[0],
            Number(number >> BigInt(32)),
            0
          );
          (0, utils_2.writeUInt32BE)(
            intBuf[1],
            Number(number & BigInt(mask)),
            0
          );
          amount = (0, utils_1.concat)(intBuf);
          amount[0] |= 64;
          return new _Amount(amount);
        }
        if (isAmountObjectIOU(value)) {
          const number = new bignumber_js_1.default(value.value);
          _Amount.assertIouIsValid(number);
          if (number.isZero()) {
            amount[0] |= 128;
          } else {
            const integerNumberString = number
              .times(`1e${-((number.e || 0) - 15)}`)
              .abs()
              .toString();
            const num = BigInt(integerNumberString);
            const intBuf = [new Uint8Array(4), new Uint8Array(4)];
            (0, utils_2.writeUInt32BE)(intBuf[0], Number(num >> BigInt(32)), 0);
            (0, utils_2.writeUInt32BE)(
              intBuf[1],
              Number(num & BigInt(mask)),
              0
            );
            amount = (0, utils_1.concat)(intBuf);
            amount[0] |= 128;
            if (number.gt(new bignumber_js_1.default(0))) {
              amount[0] |= 64;
            }
            const exponent = (number.e || 0) - 15;
            const exponentByte = 97 + exponent;
            amount[0] |= exponentByte >>> 2;
            amount[1] |= (exponentByte & 3) << 6;
          }
          const currency = currency_1.Currency.from(value.currency).toBytes();
          const issuer = account_id_1.AccountID.from(value.issuer).toBytes();
          return new _Amount((0, utils_1.concat)([amount, currency, issuer]));
        }
        if (isAmountObjectMPT(value)) {
          _Amount.assertMptIsValid(value.value);
          let leadingByte = new Uint8Array(1);
          leadingByte[0] |= 96;
          const num = BigInt(value.value);
          const intBuf = [new Uint8Array(4), new Uint8Array(4)];
          (0, utils_2.writeUInt32BE)(intBuf[0], Number(num >> BigInt(32)), 0);
          (0, utils_2.writeUInt32BE)(intBuf[1], Number(num & BigInt(mask)), 0);
          amount = (0, utils_1.concat)(intBuf);
          const mptIssuanceID = hash_192_1.Hash192.from(
            value.mpt_issuance_id
          ).toBytes();
          return new _Amount(
            (0, utils_1.concat)([leadingByte, amount, mptIssuanceID])
          );
        }
        throw new Error("Invalid type to construct an Amount");
      }
      /**
       * Read an amount from a BinaryParser
       *
       * @param parser BinaryParser to read the Amount from
       * @returns An Amount object
       */
      static fromParser(parser) {
        const isIOU = parser.peek() & 128;
        if (isIOU) return new _Amount(parser.read(48));
        const isMPT = parser.peek() & 32;
        const numBytes = isMPT ? 33 : 8;
        return new _Amount(parser.read(numBytes));
      }
      /**
       * Get the JSON representation of this Amount
       *
       * @returns the JSON interpretation of this.bytes
       */
      toJSON() {
        if (this.isNative()) {
          const bytes = this.bytes;
          const isPositive = bytes[0] & 64;
          const sign = isPositive ? "" : "-";
          bytes[0] &= 63;
          const msb = BigInt((0, utils_2.readUInt32BE)(bytes.slice(0, 4), 0));
          const lsb = BigInt((0, utils_2.readUInt32BE)(bytes.slice(4), 0));
          const num = (msb << BigInt(32)) | lsb;
          return `${sign}${num.toString()}`;
        }
        if (this.isIOU()) {
          const parser = new binary_parser_1.BinaryParser(this.toString());
          const mantissa = parser.read(8);
          const currency = currency_1.Currency.fromParser(parser);
          const issuer = account_id_1.AccountID.fromParser(parser);
          const b1 = mantissa[0];
          const b2 = mantissa[1];
          const isPositive = b1 & 64;
          const sign = isPositive ? "" : "-";
          const exponent = ((b1 & 63) << 2) + ((b2 & 255) >> 6) - 97;
          mantissa[0] = 0;
          mantissa[1] &= 63;
          const value = new bignumber_js_1.default(
            `${sign}0x${(0, utils_1.bytesToHex)(mantissa)}`
          ).times(`1e${exponent}`);
          _Amount.assertIouIsValid(value);
          return {
            value: value.toString(),
            currency: currency.toJSON(),
            issuer: issuer.toJSON(),
          };
        }
        if (this.isMPT()) {
          const parser = new binary_parser_1.BinaryParser(this.toString());
          const leadingByte = parser.read(1);
          const amount = parser.read(8);
          const mptID = hash_192_1.Hash192.fromParser(parser);
          const isPositive = leadingByte[0] & 64;
          const sign = isPositive ? "" : "-";
          const msb = BigInt((0, utils_2.readUInt32BE)(amount.slice(0, 4), 0));
          const lsb = BigInt((0, utils_2.readUInt32BE)(amount.slice(4), 0));
          const num = (msb << BigInt(32)) | lsb;
          return {
            value: `${sign}${num.toString()}`,
            mpt_issuance_id: mptID.toString(),
          };
        }
        throw new Error("Invalid amount to construct JSON");
      }
      /**
       * Validate XRP amount
       *
       * @param amount String representing XRP amount
       * @returns void, but will throw if invalid amount
       */
      static assertXrpIsValid(amount) {
        if (amount.indexOf(".") !== -1) {
          throw new Error(`${amount.toString()} is an illegal amount`);
        }
        const decimal = new bignumber_js_1.default(amount);
        if (!decimal.isZero()) {
          if (decimal.lt(MIN_XRP) || decimal.gt(MAX_DROPS)) {
            throw new Error(`${amount.toString()} is an illegal amount`);
          }
        }
      }
      /**
       * Validate IOU.value amount
       *
       * @param decimal BigNumber object representing IOU.value
       * @returns void, but will throw if invalid amount
       */
      static assertIouIsValid(decimal) {
        if (!decimal.isZero()) {
          const p = decimal.precision();
          const e = (decimal.e || 0) - 15;
          if (
            p > MAX_IOU_PRECISION ||
            e > MAX_IOU_EXPONENT ||
            e < MIN_IOU_EXPONENT
          ) {
            throw new Error("Decimal precision out of range");
          }
          this.verifyNoDecimal(decimal);
        }
      }
      /**
       * Validate MPT.value amount
       *
       * @param decimal BigNumber object representing MPT.value
       * @returns void, but will throw if invalid amount
       */
      static assertMptIsValid(amount) {
        if (amount.indexOf(".") !== -1) {
          throw new Error(`${amount.toString()} is an illegal amount`);
        }
        const decimal = new bignumber_js_1.default(amount);
        if (!decimal.isZero()) {
          if (decimal < (0, bignumber_js_1.default)(0)) {
            throw new Error(`${amount.toString()} is an illegal amount`);
          }
          if (Number(BigInt(amount) & BigInt(mptMask)) != 0) {
            throw new Error(`${amount.toString()} is an illegal amount`);
          }
        }
      }
      /**
       * Ensure that the value after being multiplied by the exponent does not
       * contain a decimal.
       *
       * @param decimal a Decimal object
       * @returns a string of the object without a decimal
       */
      static verifyNoDecimal(decimal) {
        const integerNumberString = decimal
          .times(`1e${-((decimal.e || 0) - 15)}`)
          .abs()
          .toString();
        if (integerNumberString.indexOf(".") !== -1) {
          throw new Error("Decimal place found in integerNumberString");
        }
      }
      /**
       * Test if this amount is in units of Native Currency(XRP)
       *
       * @returns true if Native (XRP)
       */
      isNative() {
        return (this.bytes[0] & 128) === 0 && (this.bytes[0] & 32) === 0;
      }
      /**
       * Test if this amount is in units of MPT
       *
       * @returns true if MPT
       */
      isMPT() {
        return (this.bytes[0] & 128) === 0 && (this.bytes[0] & 32) !== 0;
      }
      /**
       * Test if this amount is in units of IOU
       *
       * @returns true if IOU
       */
      isIOU() {
        return (this.bytes[0] & 128) !== 0;
      }
    };
    exports2.Amount = Amount;
    Amount.defaultAmount = new Amount(
      (0, utils_1.hexToBytes)("4000000000000000")
    );
  },
});

// node_modules/ripple-binary-codec/dist/types/blob.js
var require_blob = __commonJS({
  "node_modules/ripple-binary-codec/dist/types/blob.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Blob = void 0;
    var serialized_type_1 = require_serialized_type();
    var utils_1 = require_utils2();
    var Blob2 = class _Blob extends serialized_type_1.SerializedType {
      constructor(bytes) {
        super(bytes);
      }
      /**
       * Defines how to read a Blob from a BinaryParser
       *
       * @param parser The binary parser to read the Blob from
       * @param hint The length of the blob, computed by readVariableLengthLength() and passed in
       * @returns A Blob object
       */
      static fromParser(parser, hint) {
        return new _Blob(parser.read(hint));
      }
      /**
       * Create a Blob object from a hex-string
       *
       * @param value existing Blob object or a hex-string
       * @returns A Blob object
       */
      static from(value) {
        if (value instanceof _Blob) {
          return value;
        }
        if (typeof value === "string") {
          if (!/^[A-F0-9]*$/iu.test(value)) {
            throw new Error("Cannot construct Blob from a non-hex string");
          }
          return new _Blob((0, utils_1.hexToBytes)(value));
        }
        throw new Error("Cannot construct Blob from value given");
      }
    };
    exports2.Blob = Blob2;
  },
});

// node_modules/ripple-binary-codec/dist/types/hash-128.js
var require_hash_128 = __commonJS({
  "node_modules/ripple-binary-codec/dist/types/hash-128.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Hash128 = void 0;
    var hash_1 = require_hash();
    var utils_1 = require_utils2();
    var Hash128 = class _Hash128 extends hash_1.Hash {
      constructor(bytes) {
        if (bytes && bytes.byteLength === 0) {
          bytes = _Hash128.ZERO_128.bytes;
        }
        super(
          bytes !== null && bytes !== void 0 ? bytes : _Hash128.ZERO_128.bytes
        );
      }
      /**
       * Get the hex representation of a hash-128 bytes, allowing unset
       *
       * @returns hex String of this.bytes
       */
      toHex() {
        const hex = (0, utils_1.bytesToHex)(this.toBytes());
        if (/^0+$/.exec(hex)) {
          return "";
        }
        return hex;
      }
    };
    exports2.Hash128 = Hash128;
    Hash128.width = 16;
    Hash128.ZERO_128 = new Hash128(new Uint8Array(Hash128.width));
  },
});

// node_modules/ripple-binary-codec/dist/types/hash-256.js
var require_hash_256 = __commonJS({
  "node_modules/ripple-binary-codec/dist/types/hash-256.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Hash256 = void 0;
    var hash_1 = require_hash();
    var Hash256 = class _Hash256 extends hash_1.Hash {
      constructor(bytes) {
        super(
          bytes !== null && bytes !== void 0 ? bytes : _Hash256.ZERO_256.bytes
        );
      }
    };
    exports2.Hash256 = Hash256;
    Hash256.width = 32;
    Hash256.ZERO_256 = new Hash256(new Uint8Array(Hash256.width));
  },
});

// node_modules/ripple-binary-codec/dist/types/issue.js
var require_issue = __commonJS({
  "node_modules/ripple-binary-codec/dist/types/issue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Issue = void 0;
    var utils_1 = require_utils2();
    var binary_parser_1 = require_binary_parser();
    var account_id_1 = require_account_id();
    var currency_1 = require_currency();
    var serialized_type_1 = require_serialized_type();
    var hash_192_1 = require_hash_192();
    function isIssueObject(arg) {
      const keys = Object.keys(arg).sort();
      const isXRP = keys.length === 1 && keys[0] === "currency";
      const isIOU =
        keys.length === 2 && keys[0] === "currency" && keys[1] === "issuer";
      const isMPT = keys.length === 1 && keys[0] === "mpt_issuance_id";
      return isXRP || isIOU || isMPT;
    }
    var Issue = class _Issue extends serialized_type_1.SerializedType {
      constructor(bytes) {
        super(
          bytes !== null && bytes !== void 0
            ? bytes
            : _Issue.ZERO_ISSUED_CURRENCY.bytes
        );
      }
      /**
       * Construct an amount from an IOU or string amount
       *
       * @param value An Amount, object representing an IOU, MPTAmount, or a string
       *     representing an integer amount
       * @returns An Issue object
       */
      static from(value) {
        if (value instanceof _Issue) {
          return value;
        }
        if (isIssueObject(value)) {
          if (value.currency) {
            const currency = currency_1.Currency.from(
              value.currency.toString()
            ).toBytes();
            if (value.issuer) {
              const issuer = account_id_1.AccountID.from(
                value.issuer.toString()
              ).toBytes();
              return new _Issue((0, utils_1.concat)([currency, issuer]));
            }
            return new _Issue(currency);
          }
          if (value.mpt_issuance_id) {
            const mptIssuanceIdBytes = hash_192_1.Hash192.from(
              value.mpt_issuance_id.toString()
            ).toBytes();
            return new _Issue(mptIssuanceIdBytes);
          }
        }
        throw new Error("Invalid type to construct an Amount");
      }
      /**
       * Read an amount from a BinaryParser
       *
       * @param parser BinaryParser to read the Amount from
       * @param hint The number of bytes to consume from the parser.
       * For an MPT amount, pass 24 (the fixed length for Hash192).
       *
       * @returns An Issue object
       */
      static fromParser(parser, hint) {
        if (hint === hash_192_1.Hash192.width) {
          const mptBytes = parser.read(hash_192_1.Hash192.width);
          return new _Issue(mptBytes);
        }
        const currency = parser.read(20);
        if (new currency_1.Currency(currency).toJSON() === "XRP") {
          return new _Issue(currency);
        }
        const currencyAndIssuer = [currency, parser.read(20)];
        return new _Issue((0, utils_1.concat)(currencyAndIssuer));
      }
      /**
       * Get the JSON representation of this Amount
       *
       * @returns the JSON interpretation of this.bytes
       */
      toJSON() {
        if (this.toBytes().length === hash_192_1.Hash192.width) {
          return {
            mpt_issuance_id: this.toHex().toUpperCase(),
          };
        }
        const parser = new binary_parser_1.BinaryParser(this.toString());
        const currency = currency_1.Currency.fromParser(parser);
        if (currency.toJSON() === "XRP") {
          return { currency: currency.toJSON() };
        }
        const issuer = account_id_1.AccountID.fromParser(parser);
        return {
          currency: currency.toJSON(),
          issuer: issuer.toJSON(),
        };
      }
    };
    exports2.Issue = Issue;
    Issue.ZERO_ISSUED_CURRENCY = new Issue(new Uint8Array(20));
  },
});

// node_modules/ripple-binary-codec/dist/types/st-number.js
var require_st_number = __commonJS({
  "node_modules/ripple-binary-codec/dist/types/st-number.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.STNumber = void 0;
    var serialized_type_1 = require_serialized_type();
    var utils_1 = require_utils4();
    var MIN_MANTISSA = BigInt("1000000000000000");
    var MAX_MANTISSA = BigInt("9999999999999999");
    var MIN_EXPONENT = -32768;
    var MAX_EXPONENT = 32768;
    var DEFAULT_VALUE_EXPONENT = -2147483648;
    function extractNumberPartsFromString(val) {
      const regex = /^([-+]?)([0-9]+)(?:\.([0-9]+))?(?:[eE]([+-]?[0-9]+))?$/;
      const match = regex.exec(val);
      if (!match) throw new Error(`Unable to parse number from string: ${val}`);
      const [, sign, intPart, fracPart, expPart] = match;
      const cleanIntPart = intPart.replace(/^0+(?=\d)/, "") || "0";
      let mantissaStr = cleanIntPart;
      let exponent = 0;
      if (fracPart) {
        mantissaStr += fracPart;
        exponent -= fracPart.length;
      }
      if (expPart) exponent += parseInt(expPart, 10);
      let mantissa = BigInt(mantissaStr);
      if (sign === "-") mantissa = -mantissa;
      const isNegative = mantissa < BigInt(0);
      return { mantissa, exponent, isNegative };
    }
    function normalize(mantissa, exponent) {
      let m = mantissa < BigInt(0) ? -mantissa : mantissa;
      const isNegative = mantissa < BigInt(0);
      while (m !== BigInt(0) && m < MIN_MANTISSA && exponent > MIN_EXPONENT) {
        exponent -= 1;
        m *= BigInt(10);
      }
      while (m > MAX_MANTISSA) {
        if (exponent >= MAX_EXPONENT)
          throw new Error("Mantissa and exponent are too large");
        exponent += 1;
        m /= BigInt(10);
      }
      if (isNegative) m = -m;
      return { mantissa: m, exponent };
    }
    var STNumber = class _STNumber extends serialized_type_1.SerializedType {
      /**
       * Construct a STNumber from 12 bytes (8 for mantissa, 4 for exponent).
       * @param bytes - 12-byte Uint8Array
       * @throws Error if input is not a Uint8Array of length 12.
       */
      constructor(bytes) {
        const used =
          bytes !== null && bytes !== void 0 ? bytes : _STNumber.defaultBytes;
        if (!(used instanceof Uint8Array) || used.length !== 12) {
          throw new Error(
            `STNumber must be constructed from a 12-byte Uint8Array, got ${
              used === null || used === void 0 ? void 0 : used.length
            }`
          );
        }
        super(used);
      }
      /**
       * Construct from a number string (or another STNumber).
       *
       * @param value - A string, or STNumber instance.
       * @returns STNumber instance.
       * @throws Error if not a string or STNumber.
       */
      static from(value) {
        if (value instanceof _STNumber) {
          return value;
        }
        if (typeof value === "string") {
          return _STNumber.fromValue(value);
        }
        throw new Error(
          "STNumber.from: Only string or STNumber instance is supported"
        );
      }
      /**
       * Construct from a number string (integer, decimal, or scientific notation).
       * Handles normalization to XRPL Number constraints.
       *
       * @param val - The number as a string (e.g. '1.23', '-123e5').
       * @returns STNumber instance
       * @throws Error if val is not a valid number string.
       */
      static fromValue(val) {
        const { mantissa, exponent, isNegative } =
          extractNumberPartsFromString(val);
        let normalizedMantissa;
        let normalizedExponent;
        if (mantissa === BigInt(0) && exponent === 0 && !isNegative) {
          normalizedMantissa = BigInt(0);
          normalizedExponent = DEFAULT_VALUE_EXPONENT;
        } else {
          ({ mantissa: normalizedMantissa, exponent: normalizedExponent } =
            normalize(mantissa, exponent));
        }
        const bytes = new Uint8Array(12);
        (0, utils_1.writeInt64BE)(bytes, normalizedMantissa, 0);
        (0, utils_1.writeInt32BE)(bytes, normalizedExponent, 8);
        return new _STNumber(bytes);
      }
      /**
       * Read a STNumber from a BinaryParser stream (12 bytes).
       * @param parser - BinaryParser positioned at the start of a number
       * @returns STNumber instance
       */
      static fromParser(parser) {
        return new _STNumber(parser.read(12));
      }
      /**
       * Convert this STNumber to a normalized string representation.
       * The output is decimal or scientific notation, depending on exponent range.
       * Follows XRPL convention: zero is "0", other values are normalized to a canonical string.
       *
       * @returns String representation of the value
       */
      // eslint-disable-next-line complexity -- required
      toJSON() {
        const b = this.bytes;
        if (!b || b.length !== 12)
          throw new Error("STNumber internal bytes not set or wrong length");
        const mantissa = (0, utils_1.readInt64BE)(b, 0);
        const exponent = (0, utils_1.readInt32BE)(b, 8);
        if (mantissa === BigInt(0) && exponent === DEFAULT_VALUE_EXPONENT) {
          return "0";
        }
        if (exponent === 0) return mantissa.toString();
        if (exponent < -25 || exponent > -5) {
          return `${mantissa}e${exponent}`;
        }
        const isNegative = mantissa < BigInt(0);
        const mantissaAbs = mantissa < BigInt(0) ? -mantissa : mantissa;
        const padPrefix = 27;
        const padSuffix = 23;
        const mantissaStr = mantissaAbs.toString();
        const rawValue =
          "0".repeat(padPrefix) + mantissaStr + "0".repeat(padSuffix);
        const OFFSET = exponent + 43;
        const integerPart = rawValue.slice(0, OFFSET).replace(/^0+/, "") || "0";
        const fractionPart = rawValue.slice(OFFSET).replace(/0+$/, "");
        return `${isNegative ? "-" : ""}${integerPart}${
          fractionPart ? "." + fractionPart : ""
        }`;
      }
    };
    exports2.STNumber = STNumber;
    STNumber.defaultBytes = new Uint8Array(12);
  },
});

// node_modules/ripple-binary-codec/dist/types/path-set.js
var require_path_set = __commonJS({
  "node_modules/ripple-binary-codec/dist/types/path-set.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PathSet = void 0;
    var account_id_1 = require_account_id();
    var currency_1 = require_currency();
    var binary_parser_1 = require_binary_parser();
    var serialized_type_1 = require_serialized_type();
    var utils_1 = require_utils2();
    var PATHSET_END_BYTE = 0;
    var PATH_SEPARATOR_BYTE = 255;
    var TYPE_ACCOUNT = 1;
    var TYPE_CURRENCY = 16;
    var TYPE_ISSUER = 32;
    function isHopObject(arg) {
      return (
        arg.issuer !== void 0 ||
        arg.account !== void 0 ||
        arg.currency !== void 0
      );
    }
    function isPathSet(arg) {
      return (
        (Array.isArray(arg) && arg.length === 0) ||
        (Array.isArray(arg) && Array.isArray(arg[0]) && arg[0].length === 0) ||
        (Array.isArray(arg) && Array.isArray(arg[0]) && isHopObject(arg[0][0]))
      );
    }
    var Hop = class _Hop extends serialized_type_1.SerializedType {
      /**
       * Create a Hop from a HopObject
       *
       * @param value Either a hop or HopObject to create a hop with
       * @returns a Hop
       */
      static from(value) {
        if (value instanceof _Hop) {
          return value;
        }
        const bytes = [Uint8Array.from([0])];
        if (value.account) {
          bytes.push(account_id_1.AccountID.from(value.account).toBytes());
          bytes[0][0] |= TYPE_ACCOUNT;
        }
        if (value.currency) {
          bytes.push(currency_1.Currency.from(value.currency).toBytes());
          bytes[0][0] |= TYPE_CURRENCY;
        }
        if (value.issuer) {
          bytes.push(account_id_1.AccountID.from(value.issuer).toBytes());
          bytes[0][0] |= TYPE_ISSUER;
        }
        return new _Hop((0, utils_1.concat)(bytes));
      }
      /**
       * Construct a Hop from a BinaryParser
       *
       * @param parser BinaryParser to read the Hop from
       * @returns a Hop
       */
      static fromParser(parser) {
        const type = parser.readUInt8();
        const bytes = [Uint8Array.from([type])];
        if (type & TYPE_ACCOUNT) {
          bytes.push(parser.read(account_id_1.AccountID.width));
        }
        if (type & TYPE_CURRENCY) {
          bytes.push(parser.read(currency_1.Currency.width));
        }
        if (type & TYPE_ISSUER) {
          bytes.push(parser.read(account_id_1.AccountID.width));
        }
        return new _Hop((0, utils_1.concat)(bytes));
      }
      /**
       * Get the JSON interpretation of this hop
       *
       * @returns a HopObject, an JS object with optional account, issuer, and currency
       */
      toJSON() {
        const hopParser = new binary_parser_1.BinaryParser(
          (0, utils_1.bytesToHex)(this.bytes)
        );
        const type = hopParser.readUInt8();
        let account, currency, issuer;
        if (type & TYPE_ACCOUNT) {
          account = account_id_1.AccountID.fromParser(hopParser).toJSON();
        }
        if (type & TYPE_CURRENCY) {
          currency = currency_1.Currency.fromParser(hopParser).toJSON();
        }
        if (type & TYPE_ISSUER) {
          issuer = account_id_1.AccountID.fromParser(hopParser).toJSON();
        }
        const result = {};
        if (account) {
          result.account = account;
        }
        if (issuer) {
          result.issuer = issuer;
        }
        if (currency) {
          result.currency = currency;
        }
        return result;
      }
      /**
       * get a number representing the type of this hop
       *
       * @returns a number to be bitwise and-ed with TYPE_ constants to describe the types in the hop
       */
      type() {
        return this.bytes[0];
      }
    };
    var Path = class _Path extends serialized_type_1.SerializedType {
      /**
       * construct a Path from an array of Hops
       *
       * @param value Path or array of HopObjects to construct a Path
       * @returns the Path
       */
      static from(value) {
        if (value instanceof _Path) {
          return value;
        }
        const bytes = [];
        value.forEach((hop) => {
          bytes.push(Hop.from(hop).toBytes());
        });
        return new _Path((0, utils_1.concat)(bytes));
      }
      /**
       * Read a Path from a BinaryParser
       *
       * @param parser BinaryParser to read Path from
       * @returns the Path represented by the bytes read from the BinaryParser
       */
      static fromParser(parser) {
        const bytes = [];
        while (!parser.end()) {
          bytes.push(Hop.fromParser(parser).toBytes());
          if (
            parser.peek() === PATHSET_END_BYTE ||
            parser.peek() === PATH_SEPARATOR_BYTE
          ) {
            break;
          }
        }
        return new _Path((0, utils_1.concat)(bytes));
      }
      /**
       * Get the JSON representation of this Path
       *
       * @returns an Array of HopObject constructed from this.bytes
       */
      toJSON() {
        const json = [];
        const pathParser = new binary_parser_1.BinaryParser(this.toString());
        while (!pathParser.end()) {
          json.push(Hop.fromParser(pathParser).toJSON());
        }
        return json;
      }
    };
    var PathSet = class _PathSet extends serialized_type_1.SerializedType {
      /**
       * Construct a PathSet from an Array of Arrays representing paths
       *
       * @param value A PathSet or Array of Array of HopObjects
       * @returns the PathSet constructed from value
       */
      static from(value) {
        if (value instanceof _PathSet) {
          return value;
        }
        if (isPathSet(value)) {
          const bytes = [];
          value.forEach((path) => {
            bytes.push(Path.from(path).toBytes());
            bytes.push(Uint8Array.from([PATH_SEPARATOR_BYTE]));
          });
          bytes[bytes.length - 1] = Uint8Array.from([PATHSET_END_BYTE]);
          return new _PathSet((0, utils_1.concat)(bytes));
        }
        throw new Error("Cannot construct PathSet from given value");
      }
      /**
       * Construct a PathSet from a BinaryParser
       *
       * @param parser A BinaryParser to read PathSet from
       * @returns the PathSet read from parser
       */
      static fromParser(parser) {
        const bytes = [];
        while (!parser.end()) {
          bytes.push(Path.fromParser(parser).toBytes());
          bytes.push(parser.read(1));
          if (bytes[bytes.length - 1][0] == PATHSET_END_BYTE) {
            break;
          }
        }
        return new _PathSet((0, utils_1.concat)(bytes));
      }
      /**
       * Get the JSON representation of this PathSet
       *
       * @returns an Array of Array of HopObjects, representing this PathSet
       */
      toJSON() {
        const json = [];
        const pathParser = new binary_parser_1.BinaryParser(this.toString());
        while (!pathParser.end()) {
          json.push(Path.fromParser(pathParser).toJSON());
          pathParser.skip(1);
        }
        return json;
      }
    };
    exports2.PathSet = PathSet;
  },
});

// node_modules/ripple-binary-codec/dist/types/uint.js
var require_uint = __commonJS({
  "node_modules/ripple-binary-codec/dist/types/uint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UInt = void 0;
    var serialized_type_1 = require_serialized_type();
    function compare(n1, n2) {
      return n1 < n2 ? -1 : n1 == n2 ? 0 : 1;
    }
    var UInt = class extends serialized_type_1.Comparable {
      constructor(bytes) {
        super(bytes);
      }
      /**
       * Overload of compareTo for Comparable
       *
       * @param other other UInt to compare this to
       * @returns -1, 0, or 1 depending on how the objects relate to each other
       */
      compareTo(other) {
        return compare(this.valueOf(), other.valueOf());
      }
      /**
       * Convert a UInt object to JSON
       *
       * @returns number or string represented by this.bytes
       */
      toJSON() {
        const val = this.valueOf();
        return typeof val === "number" ? val : val.toString();
      }
      static checkUintRange(val, min, max) {
        if (val < min || val > max) {
          throw new Error(
            `Invalid ${this.constructor.name}: ${val} must be >= ${min} and <= ${max}`
          );
        }
      }
    };
    exports2.UInt = UInt;
  },
});

// node_modules/ripple-binary-codec/dist/types/uint-64.js
var require_uint_64 = __commonJS({
  "node_modules/ripple-binary-codec/dist/types/uint-64.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UInt64 = void 0;
    var uint_1 = require_uint();
    var utils_1 = require_utils2();
    var utils_2 = require_utils4();
    var enums_1 = require_enums();
    var HEX_REGEX = /^[a-fA-F0-9]{1,16}$/;
    var BASE10_REGEX = /^[0-9]{1,20}$/;
    var mask = BigInt(4294967295);
    var BASE10_AMOUNT_FIELDS = /* @__PURE__ */ new Set([
      "MaximumAmount",
      "OutstandingAmount",
      "MPTAmount",
      "LockedAmount",
    ]);
    function isBase10(fieldName) {
      return BASE10_AMOUNT_FIELDS.has(fieldName);
    }
    var UInt64 = class _UInt64 extends uint_1.UInt {
      constructor(bytes) {
        super(
          bytes !== null && bytes !== void 0
            ? bytes
            : _UInt64.defaultUInt64.bytes
        );
      }
      static fromParser(parser) {
        return new _UInt64(parser.read(_UInt64.width));
      }
      /**
       * Construct a UInt64 object
       *
       * @param val A UInt64, hex-string, bigInt, or number
       * @returns A UInt64 object
       */
      static from(val, fieldName = "") {
        if (val instanceof _UInt64) {
          return val;
        }
        let buf = new Uint8Array(_UInt64.width);
        if (typeof val === "number") {
          if (val < 0) {
            throw new Error("value must be an unsigned integer");
          }
          const number = BigInt(val);
          const intBuf = [new Uint8Array(4), new Uint8Array(4)];
          (0, utils_2.writeUInt32BE)(
            intBuf[0],
            Number(number >> BigInt(32)),
            0
          );
          (0, utils_2.writeUInt32BE)(
            intBuf[1],
            Number(number & BigInt(mask)),
            0
          );
          return new _UInt64((0, utils_1.concat)(intBuf));
        }
        if (typeof val === "string") {
          if (isBase10(fieldName)) {
            if (!BASE10_REGEX.test(val)) {
              throw new Error(
                `${fieldName} ${val} is not a valid base 10 string`
              );
            }
            val = BigInt(val).toString(16);
          }
          if (typeof val === "string" && !HEX_REGEX.test(val)) {
            throw new Error(`${val} is not a valid hex-string`);
          }
          const strBuf = val.padStart(16, "0");
          buf = (0, utils_1.hexToBytes)(strBuf);
          return new _UInt64(buf);
        }
        if (typeof val === "bigint") {
          const intBuf = [new Uint8Array(4), new Uint8Array(4)];
          (0, utils_2.writeUInt32BE)(
            intBuf[0],
            Number(Number(val >> BigInt(32))),
            0
          );
          (0, utils_2.writeUInt32BE)(intBuf[1], Number(val & BigInt(mask)), 0);
          return new _UInt64((0, utils_1.concat)(intBuf));
        }
        throw new Error("Cannot construct UInt64 from given value");
      }
      /**
       * The JSON representation of a UInt64 object
       *
       * @returns a hex-string
       */
      toJSON(_definitions = enums_1.DEFAULT_DEFINITIONS, fieldName = "") {
        const hexString = (0, utils_1.bytesToHex)(this.bytes);
        if (isBase10(fieldName)) {
          return BigInt("0x" + hexString).toString(10);
        }
        return hexString;
      }
      /**
       * Get the value of the UInt64
       *
       * @returns the number represented buy this.bytes
       */
      valueOf() {
        const msb = BigInt(
          (0, utils_2.readUInt32BE)(this.bytes.slice(0, 4), 0)
        );
        const lsb = BigInt((0, utils_2.readUInt32BE)(this.bytes.slice(4), 0));
        return (msb << BigInt(32)) | lsb;
      }
      /**
       * Get the bytes representation of the UInt64 object
       *
       * @returns 8 bytes representing the UInt64
       */
      toBytes() {
        return this.bytes;
      }
    };
    exports2.UInt64 = UInt64;
    UInt64.width = 64 / 8;
    UInt64.defaultUInt64 = new UInt64(new Uint8Array(UInt64.width));
  },
});

// node_modules/ripple-binary-codec/dist/types/st-object.js
var require_st_object = __commonJS({
  "node_modules/ripple-binary-codec/dist/types/st-object.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.STObject = void 0;
    var enums_1 = require_enums();
    var serialized_type_1 = require_serialized_type();
    var ripple_address_codec_1 = require_dist();
    var binary_parser_1 = require_binary_parser();
    var binary_serializer_1 = require_binary_serializer();
    var st_array_1 = require_st_array();
    var uint_64_1 = require_uint_64();
    var OBJECT_END_MARKER_BYTE = Uint8Array.from([225]);
    var OBJECT_END_MARKER = "ObjectEndMarker";
    var ST_OBJECT = "STObject";
    var DESTINATION = "Destination";
    var ACCOUNT = "Account";
    var SOURCE_TAG = "SourceTag";
    var DEST_TAG = "DestinationTag";
    function handleXAddress(field, xAddress) {
      const decoded = (0, ripple_address_codec_1.xAddressToClassicAddress)(
        xAddress
      );
      let tagName;
      if (field === DESTINATION) tagName = DEST_TAG;
      else if (field === ACCOUNT) tagName = SOURCE_TAG;
      else if (decoded.tag !== false)
        throw new Error(`${field} cannot have an associated tag`);
      return decoded.tag !== false
        ? { [field]: decoded.classicAddress, [tagName]: decoded.tag }
        : { [field]: decoded.classicAddress };
    }
    function checkForDuplicateTags(obj1, obj2) {
      if (!(obj1[SOURCE_TAG] === void 0 || obj2[SOURCE_TAG] === void 0))
        throw new Error("Cannot have Account X-Address and SourceTag");
      if (!(obj1[DEST_TAG] === void 0 || obj2[DEST_TAG] === void 0))
        throw new Error("Cannot have Destination X-Address and DestinationTag");
    }
    var STObject = class _STObject extends serialized_type_1.SerializedType {
      /**
       * Construct a STObject from a BinaryParser
       *
       * @param parser BinaryParser to read STObject from
       * @returns A STObject object
       */
      static fromParser(parser) {
        const list = new binary_serializer_1.BytesList();
        const bytes = new binary_serializer_1.BinarySerializer(list);
        while (!parser.end()) {
          const field = parser.readField();
          if (field.name === OBJECT_END_MARKER) {
            break;
          }
          const associatedValue = parser.readFieldValue(field);
          bytes.writeFieldAndValue(field, associatedValue);
          if (field.type.name === ST_OBJECT) {
            bytes.put(OBJECT_END_MARKER_BYTE);
          }
        }
        return new _STObject(list.toBytes());
      }
      /**
       * Construct a STObject from a JSON object
       *
       * @param value An object to include
       * @param filter optional, denote which field to include in serialized object
       * @param definitions optional, types and values to use to encode/decode a transaction
       * @returns a STObject object
       */
      static from(value, filter, definitions = enums_1.DEFAULT_DEFINITIONS) {
        if (value instanceof _STObject) {
          return value;
        }
        const list = new binary_serializer_1.BytesList();
        const bytes = new binary_serializer_1.BinarySerializer(list);
        let isUnlModify = false;
        const xAddressDecoded = Object.entries(value).reduce(
          (acc, [key, val]) => {
            let handled = void 0;
            if (
              val &&
              (0, ripple_address_codec_1.isValidXAddress)(val.toString())
            ) {
              handled = handleXAddress(key, val.toString());
              checkForDuplicateTags(handled, value);
            }
            return Object.assign(
              acc,
              handled !== null && handled !== void 0 ? handled : { [key]: val }
            );
          },
          {}
        );
        function isValidFieldInstance(f) {
          return (
            f !== void 0 && xAddressDecoded[f.name] !== void 0 && f.isSerialized
          );
        }
        let sorted = Object.keys(xAddressDecoded)
          .map((f) => {
            if (!(f in definitions.field)) {
              if (f[0] === f[0].toLowerCase()) return void 0;
              throw new Error(`Field ${f} is not defined in the definitions`);
            }
            return definitions.field[f];
          })
          .filter(isValidFieldInstance)
          .sort((a, b) => {
            return a.ordinal - b.ordinal;
          });
        if (filter !== void 0) {
          sorted = sorted.filter(filter);
        }
        sorted.forEach((field) => {
          var _a;
          const associatedValue =
            field.type.name === ST_OBJECT
              ? this.from(xAddressDecoded[field.name], void 0, definitions)
              : field.type.name === "STArray"
              ? st_array_1.STArray.from(
                  xAddressDecoded[field.name],
                  definitions
                )
              : field.type.name === "UInt64"
              ? uint_64_1.UInt64.from(xAddressDecoded[field.name], field.name)
              : (
                  (_a = field.associatedType) === null || _a === void 0
                    ? void 0
                    : _a.from
                )
              ? field.associatedType.from(xAddressDecoded[field.name])
              : (() => {
                  throw new Error(
                    `Type ${field.type.name} for field ${field.name} is missing associatedType.from`
                  );
                })();
          if (associatedValue == void 0) {
            throw new TypeError(
              `Unable to interpret "${field.name}: ${
                xAddressDecoded[field.name]
              }".`
            );
          }
          if (associatedValue.name === "UNLModify") {
            isUnlModify = true;
          }
          const isUnlModifyWorkaround = field.name == "Account" && isUnlModify;
          bytes.writeFieldAndValue(
            field,
            associatedValue,
            isUnlModifyWorkaround
          );
          if (field.type.name === ST_OBJECT) {
            bytes.put(OBJECT_END_MARKER_BYTE);
          }
        });
        return new _STObject(list.toBytes());
      }
      /**
       * Get the JSON interpretation of this.bytes
       * @param definitions rippled definitions used to parse the values of transaction types and such.
       *                          Can be customized for sidechains and amendments.
       * @returns a JSON object
       */
      toJSON(definitions) {
        const objectParser = new binary_parser_1.BinaryParser(
          this.toString(),
          definitions
        );
        const accumulator = {};
        while (!objectParser.end()) {
          const field = objectParser.readField();
          if (field.name === OBJECT_END_MARKER) {
            break;
          }
          accumulator[field.name] = objectParser
            .readFieldValue(field)
            .toJSON(definitions, field.name);
        }
        return accumulator;
      }
    };
    exports2.STObject = STObject;
  },
});

// node_modules/ripple-binary-codec/dist/types/st-array.js
var require_st_array = __commonJS({
  "node_modules/ripple-binary-codec/dist/types/st-array.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.STArray = void 0;
    var enums_1 = require_enums();
    var serialized_type_1 = require_serialized_type();
    var st_object_1 = require_st_object();
    var binary_parser_1 = require_binary_parser();
    var utils_1 = require_utils2();
    var ARRAY_END_MARKER = Uint8Array.from([241]);
    var ARRAY_END_MARKER_NAME = "ArrayEndMarker";
    var OBJECT_END_MARKER = Uint8Array.from([225]);
    function isObjects(args) {
      return (
        Array.isArray(args) &&
        args.every(
          (arg) =>
            typeof arg === "object" &&
            Object.keys(arg).length === 1 &&
            typeof Object.values(arg)[0] === "object"
        )
      );
    }
    var STArray = class _STArray extends serialized_type_1.SerializedType {
      /**
       * Construct an STArray from a BinaryParser
       *
       * @param parser BinaryParser to parse an STArray from
       * @returns An STArray Object
       */
      static fromParser(parser) {
        const bytes = [];
        while (!parser.end()) {
          const field = parser.readField();
          if (field.name === ARRAY_END_MARKER_NAME) {
            break;
          }
          bytes.push(
            field.header,
            parser.readFieldValue(field).toBytes(),
            OBJECT_END_MARKER
          );
        }
        bytes.push(ARRAY_END_MARKER);
        return new _STArray((0, utils_1.concat)(bytes));
      }
      /**
       * Construct an STArray from an Array of JSON Objects
       *
       * @param value STArray or Array of Objects to parse into an STArray
       * @param definitions optional, types and values to use to encode/decode a transaction
       * @returns An STArray object
       */
      static from(value, definitions = enums_1.DEFAULT_DEFINITIONS) {
        if (value instanceof _STArray) {
          return value;
        }
        if (isObjects(value)) {
          const bytes = [];
          value.forEach((obj) => {
            bytes.push(
              st_object_1.STObject.from(obj, void 0, definitions).toBytes()
            );
          });
          bytes.push(ARRAY_END_MARKER);
          return new _STArray((0, utils_1.concat)(bytes));
        }
        throw new Error("Cannot construct STArray from value given");
      }
      /**
       * Return the JSON representation of this.bytes
       *
       * @param definitions optional, types and values to use to encode/decode a transaction
       * @returns An Array of JSON objects
       */
      toJSON(definitions = enums_1.DEFAULT_DEFINITIONS) {
        const result = [];
        const arrayParser = new binary_parser_1.BinaryParser(
          this.toString(),
          definitions
        );
        while (!arrayParser.end()) {
          const field = arrayParser.readField();
          if (field.name === ARRAY_END_MARKER_NAME) {
            break;
          }
          const outer = {};
          outer[field.name] =
            st_object_1.STObject.fromParser(arrayParser).toJSON(definitions);
          result.push(outer);
        }
        return result;
      }
    };
    exports2.STArray = STArray;
  },
});

// node_modules/ripple-binary-codec/dist/types/uint-16.js
var require_uint_16 = __commonJS({
  "node_modules/ripple-binary-codec/dist/types/uint-16.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UInt16 = void 0;
    var uint_1 = require_uint();
    var utils_1 = require_utils4();
    var UInt16 = class _UInt16 extends uint_1.UInt {
      constructor(bytes) {
        super(
          bytes !== null && bytes !== void 0
            ? bytes
            : _UInt16.defaultUInt16.bytes
        );
      }
      static fromParser(parser) {
        return new _UInt16(parser.read(_UInt16.width));
      }
      /**
       * Construct a UInt16 object from a number
       *
       * @param val UInt16 object or number
       */
      static from(val) {
        if (val instanceof _UInt16) {
          return val;
        }
        if (typeof val === "number") {
          _UInt16.checkUintRange(val, 0, 65535);
          const buf = new Uint8Array(_UInt16.width);
          (0, utils_1.writeUInt16BE)(buf, val, 0);
          return new _UInt16(buf);
        }
        throw new Error("Can not construct UInt16 with given value");
      }
      /**
       * get the value of a UInt16 object
       *
       * @returns the number represented by this.bytes
       */
      valueOf() {
        return parseInt((0, utils_1.readUInt16BE)(this.bytes, 0));
      }
    };
    exports2.UInt16 = UInt16;
    UInt16.width = 16 / 8;
    UInt16.defaultUInt16 = new UInt16(new Uint8Array(UInt16.width));
  },
});

// node_modules/ripple-binary-codec/dist/types/uint-32.js
var require_uint_32 = __commonJS({
  "node_modules/ripple-binary-codec/dist/types/uint-32.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UInt32 = void 0;
    var uint_1 = require_uint();
    var utils_1 = require_utils4();
    var UInt32 = class _UInt32 extends uint_1.UInt {
      constructor(bytes) {
        super(
          bytes !== null && bytes !== void 0
            ? bytes
            : _UInt32.defaultUInt32.bytes
        );
      }
      static fromParser(parser) {
        return new _UInt32(parser.read(_UInt32.width));
      }
      /**
       * Construct a UInt32 object from a number
       *
       * @param val UInt32 object or number
       */
      static from(val) {
        if (val instanceof _UInt32) {
          return val;
        }
        const buf = new Uint8Array(_UInt32.width);
        if (typeof val === "string") {
          const num = Number.parseInt(val);
          (0, utils_1.writeUInt32BE)(buf, num, 0);
          return new _UInt32(buf);
        }
        if (typeof val === "number") {
          _UInt32.checkUintRange(val, 0, 4294967295);
          (0, utils_1.writeUInt32BE)(buf, val, 0);
          return new _UInt32(buf);
        }
        throw new Error("Cannot construct UInt32 from given value");
      }
      /**
       * get the value of a UInt32 object
       *
       * @returns the number represented by this.bytes
       */
      valueOf() {
        return parseInt((0, utils_1.readUInt32BE)(this.bytes, 0), 10);
      }
    };
    exports2.UInt32 = UInt32;
    UInt32.width = 32 / 8;
    UInt32.defaultUInt32 = new UInt32(new Uint8Array(UInt32.width));
  },
});

// node_modules/ripple-binary-codec/dist/types/uint-8.js
var require_uint_8 = __commonJS({
  "node_modules/ripple-binary-codec/dist/types/uint-8.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UInt8 = void 0;
    var uint_1 = require_uint();
    var utils_1 = require_utils2();
    var utils_2 = require_utils4();
    var UInt8 = class _UInt8 extends uint_1.UInt {
      constructor(bytes) {
        super(
          bytes !== null && bytes !== void 0 ? bytes : _UInt8.defaultUInt8.bytes
        );
      }
      static fromParser(parser) {
        return new _UInt8(parser.read(_UInt8.width));
      }
      /**
       * Construct a UInt8 object from a number
       *
       * @param val UInt8 object or number
       */
      static from(val) {
        if (val instanceof _UInt8) {
          return val;
        }
        if (typeof val === "number") {
          _UInt8.checkUintRange(val, 0, 255);
          const buf = new Uint8Array(_UInt8.width);
          (0, utils_2.writeUInt8)(buf, val, 0);
          return new _UInt8(buf);
        }
        throw new Error("Cannot construct UInt8 from given value");
      }
      /**
       * get the value of a UInt8 object
       *
       * @returns the number represented by this.bytes
       */
      valueOf() {
        return parseInt((0, utils_1.bytesToHex)(this.bytes), 16);
      }
    };
    exports2.UInt8 = UInt8;
    UInt8.width = 8 / 8;
    UInt8.defaultUInt8 = new UInt8(new Uint8Array(UInt8.width));
  },
});

// node_modules/ripple-binary-codec/dist/types/vector-256.js
var require_vector_256 = __commonJS({
  "node_modules/ripple-binary-codec/dist/types/vector-256.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Vector256 = void 0;
    var serialized_type_1 = require_serialized_type();
    var hash_256_1 = require_hash_256();
    var binary_serializer_1 = require_binary_serializer();
    var utils_1 = require_utils2();
    function isStrings(arg) {
      return (
        Array.isArray(arg) && (arg.length === 0 || typeof arg[0] === "string")
      );
    }
    var Vector256 = class _Vector256 extends serialized_type_1.SerializedType {
      constructor(bytes) {
        super(bytes);
      }
      /**
       * Construct a Vector256 from a BinaryParser
       *
       * @param parser BinaryParser to
       * @param hint length of the vector, in bytes, optional
       * @returns a Vector256 object
       */
      static fromParser(parser, hint) {
        const bytesList = new binary_serializer_1.BytesList();
        const bytes = hint !== null && hint !== void 0 ? hint : parser.size();
        const hashes = bytes / 32;
        for (let i = 0; i < hashes; i++) {
          hash_256_1.Hash256.fromParser(parser).toBytesSink(bytesList);
        }
        return new _Vector256(bytesList.toBytes());
      }
      /**
       * Construct a Vector256 object from an array of hashes
       *
       * @param value A Vector256 object or array of hex-strings representing Hash256's
       * @returns a Vector256 object
       */
      static from(value) {
        if (value instanceof _Vector256) {
          return value;
        }
        if (isStrings(value)) {
          const bytesList = new binary_serializer_1.BytesList();
          value.forEach((hash) => {
            hash_256_1.Hash256.from(hash).toBytesSink(bytesList);
          });
          return new _Vector256(bytesList.toBytes());
        }
        throw new Error("Cannot construct Vector256 from given value");
      }
      /**
       * Return an Array of hex-strings represented by this.bytes
       *
       * @returns An Array of strings representing the Hash256 objects
       */
      toJSON() {
        if (this.bytes.byteLength % 32 !== 0) {
          throw new Error("Invalid bytes for Vector256");
        }
        const result = [];
        for (let i = 0; i < this.bytes.byteLength; i += 32) {
          result.push((0, utils_1.bytesToHex)(this.bytes.slice(i, i + 32)));
        }
        return result;
      }
    };
    exports2.Vector256 = Vector256;
  },
});

// node_modules/ripple-binary-codec/dist/types/xchain-bridge.js
var require_xchain_bridge = __commonJS({
  "node_modules/ripple-binary-codec/dist/types/xchain-bridge.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.XChainBridge = void 0;
    var binary_parser_1 = require_binary_parser();
    var account_id_1 = require_account_id();
    var serialized_type_1 = require_serialized_type();
    var issue_1 = require_issue();
    var utils_1 = require_utils2();
    function isXChainBridgeObject(arg) {
      const keys = Object.keys(arg).sort();
      return (
        keys.length === 4 &&
        keys[0] === "IssuingChainDoor" &&
        keys[1] === "IssuingChainIssue" &&
        keys[2] === "LockingChainDoor" &&
        keys[3] === "LockingChainIssue"
      );
    }
    var XChainBridge = class _XChainBridge extends serialized_type_1.SerializedType {
      constructor(bytes) {
        super(
          bytes !== null && bytes !== void 0
            ? bytes
            : _XChainBridge.ZERO_XCHAIN_BRIDGE.bytes
        );
      }
      /**
       * Construct a cross-chain bridge from a JSON
       *
       * @param value XChainBridge or JSON to parse into an XChainBridge
       * @returns An XChainBridge object
       */
      static from(value) {
        if (value instanceof _XChainBridge) {
          return value;
        }
        if (!isXChainBridgeObject(value)) {
          throw new Error("Invalid type to construct an XChainBridge");
        }
        const bytes = [];
        this.TYPE_ORDER.forEach((item) => {
          const { name, type } = item;
          if (type === account_id_1.AccountID) {
            bytes.push(Uint8Array.from([20]));
          }
          const object = type.from(value[name]);
          bytes.push(object.toBytes());
        });
        return new _XChainBridge((0, utils_1.concat)(bytes));
      }
      /**
       * Read an XChainBridge from a BinaryParser
       *
       * @param parser BinaryParser to read the XChainBridge from
       * @returns An XChainBridge object
       */
      static fromParser(parser) {
        const bytes = [];
        this.TYPE_ORDER.forEach((item) => {
          const { type } = item;
          if (type === account_id_1.AccountID) {
            parser.skip(1);
            bytes.push(Uint8Array.from([20]));
          }
          const object = type.fromParser(parser);
          bytes.push(object.toBytes());
        });
        return new _XChainBridge((0, utils_1.concat)(bytes));
      }
      /**
       * Get the JSON representation of this XChainBridge
       *
       * @returns the JSON interpretation of this.bytes
       */
      toJSON() {
        const parser = new binary_parser_1.BinaryParser(this.toString());
        const json = {};
        _XChainBridge.TYPE_ORDER.forEach((item) => {
          const { name, type } = item;
          if (type === account_id_1.AccountID) {
            parser.skip(1);
          }
          const object = type.fromParser(parser).toJSON();
          json[name] = object;
        });
        return json;
      }
    };
    exports2.XChainBridge = XChainBridge;
    XChainBridge.ZERO_XCHAIN_BRIDGE = new XChainBridge(
      (0, utils_1.concat)([
        Uint8Array.from([20]),
        new Uint8Array(40),
        Uint8Array.from([20]),
        new Uint8Array(40),
      ])
    );
    XChainBridge.TYPE_ORDER = [
      { name: "LockingChainDoor", type: account_id_1.AccountID },
      { name: "LockingChainIssue", type: issue_1.Issue },
      { name: "IssuingChainDoor", type: account_id_1.AccountID },
      { name: "IssuingChainIssue", type: issue_1.Issue },
    ];
  },
});

// node_modules/ripple-binary-codec/dist/types/index.js
var require_types = __commonJS({
  "node_modules/ripple-binary-codec/dist/types/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Vector256 =
      exports2.UInt64 =
      exports2.UInt32 =
      exports2.UInt16 =
      exports2.UInt8 =
      exports2.STObject =
      exports2.STArray =
      exports2.PathSet =
      exports2.Hash256 =
      exports2.Hash192 =
      exports2.Hash160 =
      exports2.Hash128 =
      exports2.Currency =
      exports2.Blob =
      exports2.Amount =
      exports2.AccountID =
      exports2.coreTypes =
        void 0;
    var account_id_1 = require_account_id();
    Object.defineProperty(exports2, "AccountID", {
      enumerable: true,
      get: function () {
        return account_id_1.AccountID;
      },
    });
    var amount_1 = require_amount();
    Object.defineProperty(exports2, "Amount", {
      enumerable: true,
      get: function () {
        return amount_1.Amount;
      },
    });
    var blob_1 = require_blob();
    Object.defineProperty(exports2, "Blob", {
      enumerable: true,
      get: function () {
        return blob_1.Blob;
      },
    });
    var currency_1 = require_currency();
    Object.defineProperty(exports2, "Currency", {
      enumerable: true,
      get: function () {
        return currency_1.Currency;
      },
    });
    var hash_128_1 = require_hash_128();
    Object.defineProperty(exports2, "Hash128", {
      enumerable: true,
      get: function () {
        return hash_128_1.Hash128;
      },
    });
    var hash_160_1 = require_hash_160();
    Object.defineProperty(exports2, "Hash160", {
      enumerable: true,
      get: function () {
        return hash_160_1.Hash160;
      },
    });
    var hash_192_1 = require_hash_192();
    Object.defineProperty(exports2, "Hash192", {
      enumerable: true,
      get: function () {
        return hash_192_1.Hash192;
      },
    });
    var hash_256_1 = require_hash_256();
    Object.defineProperty(exports2, "Hash256", {
      enumerable: true,
      get: function () {
        return hash_256_1.Hash256;
      },
    });
    var issue_1 = require_issue();
    var st_number_1 = require_st_number();
    var path_set_1 = require_path_set();
    Object.defineProperty(exports2, "PathSet", {
      enumerable: true,
      get: function () {
        return path_set_1.PathSet;
      },
    });
    var st_array_1 = require_st_array();
    Object.defineProperty(exports2, "STArray", {
      enumerable: true,
      get: function () {
        return st_array_1.STArray;
      },
    });
    var st_object_1 = require_st_object();
    Object.defineProperty(exports2, "STObject", {
      enumerable: true,
      get: function () {
        return st_object_1.STObject;
      },
    });
    var uint_16_1 = require_uint_16();
    Object.defineProperty(exports2, "UInt16", {
      enumerable: true,
      get: function () {
        return uint_16_1.UInt16;
      },
    });
    var uint_32_1 = require_uint_32();
    Object.defineProperty(exports2, "UInt32", {
      enumerable: true,
      get: function () {
        return uint_32_1.UInt32;
      },
    });
    var uint_64_1 = require_uint_64();
    Object.defineProperty(exports2, "UInt64", {
      enumerable: true,
      get: function () {
        return uint_64_1.UInt64;
      },
    });
    var uint_8_1 = require_uint_8();
    Object.defineProperty(exports2, "UInt8", {
      enumerable: true,
      get: function () {
        return uint_8_1.UInt8;
      },
    });
    var vector_256_1 = require_vector_256();
    Object.defineProperty(exports2, "Vector256", {
      enumerable: true,
      get: function () {
        return vector_256_1.Vector256;
      },
    });
    var xchain_bridge_1 = require_xchain_bridge();
    var enums_1 = require_enums();
    var coreTypes = {
      AccountID: account_id_1.AccountID,
      Amount: amount_1.Amount,
      Blob: blob_1.Blob,
      Currency: currency_1.Currency,
      Hash128: hash_128_1.Hash128,
      Hash160: hash_160_1.Hash160,
      Hash192: hash_192_1.Hash192,
      Hash256: hash_256_1.Hash256,
      Issue: issue_1.Issue,
      Number: st_number_1.STNumber,
      PathSet: path_set_1.PathSet,
      STArray: st_array_1.STArray,
      STObject: st_object_1.STObject,
      UInt8: uint_8_1.UInt8,
      UInt16: uint_16_1.UInt16,
      UInt32: uint_32_1.UInt32,
      UInt64: uint_64_1.UInt64,
      Vector256: vector_256_1.Vector256,
      XChainBridge: xchain_bridge_1.XChainBridge,
    };
    exports2.coreTypes = coreTypes;
    enums_1.DEFAULT_DEFINITIONS.associateTypes(coreTypes);
  },
});

// node_modules/ripple-binary-codec/dist/hash-prefixes.js
var require_hash_prefixes = __commonJS({
  "node_modules/ripple-binary-codec/dist/hash-prefixes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HashPrefix = void 0;
    var utils_1 = require_utils4();
    function bytes(uint32) {
      const result = new Uint8Array(4);
      (0, utils_1.writeUInt32BE)(result, uint32, 0);
      return result;
    }
    var HashPrefix = {
      transactionID: bytes(1415073280),
      // transaction plus metadata
      transaction: bytes(1397638144),
      // account state
      accountStateEntry: bytes(1296846336),
      // inner node in tree
      innerNode: bytes(1296649728),
      // ledger master data for signing
      ledgerHeader: bytes(1280791040),
      // inner transaction to sign
      transactionSig: bytes(1398036480),
      // inner transaction to sign
      transactionMultiSig: bytes(1397576704),
      // validation for signing
      validation: bytes(1447119872),
      // proposal for signing
      proposal: bytes(1347571712),
      // payment channel claim
      paymentChannelClaim: bytes(1129073920),
      // batch
      batch: bytes(1111705600),
    };
    exports2.HashPrefix = HashPrefix;
  },
});

// node_modules/@xrplf/isomorphic/dist/sha512/index.js
var require_sha512 = __commonJS({
  "node_modules/@xrplf/isomorphic/dist/sha512/index.js"(exports2) {
    "use strict";
    var __importDefault =
      (exports2 && exports2.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sha512 = void 0;
    var crypto_1 = require("crypto");
    var wrapCryptoCreateHash_1 = __importDefault(
      require_wrapCryptoCreateHash()
    );
    exports2.sha512 = (0, wrapCryptoCreateHash_1.default)(
      "sha512",
      crypto_1.createHash
    );
  },
});

// node_modules/ripple-binary-codec/dist/hashes.js
var require_hashes = __commonJS({
  "node_modules/ripple-binary-codec/dist/hashes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.transactionID = exports2.sha512Half = exports2.Sha512Half = void 0;
    var hash_prefixes_1 = require_hash_prefixes();
    var types_1 = require_types();
    var binary_serializer_1 = require_binary_serializer();
    var sha512_1 = require_sha512();
    var Sha512Half = class _Sha512Half extends binary_serializer_1.BytesList {
      constructor() {
        super(...arguments);
        this.hash = sha512_1.sha512.create();
      }
      /**
       * Construct a new Sha512Hash and write bytes this.hash
       *
       * @param bytes bytes to write to this.hash
       * @returns the new Sha512Hash object
       */
      static put(bytes) {
        return new _Sha512Half().put(bytes);
      }
      /**
       * Write bytes to an existing Sha512Hash
       *
       * @param bytes bytes to write to object
       * @returns the Sha512 object
       */
      put(bytes) {
        this.hash.update(bytes);
        return this;
      }
      /**
       * Compute SHA512 hash and slice in half
       *
       * @returns half of a SHA512 hash
       */
      finish256() {
        return Uint8Array.from(this.hash.digest().slice(0, 32));
      }
      /**
       * Constructs a Hash256 from the Sha512Half object
       *
       * @returns a Hash256 object
       */
      finish() {
        return new types_1.Hash256(this.finish256());
      }
    };
    exports2.Sha512Half = Sha512Half;
    function sha512Half(...args) {
      const hash = new Sha512Half();
      args.forEach((a) => hash.put(a));
      return hash.finish256();
    }
    exports2.sha512Half = sha512Half;
    function transactionID(serialized) {
      return new types_1.Hash256(
        sha512Half(hash_prefixes_1.HashPrefix.transactionID, serialized)
      );
    }
    exports2.transactionID = transactionID;
  },
});

// node_modules/ripple-binary-codec/dist/binary.js
var require_binary = __commonJS({
  "node_modules/ripple-binary-codec/dist/binary.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.signingBatchData =
      exports2.transactionID =
      exports2.sha512Half =
      exports2.binaryToJSON =
      exports2.signingClaimData =
      exports2.signingData =
      exports2.multiSigningData =
      exports2.readJSON =
      exports2.serializeObject =
      exports2.makeParser =
      exports2.BytesList =
      exports2.BinarySerializer =
      exports2.BinaryParser =
        void 0;
    var utils_1 = require_utils2();
    var types_1 = require_types();
    var binary_parser_1 = require_binary_parser();
    Object.defineProperty(exports2, "BinaryParser", {
      enumerable: true,
      get: function () {
        return binary_parser_1.BinaryParser;
      },
    });
    var hash_prefixes_1 = require_hash_prefixes();
    var binary_serializer_1 = require_binary_serializer();
    Object.defineProperty(exports2, "BinarySerializer", {
      enumerable: true,
      get: function () {
        return binary_serializer_1.BinarySerializer;
      },
    });
    Object.defineProperty(exports2, "BytesList", {
      enumerable: true,
      get: function () {
        return binary_serializer_1.BytesList;
      },
    });
    var hashes_1 = require_hashes();
    Object.defineProperty(exports2, "sha512Half", {
      enumerable: true,
      get: function () {
        return hashes_1.sha512Half;
      },
    });
    Object.defineProperty(exports2, "transactionID", {
      enumerable: true,
      get: function () {
        return hashes_1.transactionID;
      },
    });
    var enums_1 = require_enums();
    var makeParser = (bytes, definitions) =>
      new binary_parser_1.BinaryParser(
        bytes instanceof Uint8Array ? (0, utils_1.bytesToHex)(bytes) : bytes,
        definitions
      );
    exports2.makeParser = makeParser;
    var readJSON = (parser, definitions = enums_1.DEFAULT_DEFINITIONS) =>
      parser.readType(types_1.coreTypes.STObject).toJSON(definitions);
    exports2.readJSON = readJSON;
    var binaryToJSON = (bytes, definitions) =>
      readJSON(makeParser(bytes, definitions), definitions);
    exports2.binaryToJSON = binaryToJSON;
    function serializeObject(object, opts = {}) {
      const { prefix, suffix, signingFieldsOnly = false, definitions } = opts;
      const bytesList = new binary_serializer_1.BytesList();
      if (prefix) {
        bytesList.put(prefix);
      }
      const filter = signingFieldsOnly ? (f) => f.isSigningField : void 0;
      types_1.coreTypes.STObject.from(object, filter, definitions).toBytesSink(
        bytesList
      );
      if (suffix) {
        bytesList.put(suffix);
      }
      return bytesList.toBytes();
    }
    exports2.serializeObject = serializeObject;
    function signingData(
      transaction,
      prefix = hash_prefixes_1.HashPrefix.transactionSig,
      opts = {}
    ) {
      return serializeObject(transaction, {
        prefix,
        signingFieldsOnly: true,
        definitions: opts.definitions,
      });
    }
    exports2.signingData = signingData;
    function signingClaimData(claim) {
      const num = BigInt(String(claim.amount));
      const prefix = hash_prefixes_1.HashPrefix.paymentChannelClaim;
      const channel = types_1.coreTypes.Hash256.from(claim.channel).toBytes();
      const amount = types_1.coreTypes.UInt64.from(num).toBytes();
      const bytesList = new binary_serializer_1.BytesList();
      bytesList.put(prefix);
      bytesList.put(channel);
      bytesList.put(amount);
      return bytesList.toBytes();
    }
    exports2.signingClaimData = signingClaimData;
    function multiSigningData(
      transaction,
      signingAccount,
      opts = {
        definitions: enums_1.DEFAULT_DEFINITIONS,
      }
    ) {
      const prefix = hash_prefixes_1.HashPrefix.transactionMultiSig;
      const suffix = types_1.coreTypes.AccountID.from(signingAccount).toBytes();
      return serializeObject(transaction, {
        prefix,
        suffix,
        signingFieldsOnly: true,
        definitions: opts.definitions,
      });
    }
    exports2.multiSigningData = multiSigningData;
    function signingBatchData(batch) {
      if (batch.flags == null) {
        throw Error("No field `flags'");
      }
      if (batch.txIDs == null) {
        throw Error("No field `txIDs`");
      }
      const prefix = hash_prefixes_1.HashPrefix.batch;
      const flags = types_1.coreTypes.UInt32.from(batch.flags).toBytes();
      const txIDsLength = types_1.coreTypes.UInt32.from(
        batch.txIDs.length
      ).toBytes();
      const bytesList = new binary_serializer_1.BytesList();
      bytesList.put(prefix);
      bytesList.put(flags);
      bytesList.put(txIDsLength);
      batch.txIDs.forEach((txID) => {
        bytesList.put(types_1.coreTypes.Hash256.from(txID).toBytes());
      });
      return bytesList.toBytes();
    }
    exports2.signingBatchData = signingBatchData;
  },
});

// node_modules/ripple-binary-codec/dist/shamap.js
var require_shamap = __commonJS({
  "node_modules/ripple-binary-codec/dist/shamap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ShaMapLeaf = exports2.ShaMapNode = exports2.ShaMap = void 0;
    var types_1 = require_types();
    var hash_prefixes_1 = require_hash_prefixes();
    var hashes_1 = require_hashes();
    var ShaMapNode = class {};
    exports2.ShaMapNode = ShaMapNode;
    var ShaMapLeaf = class extends ShaMapNode {
      constructor(index, item) {
        super();
        this.index = index;
        this.item = item;
      }
      /**
       * @returns true as ShaMapLeaf is a leaf node
       */
      isLeaf() {
        return true;
      }
      /**
       * @returns false as ShaMapLeaf is not an inner node
       */
      isInner() {
        return false;
      }
      /**
       * Get the prefix of the this.item
       *
       * @returns The hash prefix, unless this.item is undefined, then it returns an empty Uint8Array
       */
      hashPrefix() {
        return this.item === void 0
          ? new Uint8Array(0)
          : this.item.hashPrefix();
      }
      /**
       * Hash the bytes representation of this
       *
       * @returns hash of this.item concatenated with this.index
       */
      hash() {
        const hash = hashes_1.Sha512Half.put(this.hashPrefix());
        this.toBytesSink(hash);
        return hash.finish();
      }
      /**
       * Write the bytes representation of this to a BytesList
       * @param list BytesList to write bytes to
       */
      toBytesSink(list) {
        if (this.item !== void 0) {
          this.item.toBytesSink(list);
        }
        this.index.toBytesSink(list);
      }
    };
    exports2.ShaMapLeaf = ShaMapLeaf;
    var ShaMapInner = class _ShaMapInner extends ShaMapNode {
      constructor(depth = 0) {
        super();
        this.depth = depth;
        this.slotBits = 0;
        this.branches = Array(16);
      }
      /**
       * @returns true as ShaMapInner is an inner node
       */
      isInner() {
        return true;
      }
      /**
       * @returns false as ShaMapInner is not a leaf node
       */
      isLeaf() {
        return false;
      }
      /**
       * Get the hash prefix for this node
       *
       * @returns hash prefix describing an inner node
       */
      hashPrefix() {
        return hash_prefixes_1.HashPrefix.innerNode;
      }
      /**
       * Set a branch of this node to be another node
       *
       * @param slot Slot to add branch to this.branches
       * @param branch Branch to add
       */
      setBranch(slot, branch) {
        this.slotBits = this.slotBits | (1 << slot);
        this.branches[slot] = branch;
      }
      /**
       * @returns true if node is empty
       */
      empty() {
        return this.slotBits === 0;
      }
      /**
       * Compute the hash of this node
       *
       * @returns The hash of this node
       */
      hash() {
        if (this.empty()) {
          return types_1.coreTypes.Hash256.ZERO_256;
        }
        const hash = hashes_1.Sha512Half.put(this.hashPrefix());
        this.toBytesSink(hash);
        return hash.finish();
      }
      /**
       * Writes the bytes representation of this node to a BytesList
       *
       * @param list BytesList to write bytes to
       */
      toBytesSink(list) {
        for (let i = 0; i < this.branches.length; i++) {
          const branch = this.branches[i];
          const hash = branch
            ? branch.hash()
            : types_1.coreTypes.Hash256.ZERO_256;
          hash.toBytesSink(list);
        }
      }
      /**
       * Add item to the SHAMap
       *
       * @param index Hash of the index of the item being inserted
       * @param item Item to insert in the map
       * @param leaf Leaf node to insert when branch doesn't exist
       */
      addItem(index, item, leaf) {
        if (index === void 0) {
          throw new Error();
        }
        if (index !== void 0) {
          const nibble = index.nibblet(this.depth);
          const existing = this.branches[nibble];
          if (existing === void 0) {
            this.setBranch(nibble, leaf || new ShaMapLeaf(index, item));
          } else if (existing instanceof ShaMapLeaf) {
            const newInner = new _ShaMapInner(this.depth + 1);
            newInner.addItem(existing.index, void 0, existing);
            newInner.addItem(index, item, leaf);
            this.setBranch(nibble, newInner);
          } else if (existing instanceof _ShaMapInner) {
            existing.addItem(index, item, leaf);
          } else {
            throw new Error("invalid ShaMap.addItem call");
          }
        }
      }
    };
    var ShaMap = class extends ShaMapInner {};
    exports2.ShaMap = ShaMap;
  },
});

// node_modules/ripple-binary-codec/dist/ledger-hashes.js
var require_ledger_hashes = __commonJS({
  "node_modules/ripple-binary-codec/dist/ledger-hashes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeLedgerData =
      exports2.ledgerHash =
      exports2.transactionTreeHash =
      exports2.accountStateHash =
        void 0;
    var shamap_1 = require_shamap();
    var hash_prefixes_1 = require_hash_prefixes();
    var hashes_1 = require_hashes();
    var binary_1 = require_binary();
    var hash_256_1 = require_hash_256();
    var st_object_1 = require_st_object();
    var uint_64_1 = require_uint_64();
    var uint_32_1 = require_uint_32();
    var uint_8_1 = require_uint_8();
    var binary_parser_1 = require_binary_parser();
    function computeHash(itemizer, itemsJson) {
      const map = new shamap_1.ShaMap();
      itemsJson.forEach((item) => map.addItem(...itemizer(item)));
      return map.hash();
    }
    function transactionItemizer(json) {
      if (!json.hash) {
        throw new Error();
      }
      const index = hash_256_1.Hash256.from(json.hash);
      const item = {
        hashPrefix() {
          return hash_prefixes_1.HashPrefix.transaction;
        },
        toBytesSink(sink) {
          const serializer = new binary_1.BinarySerializer(sink);
          serializer.writeLengthEncoded(st_object_1.STObject.from(json));
          serializer.writeLengthEncoded(
            st_object_1.STObject.from(json.metaData)
          );
        },
      };
      return [index, item, void 0];
    }
    function entryItemizer(json) {
      const index = hash_256_1.Hash256.from(json.index);
      const bytes = (0, binary_1.serializeObject)(json);
      const item = {
        hashPrefix() {
          return hash_prefixes_1.HashPrefix.accountStateEntry;
        },
        toBytesSink(sink) {
          sink.put(bytes);
        },
      };
      return [index, item, void 0];
    }
    function transactionTreeHash(param) {
      const itemizer = transactionItemizer;
      return computeHash(itemizer, param);
    }
    exports2.transactionTreeHash = transactionTreeHash;
    function accountStateHash(param) {
      const itemizer = entryItemizer;
      return computeHash(itemizer, param);
    }
    exports2.accountStateHash = accountStateHash;
    function ledgerHash(header) {
      const hash = new hashes_1.Sha512Half();
      hash.put(hash_prefixes_1.HashPrefix.ledgerHeader);
      if (
        header.parent_close_time === void 0 ||
        header.close_flags === void 0
      ) {
        throw new Error();
      }
      uint_32_1.UInt32.from(header.ledger_index).toBytesSink(hash);
      uint_64_1.UInt64.from(BigInt(String(header.total_coins))).toBytesSink(
        hash
      );
      hash_256_1.Hash256.from(header.parent_hash).toBytesSink(hash);
      hash_256_1.Hash256.from(header.transaction_hash).toBytesSink(hash);
      hash_256_1.Hash256.from(header.account_hash).toBytesSink(hash);
      uint_32_1.UInt32.from(header.parent_close_time).toBytesSink(hash);
      uint_32_1.UInt32.from(header.close_time).toBytesSink(hash);
      uint_8_1.UInt8.from(header.close_time_resolution).toBytesSink(hash);
      uint_8_1.UInt8.from(header.close_flags).toBytesSink(hash);
      return hash.finish();
    }
    exports2.ledgerHash = ledgerHash;
    function decodeLedgerData(binary, definitions) {
      if (typeof binary !== "string") {
        throw new Error("binary must be a hex string");
      }
      const parser = new binary_parser_1.BinaryParser(binary, definitions);
      return {
        ledger_index: parser.readUInt32(),
        total_coins: parser.readType(uint_64_1.UInt64).valueOf().toString(),
        parent_hash: parser.readType(hash_256_1.Hash256).toHex(),
        transaction_hash: parser.readType(hash_256_1.Hash256).toHex(),
        account_hash: parser.readType(hash_256_1.Hash256).toHex(),
        parent_close_time: parser.readUInt32(),
        close_time: parser.readUInt32(),
        close_time_resolution: parser.readUInt8(),
        close_flags: parser.readUInt8(),
      };
    }
    exports2.decodeLedgerData = decodeLedgerData;
  },
});

// node_modules/ripple-binary-codec/dist/quality.js
var require_quality = __commonJS({
  "node_modules/ripple-binary-codec/dist/quality.js"(exports2) {
    "use strict";
    var __importDefault =
      (exports2 && exports2.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.quality = void 0;
    var types_1 = require_types();
    var bignumber_js_1 = __importDefault(require_bignumber());
    var utils_1 = require_utils2();
    var quality = class {
      /**
       * Encode quality amount
       *
       * @param arg string representation of an amount
       * @returns Serialized quality
       */
      static encode(quality2) {
        const decimal = (0, bignumber_js_1.default)(quality2);
        const exponent =
          ((decimal === null || decimal === void 0 ? void 0 : decimal.e) || 0) -
          15;
        const qualityString = decimal.times(`1e${-exponent}`).abs().toString();
        const bytes = types_1.coreTypes.UInt64.from(
          BigInt(qualityString)
        ).toBytes();
        bytes[0] = exponent + 100;
        return bytes;
      }
      /**
       * Decode quality amount
       *
       * @param arg hex-string denoting serialized quality
       * @returns deserialized quality
       */
      static decode(quality2) {
        const bytes = (0, utils_1.hexToBytes)(quality2).slice(-8);
        const exponent = bytes[0] - 100;
        const mantissa = new bignumber_js_1.default(
          `0x${(0, utils_1.bytesToHex)(bytes.slice(1))}`
        );
        return mantissa.times(`1e${exponent}`);
      }
    };
    exports2.quality = quality;
  },
});

// node_modules/ripple-binary-codec/dist/coretypes.js
var require_coretypes = __commonJS({
  "node_modules/ripple-binary-codec/dist/coretypes.js"(exports2) {
    "use strict";
    var __createBinding =
      (exports2 && exports2.__createBinding) ||
      (Object.create
        ? function (o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);
            if (
              !desc ||
              ("get" in desc
                ? !m.__esModule
                : desc.writable || desc.configurable)
            ) {
              desc = {
                enumerable: true,
                get: function () {
                  return m[k];
                },
              };
            }
            Object.defineProperty(o, k2, desc);
          }
        : function (o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            o[k2] = m[k];
          });
    var __setModuleDefault =
      (exports2 && exports2.__setModuleDefault) ||
      (Object.create
        ? function (o, v) {
            Object.defineProperty(o, "default", { enumerable: true, value: v });
          }
        : function (o, v) {
            o["default"] = v;
          });
    var __importStar =
      (exports2 && exports2.__importStar) ||
      function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.types =
      exports2.ShaMap =
      exports2.HashPrefix =
      exports2.quality =
      exports2.TransactionResult =
      exports2.Type =
      exports2.LedgerEntryType =
      exports2.TransactionType =
      exports2.Field =
      exports2.DEFAULT_DEFINITIONS =
      exports2.ledgerHashes =
      exports2.binary =
      exports2.hashes =
        void 0;
    var enums_1 = require_enums();
    Object.defineProperty(exports2, "DEFAULT_DEFINITIONS", {
      enumerable: true,
      get: function () {
        return enums_1.DEFAULT_DEFINITIONS;
      },
    });
    Object.defineProperty(exports2, "Field", {
      enumerable: true,
      get: function () {
        return enums_1.Field;
      },
    });
    Object.defineProperty(exports2, "TransactionType", {
      enumerable: true,
      get: function () {
        return enums_1.TransactionType;
      },
    });
    Object.defineProperty(exports2, "LedgerEntryType", {
      enumerable: true,
      get: function () {
        return enums_1.LedgerEntryType;
      },
    });
    Object.defineProperty(exports2, "Type", {
      enumerable: true,
      get: function () {
        return enums_1.Type;
      },
    });
    Object.defineProperty(exports2, "TransactionResult", {
      enumerable: true,
      get: function () {
        return enums_1.TransactionResult;
      },
    });
    var types = __importStar(require_types());
    exports2.types = types;
    var binary = __importStar(require_binary());
    exports2.binary = binary;
    var shamap_1 = require_shamap();
    Object.defineProperty(exports2, "ShaMap", {
      enumerable: true,
      get: function () {
        return shamap_1.ShaMap;
      },
    });
    var ledgerHashes = __importStar(require_ledger_hashes());
    exports2.ledgerHashes = ledgerHashes;
    var hashes = __importStar(require_hashes());
    exports2.hashes = hashes;
    var quality_1 = require_quality();
    Object.defineProperty(exports2, "quality", {
      enumerable: true,
      get: function () {
        return quality_1.quality;
      },
    });
    var hash_prefixes_1 = require_hash_prefixes();
    Object.defineProperty(exports2, "HashPrefix", {
      enumerable: true,
      get: function () {
        return hash_prefixes_1.HashPrefix;
      },
    });
  },
});

// node_modules/ripple-binary-codec/dist/enums/xrpl-definitions.js
var require_xrpl_definitions = __commonJS({
  "node_modules/ripple-binary-codec/dist/enums/xrpl-definitions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.XrplDefinitions = void 0;
    var xrpl_definitions_base_1 = require_xrpl_definitions_base();
    var types_1 = require_types();
    var XrplDefinitions = class extends xrpl_definitions_base_1.XrplDefinitionsBase {
      /**
       * Present rippled types in a typed and updatable format.
       * For an example of the input format see `definitions.json`
       * To generate a new definitions file from rippled source code, use the tool at
       * `packages/ripple-binary-codec/tools/generateDefinitions.js`.
       *
       * See the definitions.test.js file for examples of how to create your own updated definitions.json.
       *
       * @param enums - A json encoding of the core types, transaction types, transaction results, transaction names, and fields.
       * @param additionalTypes - A list of SerializedType objects with the same name as the fields defined.
       *              These types will be included in addition to the coreTypes used on mainnet.
       */
      constructor(enums, additionalTypes) {
        const types = Object.assign({}, types_1.coreTypes, additionalTypes);
        super(enums, types);
      }
    };
    exports2.XrplDefinitions = XrplDefinitions;
  },
});

// node_modules/ripple-binary-codec/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/ripple-binary-codec/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.coreTypes =
      exports2.DEFAULT_DEFINITIONS =
      exports2.XrplDefinitionsBase =
      exports2.XrplDefinitions =
      exports2.TRANSACTION_TYPES =
      exports2.decodeLedgerData =
      exports2.decodeQuality =
      exports2.encodeQuality =
      exports2.encodeForSigningBatch =
      exports2.encodeForMultisigning =
      exports2.encodeForSigningClaim =
      exports2.encodeForSigning =
      exports2.encode =
      exports2.decode =
        void 0;
    var coretypes_1 = require_coretypes();
    var ledger_hashes_1 = require_ledger_hashes();
    Object.defineProperty(exports2, "decodeLedgerData", {
      enumerable: true,
      get: function () {
        return ledger_hashes_1.decodeLedgerData;
      },
    });
    var enums_1 = require_enums();
    Object.defineProperty(exports2, "XrplDefinitionsBase", {
      enumerable: true,
      get: function () {
        return enums_1.XrplDefinitionsBase;
      },
    });
    Object.defineProperty(exports2, "TRANSACTION_TYPES", {
      enumerable: true,
      get: function () {
        return enums_1.TRANSACTION_TYPES;
      },
    });
    Object.defineProperty(exports2, "DEFAULT_DEFINITIONS", {
      enumerable: true,
      get: function () {
        return enums_1.DEFAULT_DEFINITIONS;
      },
    });
    var xrpl_definitions_1 = require_xrpl_definitions();
    Object.defineProperty(exports2, "XrplDefinitions", {
      enumerable: true,
      get: function () {
        return xrpl_definitions_1.XrplDefinitions;
      },
    });
    var types_1 = require_types();
    Object.defineProperty(exports2, "coreTypes", {
      enumerable: true,
      get: function () {
        return types_1.coreTypes;
      },
    });
    var utils_1 = require_utils2();
    var {
      signingData,
      signingClaimData,
      multiSigningData,
      signingBatchData,
      binaryToJSON,
      serializeObject,
    } = coretypes_1.binary;
    function decode(binary, definitions) {
      if (typeof binary !== "string") {
        throw new Error("binary must be a hex string");
      }
      return binaryToJSON(binary, definitions);
    }
    exports2.decode = decode;
    function encode(json, definitions) {
      if (typeof json !== "object") {
        throw new Error();
      }
      return (0, utils_1.bytesToHex)(serializeObject(json, { definitions }));
    }
    exports2.encode = encode;
    function encodeForSigning(json, definitions) {
      if (typeof json !== "object") {
        throw new Error();
      }
      return (0, utils_1.bytesToHex)(
        signingData(json, coretypes_1.HashPrefix.transactionSig, {
          definitions,
        })
      );
    }
    exports2.encodeForSigning = encodeForSigning;
    function encodeForSigningClaim(json) {
      if (typeof json !== "object") {
        throw new Error();
      }
      return (0, utils_1.bytesToHex)(signingClaimData(json));
    }
    exports2.encodeForSigningClaim = encodeForSigningClaim;
    function encodeForMultisigning(json, signer, definitions) {
      if (typeof json !== "object") {
        throw new Error();
      }
      if (json["SigningPubKey"] !== "") {
        throw new Error();
      }
      const definitionsOpt = definitions ? { definitions } : void 0;
      return (0, utils_1.bytesToHex)(
        multiSigningData(json, signer, definitionsOpt)
      );
    }
    exports2.encodeForMultisigning = encodeForMultisigning;
    function encodeForSigningBatch(json) {
      if (typeof json !== "object") {
        throw new Error("Need an object to encode a Batch transaction");
      }
      return (0, utils_1.bytesToHex)(signingBatchData(json));
    }
    exports2.encodeForSigningBatch = encodeForSigningBatch;
    function encodeQuality(value) {
      if (typeof value !== "string") {
        throw new Error();
      }
      return (0, utils_1.bytesToHex)(coretypes_1.quality.encode(value));
    }
    exports2.encodeQuality = encodeQuality;
    function decodeQuality(value) {
      if (typeof value !== "string") {
        throw new Error();
      }
      return coretypes_1.quality.decode(value).toString();
    }
    exports2.decodeQuality = decodeQuality;
  },
});

// node_modules/xrpl/dist/npm/models/utils/index.js
var require_utils5 = __commonJS({
  "node_modules/xrpl/dist/npm/models/utils/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isHex = exports2.isFlagEnabled = exports2.onlyHasFields = void 0;
    var HEX_REGEX = /^[0-9A-Fa-f]+$/u;
    function onlyHasFields(obj, fields) {
      return Object.keys(obj).every((key) => fields.includes(key));
    }
    exports2.onlyHasFields = onlyHasFields;
    function isFlagEnabled(Flags, checkFlag) {
      return (BigInt(checkFlag) & BigInt(Flags)) === BigInt(checkFlag);
    }
    exports2.isFlagEnabled = isFlagEnabled;
    function isHex(str) {
      return HEX_REGEX.test(str);
    }
    exports2.isHex = isHex;
  },
});

// node_modules/xrpl/dist/npm/models/transactions/common.js
var require_common = __commonJS({
  "node_modules/xrpl/dist/npm/models/transactions/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseAmountValue =
      exports2.validateBaseTransaction =
      exports2.validateOptionalField =
      exports2.validateRequiredField =
      exports2.isXChainBridge =
      exports2.isAmount =
      exports2.isAccount =
      exports2.isIssuedCurrency =
      exports2.isCurrency =
      exports2.isNumber =
      exports2.isString =
        void 0;
    var ripple_address_codec_1 = require_dist();
    var ripple_binary_codec_1 = require_dist2();
    var errors_1 = require_errors();
    var utils_1 = require_utils5();
    var MEMO_SIZE = 3;
    function isMemo(obj) {
      if (obj.Memo == null) {
        return false;
      }
      const memo = obj.Memo;
      const size = Object.keys(memo).length;
      const validData =
        memo.MemoData == null || typeof memo.MemoData === "string";
      const validFormat =
        memo.MemoFormat == null || typeof memo.MemoFormat === "string";
      const validType =
        memo.MemoType == null || typeof memo.MemoType === "string";
      return (
        size >= 1 &&
        size <= MEMO_SIZE &&
        validData &&
        validFormat &&
        validType &&
        (0, utils_1.onlyHasFields)(memo, ["MemoFormat", "MemoData", "MemoType"])
      );
    }
    var SIGNER_SIZE = 3;
    function isSigner(obj) {
      const signerWrapper = obj;
      if (signerWrapper.Signer == null) {
        return false;
      }
      const signer = signerWrapper.Signer;
      return (
        Object.keys(signer).length === SIGNER_SIZE &&
        typeof signer.Account === "string" &&
        typeof signer.TxnSignature === "string" &&
        typeof signer.SigningPubKey === "string"
      );
    }
    var XRP_CURRENCY_SIZE = 1;
    var ISSUE_SIZE = 2;
    var ISSUED_CURRENCY_SIZE = 3;
    var XCHAIN_BRIDGE_SIZE = 4;
    function isRecord(value) {
      return value !== null && typeof value === "object";
    }
    function isString(str) {
      return typeof str === "string";
    }
    exports2.isString = isString;
    function isNumber(num) {
      return typeof num === "number";
    }
    exports2.isNumber = isNumber;
    function isCurrency(input) {
      return (
        isRecord(input) &&
        ((Object.keys(input).length === ISSUE_SIZE &&
          typeof input.issuer === "string" &&
          typeof input.currency === "string") ||
          (Object.keys(input).length === XRP_CURRENCY_SIZE &&
            input.currency === "XRP"))
      );
    }
    exports2.isCurrency = isCurrency;
    function isIssuedCurrency(input) {
      return (
        isRecord(input) &&
        Object.keys(input).length === ISSUED_CURRENCY_SIZE &&
        typeof input.value === "string" &&
        typeof input.issuer === "string" &&
        typeof input.currency === "string"
      );
    }
    exports2.isIssuedCurrency = isIssuedCurrency;
    function isAccount(account) {
      return (
        typeof account === "string" &&
        ((0, ripple_address_codec_1.isValidClassicAddress)(account) ||
          (0, ripple_address_codec_1.isValidXAddress)(account))
      );
    }
    exports2.isAccount = isAccount;
    function isAmount(amount) {
      return typeof amount === "string" || isIssuedCurrency(amount);
    }
    exports2.isAmount = isAmount;
    function isXChainBridge(input) {
      return (
        isRecord(input) &&
        Object.keys(input).length === XCHAIN_BRIDGE_SIZE &&
        typeof input.LockingChainDoor === "string" &&
        isCurrency(input.LockingChainIssue) &&
        typeof input.IssuingChainDoor === "string" &&
        isCurrency(input.IssuingChainIssue)
      );
    }
    exports2.isXChainBridge = isXChainBridge;
    function validateRequiredField(tx, paramName, checkValidity) {
      if (tx[paramName] == null) {
        throw new errors_1.ValidationError(
          `${tx.TransactionType}: missing field ${paramName}`
        );
      }
      if (!checkValidity(tx[paramName])) {
        throw new errors_1.ValidationError(
          `${tx.TransactionType}: invalid field ${paramName}`
        );
      }
    }
    exports2.validateRequiredField = validateRequiredField;
    function validateOptionalField(tx, paramName, checkValidity) {
      if (tx[paramName] !== void 0 && !checkValidity(tx[paramName])) {
        throw new errors_1.ValidationError(
          `${tx.TransactionType}: invalid field ${paramName}`
        );
      }
    }
    exports2.validateOptionalField = validateOptionalField;
    function validateBaseTransaction(common) {
      if (common.TransactionType === void 0) {
        throw new errors_1.ValidationError(
          "BaseTransaction: missing field TransactionType"
        );
      }
      if (typeof common.TransactionType !== "string") {
        throw new errors_1.ValidationError(
          "BaseTransaction: TransactionType not string"
        );
      }
      if (
        !ripple_binary_codec_1.TRANSACTION_TYPES.includes(
          common.TransactionType
        )
      ) {
        throw new errors_1.ValidationError(
          "BaseTransaction: Unknown TransactionType"
        );
      }
      validateRequiredField(common, "Account", isString);
      validateOptionalField(common, "Fee", isString);
      validateOptionalField(common, "Sequence", isNumber);
      validateOptionalField(common, "AccountTxnID", isString);
      validateOptionalField(common, "LastLedgerSequence", isNumber);
      const memos = common.Memos;
      if (memos !== void 0 && !memos.every(isMemo)) {
        throw new errors_1.ValidationError("BaseTransaction: invalid Memos");
      }
      const signers = common.Signers;
      if (
        signers !== void 0 &&
        (signers.length === 0 || !signers.every(isSigner))
      ) {
        throw new errors_1.ValidationError("BaseTransaction: invalid Signers");
      }
      validateOptionalField(common, "SourceTag", isNumber);
      validateOptionalField(common, "SigningPubKey", isString);
      validateOptionalField(common, "TicketSequence", isNumber);
      validateOptionalField(common, "TxnSignature", isString);
      validateOptionalField(common, "NetworkID", isNumber);
    }
    exports2.validateBaseTransaction = validateBaseTransaction;
    function parseAmountValue(amount) {
      if (!isAmount(amount)) {
        return NaN;
      }
      if (typeof amount === "string") {
        return parseFloat(amount);
      }
      return parseFloat(amount.value);
    }
    exports2.parseAmountValue = parseAmountValue;
  },
});

// node_modules/xrpl/dist/npm/models/transactions/accountSet.js
var require_accountSet = __commonJS({
  "node_modules/xrpl/dist/npm/models/transactions/accountSet.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateAccountSet =
      exports2.AccountSetTfFlags =
      exports2.AccountSetAsfFlags =
        void 0;
    var errors_1 = require_errors();
    var common_1 = require_common();
    var AccountSetAsfFlags;
    (function (AccountSetAsfFlags2) {
      AccountSetAsfFlags2[(AccountSetAsfFlags2["asfRequireDest"] = 1)] =
        "asfRequireDest";
      AccountSetAsfFlags2[(AccountSetAsfFlags2["asfRequireAuth"] = 2)] =
        "asfRequireAuth";
      AccountSetAsfFlags2[(AccountSetAsfFlags2["asfDisallowXRP"] = 3)] =
        "asfDisallowXRP";
      AccountSetAsfFlags2[(AccountSetAsfFlags2["asfDisableMaster"] = 4)] =
        "asfDisableMaster";
      AccountSetAsfFlags2[(AccountSetAsfFlags2["asfAccountTxnID"] = 5)] =
        "asfAccountTxnID";
      AccountSetAsfFlags2[(AccountSetAsfFlags2["asfNoFreeze"] = 6)] =
        "asfNoFreeze";
      AccountSetAsfFlags2[(AccountSetAsfFlags2["asfGlobalFreeze"] = 7)] =
        "asfGlobalFreeze";
      AccountSetAsfFlags2[(AccountSetAsfFlags2["asfDefaultRipple"] = 8)] =
        "asfDefaultRipple";
      AccountSetAsfFlags2[(AccountSetAsfFlags2["asfDepositAuth"] = 9)] =
        "asfDepositAuth";
      AccountSetAsfFlags2[
        (AccountSetAsfFlags2["asfAuthorizedNFTokenMinter"] = 10)
      ] = "asfAuthorizedNFTokenMinter";
      AccountSetAsfFlags2[
        (AccountSetAsfFlags2["asfDisallowIncomingNFTokenOffer"] = 12)
      ] = "asfDisallowIncomingNFTokenOffer";
      AccountSetAsfFlags2[
        (AccountSetAsfFlags2["asfDisallowIncomingCheck"] = 13)
      ] = "asfDisallowIncomingCheck";
      AccountSetAsfFlags2[
        (AccountSetAsfFlags2["asfDisallowIncomingPayChan"] = 14)
      ] = "asfDisallowIncomingPayChan";
      AccountSetAsfFlags2[
        (AccountSetAsfFlags2["asfDisallowIncomingTrustline"] = 15)
      ] = "asfDisallowIncomingTrustline";
      AccountSetAsfFlags2[
        (AccountSetAsfFlags2["asfAllowTrustLineClawback"] = 16)
      ] = "asfAllowTrustLineClawback";
    })(
      AccountSetAsfFlags ||
        (exports2.AccountSetAsfFlags = AccountSetAsfFlags = {})
    );
    var AccountSetTfFlags;
    (function (AccountSetTfFlags2) {
      AccountSetTfFlags2[(AccountSetTfFlags2["tfRequireDestTag"] = 65536)] =
        "tfRequireDestTag";
      AccountSetTfFlags2[(AccountSetTfFlags2["tfOptionalDestTag"] = 131072)] =
        "tfOptionalDestTag";
      AccountSetTfFlags2[(AccountSetTfFlags2["tfRequireAuth"] = 262144)] =
        "tfRequireAuth";
      AccountSetTfFlags2[(AccountSetTfFlags2["tfOptionalAuth"] = 524288)] =
        "tfOptionalAuth";
      AccountSetTfFlags2[(AccountSetTfFlags2["tfDisallowXRP"] = 1048576)] =
        "tfDisallowXRP";
      AccountSetTfFlags2[(AccountSetTfFlags2["tfAllowXRP"] = 2097152)] =
        "tfAllowXRP";
    })(
      AccountSetTfFlags || (exports2.AccountSetTfFlags = AccountSetTfFlags = {})
    );
    var MIN_TICK_SIZE = 3;
    var MAX_TICK_SIZE = 15;
    function validateAccountSet(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateOptionalField)(
        tx,
        "NFTokenMinter",
        common_1.isAccount
      );
      if (tx.ClearFlag !== void 0) {
        if (typeof tx.ClearFlag !== "number") {
          throw new errors_1.ValidationError("AccountSet: invalid ClearFlag");
        }
        if (!Object.values(AccountSetAsfFlags).includes(tx.ClearFlag)) {
          throw new errors_1.ValidationError("AccountSet: invalid ClearFlag");
        }
      }
      if (tx.Domain !== void 0 && typeof tx.Domain !== "string") {
        throw new errors_1.ValidationError("AccountSet: invalid Domain");
      }
      if (tx.EmailHash !== void 0 && typeof tx.EmailHash !== "string") {
        throw new errors_1.ValidationError("AccountSet: invalid EmailHash");
      }
      if (tx.MessageKey !== void 0 && typeof tx.MessageKey !== "string") {
        throw new errors_1.ValidationError("AccountSet: invalid MessageKey");
      }
      if (tx.SetFlag !== void 0) {
        if (typeof tx.SetFlag !== "number") {
          throw new errors_1.ValidationError("AccountSet: invalid SetFlag");
        }
        if (!Object.values(AccountSetAsfFlags).includes(tx.SetFlag)) {
          throw new errors_1.ValidationError("AccountSet: invalid SetFlag");
        }
      }
      if (tx.TransferRate !== void 0 && typeof tx.TransferRate !== "number") {
        throw new errors_1.ValidationError("AccountSet: invalid TransferRate");
      }
      if (tx.TickSize !== void 0) {
        if (typeof tx.TickSize !== "number") {
          throw new errors_1.ValidationError("AccountSet: invalid TickSize");
        }
        if (
          tx.TickSize !== 0 &&
          (tx.TickSize < MIN_TICK_SIZE || tx.TickSize > MAX_TICK_SIZE)
        ) {
          throw new errors_1.ValidationError("AccountSet: invalid TickSize");
        }
      }
    }
    exports2.validateAccountSet = validateAccountSet;
  },
});

// node_modules/xrpl/dist/npm/models/transactions/AMMDeposit.js
var require_AMMDeposit = __commonJS({
  "node_modules/xrpl/dist/npm/models/transactions/AMMDeposit.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateAMMDeposit = exports2.AMMDepositFlags = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common();
    var AMMDepositFlags;
    (function (AMMDepositFlags2) {
      AMMDepositFlags2[(AMMDepositFlags2["tfLPToken"] = 65536)] = "tfLPToken";
      AMMDepositFlags2[(AMMDepositFlags2["tfSingleAsset"] = 524288)] =
        "tfSingleAsset";
      AMMDepositFlags2[(AMMDepositFlags2["tfTwoAsset"] = 1048576)] =
        "tfTwoAsset";
      AMMDepositFlags2[(AMMDepositFlags2["tfOneAssetLPToken"] = 2097152)] =
        "tfOneAssetLPToken";
      AMMDepositFlags2[(AMMDepositFlags2["tfLimitLPToken"] = 4194304)] =
        "tfLimitLPToken";
      AMMDepositFlags2[(AMMDepositFlags2["tfTwoAssetIfEmpty"] = 8388608)] =
        "tfTwoAssetIfEmpty";
    })(AMMDepositFlags || (exports2.AMMDepositFlags = AMMDepositFlags = {}));
    function validateAMMDeposit(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.Asset == null) {
        throw new errors_1.ValidationError("AMMDeposit: missing field Asset");
      }
      if (!(0, common_1.isCurrency)(tx.Asset)) {
        throw new errors_1.ValidationError(
          "AMMDeposit: Asset must be a Currency"
        );
      }
      if (tx.Asset2 == null) {
        throw new errors_1.ValidationError("AMMDeposit: missing field Asset2");
      }
      if (!(0, common_1.isCurrency)(tx.Asset2)) {
        throw new errors_1.ValidationError(
          "AMMDeposit: Asset2 must be a Currency"
        );
      }
      if (tx.Amount2 != null && tx.Amount == null) {
        throw new errors_1.ValidationError(
          "AMMDeposit: must set Amount with Amount2"
        );
      } else if (tx.EPrice != null && tx.Amount == null) {
        throw new errors_1.ValidationError(
          "AMMDeposit: must set Amount with EPrice"
        );
      } else if (tx.LPTokenOut == null && tx.Amount == null) {
        throw new errors_1.ValidationError(
          "AMMDeposit: must set at least LPTokenOut or Amount"
        );
      }
      if (
        tx.LPTokenOut != null &&
        !(0, common_1.isIssuedCurrency)(tx.LPTokenOut)
      ) {
        throw new errors_1.ValidationError(
          "AMMDeposit: LPTokenOut must be an IssuedCurrencyAmount"
        );
      }
      if (tx.Amount != null && !(0, common_1.isAmount)(tx.Amount)) {
        throw new errors_1.ValidationError(
          "AMMDeposit: Amount must be an Amount"
        );
      }
      if (tx.Amount2 != null && !(0, common_1.isAmount)(tx.Amount2)) {
        throw new errors_1.ValidationError(
          "AMMDeposit: Amount2 must be an Amount"
        );
      }
      if (tx.EPrice != null && !(0, common_1.isAmount)(tx.EPrice)) {
        throw new errors_1.ValidationError(
          "AMMDeposit: EPrice must be an Amount"
        );
      }
    }
    exports2.validateAMMDeposit = validateAMMDeposit;
  },
});

// node_modules/xrpl/dist/npm/models/transactions/AMMWithdraw.js
var require_AMMWithdraw = __commonJS({
  "node_modules/xrpl/dist/npm/models/transactions/AMMWithdraw.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateAMMWithdraw = exports2.AMMWithdrawFlags = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common();
    var AMMWithdrawFlags;
    (function (AMMWithdrawFlags2) {
      AMMWithdrawFlags2[(AMMWithdrawFlags2["tfLPToken"] = 65536)] = "tfLPToken";
      AMMWithdrawFlags2[(AMMWithdrawFlags2["tfWithdrawAll"] = 131072)] =
        "tfWithdrawAll";
      AMMWithdrawFlags2[(AMMWithdrawFlags2["tfOneAssetWithdrawAll"] = 262144)] =
        "tfOneAssetWithdrawAll";
      AMMWithdrawFlags2[(AMMWithdrawFlags2["tfSingleAsset"] = 524288)] =
        "tfSingleAsset";
      AMMWithdrawFlags2[(AMMWithdrawFlags2["tfTwoAsset"] = 1048576)] =
        "tfTwoAsset";
      AMMWithdrawFlags2[(AMMWithdrawFlags2["tfOneAssetLPToken"] = 2097152)] =
        "tfOneAssetLPToken";
      AMMWithdrawFlags2[(AMMWithdrawFlags2["tfLimitLPToken"] = 4194304)] =
        "tfLimitLPToken";
    })(AMMWithdrawFlags || (exports2.AMMWithdrawFlags = AMMWithdrawFlags = {}));
    function validateAMMWithdraw(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.Asset == null) {
        throw new errors_1.ValidationError("AMMWithdraw: missing field Asset");
      }
      if (!(0, common_1.isCurrency)(tx.Asset)) {
        throw new errors_1.ValidationError(
          "AMMWithdraw: Asset must be a Currency"
        );
      }
      if (tx.Asset2 == null) {
        throw new errors_1.ValidationError("AMMWithdraw: missing field Asset2");
      }
      if (!(0, common_1.isCurrency)(tx.Asset2)) {
        throw new errors_1.ValidationError(
          "AMMWithdraw: Asset2 must be a Currency"
        );
      }
      if (tx.Amount2 != null && tx.Amount == null) {
        throw new errors_1.ValidationError(
          "AMMWithdraw: must set Amount with Amount2"
        );
      } else if (tx.EPrice != null && tx.Amount == null) {
        throw new errors_1.ValidationError(
          "AMMWithdraw: must set Amount with EPrice"
        );
      }
      if (
        tx.LPTokenIn != null &&
        !(0, common_1.isIssuedCurrency)(tx.LPTokenIn)
      ) {
        throw new errors_1.ValidationError(
          "AMMWithdraw: LPTokenIn must be an IssuedCurrencyAmount"
        );
      }
      if (tx.Amount != null && !(0, common_1.isAmount)(tx.Amount)) {
        throw new errors_1.ValidationError(
          "AMMWithdraw: Amount must be an Amount"
        );
      }
      if (tx.Amount2 != null && !(0, common_1.isAmount)(tx.Amount2)) {
        throw new errors_1.ValidationError(
          "AMMWithdraw: Amount2 must be an Amount"
        );
      }
      if (tx.EPrice != null && !(0, common_1.isAmount)(tx.EPrice)) {
        throw new errors_1.ValidationError(
          "AMMWithdraw: EPrice must be an Amount"
        );
      }
    }
    exports2.validateAMMWithdraw = validateAMMWithdraw;
  },
});

// node_modules/xrpl/dist/npm/models/transactions/NFTokenCreateOffer.js
var require_NFTokenCreateOffer = __commonJS({
  "node_modules/xrpl/dist/npm/models/transactions/NFTokenCreateOffer.js"(
    exports2
  ) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateNFTokenCreateOffer = exports2.NFTokenCreateOfferFlags =
      void 0;
    var errors_1 = require_errors();
    var utils_1 = require_utils5();
    var common_1 = require_common();
    var NFTokenCreateOfferFlags;
    (function (NFTokenCreateOfferFlags2) {
      NFTokenCreateOfferFlags2[
        (NFTokenCreateOfferFlags2["tfSellNFToken"] = 1)
      ] = "tfSellNFToken";
    })(
      NFTokenCreateOfferFlags ||
        (exports2.NFTokenCreateOfferFlags = NFTokenCreateOfferFlags = {})
    );
    function validateNFTokenSellOfferCases(tx) {
      if (tx.Owner != null) {
        throw new errors_1.ValidationError(
          "NFTokenCreateOffer: Owner must not be present for sell offers"
        );
      }
    }
    function validateNFTokenBuyOfferCases(tx) {
      if (tx.Owner == null) {
        throw new errors_1.ValidationError(
          "NFTokenCreateOffer: Owner must be present for buy offers"
        );
      }
      if ((0, common_1.parseAmountValue)(tx.Amount) <= 0) {
        throw new errors_1.ValidationError(
          "NFTokenCreateOffer: Amount must be greater than 0 for buy offers"
        );
      }
    }
    function validateNFTokenCreateOffer(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.Account === tx.Owner) {
        throw new errors_1.ValidationError(
          "NFTokenCreateOffer: Owner and Account must not be equal"
        );
      }
      if (tx.Account === tx.Destination) {
        throw new errors_1.ValidationError(
          "NFTokenCreateOffer: Destination and Account must not be equal"
        );
      }
      (0, common_1.validateOptionalField)(
        tx,
        "Destination",
        common_1.isAccount
      );
      (0, common_1.validateOptionalField)(tx, "Owner", common_1.isAccount);
      if (tx.NFTokenID == null) {
        throw new errors_1.ValidationError(
          "NFTokenCreateOffer: missing field NFTokenID"
        );
      }
      if (!(0, common_1.isAmount)(tx.Amount)) {
        throw new errors_1.ValidationError(
          "NFTokenCreateOffer: invalid Amount"
        );
      }
      if (
        typeof tx.Flags === "number" &&
        (0, utils_1.isFlagEnabled)(
          tx.Flags,
          NFTokenCreateOfferFlags.tfSellNFToken
        )
      ) {
        validateNFTokenSellOfferCases(tx);
      } else {
        validateNFTokenBuyOfferCases(tx);
      }
    }
    exports2.validateNFTokenCreateOffer = validateNFTokenCreateOffer;
  },
});

// node_modules/xrpl/dist/npm/models/transactions/NFTokenMint.js
var require_NFTokenMint = __commonJS({
  "node_modules/xrpl/dist/npm/models/transactions/NFTokenMint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateNFTokenMint = exports2.NFTokenMintFlags = void 0;
    var errors_1 = require_errors();
    var utils_1 = require_utils5();
    var common_1 = require_common();
    var NFTokenMintFlags;
    (function (NFTokenMintFlags2) {
      NFTokenMintFlags2[(NFTokenMintFlags2["tfBurnable"] = 1)] = "tfBurnable";
      NFTokenMintFlags2[(NFTokenMintFlags2["tfOnlyXRP"] = 2)] = "tfOnlyXRP";
      NFTokenMintFlags2[(NFTokenMintFlags2["tfTrustLine"] = 4)] = "tfTrustLine";
      NFTokenMintFlags2[(NFTokenMintFlags2["tfTransferable"] = 8)] =
        "tfTransferable";
    })(NFTokenMintFlags || (exports2.NFTokenMintFlags = NFTokenMintFlags = {}));
    function validateNFTokenMint(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.Account === tx.Issuer) {
        throw new errors_1.ValidationError(
          "NFTokenMint: Issuer must not be equal to Account"
        );
      }
      (0, common_1.validateOptionalField)(tx, "Issuer", common_1.isAccount);
      if (typeof tx.URI === "string" && tx.URI === "") {
        throw new errors_1.ValidationError(
          "NFTokenMint: URI must not be empty string"
        );
      }
      if (typeof tx.URI === "string" && !(0, utils_1.isHex)(tx.URI)) {
        throw new errors_1.ValidationError(
          "NFTokenMint: URI must be in hex format"
        );
      }
      if (tx.NFTokenTaxon == null) {
        throw new errors_1.ValidationError(
          "NFTokenMint: missing field NFTokenTaxon"
        );
      }
    }
    exports2.validateNFTokenMint = validateNFTokenMint;
  },
});

// node_modules/xrpl/dist/npm/models/transactions/offerCreate.js
var require_offerCreate = __commonJS({
  "node_modules/xrpl/dist/npm/models/transactions/offerCreate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateOfferCreate = exports2.OfferCreateFlags = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common();
    var OfferCreateFlags;
    (function (OfferCreateFlags2) {
      OfferCreateFlags2[(OfferCreateFlags2["tfPassive"] = 65536)] = "tfPassive";
      OfferCreateFlags2[(OfferCreateFlags2["tfImmediateOrCancel"] = 131072)] =
        "tfImmediateOrCancel";
      OfferCreateFlags2[(OfferCreateFlags2["tfFillOrKill"] = 262144)] =
        "tfFillOrKill";
      OfferCreateFlags2[(OfferCreateFlags2["tfSell"] = 524288)] = "tfSell";
    })(OfferCreateFlags || (exports2.OfferCreateFlags = OfferCreateFlags = {}));
    function validateOfferCreate(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.TakerGets === void 0) {
        throw new errors_1.ValidationError(
          "OfferCreate: missing field TakerGets"
        );
      }
      if (tx.TakerPays === void 0) {
        throw new errors_1.ValidationError(
          "OfferCreate: missing field TakerPays"
        );
      }
      if (
        typeof tx.TakerGets !== "string" &&
        !(0, common_1.isAmount)(tx.TakerGets)
      ) {
        throw new errors_1.ValidationError("OfferCreate: invalid TakerGets");
      }
      if (
        typeof tx.TakerPays !== "string" &&
        !(0, common_1.isAmount)(tx.TakerPays)
      ) {
        throw new errors_1.ValidationError("OfferCreate: invalid TakerPays");
      }
      if (tx.Expiration !== void 0 && typeof tx.Expiration !== "number") {
        throw new errors_1.ValidationError("OfferCreate: invalid Expiration");
      }
      if (tx.OfferSequence !== void 0 && typeof tx.OfferSequence !== "number") {
        throw new errors_1.ValidationError(
          "OfferCreate: invalid OfferSequence"
        );
      }
    }
    exports2.validateOfferCreate = validateOfferCreate;
  },
});

// node_modules/xrpl/dist/npm/models/transactions/payment.js
var require_payment = __commonJS({
  "node_modules/xrpl/dist/npm/models/transactions/payment.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validatePayment = exports2.PaymentFlags = void 0;
    var errors_1 = require_errors();
    var utils_1 = require_utils5();
    var common_1 = require_common();
    var PaymentFlags;
    (function (PaymentFlags2) {
      PaymentFlags2[(PaymentFlags2["tfNoRippleDirect"] = 65536)] =
        "tfNoRippleDirect";
      PaymentFlags2[(PaymentFlags2["tfPartialPayment"] = 131072)] =
        "tfPartialPayment";
      PaymentFlags2[(PaymentFlags2["tfLimitQuality"] = 262144)] =
        "tfLimitQuality";
    })(PaymentFlags || (exports2.PaymentFlags = PaymentFlags = {}));
    function validatePayment(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.Amount === void 0) {
        throw new errors_1.ValidationError(
          "PaymentTransaction: missing field Amount"
        );
      }
      if (!(0, common_1.isAmount)(tx.Amount)) {
        throw new errors_1.ValidationError(
          "PaymentTransaction: invalid Amount"
        );
      }
      (0, common_1.validateRequiredField)(
        tx,
        "Destination",
        common_1.isAccount
      );
      (0, common_1.validateOptionalField)(
        tx,
        "DestinationTag",
        common_1.isNumber
      );
      if (tx.InvoiceID !== void 0 && typeof tx.InvoiceID !== "string") {
        throw new errors_1.ValidationError(
          "PaymentTransaction: InvoiceID must be a string"
        );
      }
      if (tx.Paths !== void 0 && !isPaths(tx.Paths)) {
        throw new errors_1.ValidationError("PaymentTransaction: invalid Paths");
      }
      if (tx.SendMax !== void 0 && !(0, common_1.isAmount)(tx.SendMax)) {
        throw new errors_1.ValidationError(
          "PaymentTransaction: invalid SendMax"
        );
      }
      checkPartialPayment(tx);
    }
    exports2.validatePayment = validatePayment;
    function checkPartialPayment(tx) {
      var _a;
      if (tx.DeliverMin != null) {
        if (tx.Flags == null) {
          throw new errors_1.ValidationError(
            "PaymentTransaction: tfPartialPayment flag required with DeliverMin"
          );
        }
        const flags = tx.Flags;
        const isTfPartialPayment =
          typeof flags === "number"
            ? (0, utils_1.isFlagEnabled)(flags, PaymentFlags.tfPartialPayment)
            : (_a = flags.tfPartialPayment) !== null && _a !== void 0
            ? _a
            : false;
        if (!isTfPartialPayment) {
          throw new errors_1.ValidationError(
            "PaymentTransaction: tfPartialPayment flag required with DeliverMin"
          );
        }
        if (!(0, common_1.isAmount)(tx.DeliverMin)) {
          throw new errors_1.ValidationError(
            "PaymentTransaction: invalid DeliverMin"
          );
        }
      }
    }
    function isPathStep(pathStep) {
      if (pathStep.account !== void 0 && typeof pathStep.account !== "string") {
        return false;
      }
      if (
        pathStep.currency !== void 0 &&
        typeof pathStep.currency !== "string"
      ) {
        return false;
      }
      if (pathStep.issuer !== void 0 && typeof pathStep.issuer !== "string") {
        return false;
      }
      if (
        pathStep.account !== void 0 &&
        pathStep.currency === void 0 &&
        pathStep.issuer === void 0
      ) {
        return true;
      }
      if (pathStep.currency !== void 0 || pathStep.issuer !== void 0) {
        return true;
      }
      return false;
    }
    function isPath(path) {
      for (const pathStep of path) {
        if (!isPathStep(pathStep)) {
          return false;
        }
      }
      return true;
    }
    function isPaths(paths) {
      if (!Array.isArray(paths) || paths.length === 0) {
        return false;
      }
      for (const path of paths) {
        if (!Array.isArray(path) || path.length === 0) {
          return false;
        }
        if (!isPath(path)) {
          return false;
        }
      }
      return true;
    }
  },
});

// node_modules/xrpl/dist/npm/models/transactions/paymentChannelClaim.js
var require_paymentChannelClaim = __commonJS({
  "node_modules/xrpl/dist/npm/models/transactions/paymentChannelClaim.js"(
    exports2
  ) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validatePaymentChannelClaim = exports2.PaymentChannelClaimFlags =
      void 0;
    var errors_1 = require_errors();
    var common_1 = require_common();
    var PaymentChannelClaimFlags;
    (function (PaymentChannelClaimFlags2) {
      PaymentChannelClaimFlags2[
        (PaymentChannelClaimFlags2["tfRenew"] = 65536)
      ] = "tfRenew";
      PaymentChannelClaimFlags2[
        (PaymentChannelClaimFlags2["tfClose"] = 131072)
      ] = "tfClose";
    })(
      PaymentChannelClaimFlags ||
        (exports2.PaymentChannelClaimFlags = PaymentChannelClaimFlags = {})
    );
    function validatePaymentChannelClaim(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.Channel === void 0) {
        throw new errors_1.ValidationError(
          "PaymentChannelClaim: missing Channel"
        );
      }
      if (typeof tx.Channel !== "string") {
        throw new errors_1.ValidationError(
          "PaymentChannelClaim: Channel must be a string"
        );
      }
      if (tx.Balance !== void 0 && typeof tx.Balance !== "string") {
        throw new errors_1.ValidationError(
          "PaymentChannelClaim: Balance must be a string"
        );
      }
      if (tx.Amount !== void 0 && typeof tx.Amount !== "string") {
        throw new errors_1.ValidationError(
          "PaymentChannelClaim: Amount must be a string"
        );
      }
      if (tx.Signature !== void 0 && typeof tx.Signature !== "string") {
        throw new errors_1.ValidationError(
          "PaymentChannelClaim: Signature must be a string"
        );
      }
      if (tx.PublicKey !== void 0 && typeof tx.PublicKey !== "string") {
        throw new errors_1.ValidationError(
          "PaymentChannelClaim: PublicKey must be a string"
        );
      }
    }
    exports2.validatePaymentChannelClaim = validatePaymentChannelClaim;
  },
});

// node_modules/xrpl/dist/npm/models/transactions/trustSet.js
var require_trustSet = __commonJS({
  "node_modules/xrpl/dist/npm/models/transactions/trustSet.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateTrustSet = exports2.TrustSetFlags = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common();
    var TrustSetFlags;
    (function (TrustSetFlags2) {
      TrustSetFlags2[(TrustSetFlags2["tfSetfAuth"] = 65536)] = "tfSetfAuth";
      TrustSetFlags2[(TrustSetFlags2["tfSetNoRipple"] = 131072)] =
        "tfSetNoRipple";
      TrustSetFlags2[(TrustSetFlags2["tfClearNoRipple"] = 262144)] =
        "tfClearNoRipple";
      TrustSetFlags2[(TrustSetFlags2["tfSetFreeze"] = 1048576)] = "tfSetFreeze";
      TrustSetFlags2[(TrustSetFlags2["tfClearFreeze"] = 2097152)] =
        "tfClearFreeze";
    })(TrustSetFlags || (exports2.TrustSetFlags = TrustSetFlags = {}));
    function validateTrustSet(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      const { LimitAmount, QualityIn, QualityOut } = tx;
      if (LimitAmount === void 0) {
        throw new errors_1.ValidationError(
          "TrustSet: missing field LimitAmount"
        );
      }
      if (!(0, common_1.isAmount)(LimitAmount)) {
        throw new errors_1.ValidationError("TrustSet: invalid LimitAmount");
      }
      if (QualityIn !== void 0 && typeof QualityIn !== "number") {
        throw new errors_1.ValidationError(
          "TrustSet: QualityIn must be a number"
        );
      }
      if (QualityOut !== void 0 && typeof QualityOut !== "number") {
        throw new errors_1.ValidationError(
          "TrustSet: QualityOut must be a number"
        );
      }
    }
    exports2.validateTrustSet = validateTrustSet;
  },
});

// node_modules/xrpl/dist/npm/models/transactions/XChainModifyBridge.js
var require_XChainModifyBridge = __commonJS({
  "node_modules/xrpl/dist/npm/models/transactions/XChainModifyBridge.js"(
    exports2
  ) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateXChainModifyBridge = exports2.XChainModifyBridgeFlags =
      void 0;
    var common_1 = require_common();
    var XChainModifyBridgeFlags;
    (function (XChainModifyBridgeFlags2) {
      XChainModifyBridgeFlags2[
        (XChainModifyBridgeFlags2["tfClearAccountCreateAmount"] = 65536)
      ] = "tfClearAccountCreateAmount";
    })(
      XChainModifyBridgeFlags ||
        (exports2.XChainModifyBridgeFlags = XChainModifyBridgeFlags = {})
    );
    function validateXChainModifyBridge(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(
        tx,
        "XChainBridge",
        common_1.isXChainBridge
      );
      (0, common_1.validateOptionalField)(
        tx,
        "SignatureReward",
        common_1.isAmount
      );
      (0, common_1.validateOptionalField)(
        tx,
        "MinAccountCreateAmount",
        common_1.isAmount
      );
    }
    exports2.validateXChainModifyBridge = validateXChainModifyBridge;
  },
});

// node_modules/xrpl/dist/npm/models/utils/flags.js
var require_flags = __commonJS({
  "node_modules/xrpl/dist/npm/models/utils/flags.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setTransactionFlagsToNumber = exports2.parseAccountRootFlags =
      void 0;
    var errors_1 = require_errors();
    var AccountRoot_1 = require_AccountRoot();
    var accountSet_1 = require_accountSet();
    var AMMDeposit_1 = require_AMMDeposit();
    var AMMWithdraw_1 = require_AMMWithdraw();
    var NFTokenCreateOffer_1 = require_NFTokenCreateOffer();
    var NFTokenMint_1 = require_NFTokenMint();
    var offerCreate_1 = require_offerCreate();
    var payment_1 = require_payment();
    var paymentChannelClaim_1 = require_paymentChannelClaim();
    var trustSet_1 = require_trustSet();
    var XChainModifyBridge_1 = require_XChainModifyBridge();
    var _1 = require_utils5();
    function parseAccountRootFlags(flags) {
      const flagsInterface = {};
      Object.values(AccountRoot_1.AccountRootFlags).forEach((flag) => {
        if (
          typeof flag === "string" &&
          (0, _1.isFlagEnabled)(flags, AccountRoot_1.AccountRootFlags[flag])
        ) {
          flagsInterface[flag] = true;
        }
      });
      return flagsInterface;
    }
    exports2.parseAccountRootFlags = parseAccountRootFlags;
    var txToFlag = {
      AccountSet: accountSet_1.AccountSetTfFlags,
      AMMDeposit: AMMDeposit_1.AMMDepositFlags,
      AMMWithdraw: AMMWithdraw_1.AMMWithdrawFlags,
      NFTokenCreateOffer: NFTokenCreateOffer_1.NFTokenCreateOfferFlags,
      NFTokenMint: NFTokenMint_1.NFTokenMintFlags,
      OfferCreate: offerCreate_1.OfferCreateFlags,
      PaymentChannelClaim: paymentChannelClaim_1.PaymentChannelClaimFlags,
      Payment: payment_1.PaymentFlags,
      TrustSet: trustSet_1.TrustSetFlags,
      XChainModifyBridge: XChainModifyBridge_1.XChainModifyBridgeFlags,
    };
    function setTransactionFlagsToNumber(tx) {
      if (tx.Flags == null) {
        tx.Flags = 0;
        return;
      }
      if (typeof tx.Flags === "number") {
        return;
      }
      tx.Flags = txToFlag[tx.TransactionType]
        ? convertFlagsToNumber(tx.Flags, txToFlag[tx.TransactionType])
        : 0;
    }
    exports2.setTransactionFlagsToNumber = setTransactionFlagsToNumber;
    function convertFlagsToNumber(flags, flagEnum) {
      return Object.keys(flags).reduce((resultFlags, flag) => {
        if (flagEnum[flag] == null) {
          throw new errors_1.ValidationError(
            `flag ${flag} doesn't exist in flagEnum: ${JSON.stringify(
              flagEnum
            )}`
          );
        }
        return flags[flag] ? resultFlags | flagEnum[flag] : resultFlags;
      }, 0);
    }
  },
});

// node_modules/xrpl/dist/npm/sugar/submit.js
var require_submit = __commonJS({
  "node_modules/xrpl/dist/npm/sugar/submit.js"(exports2) {
    "use strict";
    var __awaiter =
      (exports2 && exports2.__awaiter) ||
      function (thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P
            ? value
            : new P(function (resolve) {
                resolve(value);
              });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done
              ? resolve(result.value)
              : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getLastLedgerSequence =
      exports2.getSignedTx =
      exports2.waitForFinalTransactionOutcome =
      exports2.submitRequest =
        void 0;
    var ripple_binary_codec_1 = require_dist2();
    var errors_1 = require_errors();
    var LEDGER_CLOSE_TIME = 1e3;
    function sleep(ms) {
      return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve) => {
          setTimeout(resolve, ms);
        });
      });
    }
    function submitRequest(client, signedTransaction, failHard = false) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!isSigned(signedTransaction)) {
          throw new errors_1.ValidationError("Transaction must be signed");
        }
        const signedTxEncoded =
          typeof signedTransaction === "string"
            ? signedTransaction
            : (0, ripple_binary_codec_1.encode)(signedTransaction);
        const request = {
          command: "submit",
          tx_blob: signedTxEncoded,
          fail_hard: isAccountDelete(signedTransaction) || failHard,
        };
        return client.request(request);
      });
    }
    exports2.submitRequest = submitRequest;
    function waitForFinalTransactionOutcome(
      client,
      txHash,
      lastLedger,
      submissionResult
    ) {
      return __awaiter(this, void 0, void 0, function* () {
        yield sleep(LEDGER_CLOSE_TIME);
        const latestLedger = yield client.getLedgerIndex();
        if (lastLedger < latestLedger) {
          throw new errors_1.XrplError(`The latest ledger sequence ${latestLedger} is greater than the transaction's LastLedgerSequence (${lastLedger}).
Preliminary result: ${submissionResult}`);
        }
        const txResponse = yield client
          .request({
            command: "tx",
            transaction: txHash,
          })
          .catch((error) =>
            __awaiter(this, void 0, void 0, function* () {
              var _a;
              const message =
                (_a =
                  error === null || error === void 0 ? void 0 : error.data) ===
                  null || _a === void 0
                  ? void 0
                  : _a.error;
              if (message === "txnNotFound") {
                return waitForFinalTransactionOutcome(
                  client,
                  txHash,
                  lastLedger,
                  submissionResult
                );
              }
              throw new Error(`${message} 
 Preliminary result: ${submissionResult}.
Full error details: ${String(error)}`);
            })
          );
        if (txResponse.result.validated) {
          return txResponse;
        }
        return waitForFinalTransactionOutcome(
          client,
          txHash,
          lastLedger,
          submissionResult
        );
      });
    }
    exports2.waitForFinalTransactionOutcome = waitForFinalTransactionOutcome;
    function isSigned(transaction) {
      const tx =
        typeof transaction === "string"
          ? (0, ripple_binary_codec_1.decode)(transaction)
          : transaction;
      if (typeof tx === "string") {
        return false;
      }
      if (tx.Signers != null) {
        const signers = tx.Signers;
        for (const signer of signers) {
          if (
            signer.Signer.SigningPubKey == null ||
            signer.Signer.TxnSignature == null
          ) {
            return false;
          }
        }
        return true;
      }
      return tx.SigningPubKey != null && tx.TxnSignature != null;
    }
    function getSignedTx(
      client,
      transaction,
      { autofill = true, wallet } = {}
    ) {
      return __awaiter(this, void 0, void 0, function* () {
        if (isSigned(transaction)) {
          return transaction;
        }
        if (!wallet) {
          throw new errors_1.ValidationError(
            "Wallet must be provided when submitting an unsigned transaction"
          );
        }
        let tx =
          typeof transaction === "string"
            ? (0, ripple_binary_codec_1.decode)(transaction)
            : transaction;
        if (autofill) {
          tx = yield client.autofill(tx);
        }
        return wallet.sign(tx).tx_blob;
      });
    }
    exports2.getSignedTx = getSignedTx;
    function getLastLedgerSequence(transaction) {
      const tx =
        typeof transaction === "string"
          ? (0, ripple_binary_codec_1.decode)(transaction)
          : transaction;
      return tx.LastLedgerSequence;
    }
    exports2.getLastLedgerSequence = getLastLedgerSequence;
    function isAccountDelete(transaction) {
      const tx =
        typeof transaction === "string"
          ? (0, ripple_binary_codec_1.decode)(transaction)
          : transaction;
      return tx.TransactionType === "AccountDelete";
    }
  },
});

// node_modules/xrpl/dist/npm/sugar/utils.js
var require_utils6 = __commonJS({
  "node_modules/xrpl/dist/npm/sugar/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ensureClassicAddress = void 0;
    var ripple_address_codec_1 = require_dist();
    function ensureClassicAddress(account) {
      if ((0, ripple_address_codec_1.isValidXAddress)(account)) {
        const { classicAddress, tag } = (0,
        ripple_address_codec_1.xAddressToClassicAddress)(account);
        if (tag !== false) {
          throw new Error(
            "This command does not support the use of a tag. Use an address without a tag."
          );
        }
        return classicAddress;
      }
      return account;
    }
    exports2.ensureClassicAddress = ensureClassicAddress;
  },
});

// node_modules/xrpl/dist/npm/sugar/index.js
var require_sugar = __commonJS({
  "node_modules/xrpl/dist/npm/sugar/index.js"(exports2) {
    "use strict";
    var __createBinding =
      (exports2 && exports2.__createBinding) ||
      (Object.create
        ? function (o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);
            if (
              !desc ||
              ("get" in desc
                ? !m.__esModule
                : desc.writable || desc.configurable)
            ) {
              desc = {
                enumerable: true,
                get: function () {
                  return m[k];
                },
              };
            }
            Object.defineProperty(o, k2, desc);
          }
        : function (o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            o[k2] = m[k];
          });
    var __exportStar =
      (exports2 && exports2.__exportStar) ||
      function (m, exports3) {
        for (var p in m)
          if (
            p !== "default" &&
            !Object.prototype.hasOwnProperty.call(exports3, p)
          )
            __createBinding(exports3, m, p);
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_submit(), exports2);
    __exportStar(require_utils6(), exports2);
  },
});

// node_modules/@xrplf/isomorphic/dist/ripemd160/index.js
var require_ripemd160 = __commonJS({
  "node_modules/@xrplf/isomorphic/dist/ripemd160/index.js"(exports2) {
    "use strict";
    var __importDefault =
      (exports2 && exports2.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ripemd160 = void 0;
    var crypto_1 = require("crypto");
    var wrapCryptoCreateHash_1 = __importDefault(
      require_wrapCryptoCreateHash()
    );
    exports2.ripemd160 = (0, wrapCryptoCreateHash_1.default)(
      "ripemd160",
      crypto_1.createHash
    );
  },
});

// node_modules/@noble/hashes/_md.js
var require_md = __commonJS({
  "node_modules/@noble/hashes/_md.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SHA512_IV =
      exports2.SHA384_IV =
      exports2.SHA224_IV =
      exports2.SHA256_IV =
      exports2.HashMD =
        void 0;
    exports2.setBigUint64 = setBigUint64;
    exports2.Chi = Chi;
    exports2.Maj = Maj;
    var utils_ts_1 = require_utils();
    function setBigUint64(view, byteOffset, value, isLE) {
      if (typeof view.setBigUint64 === "function")
        return view.setBigUint64(byteOffset, value, isLE);
      const _32n = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number((value >> _32n) & _u32_max);
      const wl = Number(value & _u32_max);
      const h = isLE ? 4 : 0;
      const l = isLE ? 0 : 4;
      view.setUint32(byteOffset + h, wh, isLE);
      view.setUint32(byteOffset + l, wl, isLE);
    }
    function Chi(a, b, c) {
      return (a & b) ^ (~a & c);
    }
    function Maj(a, b, c) {
      return (a & b) ^ (a & c) ^ (b & c);
    }
    var HashMD = class extends utils_ts_1.Hash {
      constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_ts_1.createView)(this.buffer);
      }
      update(data) {
        (0, utils_ts_1.aexists)(this);
        data = (0, utils_ts_1.toBytes)(data);
        (0, utils_ts_1.abytes)(data);
        const { view, buffer, blockLen } = this;
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = (0, utils_ts_1.createView)(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        (0, utils_ts_1.aexists)(this);
        (0, utils_ts_1.aoutput)(out, this);
        this.finished = true;
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        buffer[pos++] = 128;
        (0, utils_ts_1.clean)(this.buffer.subarray(pos));
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i = pos; i < blockLen; i++) buffer[i] = 0;
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_ts_1.createView)(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.destroyed = destroyed;
        to.finished = finished;
        to.length = length;
        to.pos = pos;
        if (length % blockLen) to.buffer.set(buffer);
        return to;
      }
      clone() {
        return this._cloneInto();
      }
    };
    exports2.HashMD = HashMD;
    exports2.SHA256_IV = Uint32Array.from([
      1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924,
      528734635, 1541459225,
    ]);
    exports2.SHA224_IV = Uint32Array.from([
      3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025,
      1694076839, 3204075428,
    ]);
    exports2.SHA384_IV = Uint32Array.from([
      3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999,
      355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025,
      3675008525, 1694076839, 1203062813, 3204075428,
    ]);
    exports2.SHA512_IV = Uint32Array.from([
      1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723,
      2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199,
      528734635, 4215389547, 1541459225, 327033209,
    ]);
  },
});

// node_modules/@noble/hashes/_u64.js
var require_u64 = __commonJS({
  "node_modules/@noble/hashes/_u64.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toBig =
      exports2.shrSL =
      exports2.shrSH =
      exports2.rotrSL =
      exports2.rotrSH =
      exports2.rotrBL =
      exports2.rotrBH =
      exports2.rotr32L =
      exports2.rotr32H =
      exports2.rotlSL =
      exports2.rotlSH =
      exports2.rotlBL =
      exports2.rotlBH =
      exports2.add5L =
      exports2.add5H =
      exports2.add4L =
      exports2.add4H =
      exports2.add3L =
      exports2.add3H =
        void 0;
    exports2.add = add;
    exports2.fromBig = fromBig;
    exports2.split = split;
    var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
    var _32n = /* @__PURE__ */ BigInt(32);
    function fromBig(n, le = false) {
      if (le)
        return {
          h: Number(n & U32_MASK64),
          l: Number((n >> _32n) & U32_MASK64),
        };
      return {
        h: Number((n >> _32n) & U32_MASK64) | 0,
        l: Number(n & U32_MASK64) | 0,
      };
    }
    function split(lst, le = false) {
      const len = lst.length;
      let Ah = new Uint32Array(len);
      let Al = new Uint32Array(len);
      for (let i = 0; i < len; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
      }
      return [Ah, Al];
    }
    var toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);
    exports2.toBig = toBig;
    var shrSH = (h, _l, s) => h >>> s;
    exports2.shrSH = shrSH;
    var shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
    exports2.shrSL = shrSL;
    var rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));
    exports2.rotrSH = rotrSH;
    var rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
    exports2.rotrSL = rotrSL;
    var rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));
    exports2.rotrBH = rotrBH;
    var rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));
    exports2.rotrBL = rotrBL;
    var rotr32H = (_h, l) => l;
    exports2.rotr32H = rotr32H;
    var rotr32L = (h, _l) => h;
    exports2.rotr32L = rotr32L;
    var rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));
    exports2.rotlSH = rotlSH;
    var rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));
    exports2.rotlSL = rotlSL;
    var rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));
    exports2.rotlBH = rotlBH;
    var rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));
    exports2.rotlBL = rotlBL;
    function add(Ah, Al, Bh, Bl) {
      const l = (Al >>> 0) + (Bl >>> 0);
      return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };
    }
    var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
    exports2.add3L = add3L;
    var add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;
    exports2.add3H = add3H;
    var add4L = (Al, Bl, Cl, Dl) =>
      (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
    exports2.add4L = add4L;
    var add4H = (low, Ah, Bh, Ch, Dh) =>
      (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;
    exports2.add4H = add4H;
    var add5L = (Al, Bl, Cl, Dl, El) =>
      (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
    exports2.add5L = add5L;
    var add5H = (low, Ah, Bh, Ch, Dh, Eh) =>
      (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;
    exports2.add5H = add5H;
    var u64 = {
      fromBig,
      split,
      toBig,
      shrSH,
      shrSL,
      rotrSH,
      rotrSL,
      rotrBH,
      rotrBL,
      rotr32H,
      rotr32L,
      rotlSH,
      rotlSL,
      rotlBH,
      rotlBL,
      add,
      add3L,
      add3H,
      add4L,
      add4H,
      add5H,
      add5L,
    };
    exports2.default = u64;
  },
});

// node_modules/@noble/hashes/sha2.js
var require_sha2 = __commonJS({
  "node_modules/@noble/hashes/sha2.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sha512_224 =
      exports2.sha512_256 =
      exports2.sha384 =
      exports2.sha512 =
      exports2.sha224 =
      exports2.sha256 =
      exports2.SHA512_256 =
      exports2.SHA512_224 =
      exports2.SHA384 =
      exports2.SHA512 =
      exports2.SHA224 =
      exports2.SHA256 =
        void 0;
    var _md_ts_1 = require_md();
    var u64 = require_u64();
    var utils_ts_1 = require_utils();
    var SHA256_K = /* @__PURE__ */ Uint32Array.from([
      1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993,
      2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987,
      1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774,
      264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
      2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711,
      113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291,
      1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
      3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
      430227734, 506948616, 659060556, 883997877, 958139571, 1322822218,
      1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424,
      2428436474, 2756734187, 3204031479, 3329325298,
    ]);
    var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
    var SHA256 = class extends _md_ts_1.HashMD {
      constructor(outputLen = 32) {
        super(64, outputLen, 8, false);
        this.A = _md_ts_1.SHA256_IV[0] | 0;
        this.B = _md_ts_1.SHA256_IV[1] | 0;
        this.C = _md_ts_1.SHA256_IV[2] | 0;
        this.D = _md_ts_1.SHA256_IV[3] | 0;
        this.E = _md_ts_1.SHA256_IV[4] | 0;
        this.F = _md_ts_1.SHA256_IV[5] | 0;
        this.G = _md_ts_1.SHA256_IV[6] | 0;
        this.H = _md_ts_1.SHA256_IV[7] | 0;
      }
      get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
      }
      // prettier-ignore
      set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
          const W15 = SHA256_W[i - 15];
          const W2 = SHA256_W[i - 2];
          const s0 =
            (0, utils_ts_1.rotr)(W15, 7) ^
            (0, utils_ts_1.rotr)(W15, 18) ^
            (W15 >>> 3);
          const s1 =
            (0, utils_ts_1.rotr)(W2, 17) ^
            (0, utils_ts_1.rotr)(W2, 19) ^
            (W2 >>> 10);
          SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;
        }
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
          const sigma1 =
            (0, utils_ts_1.rotr)(E, 6) ^
            (0, utils_ts_1.rotr)(E, 11) ^
            (0, utils_ts_1.rotr)(E, 25);
          const T1 =
            (H +
              sigma1 +
              (0, _md_ts_1.Chi)(E, F, G) +
              SHA256_K[i] +
              SHA256_W[i]) |
            0;
          const sigma0 =
            (0, utils_ts_1.rotr)(A, 2) ^
            (0, utils_ts_1.rotr)(A, 13) ^
            (0, utils_ts_1.rotr)(A, 22);
          const T2 = (sigma0 + (0, _md_ts_1.Maj)(A, B, C)) | 0;
          H = G;
          G = F;
          F = E;
          E = (D + T1) | 0;
          D = C;
          C = B;
          B = A;
          A = (T1 + T2) | 0;
        }
        A = (A + this.A) | 0;
        B = (B + this.B) | 0;
        C = (C + this.C) | 0;
        D = (D + this.D) | 0;
        E = (E + this.E) | 0;
        F = (F + this.F) | 0;
        G = (G + this.G) | 0;
        H = (H + this.H) | 0;
        this.set(A, B, C, D, E, F, G, H);
      }
      roundClean() {
        (0, utils_ts_1.clean)(SHA256_W);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        (0, utils_ts_1.clean)(this.buffer);
      }
    };
    exports2.SHA256 = SHA256;
    var SHA224 = class extends SHA256 {
      constructor() {
        super(28);
        this.A = _md_ts_1.SHA224_IV[0] | 0;
        this.B = _md_ts_1.SHA224_IV[1] | 0;
        this.C = _md_ts_1.SHA224_IV[2] | 0;
        this.D = _md_ts_1.SHA224_IV[3] | 0;
        this.E = _md_ts_1.SHA224_IV[4] | 0;
        this.F = _md_ts_1.SHA224_IV[5] | 0;
        this.G = _md_ts_1.SHA224_IV[6] | 0;
        this.H = _md_ts_1.SHA224_IV[7] | 0;
      }
    };
    exports2.SHA224 = SHA224;
    var K512 = /* @__PURE__ */ (() =>
      u64.split(
        [
          "0x428a2f98d728ae22",
          "0x7137449123ef65cd",
          "0xb5c0fbcfec4d3b2f",
          "0xe9b5dba58189dbbc",
          "0x3956c25bf348b538",
          "0x59f111f1b605d019",
          "0x923f82a4af194f9b",
          "0xab1c5ed5da6d8118",
          "0xd807aa98a3030242",
          "0x12835b0145706fbe",
          "0x243185be4ee4b28c",
          "0x550c7dc3d5ffb4e2",
          "0x72be5d74f27b896f",
          "0x80deb1fe3b1696b1",
          "0x9bdc06a725c71235",
          "0xc19bf174cf692694",
          "0xe49b69c19ef14ad2",
          "0xefbe4786384f25e3",
          "0x0fc19dc68b8cd5b5",
          "0x240ca1cc77ac9c65",
          "0x2de92c6f592b0275",
          "0x4a7484aa6ea6e483",
          "0x5cb0a9dcbd41fbd4",
          "0x76f988da831153b5",
          "0x983e5152ee66dfab",
          "0xa831c66d2db43210",
          "0xb00327c898fb213f",
          "0xbf597fc7beef0ee4",
          "0xc6e00bf33da88fc2",
          "0xd5a79147930aa725",
          "0x06ca6351e003826f",
          "0x142929670a0e6e70",
          "0x27b70a8546d22ffc",
          "0x2e1b21385c26c926",
          "0x4d2c6dfc5ac42aed",
          "0x53380d139d95b3df",
          "0x650a73548baf63de",
          "0x766a0abb3c77b2a8",
          "0x81c2c92e47edaee6",
          "0x92722c851482353b",
          "0xa2bfe8a14cf10364",
          "0xa81a664bbc423001",
          "0xc24b8b70d0f89791",
          "0xc76c51a30654be30",
          "0xd192e819d6ef5218",
          "0xd69906245565a910",
          "0xf40e35855771202a",
          "0x106aa07032bbd1b8",
          "0x19a4c116b8d2d0c8",
          "0x1e376c085141ab53",
          "0x2748774cdf8eeb99",
          "0x34b0bcb5e19b48a8",
          "0x391c0cb3c5c95a63",
          "0x4ed8aa4ae3418acb",
          "0x5b9cca4f7763e373",
          "0x682e6ff3d6b2b8a3",
          "0x748f82ee5defb2fc",
          "0x78a5636f43172f60",
          "0x84c87814a1f0ab72",
          "0x8cc702081a6439ec",
          "0x90befffa23631e28",
          "0xa4506cebde82bde9",
          "0xbef9a3f7b2c67915",
          "0xc67178f2e372532b",
          "0xca273eceea26619c",
          "0xd186b8c721c0c207",
          "0xeada7dd6cde0eb1e",
          "0xf57d4f7fee6ed178",
          "0x06f067aa72176fba",
          "0x0a637dc5a2c898a6",
          "0x113f9804bef90dae",
          "0x1b710b35131c471b",
          "0x28db77f523047d84",
          "0x32caab7b40c72493",
          "0x3c9ebe0a15c9bebc",
          "0x431d67c49c100d4c",
          "0x4cc5d4becb3e42b6",
          "0x597f299cfc657e2a",
          "0x5fcb6fab3ad6faec",
          "0x6c44198c4a475817",
        ].map((n) => BigInt(n))
      ))();
    var SHA512_Kh = /* @__PURE__ */ (() => K512[0])();
    var SHA512_Kl = /* @__PURE__ */ (() => K512[1])();
    var SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
    var SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
    var SHA512 = class extends _md_ts_1.HashMD {
      constructor(outputLen = 64) {
        super(128, outputLen, 16, false);
        this.Ah = _md_ts_1.SHA512_IV[0] | 0;
        this.Al = _md_ts_1.SHA512_IV[1] | 0;
        this.Bh = _md_ts_1.SHA512_IV[2] | 0;
        this.Bl = _md_ts_1.SHA512_IV[3] | 0;
        this.Ch = _md_ts_1.SHA512_IV[4] | 0;
        this.Cl = _md_ts_1.SHA512_IV[5] | 0;
        this.Dh = _md_ts_1.SHA512_IV[6] | 0;
        this.Dl = _md_ts_1.SHA512_IV[7] | 0;
        this.Eh = _md_ts_1.SHA512_IV[8] | 0;
        this.El = _md_ts_1.SHA512_IV[9] | 0;
        this.Fh = _md_ts_1.SHA512_IV[10] | 0;
        this.Fl = _md_ts_1.SHA512_IV[11] | 0;
        this.Gh = _md_ts_1.SHA512_IV[12] | 0;
        this.Gl = _md_ts_1.SHA512_IV[13] | 0;
        this.Hh = _md_ts_1.SHA512_IV[14] | 0;
        this.Hl = _md_ts_1.SHA512_IV[15] | 0;
      }
      // prettier-ignore
      get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
      }
      // prettier-ignore
      set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4) {
          SHA512_W_H[i] = view.getUint32(offset);
          SHA512_W_L[i] = view.getUint32((offset += 4));
        }
        for (let i = 16; i < 80; i++) {
          const W15h = SHA512_W_H[i - 15] | 0;
          const W15l = SHA512_W_L[i - 15] | 0;
          const s0h =
            u64.rotrSH(W15h, W15l, 1) ^
            u64.rotrSH(W15h, W15l, 8) ^
            u64.shrSH(W15h, W15l, 7);
          const s0l =
            u64.rotrSL(W15h, W15l, 1) ^
            u64.rotrSL(W15h, W15l, 8) ^
            u64.shrSL(W15h, W15l, 7);
          const W2h = SHA512_W_H[i - 2] | 0;
          const W2l = SHA512_W_L[i - 2] | 0;
          const s1h =
            u64.rotrSH(W2h, W2l, 19) ^
            u64.rotrBH(W2h, W2l, 61) ^
            u64.shrSH(W2h, W2l, 6);
          const s1l =
            u64.rotrSL(W2h, W2l, 19) ^
            u64.rotrBL(W2h, W2l, 61) ^
            u64.shrSL(W2h, W2l, 6);
          const SUMl = u64.add4L(
            s0l,
            s1l,
            SHA512_W_L[i - 7],
            SHA512_W_L[i - 16]
          );
          const SUMh = u64.add4H(
            SUMl,
            s0h,
            s1h,
            SHA512_W_H[i - 7],
            SHA512_W_H[i - 16]
          );
          SHA512_W_H[i] = SUMh | 0;
          SHA512_W_L[i] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } =
          this;
        for (let i = 0; i < 80; i++) {
          const sigma1h =
            u64.rotrSH(Eh, El, 14) ^
            u64.rotrSH(Eh, El, 18) ^
            u64.rotrBH(Eh, El, 41);
          const sigma1l =
            u64.rotrSL(Eh, El, 14) ^
            u64.rotrSL(Eh, El, 18) ^
            u64.rotrBL(Eh, El, 41);
          const CHIh = (Eh & Fh) ^ (~Eh & Gh);
          const CHIl = (El & Fl) ^ (~El & Gl);
          const T1ll = u64.add5L(
            Hl,
            sigma1l,
            CHIl,
            SHA512_Kl[i],
            SHA512_W_L[i]
          );
          const T1h = u64.add5H(
            T1ll,
            Hh,
            sigma1h,
            CHIh,
            SHA512_Kh[i],
            SHA512_W_H[i]
          );
          const T1l = T1ll | 0;
          const sigma0h =
            u64.rotrSH(Ah, Al, 28) ^
            u64.rotrBH(Ah, Al, 34) ^
            u64.rotrBH(Ah, Al, 39);
          const sigma0l =
            u64.rotrSL(Ah, Al, 28) ^
            u64.rotrBL(Ah, Al, 34) ^
            u64.rotrBL(Ah, Al, 39);
          const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);
          const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);
          Hh = Gh | 0;
          Hl = Gl | 0;
          Gh = Fh | 0;
          Gl = Fl | 0;
          Fh = Eh | 0;
          Fl = El | 0;
          ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
          Dh = Ch | 0;
          Dl = Cl | 0;
          Ch = Bh | 0;
          Cl = Bl | 0;
          Bh = Ah | 0;
          Bl = Al | 0;
          const All = u64.add3L(T1l, sigma0l, MAJl);
          Ah = u64.add3H(All, T1h, sigma0h, MAJh);
          Al = All | 0;
        }
        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(
          Ah,
          Al,
          Bh,
          Bl,
          Ch,
          Cl,
          Dh,
          Dl,
          Eh,
          El,
          Fh,
          Fl,
          Gh,
          Gl,
          Hh,
          Hl
        );
      }
      roundClean() {
        (0, utils_ts_1.clean)(SHA512_W_H, SHA512_W_L);
      }
      destroy() {
        (0, utils_ts_1.clean)(this.buffer);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      }
    };
    exports2.SHA512 = SHA512;
    var SHA384 = class extends SHA512 {
      constructor() {
        super(48);
        this.Ah = _md_ts_1.SHA384_IV[0] | 0;
        this.Al = _md_ts_1.SHA384_IV[1] | 0;
        this.Bh = _md_ts_1.SHA384_IV[2] | 0;
        this.Bl = _md_ts_1.SHA384_IV[3] | 0;
        this.Ch = _md_ts_1.SHA384_IV[4] | 0;
        this.Cl = _md_ts_1.SHA384_IV[5] | 0;
        this.Dh = _md_ts_1.SHA384_IV[6] | 0;
        this.Dl = _md_ts_1.SHA384_IV[7] | 0;
        this.Eh = _md_ts_1.SHA384_IV[8] | 0;
        this.El = _md_ts_1.SHA384_IV[9] | 0;
        this.Fh = _md_ts_1.SHA384_IV[10] | 0;
        this.Fl = _md_ts_1.SHA384_IV[11] | 0;
        this.Gh = _md_ts_1.SHA384_IV[12] | 0;
        this.Gl = _md_ts_1.SHA384_IV[13] | 0;
        this.Hh = _md_ts_1.SHA384_IV[14] | 0;
        this.Hl = _md_ts_1.SHA384_IV[15] | 0;
      }
    };
    exports2.SHA384 = SHA384;
    var T224_IV = /* @__PURE__ */ Uint32Array.from([
      2352822216, 424955298, 1944164710, 2312950998, 502970286, 855612546,
      1738396948, 1479516111, 258812777, 2077511080, 2011393907, 79989058,
      1067287976, 1780299464, 286451373, 2446758561,
    ]);
    var T256_IV = /* @__PURE__ */ Uint32Array.from([
      573645204, 4230739756, 2673172387, 3360449730, 596883563, 1867755857,
      2520282905, 1497426621, 2519219938, 2827943907, 3193839141, 1401305490,
      721525244, 746961066, 246885852, 2177182882,
    ]);
    var SHA512_224 = class extends SHA512 {
      constructor() {
        super(28);
        this.Ah = T224_IV[0] | 0;
        this.Al = T224_IV[1] | 0;
        this.Bh = T224_IV[2] | 0;
        this.Bl = T224_IV[3] | 0;
        this.Ch = T224_IV[4] | 0;
        this.Cl = T224_IV[5] | 0;
        this.Dh = T224_IV[6] | 0;
        this.Dl = T224_IV[7] | 0;
        this.Eh = T224_IV[8] | 0;
        this.El = T224_IV[9] | 0;
        this.Fh = T224_IV[10] | 0;
        this.Fl = T224_IV[11] | 0;
        this.Gh = T224_IV[12] | 0;
        this.Gl = T224_IV[13] | 0;
        this.Hh = T224_IV[14] | 0;
        this.Hl = T224_IV[15] | 0;
      }
    };
    exports2.SHA512_224 = SHA512_224;
    var SHA512_256 = class extends SHA512 {
      constructor() {
        super(32);
        this.Ah = T256_IV[0] | 0;
        this.Al = T256_IV[1] | 0;
        this.Bh = T256_IV[2] | 0;
        this.Bl = T256_IV[3] | 0;
        this.Ch = T256_IV[4] | 0;
        this.Cl = T256_IV[5] | 0;
        this.Dh = T256_IV[6] | 0;
        this.Dl = T256_IV[7] | 0;
        this.Eh = T256_IV[8] | 0;
        this.El = T256_IV[9] | 0;
        this.Fh = T256_IV[10] | 0;
        this.Fl = T256_IV[11] | 0;
        this.Gh = T256_IV[12] | 0;
        this.Gl = T256_IV[13] | 0;
        this.Hh = T256_IV[14] | 0;
        this.Hl = T256_IV[15] | 0;
      }
    };
    exports2.SHA512_256 = SHA512_256;
    exports2.sha256 = (0, utils_ts_1.createHasher)(() => new SHA256());
    exports2.sha224 = (0, utils_ts_1.createHasher)(() => new SHA224());
    exports2.sha512 = (0, utils_ts_1.createHasher)(() => new SHA512());
    exports2.sha384 = (0, utils_ts_1.createHasher)(() => new SHA384());
    exports2.sha512_256 = (0, utils_ts_1.createHasher)(() => new SHA512_256());
    exports2.sha512_224 = (0, utils_ts_1.createHasher)(() => new SHA512_224());
  },
});

// node_modules/@noble/hashes/hmac.js
var require_hmac = __commonJS({
  "node_modules/@noble/hashes/hmac.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hmac = exports2.HMAC = void 0;
    var utils_ts_1 = require_utils();
    var HMAC = class extends utils_ts_1.Hash {
      constructor(hash, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        (0, utils_ts_1.ahash)(hash);
        const key = (0, utils_ts_1.toBytes)(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== "function")
          throw new Error(
            "Expected instance of class which extends utils.Hash"
          );
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        pad.set(
          key.length > blockLen ? hash.create().update(key).digest() : key
        );
        for (let i = 0; i < pad.length; i++) pad[i] ^= 54;
        this.iHash.update(pad);
        this.oHash = hash.create();
        for (let i = 0; i < pad.length; i++) pad[i] ^= 54 ^ 92;
        this.oHash.update(pad);
        (0, utils_ts_1.clean)(pad);
      }
      update(buf) {
        (0, utils_ts_1.aexists)(this);
        this.iHash.update(buf);
        return this;
      }
      digestInto(out) {
        (0, utils_ts_1.aexists)(this);
        (0, utils_ts_1.abytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
      }
      digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
      }
      _cloneInto(to) {
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
      }
      clone() {
        return this._cloneInto();
      }
      destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
      }
    };
    exports2.HMAC = HMAC;
    var hmac = (hash, key, message) =>
      new HMAC(hash, key).update(message).digest();
    exports2.hmac = hmac;
    exports2.hmac.create = (hash, key) => new HMAC(hash, key);
  },
});

// node_modules/@noble/curves/utils.js
var require_utils7 = __commonJS({
  "node_modules/@noble/curves/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.notImplemented =
      exports2.bitMask =
      exports2.utf8ToBytes =
      exports2.randomBytes =
      exports2.isBytes =
      exports2.hexToBytes =
      exports2.concatBytes =
      exports2.bytesToUtf8 =
      exports2.bytesToHex =
      exports2.anumber =
      exports2.abytes =
        void 0;
    exports2.abool = abool;
    exports2._abool2 = _abool2;
    exports2._abytes2 = _abytes2;
    exports2.numberToHexUnpadded = numberToHexUnpadded;
    exports2.hexToNumber = hexToNumber;
    exports2.bytesToNumberBE = bytesToNumberBE;
    exports2.bytesToNumberLE = bytesToNumberLE;
    exports2.numberToBytesBE = numberToBytesBE;
    exports2.numberToBytesLE = numberToBytesLE;
    exports2.numberToVarBytesBE = numberToVarBytesBE;
    exports2.ensureBytes = ensureBytes;
    exports2.equalBytes = equalBytes;
    exports2.copyBytes = copyBytes;
    exports2.asciiToBytes = asciiToBytes;
    exports2.inRange = inRange;
    exports2.aInRange = aInRange;
    exports2.bitLen = bitLen;
    exports2.bitGet = bitGet;
    exports2.bitSet = bitSet;
    exports2.createHmacDrbg = createHmacDrbg;
    exports2.validateObject = validateObject;
    exports2.isHash = isHash;
    exports2._validateObject = _validateObject;
    exports2.memoized = memoized;
    var utils_js_1 = require_utils();
    var utils_js_2 = require_utils();
    Object.defineProperty(exports2, "abytes", {
      enumerable: true,
      get: function () {
        return utils_js_2.abytes;
      },
    });
    Object.defineProperty(exports2, "anumber", {
      enumerable: true,
      get: function () {
        return utils_js_2.anumber;
      },
    });
    Object.defineProperty(exports2, "bytesToHex", {
      enumerable: true,
      get: function () {
        return utils_js_2.bytesToHex;
      },
    });
    Object.defineProperty(exports2, "bytesToUtf8", {
      enumerable: true,
      get: function () {
        return utils_js_2.bytesToUtf8;
      },
    });
    Object.defineProperty(exports2, "concatBytes", {
      enumerable: true,
      get: function () {
        return utils_js_2.concatBytes;
      },
    });
    Object.defineProperty(exports2, "hexToBytes", {
      enumerable: true,
      get: function () {
        return utils_js_2.hexToBytes;
      },
    });
    Object.defineProperty(exports2, "isBytes", {
      enumerable: true,
      get: function () {
        return utils_js_2.isBytes;
      },
    });
    Object.defineProperty(exports2, "randomBytes", {
      enumerable: true,
      get: function () {
        return utils_js_2.randomBytes;
      },
    });
    Object.defineProperty(exports2, "utf8ToBytes", {
      enumerable: true,
      get: function () {
        return utils_js_2.utf8ToBytes;
      },
    });
    var _0n = /* @__PURE__ */ BigInt(0);
    var _1n = /* @__PURE__ */ BigInt(1);
    function abool(title, value) {
      if (typeof value !== "boolean")
        throw new Error(title + " boolean expected, got " + value);
    }
    function _abool2(value, title = "") {
      if (typeof value !== "boolean") {
        const prefix = title && `"${title}"`;
        throw new Error(prefix + "expected boolean, got type=" + typeof value);
      }
      return value;
    }
    function _abytes2(value, length, title = "") {
      const bytes = (0, utils_js_1.isBytes)(value);
      const len = value?.length;
      const needsLen = length !== void 0;
      if (!bytes || (needsLen && len !== length)) {
        const prefix = title && `"${title}" `;
        const ofLen = needsLen ? ` of length ${length}` : "";
        const got = bytes ? `length=${len}` : `type=${typeof value}`;
        throw new Error(
          prefix + "expected Uint8Array" + ofLen + ", got " + got
        );
      }
      return value;
    }
    function numberToHexUnpadded(num) {
      const hex = num.toString(16);
      return hex.length & 1 ? "0" + hex : hex;
    }
    function hexToNumber(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      return hex === "" ? _0n : BigInt("0x" + hex);
    }
    function bytesToNumberBE(bytes) {
      return hexToNumber((0, utils_js_1.bytesToHex)(bytes));
    }
    function bytesToNumberLE(bytes) {
      (0, utils_js_1.abytes)(bytes);
      return hexToNumber(
        (0, utils_js_1.bytesToHex)(Uint8Array.from(bytes).reverse())
      );
    }
    function numberToBytesBE(n, len) {
      return (0, utils_js_1.hexToBytes)(n.toString(16).padStart(len * 2, "0"));
    }
    function numberToBytesLE(n, len) {
      return numberToBytesBE(n, len).reverse();
    }
    function numberToVarBytesBE(n) {
      return (0, utils_js_1.hexToBytes)(numberToHexUnpadded(n));
    }
    function ensureBytes(title, hex, expectedLength) {
      let res;
      if (typeof hex === "string") {
        try {
          res = (0, utils_js_1.hexToBytes)(hex);
        } catch (e) {
          throw new Error(
            title + " must be hex string or Uint8Array, cause: " + e
          );
        }
      } else if ((0, utils_js_1.isBytes)(hex)) {
        res = Uint8Array.from(hex);
      } else {
        throw new Error(title + " must be hex string or Uint8Array");
      }
      const len = res.length;
      if (typeof expectedLength === "number" && len !== expectedLength)
        throw new Error(
          title + " of length " + expectedLength + " expected, got " + len
        );
      return res;
    }
    function equalBytes(a, b) {
      if (a.length !== b.length) return false;
      let diff = 0;
      for (let i = 0; i < a.length; i++) diff |= a[i] ^ b[i];
      return diff === 0;
    }
    function copyBytes(bytes) {
      return Uint8Array.from(bytes);
    }
    function asciiToBytes(ascii) {
      return Uint8Array.from(ascii, (c, i) => {
        const charCode = c.charCodeAt(0);
        if (c.length !== 1 || charCode > 127) {
          throw new Error(
            `string contains non-ASCII character "${ascii[i]}" with code ${charCode} at position ${i}`
          );
        }
        return charCode;
      });
    }
    var isPosBig = (n) => typeof n === "bigint" && _0n <= n;
    function inRange(n, min, max) {
      return (
        isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max
      );
    }
    function aInRange(title, n, min, max) {
      if (!inRange(n, min, max))
        throw new Error(
          "expected valid " +
            title +
            ": " +
            min +
            " <= n < " +
            max +
            ", got " +
            n
        );
    }
    function bitLen(n) {
      let len;
      for (len = 0; n > _0n; n >>= _1n, len += 1);
      return len;
    }
    function bitGet(n, pos) {
      return (n >> BigInt(pos)) & _1n;
    }
    function bitSet(n, pos, value) {
      return n | ((value ? _1n : _0n) << BigInt(pos));
    }
    var bitMask = (n) => (_1n << BigInt(n)) - _1n;
    exports2.bitMask = bitMask;
    function createHmacDrbg(hashLen, qByteLen, hmacFn) {
      if (typeof hashLen !== "number" || hashLen < 2)
        throw new Error("hashLen must be a number");
      if (typeof qByteLen !== "number" || qByteLen < 2)
        throw new Error("qByteLen must be a number");
      if (typeof hmacFn !== "function")
        throw new Error("hmacFn must be a function");
      const u8n = (len) => new Uint8Array(len);
      const u8of = (byte) => Uint8Array.of(byte);
      let v = u8n(hashLen);
      let k = u8n(hashLen);
      let i = 0;
      const reset = () => {
        v.fill(1);
        k.fill(0);
        i = 0;
      };
      const h = (...b) => hmacFn(k, v, ...b);
      const reseed = (seed = u8n(0)) => {
        k = h(u8of(0), seed);
        v = h();
        if (seed.length === 0) return;
        k = h(u8of(1), seed);
        v = h();
      };
      const gen = () => {
        if (i++ >= 1e3) throw new Error("drbg: tried 1000 values");
        let len = 0;
        const out = [];
        while (len < qByteLen) {
          v = h();
          const sl = v.slice();
          out.push(sl);
          len += v.length;
        }
        return (0, utils_js_1.concatBytes)(...out);
      };
      const genUntil = (seed, pred) => {
        reset();
        reseed(seed);
        let res = void 0;
        while (!(res = pred(gen()))) reseed();
        reset();
        return res;
      };
      return genUntil;
    }
    var validatorFns = {
      bigint: (val) => typeof val === "bigint",
      function: (val) => typeof val === "function",
      boolean: (val) => typeof val === "boolean",
      string: (val) => typeof val === "string",
      stringOrUint8Array: (val) =>
        typeof val === "string" || (0, utils_js_1.isBytes)(val),
      isSafeInteger: (val) => Number.isSafeInteger(val),
      array: (val) => Array.isArray(val),
      field: (val, object) => object.Fp.isValid(val),
      hash: (val) =>
        typeof val === "function" && Number.isSafeInteger(val.outputLen),
    };
    function validateObject(object, validators, optValidators = {}) {
      const checkField = (fieldName, type, isOptional) => {
        const checkVal = validatorFns[type];
        if (typeof checkVal !== "function")
          throw new Error("invalid validator function");
        const val = object[fieldName];
        if (isOptional && val === void 0) return;
        if (!checkVal(val, object)) {
          throw new Error(
            "param " +
              String(fieldName) +
              " is invalid. Expected " +
              type +
              ", got " +
              val
          );
        }
      };
      for (const [fieldName, type] of Object.entries(validators))
        checkField(fieldName, type, false);
      for (const [fieldName, type] of Object.entries(optValidators))
        checkField(fieldName, type, true);
      return object;
    }
    function isHash(val) {
      return typeof val === "function" && Number.isSafeInteger(val.outputLen);
    }
    function _validateObject(object, fields, optFields = {}) {
      if (!object || typeof object !== "object")
        throw new Error("expected valid options object");
      function checkField(fieldName, expectedType, isOpt) {
        const val = object[fieldName];
        if (isOpt && val === void 0) return;
        const current = typeof val;
        if (current !== expectedType || val === null)
          throw new Error(
            `param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`
          );
      }
      Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));
      Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));
    }
    var notImplemented = () => {
      throw new Error("not implemented");
    };
    exports2.notImplemented = notImplemented;
    function memoized(fn) {
      const map = /* @__PURE__ */ new WeakMap();
      return (arg, ...args) => {
        const val = map.get(arg);
        if (val !== void 0) return val;
        const computed = fn(arg, ...args);
        map.set(arg, computed);
        return computed;
      };
    }
  },
});

// node_modules/@noble/curves/abstract/modular.js
var require_modular = __commonJS({
  "node_modules/@noble/curves/abstract/modular.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isNegativeLE = void 0;
    exports2.mod = mod;
    exports2.pow = pow;
    exports2.pow2 = pow2;
    exports2.invert = invert;
    exports2.tonelliShanks = tonelliShanks;
    exports2.FpSqrt = FpSqrt;
    exports2.validateField = validateField;
    exports2.FpPow = FpPow;
    exports2.FpInvertBatch = FpInvertBatch;
    exports2.FpDiv = FpDiv;
    exports2.FpLegendre = FpLegendre;
    exports2.FpIsSquare = FpIsSquare;
    exports2.nLength = nLength;
    exports2.Field = Field;
    exports2.FpSqrtOdd = FpSqrtOdd;
    exports2.FpSqrtEven = FpSqrtEven;
    exports2.hashToPrivateScalar = hashToPrivateScalar;
    exports2.getFieldBytesLength = getFieldBytesLength;
    exports2.getMinHashLength = getMinHashLength;
    exports2.mapHashToField = mapHashToField;
    var utils_ts_1 = require_utils7();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = /* @__PURE__ */ BigInt(2);
    var _3n = /* @__PURE__ */ BigInt(3);
    var _4n = /* @__PURE__ */ BigInt(4);
    var _5n = /* @__PURE__ */ BigInt(5);
    var _7n = /* @__PURE__ */ BigInt(7);
    var _8n = /* @__PURE__ */ BigInt(8);
    var _9n = /* @__PURE__ */ BigInt(9);
    var _16n = /* @__PURE__ */ BigInt(16);
    function mod(a, b) {
      const result = a % b;
      return result >= _0n ? result : b + result;
    }
    function pow(num, power, modulo) {
      return FpPow(Field(modulo), num, power);
    }
    function pow2(x, power, modulo) {
      let res = x;
      while (power-- > _0n) {
        res *= res;
        res %= modulo;
      }
      return res;
    }
    function invert(number, modulo) {
      if (number === _0n) throw new Error("invert: expected non-zero number");
      if (modulo <= _0n)
        throw new Error("invert: expected positive modulus, got " + modulo);
      let a = mod(number, modulo);
      let b = modulo;
      let x = _0n,
        y = _1n,
        u = _1n,
        v = _0n;
      while (a !== _0n) {
        const q = b / a;
        const r = b % a;
        const m = x - u * q;
        const n = y - v * q;
        (b = a), (a = r), (x = u), (y = v), (u = m), (v = n);
      }
      const gcd = b;
      if (gcd !== _1n) throw new Error("invert: does not exist");
      return mod(x, modulo);
    }
    function assertIsSquare(Fp, root, n) {
      if (!Fp.eql(Fp.sqr(root), n)) throw new Error("Cannot find square root");
    }
    function sqrt3mod4(Fp, n) {
      const p1div4 = (Fp.ORDER + _1n) / _4n;
      const root = Fp.pow(n, p1div4);
      assertIsSquare(Fp, root, n);
      return root;
    }
    function sqrt5mod8(Fp, n) {
      const p5div8 = (Fp.ORDER - _5n) / _8n;
      const n2 = Fp.mul(n, _2n);
      const v = Fp.pow(n2, p5div8);
      const nv = Fp.mul(n, v);
      const i = Fp.mul(Fp.mul(nv, _2n), v);
      const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
      assertIsSquare(Fp, root, n);
      return root;
    }
    function sqrt9mod16(P) {
      const Fp_ = Field(P);
      const tn = tonelliShanks(P);
      const c1 = tn(Fp_, Fp_.neg(Fp_.ONE));
      const c2 = tn(Fp_, c1);
      const c3 = tn(Fp_, Fp_.neg(c1));
      const c4 = (P + _7n) / _16n;
      return (Fp, n) => {
        let tv1 = Fp.pow(n, c4);
        let tv2 = Fp.mul(tv1, c1);
        const tv3 = Fp.mul(tv1, c2);
        const tv4 = Fp.mul(tv1, c3);
        const e1 = Fp.eql(Fp.sqr(tv2), n);
        const e2 = Fp.eql(Fp.sqr(tv3), n);
        tv1 = Fp.cmov(tv1, tv2, e1);
        tv2 = Fp.cmov(tv4, tv3, e2);
        const e3 = Fp.eql(Fp.sqr(tv2), n);
        const root = Fp.cmov(tv1, tv2, e3);
        assertIsSquare(Fp, root, n);
        return root;
      };
    }
    function tonelliShanks(P) {
      if (P < _3n) throw new Error("sqrt is not defined for small field");
      let Q = P - _1n;
      let S = 0;
      while (Q % _2n === _0n) {
        Q /= _2n;
        S++;
      }
      let Z = _2n;
      const _Fp = Field(P);
      while (FpLegendre(_Fp, Z) === 1) {
        if (Z++ > 1e3)
          throw new Error("Cannot find square root: probably non-prime P");
      }
      if (S === 1) return sqrt3mod4;
      let cc = _Fp.pow(Z, Q);
      const Q1div2 = (Q + _1n) / _2n;
      return function tonelliSlow(Fp, n) {
        if (Fp.is0(n)) return n;
        if (FpLegendre(Fp, n) !== 1) throw new Error("Cannot find square root");
        let M = S;
        let c = Fp.mul(Fp.ONE, cc);
        let t = Fp.pow(n, Q);
        let R = Fp.pow(n, Q1div2);
        while (!Fp.eql(t, Fp.ONE)) {
          if (Fp.is0(t)) return Fp.ZERO;
          let i = 1;
          let t_tmp = Fp.sqr(t);
          while (!Fp.eql(t_tmp, Fp.ONE)) {
            i++;
            t_tmp = Fp.sqr(t_tmp);
            if (i === M) throw new Error("Cannot find square root");
          }
          const exponent = _1n << BigInt(M - i - 1);
          const b = Fp.pow(c, exponent);
          M = i;
          c = Fp.sqr(b);
          t = Fp.mul(t, c);
          R = Fp.mul(R, b);
        }
        return R;
      };
    }
    function FpSqrt(P) {
      if (P % _4n === _3n) return sqrt3mod4;
      if (P % _8n === _5n) return sqrt5mod8;
      if (P % _16n === _9n) return sqrt9mod16(P);
      return tonelliShanks(P);
    }
    var isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;
    exports2.isNegativeLE = isNegativeLE;
    var FIELD_FIELDS = [
      "create",
      "isValid",
      "is0",
      "neg",
      "inv",
      "sqrt",
      "sqr",
      "eql",
      "add",
      "sub",
      "mul",
      "pow",
      "div",
      "addN",
      "subN",
      "mulN",
      "sqrN",
    ];
    function validateField(field) {
      const initial = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "number",
        BITS: "number",
      };
      const opts = FIELD_FIELDS.reduce((map, val) => {
        map[val] = "function";
        return map;
      }, initial);
      (0, utils_ts_1._validateObject)(field, opts);
      return field;
    }
    function FpPow(Fp, num, power) {
      if (power < _0n)
        throw new Error("invalid exponent, negatives unsupported");
      if (power === _0n) return Fp.ONE;
      if (power === _1n) return num;
      let p = Fp.ONE;
      let d = num;
      while (power > _0n) {
        if (power & _1n) p = Fp.mul(p, d);
        d = Fp.sqr(d);
        power >>= _1n;
      }
      return p;
    }
    function FpInvertBatch(Fp, nums, passZero = false) {
      const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : void 0);
      const multipliedAcc = nums.reduce((acc, num, i) => {
        if (Fp.is0(num)) return acc;
        inverted[i] = acc;
        return Fp.mul(acc, num);
      }, Fp.ONE);
      const invertedAcc = Fp.inv(multipliedAcc);
      nums.reduceRight((acc, num, i) => {
        if (Fp.is0(num)) return acc;
        inverted[i] = Fp.mul(acc, inverted[i]);
        return Fp.mul(acc, num);
      }, invertedAcc);
      return inverted;
    }
    function FpDiv(Fp, lhs, rhs) {
      return Fp.mul(
        lhs,
        typeof rhs === "bigint" ? invert(rhs, Fp.ORDER) : Fp.inv(rhs)
      );
    }
    function FpLegendre(Fp, n) {
      const p1mod2 = (Fp.ORDER - _1n) / _2n;
      const powered = Fp.pow(n, p1mod2);
      const yes = Fp.eql(powered, Fp.ONE);
      const zero = Fp.eql(powered, Fp.ZERO);
      const no = Fp.eql(powered, Fp.neg(Fp.ONE));
      if (!yes && !zero && !no)
        throw new Error("invalid Legendre symbol result");
      return yes ? 1 : zero ? 0 : -1;
    }
    function FpIsSquare(Fp, n) {
      const l = FpLegendre(Fp, n);
      return l === 1;
    }
    function nLength(n, nBitLength) {
      if (nBitLength !== void 0) (0, utils_ts_1.anumber)(nBitLength);
      const _nBitLength =
        nBitLength !== void 0 ? nBitLength : n.toString(2).length;
      const nByteLength = Math.ceil(_nBitLength / 8);
      return { nBitLength: _nBitLength, nByteLength };
    }
    function Field(ORDER, bitLenOrOpts, isLE = false, opts = {}) {
      if (ORDER <= _0n)
        throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
      let _nbitLength = void 0;
      let _sqrt = void 0;
      let modFromBytes = false;
      let allowedLengths = void 0;
      if (typeof bitLenOrOpts === "object" && bitLenOrOpts != null) {
        if (opts.sqrt || isLE)
          throw new Error("cannot specify opts in two arguments");
        const _opts = bitLenOrOpts;
        if (_opts.BITS) _nbitLength = _opts.BITS;
        if (_opts.sqrt) _sqrt = _opts.sqrt;
        if (typeof _opts.isLE === "boolean") isLE = _opts.isLE;
        if (typeof _opts.modFromBytes === "boolean")
          modFromBytes = _opts.modFromBytes;
        allowedLengths = _opts.allowedLengths;
      } else {
        if (typeof bitLenOrOpts === "number") _nbitLength = bitLenOrOpts;
        if (opts.sqrt) _sqrt = opts.sqrt;
      }
      const { nBitLength: BITS, nByteLength: BYTES } = nLength(
        ORDER,
        _nbitLength
      );
      if (BYTES > 2048)
        throw new Error("invalid field: expected ORDER of <= 2048 bytes");
      let sqrtP;
      const f = Object.freeze({
        ORDER,
        isLE,
        BITS,
        BYTES,
        MASK: (0, utils_ts_1.bitMask)(BITS),
        ZERO: _0n,
        ONE: _1n,
        allowedLengths,
        create: (num) => mod(num, ORDER),
        isValid: (num) => {
          if (typeof num !== "bigint")
            throw new Error(
              "invalid field element: expected bigint, got " + typeof num
            );
          return _0n <= num && num < ORDER;
        },
        is0: (num) => num === _0n,
        // is valid and invertible
        isValidNot0: (num) => !f.is0(num) && f.isValid(num),
        isOdd: (num) => (num & _1n) === _1n,
        neg: (num) => mod(-num, ORDER),
        eql: (lhs, rhs) => lhs === rhs,
        sqr: (num) => mod(num * num, ORDER),
        add: (lhs, rhs) => mod(lhs + rhs, ORDER),
        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
        pow: (num, power) => FpPow(f, num, power),
        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
        // Same as above, but doesn't normalize
        sqrN: (num) => num * num,
        addN: (lhs, rhs) => lhs + rhs,
        subN: (lhs, rhs) => lhs - rhs,
        mulN: (lhs, rhs) => lhs * rhs,
        inv: (num) => invert(num, ORDER),
        sqrt:
          _sqrt ||
          ((n) => {
            if (!sqrtP) sqrtP = FpSqrt(ORDER);
            return sqrtP(f, n);
          }),
        toBytes: (num) =>
          isLE
            ? (0, utils_ts_1.numberToBytesLE)(num, BYTES)
            : (0, utils_ts_1.numberToBytesBE)(num, BYTES),
        fromBytes: (bytes, skipValidation = true) => {
          if (allowedLengths) {
            if (
              !allowedLengths.includes(bytes.length) ||
              bytes.length > BYTES
            ) {
              throw new Error(
                "Field.fromBytes: expected " +
                  allowedLengths +
                  " bytes, got " +
                  bytes.length
              );
            }
            const padded = new Uint8Array(BYTES);
            padded.set(bytes, isLE ? 0 : padded.length - bytes.length);
            bytes = padded;
          }
          if (bytes.length !== BYTES)
            throw new Error(
              "Field.fromBytes: expected " +
                BYTES +
                " bytes, got " +
                bytes.length
            );
          let scalar = isLE
            ? (0, utils_ts_1.bytesToNumberLE)(bytes)
            : (0, utils_ts_1.bytesToNumberBE)(bytes);
          if (modFromBytes) scalar = mod(scalar, ORDER);
          if (!skipValidation) {
            if (!f.isValid(scalar))
              throw new Error(
                "invalid field element: outside of range 0..ORDER"
              );
          }
          return scalar;
        },
        // TODO: we don't need it here, move out to separate fn
        invertBatch: (lst) => FpInvertBatch(f, lst),
        // We can't move this out because Fp6, Fp12 implement it
        // and it's unclear what to return in there.
        cmov: (a, b, c) => (c ? b : a),
      });
      return Object.freeze(f);
    }
    function FpSqrtOdd(Fp, elm) {
      if (!Fp.isOdd) throw new Error("Field doesn't have isOdd");
      const root = Fp.sqrt(elm);
      return Fp.isOdd(root) ? root : Fp.neg(root);
    }
    function FpSqrtEven(Fp, elm) {
      if (!Fp.isOdd) throw new Error("Field doesn't have isOdd");
      const root = Fp.sqrt(elm);
      return Fp.isOdd(root) ? Fp.neg(root) : root;
    }
    function hashToPrivateScalar(hash, groupOrder, isLE = false) {
      hash = (0, utils_ts_1.ensureBytes)("privateHash", hash);
      const hashLen = hash.length;
      const minLen = nLength(groupOrder).nByteLength + 8;
      if (minLen < 24 || hashLen < minLen || hashLen > 1024)
        throw new Error(
          "hashToPrivateScalar: expected " +
            minLen +
            "-1024 bytes of input, got " +
            hashLen
        );
      const num = isLE
        ? (0, utils_ts_1.bytesToNumberLE)(hash)
        : (0, utils_ts_1.bytesToNumberBE)(hash);
      return mod(num, groupOrder - _1n) + _1n;
    }
    function getFieldBytesLength(fieldOrder) {
      if (typeof fieldOrder !== "bigint")
        throw new Error("field order must be bigint");
      const bitLength = fieldOrder.toString(2).length;
      return Math.ceil(bitLength / 8);
    }
    function getMinHashLength(fieldOrder) {
      const length = getFieldBytesLength(fieldOrder);
      return length + Math.ceil(length / 2);
    }
    function mapHashToField(key, fieldOrder, isLE = false) {
      const len = key.length;
      const fieldLen = getFieldBytesLength(fieldOrder);
      const minLen = getMinHashLength(fieldOrder);
      if (len < 16 || len < minLen || len > 1024)
        throw new Error(
          "expected " + minLen + "-1024 bytes of input, got " + len
        );
      const num = isLE
        ? (0, utils_ts_1.bytesToNumberLE)(key)
        : (0, utils_ts_1.bytesToNumberBE)(key);
      const reduced = mod(num, fieldOrder - _1n) + _1n;
      return isLE
        ? (0, utils_ts_1.numberToBytesLE)(reduced, fieldLen)
        : (0, utils_ts_1.numberToBytesBE)(reduced, fieldLen);
    }
  },
});

// node_modules/@noble/curves/abstract/curve.js
var require_curve = __commonJS({
  "node_modules/@noble/curves/abstract/curve.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.wNAF = void 0;
    exports2.negateCt = negateCt;
    exports2.normalizeZ = normalizeZ;
    exports2.mulEndoUnsafe = mulEndoUnsafe;
    exports2.pippenger = pippenger;
    exports2.precomputeMSMUnsafe = precomputeMSMUnsafe;
    exports2.validateBasic = validateBasic;
    exports2._createCurveFields = _createCurveFields;
    var utils_ts_1 = require_utils7();
    var modular_ts_1 = require_modular();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    function negateCt(condition, item) {
      const neg = item.negate();
      return condition ? neg : item;
    }
    function normalizeZ(c, points) {
      const invertedZs = (0, modular_ts_1.FpInvertBatch)(
        c.Fp,
        points.map((p) => p.Z)
      );
      return points.map((p, i) => c.fromAffine(p.toAffine(invertedZs[i])));
    }
    function validateW(W, bits) {
      if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
        throw new Error(
          "invalid window size, expected [1.." + bits + "], got W=" + W
        );
    }
    function calcWOpts(W, scalarBits) {
      validateW(W, scalarBits);
      const windows = Math.ceil(scalarBits / W) + 1;
      const windowSize = 2 ** (W - 1);
      const maxNumber = 2 ** W;
      const mask = (0, utils_ts_1.bitMask)(W);
      const shiftBy = BigInt(W);
      return { windows, windowSize, mask, maxNumber, shiftBy };
    }
    function calcOffsets(n, window2, wOpts) {
      const { windowSize, mask, maxNumber, shiftBy } = wOpts;
      let wbits = Number(n & mask);
      let nextN = n >> shiftBy;
      if (wbits > windowSize) {
        wbits -= maxNumber;
        nextN += _1n;
      }
      const offsetStart = window2 * windowSize;
      const offset = offsetStart + Math.abs(wbits) - 1;
      const isZero = wbits === 0;
      const isNeg = wbits < 0;
      const isNegF = window2 % 2 !== 0;
      const offsetF = offsetStart;
      return { nextN, offset, isZero, isNeg, isNegF, offsetF };
    }
    function validateMSMPoints(points, c) {
      if (!Array.isArray(points)) throw new Error("array expected");
      points.forEach((p, i) => {
        if (!(p instanceof c)) throw new Error("invalid point at index " + i);
      });
    }
    function validateMSMScalars(scalars, field) {
      if (!Array.isArray(scalars)) throw new Error("array of scalars expected");
      scalars.forEach((s, i) => {
        if (!field.isValid(s)) throw new Error("invalid scalar at index " + i);
      });
    }
    var pointPrecomputes = /* @__PURE__ */ new WeakMap();
    var pointWindowSizes = /* @__PURE__ */ new WeakMap();
    function getW(P) {
      return pointWindowSizes.get(P) || 1;
    }
    function assert0(n) {
      if (n !== _0n) throw new Error("invalid wNAF");
    }
    var wNAF = class {
      // Parametrized with a given Point class (not individual point)
      constructor(Point, bits) {
        this.BASE = Point.BASE;
        this.ZERO = Point.ZERO;
        this.Fn = Point.Fn;
        this.bits = bits;
      }
      // non-const time multiplication ladder
      _unsafeLadder(elm, n, p = this.ZERO) {
        let d = elm;
        while (n > _0n) {
          if (n & _1n) p = p.add(d);
          d = d.double();
          n >>= _1n;
        }
        return p;
      }
      /**
       * Creates a wNAF precomputation window. Used for caching.
       * Default window size is set by `utils.precompute()` and is equal to 8.
       * Number of precomputed points depends on the curve size:
       * 2^(1) * (Math.ceil( / ) + 1), where:
       * -  is the window size
       * -  is the bitlength of the curve order.
       * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
       * @param point Point instance
       * @param W window size
       * @returns precomputed point tables flattened to a single array
       */
      precomputeWindow(point, W) {
        const { windows, windowSize } = calcWOpts(W, this.bits);
        const points = [];
        let p = point;
        let base = p;
        for (let window2 = 0; window2 < windows; window2++) {
          base = p;
          points.push(base);
          for (let i = 1; i < windowSize; i++) {
            base = base.add(p);
            points.push(base);
          }
          p = base.double();
        }
        return points;
      }
      /**
       * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
       * More compact implementation:
       * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
       * @returns real and fake (for const-time) points
       */
      wNAF(W, precomputes, n) {
        if (!this.Fn.isValid(n)) throw new Error("invalid scalar");
        let p = this.ZERO;
        let f = this.BASE;
        const wo = calcWOpts(W, this.bits);
        for (let window2 = 0; window2 < wo.windows; window2++) {
          const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(
            n,
            window2,
            wo
          );
          n = nextN;
          if (isZero) {
            f = f.add(negateCt(isNegF, precomputes[offsetF]));
          } else {
            p = p.add(negateCt(isNeg, precomputes[offset]));
          }
        }
        assert0(n);
        return { p, f };
      }
      /**
       * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
       * @param acc accumulator point to add result of multiplication
       * @returns point
       */
      wNAFUnsafe(W, precomputes, n, acc = this.ZERO) {
        const wo = calcWOpts(W, this.bits);
        for (let window2 = 0; window2 < wo.windows; window2++) {
          if (n === _0n) break;
          const { nextN, offset, isZero, isNeg } = calcOffsets(n, window2, wo);
          n = nextN;
          if (isZero) {
            continue;
          } else {
            const item = precomputes[offset];
            acc = acc.add(isNeg ? item.negate() : item);
          }
        }
        assert0(n);
        return acc;
      }
      getPrecomputes(W, point, transform) {
        let comp = pointPrecomputes.get(point);
        if (!comp) {
          comp = this.precomputeWindow(point, W);
          if (W !== 1) {
            if (typeof transform === "function") comp = transform(comp);
            pointPrecomputes.set(point, comp);
          }
        }
        return comp;
      }
      cached(point, scalar, transform) {
        const W = getW(point);
        return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);
      }
      unsafe(point, scalar, transform, prev) {
        const W = getW(point);
        if (W === 1) return this._unsafeLadder(point, scalar, prev);
        return this.wNAFUnsafe(
          W,
          this.getPrecomputes(W, point, transform),
          scalar,
          prev
        );
      }
      // We calculate precomputes for elliptic curve point multiplication
      // using windowed method. This specifies window size and
      // stores precomputed values. Usually only base point would be precomputed.
      createCache(P, W) {
        validateW(W, this.bits);
        pointWindowSizes.set(P, W);
        pointPrecomputes.delete(P);
      }
      hasCache(elm) {
        return getW(elm) !== 1;
      }
    };
    exports2.wNAF = wNAF;
    function mulEndoUnsafe(Point, point, k1, k2) {
      let acc = point;
      let p1 = Point.ZERO;
      let p2 = Point.ZERO;
      while (k1 > _0n || k2 > _0n) {
        if (k1 & _1n) p1 = p1.add(acc);
        if (k2 & _1n) p2 = p2.add(acc);
        acc = acc.double();
        k1 >>= _1n;
        k2 >>= _1n;
      }
      return { p1, p2 };
    }
    function pippenger(c, fieldN, points, scalars) {
      validateMSMPoints(points, c);
      validateMSMScalars(scalars, fieldN);
      const plength = points.length;
      const slength = scalars.length;
      if (plength !== slength)
        throw new Error("arrays of points and scalars must have equal length");
      const zero = c.ZERO;
      const wbits = (0, utils_ts_1.bitLen)(BigInt(plength));
      let windowSize = 1;
      if (wbits > 12) windowSize = wbits - 3;
      else if (wbits > 4) windowSize = wbits - 2;
      else if (wbits > 0) windowSize = 2;
      const MASK = (0, utils_ts_1.bitMask)(windowSize);
      const buckets = new Array(Number(MASK) + 1).fill(zero);
      const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
      let sum = zero;
      for (let i = lastBits; i >= 0; i -= windowSize) {
        buckets.fill(zero);
        for (let j = 0; j < slength; j++) {
          const scalar = scalars[j];
          const wbits2 = Number((scalar >> BigInt(i)) & MASK);
          buckets[wbits2] = buckets[wbits2].add(points[j]);
        }
        let resI = zero;
        for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {
          sumI = sumI.add(buckets[j]);
          resI = resI.add(sumI);
        }
        sum = sum.add(resI);
        if (i !== 0) for (let j = 0; j < windowSize; j++) sum = sum.double();
      }
      return sum;
    }
    function precomputeMSMUnsafe(c, fieldN, points, windowSize) {
      validateW(windowSize, fieldN.BITS);
      validateMSMPoints(points, c);
      const zero = c.ZERO;
      const tableSize = 2 ** windowSize - 1;
      const chunks = Math.ceil(fieldN.BITS / windowSize);
      const MASK = (0, utils_ts_1.bitMask)(windowSize);
      const tables = points.map((p) => {
        const res = [];
        for (let i = 0, acc = p; i < tableSize; i++) {
          res.push(acc);
          acc = acc.add(p);
        }
        return res;
      });
      return (scalars) => {
        validateMSMScalars(scalars, fieldN);
        if (scalars.length > points.length)
          throw new Error(
            "array of scalars must be smaller than array of points"
          );
        let res = zero;
        for (let i = 0; i < chunks; i++) {
          if (res !== zero)
            for (let j = 0; j < windowSize; j++) res = res.double();
          const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);
          for (let j = 0; j < scalars.length; j++) {
            const n = scalars[j];
            const curr = Number((n >> shiftBy) & MASK);
            if (!curr) continue;
            res = res.add(tables[j][curr - 1]);
          }
        }
        return res;
      };
    }
    function validateBasic(curve) {
      (0, modular_ts_1.validateField)(curve.Fp);
      (0, utils_ts_1.validateObject)(
        curve,
        {
          n: "bigint",
          h: "bigint",
          Gx: "field",
          Gy: "field",
        },
        {
          nBitLength: "isSafeInteger",
          nByteLength: "isSafeInteger",
        }
      );
      return Object.freeze({
        ...(0, modular_ts_1.nLength)(curve.n, curve.nBitLength),
        ...curve,
        ...{ p: curve.Fp.ORDER },
      });
    }
    function createField(order, field, isLE) {
      if (field) {
        if (field.ORDER !== order)
          throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
        (0, modular_ts_1.validateField)(field);
        return field;
      } else {
        return (0, modular_ts_1.Field)(order, { isLE });
      }
    }
    function _createCurveFields(type, CURVE, curveOpts = {}, FpFnLE) {
      if (FpFnLE === void 0) FpFnLE = type === "edwards";
      if (!CURVE || typeof CURVE !== "object")
        throw new Error(`expected valid ${type} CURVE object`);
      for (const p of ["p", "n", "h"]) {
        const val = CURVE[p];
        if (!(typeof val === "bigint" && val > _0n))
          throw new Error(`CURVE.${p} must be positive bigint`);
      }
      const Fp = createField(CURVE.p, curveOpts.Fp, FpFnLE);
      const Fn = createField(CURVE.n, curveOpts.Fn, FpFnLE);
      const _b = type === "weierstrass" ? "b" : "d";
      const params = ["Gx", "Gy", "a", _b];
      for (const p of params) {
        if (!Fp.isValid(CURVE[p]))
          throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);
      }
      CURVE = Object.freeze(Object.assign({}, CURVE));
      return { CURVE, Fp, Fn };
    }
  },
});

// node_modules/@noble/curves/abstract/weierstrass.js
var require_weierstrass = __commonJS({
  "node_modules/@noble/curves/abstract/weierstrass.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DER = exports2.DERErr = void 0;
    exports2._splitEndoScalar = _splitEndoScalar;
    exports2._normFnElement = _normFnElement;
    exports2.weierstrassN = weierstrassN;
    exports2.SWUFpSqrtRatio = SWUFpSqrtRatio;
    exports2.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
    exports2.ecdh = ecdh;
    exports2.ecdsa = ecdsa;
    exports2.weierstrassPoints = weierstrassPoints;
    exports2._legacyHelperEquat = _legacyHelperEquat;
    exports2.weierstrass = weierstrass;
    var hmac_js_1 = require_hmac();
    var utils_1 = require_utils();
    var utils_ts_1 = require_utils7();
    var curve_ts_1 = require_curve();
    var modular_ts_1 = require_modular();
    var divNearest = (num, den) => (num + (num >= 0 ? den : -den) / _2n) / den;
    function _splitEndoScalar(k, basis, n) {
      const [[a1, b1], [a2, b2]] = basis;
      const c1 = divNearest(b2 * k, n);
      const c2 = divNearest(-b1 * k, n);
      let k1 = k - c1 * a1 - c2 * a2;
      let k2 = -c1 * b1 - c2 * b2;
      const k1neg = k1 < _0n;
      const k2neg = k2 < _0n;
      if (k1neg) k1 = -k1;
      if (k2neg) k2 = -k2;
      const MAX_NUM =
        (0, utils_ts_1.bitMask)(Math.ceil((0, utils_ts_1.bitLen)(n) / 2)) + _1n;
      if (k1 < _0n || k1 >= MAX_NUM || k2 < _0n || k2 >= MAX_NUM) {
        throw new Error("splitScalar (endomorphism): failed, k=" + k);
      }
      return { k1neg, k1, k2neg, k2 };
    }
    function validateSigFormat(format) {
      if (!["compact", "recovered", "der"].includes(format))
        throw new Error(
          'Signature format must be "compact", "recovered", or "der"'
        );
      return format;
    }
    function validateSigOpts(opts, def) {
      const optsn = {};
      for (let optName of Object.keys(def)) {
        optsn[optName] =
          opts[optName] === void 0 ? def[optName] : opts[optName];
      }
      (0, utils_ts_1._abool2)(optsn.lowS, "lowS");
      (0, utils_ts_1._abool2)(optsn.prehash, "prehash");
      if (optsn.format !== void 0) validateSigFormat(optsn.format);
      return optsn;
    }
    var DERErr = class extends Error {
      constructor(m = "") {
        super(m);
      }
    };
    exports2.DERErr = DERErr;
    exports2.DER = {
      // asn.1 DER encoding utils
      Err: DERErr,
      // Basic building block is TLV (Tag-Length-Value)
      _tlv: {
        encode: (tag, data) => {
          const { Err: E } = exports2.DER;
          if (tag < 0 || tag > 256) throw new E("tlv.encode: wrong tag");
          if (data.length & 1) throw new E("tlv.encode: unpadded data");
          const dataLen = data.length / 2;
          const len = (0, utils_ts_1.numberToHexUnpadded)(dataLen);
          if ((len.length / 2) & 128)
            throw new E("tlv.encode: long form length too big");
          const lenLen =
            dataLen > 127
              ? (0, utils_ts_1.numberToHexUnpadded)((len.length / 2) | 128)
              : "";
          const t = (0, utils_ts_1.numberToHexUnpadded)(tag);
          return t + lenLen + len + data;
        },
        // v - value, l - left bytes (unparsed)
        decode(tag, data) {
          const { Err: E } = exports2.DER;
          let pos = 0;
          if (tag < 0 || tag > 256) throw new E("tlv.encode: wrong tag");
          if (data.length < 2 || data[pos++] !== tag)
            throw new E("tlv.decode: wrong tlv");
          const first = data[pos++];
          const isLong = !!(first & 128);
          let length = 0;
          if (!isLong) length = first;
          else {
            const lenLen = first & 127;
            if (!lenLen)
              throw new E("tlv.decode(long): indefinite length not supported");
            if (lenLen > 4)
              throw new E("tlv.decode(long): byte length is too big");
            const lengthBytes = data.subarray(pos, pos + lenLen);
            if (lengthBytes.length !== lenLen)
              throw new E("tlv.decode: length bytes not complete");
            if (lengthBytes[0] === 0)
              throw new E("tlv.decode(long): zero leftmost byte");
            for (const b of lengthBytes) length = (length << 8) | b;
            pos += lenLen;
            if (length < 128)
              throw new E("tlv.decode(long): not minimal encoding");
          }
          const v = data.subarray(pos, pos + length);
          if (v.length !== length)
            throw new E("tlv.decode: wrong value length");
          return { v, l: data.subarray(pos + length) };
        },
      },
      // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
      // since we always use positive integers here. It must always be empty:
      // - add zero byte if exists
      // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
      _int: {
        encode(num) {
          const { Err: E } = exports2.DER;
          if (num < _0n)
            throw new E("integer: negative integers are not allowed");
          let hex = (0, utils_ts_1.numberToHexUnpadded)(num);
          if (Number.parseInt(hex[0], 16) & 8) hex = "00" + hex;
          if (hex.length & 1)
            throw new E("unexpected DER parsing assertion: unpadded hex");
          return hex;
        },
        decode(data) {
          const { Err: E } = exports2.DER;
          if (data[0] & 128) throw new E("invalid signature integer: negative");
          if (data[0] === 0 && !(data[1] & 128))
            throw new E("invalid signature integer: unnecessary leading zero");
          return (0, utils_ts_1.bytesToNumberBE)(data);
        },
      },
      toSig(hex) {
        const { Err: E, _int: int, _tlv: tlv } = exports2.DER;
        const data = (0, utils_ts_1.ensureBytes)("signature", hex);
        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
        if (seqLeftBytes.length)
          throw new E("invalid signature: left bytes after parsing");
        const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
        const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
        if (sLeftBytes.length)
          throw new E("invalid signature: left bytes after parsing");
        return { r: int.decode(rBytes), s: int.decode(sBytes) };
      },
      hexFromSig(sig) {
        const { _tlv: tlv, _int: int } = exports2.DER;
        const rs = tlv.encode(2, int.encode(sig.r));
        const ss = tlv.encode(2, int.encode(sig.s));
        const seq = rs + ss;
        return tlv.encode(48, seq);
      },
    };
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _4n = BigInt(4);
    function _normFnElement(Fn, key) {
      const { BYTES: expected } = Fn;
      let num;
      if (typeof key === "bigint") {
        num = key;
      } else {
        let bytes = (0, utils_ts_1.ensureBytes)("private key", key);
        try {
          num = Fn.fromBytes(bytes);
        } catch (error) {
          throw new Error(
            `invalid private key: expected ui8a of size ${expected}, got ${typeof key}`
          );
        }
      }
      if (!Fn.isValidNot0(num))
        throw new Error("invalid private key: out of range [1..N-1]");
      return num;
    }
    function weierstrassN(params, extraOpts = {}) {
      const validated = (0, curve_ts_1._createCurveFields)(
        "weierstrass",
        params,
        extraOpts
      );
      const { Fp, Fn } = validated;
      let CURVE = validated.CURVE;
      const { h: cofactor, n: CURVE_ORDER } = CURVE;
      (0, utils_ts_1._validateObject)(
        extraOpts,
        {},
        {
          allowInfinityPoint: "boolean",
          clearCofactor: "function",
          isTorsionFree: "function",
          fromBytes: "function",
          toBytes: "function",
          endo: "object",
          wrapPrivateKey: "boolean",
        }
      );
      const { endo } = extraOpts;
      if (endo) {
        if (
          !Fp.is0(CURVE.a) ||
          typeof endo.beta !== "bigint" ||
          !Array.isArray(endo.basises)
        ) {
          throw new Error(
            'invalid endo: expected "beta": bigint and "basises": array'
          );
        }
      }
      const lengths = getWLengths(Fp, Fn);
      function assertCompressionIsSupported() {
        if (!Fp.isOdd)
          throw new Error(
            "compression is not supported: Field does not have .isOdd()"
          );
      }
      function pointToBytes(_c, point, isCompressed) {
        const { x, y } = point.toAffine();
        const bx = Fp.toBytes(x);
        (0, utils_ts_1._abool2)(isCompressed, "isCompressed");
        if (isCompressed) {
          assertCompressionIsSupported();
          const hasEvenY = !Fp.isOdd(y);
          return (0, utils_ts_1.concatBytes)(pprefix(hasEvenY), bx);
        } else {
          return (0, utils_ts_1.concatBytes)(
            Uint8Array.of(4),
            bx,
            Fp.toBytes(y)
          );
        }
      }
      function pointFromBytes(bytes) {
        (0, utils_ts_1._abytes2)(bytes, void 0, "Point");
        const { publicKey: comp, publicKeyUncompressed: uncomp } = lengths;
        const length = bytes.length;
        const head = bytes[0];
        const tail = bytes.subarray(1);
        if (length === comp && (head === 2 || head === 3)) {
          const x = Fp.fromBytes(tail);
          if (!Fp.isValid(x))
            throw new Error("bad point: is not on curve, wrong x");
          const y2 = weierstrassEquation(x);
          let y;
          try {
            y = Fp.sqrt(y2);
          } catch (sqrtError) {
            const err =
              sqrtError instanceof Error ? ": " + sqrtError.message : "";
            throw new Error("bad point: is not on curve, sqrt error" + err);
          }
          assertCompressionIsSupported();
          const isYOdd = Fp.isOdd(y);
          const isHeadOdd = (head & 1) === 1;
          if (isHeadOdd !== isYOdd) y = Fp.neg(y);
          return { x, y };
        } else if (length === uncomp && head === 4) {
          const L = Fp.BYTES;
          const x = Fp.fromBytes(tail.subarray(0, L));
          const y = Fp.fromBytes(tail.subarray(L, L * 2));
          if (!isValidXY(x, y)) throw new Error("bad point: is not on curve");
          return { x, y };
        } else {
          throw new Error(
            `bad point: got length ${length}, expected compressed=${comp} or uncompressed=${uncomp}`
          );
        }
      }
      const encodePoint = extraOpts.toBytes || pointToBytes;
      const decodePoint = extraOpts.fromBytes || pointFromBytes;
      function weierstrassEquation(x) {
        const x2 = Fp.sqr(x);
        const x3 = Fp.mul(x2, x);
        return Fp.add(Fp.add(x3, Fp.mul(x, CURVE.a)), CURVE.b);
      }
      function isValidXY(x, y) {
        const left = Fp.sqr(y);
        const right = weierstrassEquation(x);
        return Fp.eql(left, right);
      }
      if (!isValidXY(CURVE.Gx, CURVE.Gy))
        throw new Error("bad curve params: generator point");
      const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n), _4n);
      const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));
      if (Fp.is0(Fp.add(_4a3, _27b2)))
        throw new Error("bad curve params: a or b");
      function acoord(title, n, banZero = false) {
        if (!Fp.isValid(n) || (banZero && Fp.is0(n)))
          throw new Error(`bad point coordinate ${title}`);
        return n;
      }
      function aprjpoint(other) {
        if (!(other instanceof Point))
          throw new Error("ProjectivePoint expected");
      }
      function splitEndoScalarN(k) {
        if (!endo || !endo.basises) throw new Error("no endo");
        return _splitEndoScalar(k, endo.basises, Fn.ORDER);
      }
      const toAffineMemo = (0, utils_ts_1.memoized)((p, iz) => {
        const { X, Y, Z } = p;
        if (Fp.eql(Z, Fp.ONE)) return { x: X, y: Y };
        const is0 = p.is0();
        if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(Z);
        const x = Fp.mul(X, iz);
        const y = Fp.mul(Y, iz);
        const zz = Fp.mul(Z, iz);
        if (is0) return { x: Fp.ZERO, y: Fp.ZERO };
        if (!Fp.eql(zz, Fp.ONE)) throw new Error("invZ was invalid");
        return { x, y };
      });
      const assertValidMemo = (0, utils_ts_1.memoized)((p) => {
        if (p.is0()) {
          if (extraOpts.allowInfinityPoint && !Fp.is0(p.Y)) return;
          throw new Error("bad point: ZERO");
        }
        const { x, y } = p.toAffine();
        if (!Fp.isValid(x) || !Fp.isValid(y))
          throw new Error("bad point: x or y not field elements");
        if (!isValidXY(x, y))
          throw new Error("bad point: equation left != right");
        if (!p.isTorsionFree())
          throw new Error("bad point: not in prime-order subgroup");
        return true;
      });
      function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {
        k2p = new Point(Fp.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);
        k1p = (0, curve_ts_1.negateCt)(k1neg, k1p);
        k2p = (0, curve_ts_1.negateCt)(k2neg, k2p);
        return k1p.add(k2p);
      }
      class Point {
        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
        constructor(X, Y, Z) {
          this.X = acoord("x", X);
          this.Y = acoord("y", Y, true);
          this.Z = acoord("z", Z);
          Object.freeze(this);
        }
        static CURVE() {
          return CURVE;
        }
        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
        static fromAffine(p) {
          const { x, y } = p || {};
          if (!p || !Fp.isValid(x) || !Fp.isValid(y))
            throw new Error("invalid affine point");
          if (p instanceof Point)
            throw new Error("projective point not allowed");
          if (Fp.is0(x) && Fp.is0(y)) return Point.ZERO;
          return new Point(x, y, Fp.ONE);
        }
        static fromBytes(bytes) {
          const P = Point.fromAffine(
            decodePoint((0, utils_ts_1._abytes2)(bytes, void 0, "point"))
          );
          P.assertValidity();
          return P;
        }
        static fromHex(hex) {
          return Point.fromBytes((0, utils_ts_1.ensureBytes)("pointHex", hex));
        }
        get x() {
          return this.toAffine().x;
        }
        get y() {
          return this.toAffine().y;
        }
        /**
         *
         * @param windowSize
         * @param isLazy true will defer table computation until the first multiplication
         * @returns
         */
        precompute(windowSize = 8, isLazy = true) {
          wnaf.createCache(this, windowSize);
          if (!isLazy) this.multiply(_3n);
          return this;
        }
        // TODO: return `this`
        /** A point on curve is valid if it conforms to equation. */
        assertValidity() {
          assertValidMemo(this);
        }
        hasEvenY() {
          const { y } = this.toAffine();
          if (!Fp.isOdd) throw new Error("Field doesn't support isOdd");
          return !Fp.isOdd(y);
        }
        /** Compare one point to another. */
        equals(other) {
          aprjpoint(other);
          const { X: X1, Y: Y1, Z: Z1 } = this;
          const { X: X2, Y: Y2, Z: Z2 } = other;
          const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
          const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
          return U1 && U2;
        }
        /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
        negate() {
          return new Point(this.X, Fp.neg(this.Y), this.Z);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
          const { a, b } = CURVE;
          const b3 = Fp.mul(b, _3n);
          const { X: X1, Y: Y1, Z: Z1 } = this;
          let X3 = Fp.ZERO,
            Y3 = Fp.ZERO,
            Z3 = Fp.ZERO;
          let t0 = Fp.mul(X1, X1);
          let t1 = Fp.mul(Y1, Y1);
          let t2 = Fp.mul(Z1, Z1);
          let t3 = Fp.mul(X1, Y1);
          t3 = Fp.add(t3, t3);
          Z3 = Fp.mul(X1, Z1);
          Z3 = Fp.add(Z3, Z3);
          X3 = Fp.mul(a, Z3);
          Y3 = Fp.mul(b3, t2);
          Y3 = Fp.add(X3, Y3);
          X3 = Fp.sub(t1, Y3);
          Y3 = Fp.add(t1, Y3);
          Y3 = Fp.mul(X3, Y3);
          X3 = Fp.mul(t3, X3);
          Z3 = Fp.mul(b3, Z3);
          t2 = Fp.mul(a, t2);
          t3 = Fp.sub(t0, t2);
          t3 = Fp.mul(a, t3);
          t3 = Fp.add(t3, Z3);
          Z3 = Fp.add(t0, t0);
          t0 = Fp.add(Z3, t0);
          t0 = Fp.add(t0, t2);
          t0 = Fp.mul(t0, t3);
          Y3 = Fp.add(Y3, t0);
          t2 = Fp.mul(Y1, Z1);
          t2 = Fp.add(t2, t2);
          t0 = Fp.mul(t2, t3);
          X3 = Fp.sub(X3, t0);
          Z3 = Fp.mul(t2, t1);
          Z3 = Fp.add(Z3, Z3);
          Z3 = Fp.add(Z3, Z3);
          return new Point(X3, Y3, Z3);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(other) {
          aprjpoint(other);
          const { X: X1, Y: Y1, Z: Z1 } = this;
          const { X: X2, Y: Y2, Z: Z2 } = other;
          let X3 = Fp.ZERO,
            Y3 = Fp.ZERO,
            Z3 = Fp.ZERO;
          const a = CURVE.a;
          const b3 = Fp.mul(CURVE.b, _3n);
          let t0 = Fp.mul(X1, X2);
          let t1 = Fp.mul(Y1, Y2);
          let t2 = Fp.mul(Z1, Z2);
          let t3 = Fp.add(X1, Y1);
          let t4 = Fp.add(X2, Y2);
          t3 = Fp.mul(t3, t4);
          t4 = Fp.add(t0, t1);
          t3 = Fp.sub(t3, t4);
          t4 = Fp.add(X1, Z1);
          let t5 = Fp.add(X2, Z2);
          t4 = Fp.mul(t4, t5);
          t5 = Fp.add(t0, t2);
          t4 = Fp.sub(t4, t5);
          t5 = Fp.add(Y1, Z1);
          X3 = Fp.add(Y2, Z2);
          t5 = Fp.mul(t5, X3);
          X3 = Fp.add(t1, t2);
          t5 = Fp.sub(t5, X3);
          Z3 = Fp.mul(a, t4);
          X3 = Fp.mul(b3, t2);
          Z3 = Fp.add(X3, Z3);
          X3 = Fp.sub(t1, Z3);
          Z3 = Fp.add(t1, Z3);
          Y3 = Fp.mul(X3, Z3);
          t1 = Fp.add(t0, t0);
          t1 = Fp.add(t1, t0);
          t2 = Fp.mul(a, t2);
          t4 = Fp.mul(b3, t4);
          t1 = Fp.add(t1, t2);
          t2 = Fp.sub(t0, t2);
          t2 = Fp.mul(a, t2);
          t4 = Fp.add(t4, t2);
          t0 = Fp.mul(t1, t4);
          Y3 = Fp.add(Y3, t0);
          t0 = Fp.mul(t5, t4);
          X3 = Fp.mul(t3, X3);
          X3 = Fp.sub(X3, t0);
          t0 = Fp.mul(t3, t1);
          Z3 = Fp.mul(t5, Z3);
          Z3 = Fp.add(Z3, t0);
          return new Point(X3, Y3, Z3);
        }
        subtract(other) {
          return this.add(other.negate());
        }
        is0() {
          return this.equals(Point.ZERO);
        }
        /**
         * Constant time multiplication.
         * Uses wNAF method. Windowed method may be 10% faster,
         * but takes 2x longer to generate and consumes 2x memory.
         * Uses precomputes when available.
         * Uses endomorphism for Koblitz curves.
         * @param scalar by which the point would be multiplied
         * @returns New point
         */
        multiply(scalar) {
          const { endo: endo2 } = extraOpts;
          if (!Fn.isValidNot0(scalar))
            throw new Error("invalid scalar: out of range");
          let point, fake;
          const mul = (n) =>
            wnaf.cached(this, n, (p) => (0, curve_ts_1.normalizeZ)(Point, p));
          if (endo2) {
            const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(scalar);
            const { p: k1p, f: k1f } = mul(k1);
            const { p: k2p, f: k2f } = mul(k2);
            fake = k1f.add(k2f);
            point = finishEndo(endo2.beta, k1p, k2p, k1neg, k2neg);
          } else {
            const { p, f } = mul(scalar);
            point = p;
            fake = f;
          }
          return (0, curve_ts_1.normalizeZ)(Point, [point, fake])[0];
        }
        /**
         * Non-constant-time multiplication. Uses double-and-add algorithm.
         * It's faster, but should only be used when you don't care about
         * an exposed secret key e.g. sig verification, which works over *public* keys.
         */
        multiplyUnsafe(sc) {
          const { endo: endo2 } = extraOpts;
          const p = this;
          if (!Fn.isValid(sc)) throw new Error("invalid scalar: out of range");
          if (sc === _0n || p.is0()) return Point.ZERO;
          if (sc === _1n) return p;
          if (wnaf.hasCache(this)) return this.multiply(sc);
          if (endo2) {
            const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(sc);
            const { p1, p2 } = (0, curve_ts_1.mulEndoUnsafe)(Point, p, k1, k2);
            return finishEndo(endo2.beta, p1, p2, k1neg, k2neg);
          } else {
            return wnaf.unsafe(p, sc);
          }
        }
        multiplyAndAddUnsafe(Q, a, b) {
          const sum = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b));
          return sum.is0() ? void 0 : sum;
        }
        /**
         * Converts Projective point to affine (x, y) coordinates.
         * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
         */
        toAffine(invertedZ) {
          return toAffineMemo(this, invertedZ);
        }
        /**
         * Checks whether Point is free of torsion elements (is in prime subgroup).
         * Always torsion-free for cofactor=1 curves.
         */
        isTorsionFree() {
          const { isTorsionFree } = extraOpts;
          if (cofactor === _1n) return true;
          if (isTorsionFree) return isTorsionFree(Point, this);
          return wnaf.unsafe(this, CURVE_ORDER).is0();
        }
        clearCofactor() {
          const { clearCofactor } = extraOpts;
          if (cofactor === _1n) return this;
          if (clearCofactor) return clearCofactor(Point, this);
          return this.multiplyUnsafe(cofactor);
        }
        isSmallOrder() {
          return this.multiplyUnsafe(cofactor).is0();
        }
        toBytes(isCompressed = true) {
          (0, utils_ts_1._abool2)(isCompressed, "isCompressed");
          this.assertValidity();
          return encodePoint(Point, this, isCompressed);
        }
        toHex(isCompressed = true) {
          return (0, utils_ts_1.bytesToHex)(this.toBytes(isCompressed));
        }
        toString() {
          return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
        }
        // TODO: remove
        get px() {
          return this.X;
        }
        get py() {
          return this.X;
        }
        get pz() {
          return this.Z;
        }
        toRawBytes(isCompressed = true) {
          return this.toBytes(isCompressed);
        }
        _setWindowSize(windowSize) {
          this.precompute(windowSize);
        }
        static normalizeZ(points) {
          return (0, curve_ts_1.normalizeZ)(Point, points);
        }
        static msm(points, scalars) {
          return (0, curve_ts_1.pippenger)(Point, Fn, points, scalars);
        }
        static fromPrivateKey(privateKey) {
          return Point.BASE.multiply(_normFnElement(Fn, privateKey));
        }
      }
      Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
      Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
      Point.Fp = Fp;
      Point.Fn = Fn;
      const bits = Fn.BITS;
      const wnaf = new curve_ts_1.wNAF(
        Point,
        extraOpts.endo ? Math.ceil(bits / 2) : bits
      );
      Point.BASE.precompute(8);
      return Point;
    }
    function pprefix(hasEvenY) {
      return Uint8Array.of(hasEvenY ? 2 : 3);
    }
    function SWUFpSqrtRatio(Fp, Z) {
      const q = Fp.ORDER;
      let l = _0n;
      for (let o = q - _1n; o % _2n === _0n; o /= _2n) l += _1n;
      const c1 = l;
      const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);
      const _2n_pow_c1 = _2n_pow_c1_1 * _2n;
      const c2 = (q - _1n) / _2n_pow_c1;
      const c3 = (c2 - _1n) / _2n;
      const c4 = _2n_pow_c1 - _1n;
      const c5 = _2n_pow_c1_1;
      const c6 = Fp.pow(Z, c2);
      const c7 = Fp.pow(Z, (c2 + _1n) / _2n);
      let sqrtRatio = (u, v) => {
        let tv1 = c6;
        let tv2 = Fp.pow(v, c4);
        let tv3 = Fp.sqr(tv2);
        tv3 = Fp.mul(tv3, v);
        let tv5 = Fp.mul(u, tv3);
        tv5 = Fp.pow(tv5, c3);
        tv5 = Fp.mul(tv5, tv2);
        tv2 = Fp.mul(tv5, v);
        tv3 = Fp.mul(tv5, u);
        let tv4 = Fp.mul(tv3, tv2);
        tv5 = Fp.pow(tv4, c5);
        let isQR = Fp.eql(tv5, Fp.ONE);
        tv2 = Fp.mul(tv3, c7);
        tv5 = Fp.mul(tv4, tv1);
        tv3 = Fp.cmov(tv2, tv3, isQR);
        tv4 = Fp.cmov(tv5, tv4, isQR);
        for (let i = c1; i > _1n; i--) {
          let tv52 = i - _2n;
          tv52 = _2n << (tv52 - _1n);
          let tvv5 = Fp.pow(tv4, tv52);
          const e1 = Fp.eql(tvv5, Fp.ONE);
          tv2 = Fp.mul(tv3, tv1);
          tv1 = Fp.mul(tv1, tv1);
          tvv5 = Fp.mul(tv4, tv1);
          tv3 = Fp.cmov(tv2, tv3, e1);
          tv4 = Fp.cmov(tvv5, tv4, e1);
        }
        return { isValid: isQR, value: tv3 };
      };
      if (Fp.ORDER % _4n === _3n) {
        const c12 = (Fp.ORDER - _3n) / _4n;
        const c22 = Fp.sqrt(Fp.neg(Z));
        sqrtRatio = (u, v) => {
          let tv1 = Fp.sqr(v);
          const tv2 = Fp.mul(u, v);
          tv1 = Fp.mul(tv1, tv2);
          let y1 = Fp.pow(tv1, c12);
          y1 = Fp.mul(y1, tv2);
          const y2 = Fp.mul(y1, c22);
          const tv3 = Fp.mul(Fp.sqr(y1), v);
          const isQR = Fp.eql(tv3, u);
          let y = Fp.cmov(y2, y1, isQR);
          return { isValid: isQR, value: y };
        };
      }
      return sqrtRatio;
    }
    function mapToCurveSimpleSWU(Fp, opts) {
      (0, modular_ts_1.validateField)(Fp);
      const { A, B, Z } = opts;
      if (!Fp.isValid(A) || !Fp.isValid(B) || !Fp.isValid(Z))
        throw new Error("mapToCurveSimpleSWU: invalid opts");
      const sqrtRatio = SWUFpSqrtRatio(Fp, Z);
      if (!Fp.isOdd) throw new Error("Field does not have .isOdd()");
      return (u) => {
        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
        tv1 = Fp.sqr(u);
        tv1 = Fp.mul(tv1, Z);
        tv2 = Fp.sqr(tv1);
        tv2 = Fp.add(tv2, tv1);
        tv3 = Fp.add(tv2, Fp.ONE);
        tv3 = Fp.mul(tv3, B);
        tv4 = Fp.cmov(Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO));
        tv4 = Fp.mul(tv4, A);
        tv2 = Fp.sqr(tv3);
        tv6 = Fp.sqr(tv4);
        tv5 = Fp.mul(tv6, A);
        tv2 = Fp.add(tv2, tv5);
        tv2 = Fp.mul(tv2, tv3);
        tv6 = Fp.mul(tv6, tv4);
        tv5 = Fp.mul(tv6, B);
        tv2 = Fp.add(tv2, tv5);
        x = Fp.mul(tv1, tv3);
        const { isValid, value } = sqrtRatio(tv2, tv6);
        y = Fp.mul(tv1, u);
        y = Fp.mul(y, value);
        x = Fp.cmov(x, tv3, isValid);
        y = Fp.cmov(y, value, isValid);
        const e1 = Fp.isOdd(u) === Fp.isOdd(y);
        y = Fp.cmov(Fp.neg(y), y, e1);
        const tv4_inv = (0, modular_ts_1.FpInvertBatch)(Fp, [tv4], true)[0];
        x = Fp.mul(x, tv4_inv);
        return { x, y };
      };
    }
    function getWLengths(Fp, Fn) {
      return {
        secretKey: Fn.BYTES,
        publicKey: 1 + Fp.BYTES,
        publicKeyUncompressed: 1 + 2 * Fp.BYTES,
        publicKeyHasPrefix: true,
        signature: 2 * Fn.BYTES,
      };
    }
    function ecdh(Point, ecdhOpts = {}) {
      const { Fn } = Point;
      const randomBytes_ = ecdhOpts.randomBytes || utils_ts_1.randomBytes;
      const lengths = Object.assign(getWLengths(Point.Fp, Fn), {
        seed: (0, modular_ts_1.getMinHashLength)(Fn.ORDER),
      });
      function isValidSecretKey(secretKey) {
        try {
          return !!_normFnElement(Fn, secretKey);
        } catch (error) {
          return false;
        }
      }
      function isValidPublicKey(publicKey, isCompressed) {
        const { publicKey: comp, publicKeyUncompressed } = lengths;
        try {
          const l = publicKey.length;
          if (isCompressed === true && l !== comp) return false;
          if (isCompressed === false && l !== publicKeyUncompressed)
            return false;
          return !!Point.fromBytes(publicKey);
        } catch (error) {
          return false;
        }
      }
      function randomSecretKey(seed = randomBytes_(lengths.seed)) {
        return (0, modular_ts_1.mapHashToField)(
          (0, utils_ts_1._abytes2)(seed, lengths.seed, "seed"),
          Fn.ORDER
        );
      }
      function getPublicKey(secretKey, isCompressed = true) {
        return Point.BASE.multiply(_normFnElement(Fn, secretKey)).toBytes(
          isCompressed
        );
      }
      function keygen(seed) {
        const secretKey = randomSecretKey(seed);
        return { secretKey, publicKey: getPublicKey(secretKey) };
      }
      function isProbPub(item) {
        if (typeof item === "bigint") return false;
        if (item instanceof Point) return true;
        const { secretKey, publicKey, publicKeyUncompressed } = lengths;
        if (Fn.allowedLengths || secretKey === publicKey) return void 0;
        const l = (0, utils_ts_1.ensureBytes)("key", item).length;
        return l === publicKey || l === publicKeyUncompressed;
      }
      function getSharedSecret(secretKeyA, publicKeyB, isCompressed = true) {
        if (isProbPub(secretKeyA) === true)
          throw new Error("first arg must be private key");
        if (isProbPub(publicKeyB) === false)
          throw new Error("second arg must be public key");
        const s = _normFnElement(Fn, secretKeyA);
        const b = Point.fromHex(publicKeyB);
        return b.multiply(s).toBytes(isCompressed);
      }
      const utils = {
        isValidSecretKey,
        isValidPublicKey,
        randomSecretKey,
        // TODO: remove
        isValidPrivateKey: isValidSecretKey,
        randomPrivateKey: randomSecretKey,
        normPrivateKeyToScalar: (key) => _normFnElement(Fn, key),
        precompute(windowSize = 8, point = Point.BASE) {
          return point.precompute(windowSize, false);
        },
      };
      return Object.freeze({
        getPublicKey,
        getSharedSecret,
        keygen,
        Point,
        utils,
        lengths,
      });
    }
    function ecdsa(Point, hash, ecdsaOpts = {}) {
      (0, utils_1.ahash)(hash);
      (0, utils_ts_1._validateObject)(
        ecdsaOpts,
        {},
        {
          hmac: "function",
          lowS: "boolean",
          randomBytes: "function",
          bits2int: "function",
          bits2int_modN: "function",
        }
      );
      const randomBytes = ecdsaOpts.randomBytes || utils_ts_1.randomBytes;
      const hmac =
        ecdsaOpts.hmac ||
        ((key, ...msgs) =>
          (0, hmac_js_1.hmac)(hash, key, (0, utils_ts_1.concatBytes)(...msgs)));
      const { Fp, Fn } = Point;
      const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;
      const { keygen, getPublicKey, getSharedSecret, utils, lengths } = ecdh(
        Point,
        ecdsaOpts
      );
      const defaultSigOpts = {
        prehash: false,
        lowS: typeof ecdsaOpts.lowS === "boolean" ? ecdsaOpts.lowS : false,
        format: void 0,
        //'compact' as ECDSASigFormat,
        extraEntropy: false,
      };
      const defaultSigOpts_format = "compact";
      function isBiggerThanHalfOrder(number) {
        const HALF = CURVE_ORDER >> _1n;
        return number > HALF;
      }
      function validateRS(title, num) {
        if (!Fn.isValidNot0(num))
          throw new Error(
            `invalid signature ${title}: out of range 1..Point.Fn.ORDER`
          );
        return num;
      }
      function validateSigLength(bytes, format) {
        validateSigFormat(format);
        const size = lengths.signature;
        const sizer =
          format === "compact"
            ? size
            : format === "recovered"
            ? size + 1
            : void 0;
        return (0, utils_ts_1._abytes2)(bytes, sizer, `${format} signature`);
      }
      class Signature {
        constructor(r, s, recovery) {
          this.r = validateRS("r", r);
          this.s = validateRS("s", s);
          if (recovery != null) this.recovery = recovery;
          Object.freeze(this);
        }
        static fromBytes(bytes, format = defaultSigOpts_format) {
          validateSigLength(bytes, format);
          let recid;
          if (format === "der") {
            const { r: r2, s: s2 } = exports2.DER.toSig(
              (0, utils_ts_1._abytes2)(bytes)
            );
            return new Signature(r2, s2);
          }
          if (format === "recovered") {
            recid = bytes[0];
            format = "compact";
            bytes = bytes.subarray(1);
          }
          const L = Fn.BYTES;
          const r = bytes.subarray(0, L);
          const s = bytes.subarray(L, L * 2);
          return new Signature(Fn.fromBytes(r), Fn.fromBytes(s), recid);
        }
        static fromHex(hex, format) {
          return this.fromBytes((0, utils_ts_1.hexToBytes)(hex), format);
        }
        addRecoveryBit(recovery) {
          return new Signature(this.r, this.s, recovery);
        }
        recoverPublicKey(messageHash) {
          const FIELD_ORDER = Fp.ORDER;
          const { r, s, recovery: rec } = this;
          if (rec == null || ![0, 1, 2, 3].includes(rec))
            throw new Error("recovery id invalid");
          const hasCofactor = CURVE_ORDER * _2n < FIELD_ORDER;
          if (hasCofactor && rec > 1)
            throw new Error("recovery id is ambiguous for h>1 curve");
          const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;
          if (!Fp.isValid(radj)) throw new Error("recovery id 2 or 3 invalid");
          const x = Fp.toBytes(radj);
          const R = Point.fromBytes(
            (0, utils_ts_1.concatBytes)(pprefix((rec & 1) === 0), x)
          );
          const ir = Fn.inv(radj);
          const h = bits2int_modN(
            (0, utils_ts_1.ensureBytes)("msgHash", messageHash)
          );
          const u1 = Fn.create(-h * ir);
          const u2 = Fn.create(s * ir);
          const Q = Point.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));
          if (Q.is0()) throw new Error("point at infinify");
          Q.assertValidity();
          return Q;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
          return isBiggerThanHalfOrder(this.s);
        }
        toBytes(format = defaultSigOpts_format) {
          validateSigFormat(format);
          if (format === "der")
            return (0, utils_ts_1.hexToBytes)(exports2.DER.hexFromSig(this));
          const r = Fn.toBytes(this.r);
          const s = Fn.toBytes(this.s);
          if (format === "recovered") {
            if (this.recovery == null)
              throw new Error("recovery bit must be present");
            return (0, utils_ts_1.concatBytes)(
              Uint8Array.of(this.recovery),
              r,
              s
            );
          }
          return (0, utils_ts_1.concatBytes)(r, s);
        }
        toHex(format) {
          return (0, utils_ts_1.bytesToHex)(this.toBytes(format));
        }
        // TODO: remove
        assertValidity() {}
        static fromCompact(hex) {
          return Signature.fromBytes(
            (0, utils_ts_1.ensureBytes)("sig", hex),
            "compact"
          );
        }
        static fromDER(hex) {
          return Signature.fromBytes(
            (0, utils_ts_1.ensureBytes)("sig", hex),
            "der"
          );
        }
        normalizeS() {
          return this.hasHighS()
            ? new Signature(this.r, Fn.neg(this.s), this.recovery)
            : this;
        }
        toDERRawBytes() {
          return this.toBytes("der");
        }
        toDERHex() {
          return (0, utils_ts_1.bytesToHex)(this.toBytes("der"));
        }
        toCompactRawBytes() {
          return this.toBytes("compact");
        }
        toCompactHex() {
          return (0, utils_ts_1.bytesToHex)(this.toBytes("compact"));
        }
      }
      const bits2int =
        ecdsaOpts.bits2int ||
        function bits2int_def(bytes) {
          if (bytes.length > 8192) throw new Error("input is too large");
          const num = (0, utils_ts_1.bytesToNumberBE)(bytes);
          const delta = bytes.length * 8 - fnBits;
          return delta > 0 ? num >> BigInt(delta) : num;
        };
      const bits2int_modN =
        ecdsaOpts.bits2int_modN ||
        function bits2int_modN_def(bytes) {
          return Fn.create(bits2int(bytes));
        };
      const ORDER_MASK = (0, utils_ts_1.bitMask)(fnBits);
      function int2octets(num) {
        (0, utils_ts_1.aInRange)("num < 2^" + fnBits, num, _0n, ORDER_MASK);
        return Fn.toBytes(num);
      }
      function validateMsgAndHash(message, prehash) {
        (0, utils_ts_1._abytes2)(message, void 0, "message");
        return prehash
          ? (0, utils_ts_1._abytes2)(hash(message), void 0, "prehashed message")
          : message;
      }
      function prepSig(message, privateKey, opts) {
        if (["recovered", "canonical"].some((k) => k in opts))
          throw new Error("sign() legacy options not supported");
        const { lowS, prehash, extraEntropy } = validateSigOpts(
          opts,
          defaultSigOpts
        );
        message = validateMsgAndHash(message, prehash);
        const h1int = bits2int_modN(message);
        const d = _normFnElement(Fn, privateKey);
        const seedArgs = [int2octets(d), int2octets(h1int)];
        if (extraEntropy != null && extraEntropy !== false) {
          const e =
            extraEntropy === true
              ? randomBytes(lengths.secretKey)
              : extraEntropy;
          seedArgs.push((0, utils_ts_1.ensureBytes)("extraEntropy", e));
        }
        const seed = (0, utils_ts_1.concatBytes)(...seedArgs);
        const m = h1int;
        function k2sig(kBytes) {
          const k = bits2int(kBytes);
          if (!Fn.isValidNot0(k)) return;
          const ik = Fn.inv(k);
          const q = Point.BASE.multiply(k).toAffine();
          const r = Fn.create(q.x);
          if (r === _0n) return;
          const s = Fn.create(ik * Fn.create(m + r * d));
          if (s === _0n) return;
          let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n);
          let normS = s;
          if (lowS && isBiggerThanHalfOrder(s)) {
            normS = Fn.neg(s);
            recovery ^= 1;
          }
          return new Signature(r, normS, recovery);
        }
        return { seed, k2sig };
      }
      function sign(message, secretKey, opts = {}) {
        message = (0, utils_ts_1.ensureBytes)("message", message);
        const { seed, k2sig } = prepSig(message, secretKey, opts);
        const drbg = (0, utils_ts_1.createHmacDrbg)(
          hash.outputLen,
          Fn.BYTES,
          hmac
        );
        const sig = drbg(seed, k2sig);
        return sig;
      }
      function tryParsingSig(sg) {
        let sig = void 0;
        const isHex = typeof sg === "string" || (0, utils_ts_1.isBytes)(sg);
        const isObj =
          !isHex &&
          sg !== null &&
          typeof sg === "object" &&
          typeof sg.r === "bigint" &&
          typeof sg.s === "bigint";
        if (!isHex && !isObj)
          throw new Error(
            "invalid signature, expected Uint8Array, hex string or Signature instance"
          );
        if (isObj) {
          sig = new Signature(sg.r, sg.s);
        } else if (isHex) {
          try {
            sig = Signature.fromBytes(
              (0, utils_ts_1.ensureBytes)("sig", sg),
              "der"
            );
          } catch (derError) {
            if (!(derError instanceof exports2.DER.Err)) throw derError;
          }
          if (!sig) {
            try {
              sig = Signature.fromBytes(
                (0, utils_ts_1.ensureBytes)("sig", sg),
                "compact"
              );
            } catch (error) {
              return false;
            }
          }
        }
        if (!sig) return false;
        return sig;
      }
      function verify(signature, message, publicKey, opts = {}) {
        const { lowS, prehash, format } = validateSigOpts(opts, defaultSigOpts);
        publicKey = (0, utils_ts_1.ensureBytes)("publicKey", publicKey);
        message = validateMsgAndHash(
          (0, utils_ts_1.ensureBytes)("message", message),
          prehash
        );
        if ("strict" in opts)
          throw new Error("options.strict was renamed to lowS");
        const sig =
          format === void 0
            ? tryParsingSig(signature)
            : Signature.fromBytes(
                (0, utils_ts_1.ensureBytes)("sig", signature),
                format
              );
        if (sig === false) return false;
        try {
          const P = Point.fromBytes(publicKey);
          if (lowS && sig.hasHighS()) return false;
          const { r, s } = sig;
          const h = bits2int_modN(message);
          const is = Fn.inv(s);
          const u1 = Fn.create(h * is);
          const u2 = Fn.create(r * is);
          const R = Point.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2));
          if (R.is0()) return false;
          const v = Fn.create(R.x);
          return v === r;
        } catch (e) {
          return false;
        }
      }
      function recoverPublicKey(signature, message, opts = {}) {
        const { prehash } = validateSigOpts(opts, defaultSigOpts);
        message = validateMsgAndHash(message, prehash);
        return Signature.fromBytes(signature, "recovered")
          .recoverPublicKey(message)
          .toBytes();
      }
      return Object.freeze({
        keygen,
        getPublicKey,
        getSharedSecret,
        utils,
        lengths,
        Point,
        sign,
        verify,
        recoverPublicKey,
        Signature,
        hash,
      });
    }
    function weierstrassPoints(c) {
      const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);
      const Point = weierstrassN(CURVE, curveOpts);
      return _weierstrass_new_output_to_legacy(c, Point);
    }
    function _weierstrass_legacy_opts_to_new(c) {
      const CURVE = {
        a: c.a,
        b: c.b,
        p: c.Fp.ORDER,
        n: c.n,
        h: c.h,
        Gx: c.Gx,
        Gy: c.Gy,
      };
      const Fp = c.Fp;
      let allowedLengths = c.allowedPrivateKeyLengths
        ? Array.from(
            new Set(c.allowedPrivateKeyLengths.map((l) => Math.ceil(l / 2)))
          )
        : void 0;
      const Fn = (0, modular_ts_1.Field)(CURVE.n, {
        BITS: c.nBitLength,
        allowedLengths,
        modFromBytes: c.wrapPrivateKey,
      });
      const curveOpts = {
        Fp,
        Fn,
        allowInfinityPoint: c.allowInfinityPoint,
        endo: c.endo,
        isTorsionFree: c.isTorsionFree,
        clearCofactor: c.clearCofactor,
        fromBytes: c.fromBytes,
        toBytes: c.toBytes,
      };
      return { CURVE, curveOpts };
    }
    function _ecdsa_legacy_opts_to_new(c) {
      const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);
      const ecdsaOpts = {
        hmac: c.hmac,
        randomBytes: c.randomBytes,
        lowS: c.lowS,
        bits2int: c.bits2int,
        bits2int_modN: c.bits2int_modN,
      };
      return { CURVE, curveOpts, hash: c.hash, ecdsaOpts };
    }
    function _legacyHelperEquat(Fp, a, b) {
      function weierstrassEquation(x) {
        const x2 = Fp.sqr(x);
        const x3 = Fp.mul(x2, x);
        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b);
      }
      return weierstrassEquation;
    }
    function _weierstrass_new_output_to_legacy(c, Point) {
      const { Fp, Fn } = Point;
      function isWithinCurveOrder(num) {
        return (0, utils_ts_1.inRange)(num, _1n, Fn.ORDER);
      }
      const weierstrassEquation = _legacyHelperEquat(Fp, c.a, c.b);
      return Object.assign(
        {},
        {
          CURVE: c,
          Point,
          ProjectivePoint: Point,
          normPrivateKeyToScalar: (key) => _normFnElement(Fn, key),
          weierstrassEquation,
          isWithinCurveOrder,
        }
      );
    }
    function _ecdsa_new_output_to_legacy(c, _ecdsa) {
      const Point = _ecdsa.Point;
      return Object.assign({}, _ecdsa, {
        ProjectivePoint: Point,
        CURVE: Object.assign(
          {},
          c,
          (0, modular_ts_1.nLength)(Point.Fn.ORDER, Point.Fn.BITS)
        ),
      });
    }
    function weierstrass(c) {
      const { CURVE, curveOpts, hash, ecdsaOpts } =
        _ecdsa_legacy_opts_to_new(c);
      const Point = weierstrassN(CURVE, curveOpts);
      const signs = ecdsa(Point, hash, ecdsaOpts);
      return _ecdsa_new_output_to_legacy(c, signs);
    }
  },
});

// node_modules/@noble/curves/_shortw_utils.js
var require_shortw_utils = __commonJS({
  "node_modules/@noble/curves/_shortw_utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getHash = getHash;
    exports2.createCurve = createCurve;
    var weierstrass_ts_1 = require_weierstrass();
    function getHash(hash) {
      return { hash };
    }
    function createCurve(curveDef, defHash) {
      const create = (hash) =>
        (0, weierstrass_ts_1.weierstrass)({ ...curveDef, hash });
      return { ...create(defHash), create };
    }
  },
});

// node_modules/@noble/curves/abstract/hash-to-curve.js
var require_hash_to_curve = __commonJS({
  "node_modules/@noble/curves/abstract/hash-to-curve.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2._DST_scalar = void 0;
    exports2.expand_message_xmd = expand_message_xmd;
    exports2.expand_message_xof = expand_message_xof;
    exports2.hash_to_field = hash_to_field;
    exports2.isogenyMap = isogenyMap;
    exports2.createHasher = createHasher;
    var utils_ts_1 = require_utils7();
    var modular_ts_1 = require_modular();
    var os2ip = utils_ts_1.bytesToNumberBE;
    function i2osp(value, length) {
      anum(value);
      anum(length);
      if (value < 0 || value >= 1 << (8 * length))
        throw new Error("invalid I2OSP input: " + value);
      const res = Array.from({ length }).fill(0);
      for (let i = length - 1; i >= 0; i--) {
        res[i] = value & 255;
        value >>>= 8;
      }
      return new Uint8Array(res);
    }
    function strxor(a, b) {
      const arr = new Uint8Array(a.length);
      for (let i = 0; i < a.length; i++) {
        arr[i] = a[i] ^ b[i];
      }
      return arr;
    }
    function anum(item) {
      if (!Number.isSafeInteger(item)) throw new Error("number expected");
    }
    function normDST(DST) {
      if (!(0, utils_ts_1.isBytes)(DST) && typeof DST !== "string")
        throw new Error("DST must be Uint8Array or string");
      return typeof DST === "string" ? (0, utils_ts_1.utf8ToBytes)(DST) : DST;
    }
    function expand_message_xmd(msg, DST, lenInBytes, H) {
      (0, utils_ts_1.abytes)(msg);
      anum(lenInBytes);
      DST = normDST(DST);
      if (DST.length > 255)
        DST = H(
          (0, utils_ts_1.concatBytes)(
            (0, utils_ts_1.utf8ToBytes)("H2C-OVERSIZE-DST-"),
            DST
          )
        );
      const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
      const ell = Math.ceil(lenInBytes / b_in_bytes);
      if (lenInBytes > 65535 || ell > 255)
        throw new Error("expand_message_xmd: invalid lenInBytes");
      const DST_prime = (0, utils_ts_1.concatBytes)(DST, i2osp(DST.length, 1));
      const Z_pad = i2osp(0, r_in_bytes);
      const l_i_b_str = i2osp(lenInBytes, 2);
      const b = new Array(ell);
      const b_0 = H(
        (0, utils_ts_1.concatBytes)(
          Z_pad,
          msg,
          l_i_b_str,
          i2osp(0, 1),
          DST_prime
        )
      );
      b[0] = H((0, utils_ts_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
      for (let i = 1; i <= ell; i++) {
        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
        b[i] = H((0, utils_ts_1.concatBytes)(...args));
      }
      const pseudo_random_bytes = (0, utils_ts_1.concatBytes)(...b);
      return pseudo_random_bytes.slice(0, lenInBytes);
    }
    function expand_message_xof(msg, DST, lenInBytes, k, H) {
      (0, utils_ts_1.abytes)(msg);
      anum(lenInBytes);
      DST = normDST(DST);
      if (DST.length > 255) {
        const dkLen = Math.ceil((2 * k) / 8);
        DST = H.create({ dkLen })
          .update((0, utils_ts_1.utf8ToBytes)("H2C-OVERSIZE-DST-"))
          .update(DST)
          .digest();
      }
      if (lenInBytes > 65535 || DST.length > 255)
        throw new Error("expand_message_xof: invalid lenInBytes");
      return H.create({ dkLen: lenInBytes })
        .update(msg)
        .update(i2osp(lenInBytes, 2))
        .update(DST)
        .update(i2osp(DST.length, 1))
        .digest();
    }
    function hash_to_field(msg, count, options) {
      (0, utils_ts_1._validateObject)(options, {
        p: "bigint",
        m: "number",
        k: "number",
        hash: "function",
      });
      const { p, k, m, hash, expand, DST } = options;
      if (!(0, utils_ts_1.isHash)(options.hash))
        throw new Error("expected valid hash");
      (0, utils_ts_1.abytes)(msg);
      anum(count);
      const log2p = p.toString(2).length;
      const L = Math.ceil((log2p + k) / 8);
      const len_in_bytes = count * m * L;
      let prb;
      if (expand === "xmd") {
        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
      } else if (expand === "xof") {
        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
      } else if (expand === "_internal_pass") {
        prb = msg;
      } else {
        throw new Error('expand must be "xmd" or "xof"');
      }
      const u = new Array(count);
      for (let i = 0; i < count; i++) {
        const e = new Array(m);
        for (let j = 0; j < m; j++) {
          const elm_offset = L * (j + i * m);
          const tv = prb.subarray(elm_offset, elm_offset + L);
          e[j] = (0, modular_ts_1.mod)(os2ip(tv), p);
        }
        u[i] = e;
      }
      return u;
    }
    function isogenyMap(field, map) {
      const coeff = map.map((i) => Array.from(i).reverse());
      return (x, y) => {
        const [xn, xd, yn, yd] = coeff.map((val) =>
          val.reduce((acc, i) => field.add(field.mul(acc, x), i))
        );
        const [xd_inv, yd_inv] = (0, modular_ts_1.FpInvertBatch)(
          field,
          [xd, yd],
          true
        );
        x = field.mul(xn, xd_inv);
        y = field.mul(y, field.mul(yn, yd_inv));
        return { x, y };
      };
    }
    exports2._DST_scalar = (0, utils_ts_1.utf8ToBytes)("HashToScalar-");
    function createHasher(Point, mapToCurve, defaults) {
      if (typeof mapToCurve !== "function")
        throw new Error("mapToCurve() must be defined");
      function map(num) {
        return Point.fromAffine(mapToCurve(num));
      }
      function clear(initial) {
        const P = initial.clearCofactor();
        if (P.equals(Point.ZERO)) return Point.ZERO;
        P.assertValidity();
        return P;
      }
      return {
        defaults,
        hashToCurve(msg, options) {
          const opts = Object.assign({}, defaults, options);
          const u = hash_to_field(msg, 2, opts);
          const u0 = map(u[0]);
          const u1 = map(u[1]);
          return clear(u0.add(u1));
        },
        encodeToCurve(msg, options) {
          const optsDst = defaults.encodeDST ? { DST: defaults.encodeDST } : {};
          const opts = Object.assign({}, defaults, optsDst, options);
          const u = hash_to_field(msg, 1, opts);
          const u0 = map(u[0]);
          return clear(u0);
        },
        /** See {@link H2CHasher} */
        mapToCurve(scalars) {
          if (!Array.isArray(scalars))
            throw new Error("expected array of bigints");
          for (const i of scalars)
            if (typeof i !== "bigint")
              throw new Error("expected array of bigints");
          return clear(map(scalars));
        },
        // hash_to_scalar can produce 0: https://www.rfc-editor.org/errata/eid8393
        // RFC 9380, draft-irtf-cfrg-bbs-signatures-08
        hashToScalar(msg, options) {
          const N = Point.Fn.ORDER;
          const opts = Object.assign(
            {},
            defaults,
            { p: N, m: 1, DST: exports2._DST_scalar },
            options
          );
          return hash_to_field(msg, 1, opts)[0][0];
        },
      };
    }
  },
});

// node_modules/@noble/curves/secp256k1.js
var require_secp256k1 = __commonJS({
  "node_modules/@noble/curves/secp256k1.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encodeToCurve =
      exports2.hashToCurve =
      exports2.secp256k1_hasher =
      exports2.schnorr =
      exports2.secp256k1 =
        void 0;
    var sha2_js_1 = require_sha2();
    var utils_js_1 = require_utils();
    var _shortw_utils_ts_1 = require_shortw_utils();
    var hash_to_curve_ts_1 = require_hash_to_curve();
    var modular_ts_1 = require_modular();
    var weierstrass_ts_1 = require_weierstrass();
    var utils_ts_1 = require_utils7();
    var secp256k1_CURVE = {
      p: BigInt(
        "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"
      ),
      n: BigInt(
        "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"
      ),
      h: BigInt(1),
      a: BigInt(0),
      b: BigInt(7),
      Gx: BigInt(
        "0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"
      ),
      Gy: BigInt(
        "0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
      ),
    };
    var secp256k1_ENDO = {
      beta: BigInt(
        "0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"
      ),
      basises: [
        [
          BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
          -BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
        ],
        [
          BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),
          BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
        ],
      ],
    };
    var _0n = /* @__PURE__ */ BigInt(0);
    var _1n = /* @__PURE__ */ BigInt(1);
    var _2n = /* @__PURE__ */ BigInt(2);
    function sqrtMod(y) {
      const P = secp256k1_CURVE.p;
      const _3n = BigInt(3),
        _6n = BigInt(6),
        _11n = BigInt(11),
        _22n = BigInt(22);
      const _23n = BigInt(23),
        _44n = BigInt(44),
        _88n = BigInt(88);
      const b2 = (y * y * y) % P;
      const b3 = (b2 * b2 * y) % P;
      const b6 = ((0, modular_ts_1.pow2)(b3, _3n, P) * b3) % P;
      const b9 = ((0, modular_ts_1.pow2)(b6, _3n, P) * b3) % P;
      const b11 = ((0, modular_ts_1.pow2)(b9, _2n, P) * b2) % P;
      const b22 = ((0, modular_ts_1.pow2)(b11, _11n, P) * b11) % P;
      const b44 = ((0, modular_ts_1.pow2)(b22, _22n, P) * b22) % P;
      const b88 = ((0, modular_ts_1.pow2)(b44, _44n, P) * b44) % P;
      const b176 = ((0, modular_ts_1.pow2)(b88, _88n, P) * b88) % P;
      const b220 = ((0, modular_ts_1.pow2)(b176, _44n, P) * b44) % P;
      const b223 = ((0, modular_ts_1.pow2)(b220, _3n, P) * b3) % P;
      const t1 = ((0, modular_ts_1.pow2)(b223, _23n, P) * b22) % P;
      const t2 = ((0, modular_ts_1.pow2)(t1, _6n, P) * b2) % P;
      const root = (0, modular_ts_1.pow2)(t2, _2n, P);
      if (!Fpk1.eql(Fpk1.sqr(root), y))
        throw new Error("Cannot find square root");
      return root;
    }
    var Fpk1 = (0, modular_ts_1.Field)(secp256k1_CURVE.p, { sqrt: sqrtMod });
    exports2.secp256k1 = (0, _shortw_utils_ts_1.createCurve)(
      { ...secp256k1_CURVE, Fp: Fpk1, lowS: true, endo: secp256k1_ENDO },
      sha2_js_1.sha256
    );
    var TAGGED_HASH_PREFIXES = {};
    function taggedHash(tag, ...messages) {
      let tagP = TAGGED_HASH_PREFIXES[tag];
      if (tagP === void 0) {
        const tagH = (0, sha2_js_1.sha256)((0, utils_ts_1.utf8ToBytes)(tag));
        tagP = (0, utils_ts_1.concatBytes)(tagH, tagH);
        TAGGED_HASH_PREFIXES[tag] = tagP;
      }
      return (0, sha2_js_1.sha256)(
        (0, utils_ts_1.concatBytes)(tagP, ...messages)
      );
    }
    var pointToBytes = (point) => point.toBytes(true).slice(1);
    var Pointk1 = /* @__PURE__ */ (() => exports2.secp256k1.Point)();
    var hasEven = (y) => y % _2n === _0n;
    function schnorrGetExtPubKey(priv) {
      const { Fn, BASE } = Pointk1;
      const d_ = (0, weierstrass_ts_1._normFnElement)(Fn, priv);
      const p = BASE.multiply(d_);
      const scalar = hasEven(p.y) ? d_ : Fn.neg(d_);
      return { scalar, bytes: pointToBytes(p) };
    }
    function lift_x(x) {
      const Fp = Fpk1;
      if (!Fp.isValidNot0(x)) throw new Error("invalid x: Fail if x \u2265 p");
      const xx = Fp.create(x * x);
      const c = Fp.create(xx * x + BigInt(7));
      let y = Fp.sqrt(c);
      if (!hasEven(y)) y = Fp.neg(y);
      const p = Pointk1.fromAffine({ x, y });
      p.assertValidity();
      return p;
    }
    var num = utils_ts_1.bytesToNumberBE;
    function challenge(...args) {
      return Pointk1.Fn.create(num(taggedHash("BIP0340/challenge", ...args)));
    }
    function schnorrGetPublicKey(secretKey) {
      return schnorrGetExtPubKey(secretKey).bytes;
    }
    function schnorrSign(
      message,
      secretKey,
      auxRand = (0, utils_js_1.randomBytes)(32)
    ) {
      const { Fn } = Pointk1;
      const m = (0, utils_ts_1.ensureBytes)("message", message);
      const { bytes: px, scalar: d } = schnorrGetExtPubKey(secretKey);
      const a = (0, utils_ts_1.ensureBytes)("auxRand", auxRand, 32);
      const t = Fn.toBytes(d ^ num(taggedHash("BIP0340/aux", a)));
      const rand = taggedHash("BIP0340/nonce", t, px, m);
      const { bytes: rx, scalar: k } = schnorrGetExtPubKey(rand);
      const e = challenge(rx, px, m);
      const sig = new Uint8Array(64);
      sig.set(rx, 0);
      sig.set(Fn.toBytes(Fn.create(k + e * d)), 32);
      if (!schnorrVerify(sig, m, px))
        throw new Error("sign: Invalid signature produced");
      return sig;
    }
    function schnorrVerify(signature, message, publicKey) {
      const { Fn, BASE } = Pointk1;
      const sig = (0, utils_ts_1.ensureBytes)("signature", signature, 64);
      const m = (0, utils_ts_1.ensureBytes)("message", message);
      const pub = (0, utils_ts_1.ensureBytes)("publicKey", publicKey, 32);
      try {
        const P = lift_x(num(pub));
        const r = num(sig.subarray(0, 32));
        if (!(0, utils_ts_1.inRange)(r, _1n, secp256k1_CURVE.p)) return false;
        const s = num(sig.subarray(32, 64));
        if (!(0, utils_ts_1.inRange)(s, _1n, secp256k1_CURVE.n)) return false;
        const e = challenge(Fn.toBytes(r), pointToBytes(P), m);
        const R = BASE.multiplyUnsafe(s).add(P.multiplyUnsafe(Fn.neg(e)));
        const { x, y } = R.toAffine();
        if (R.is0() || !hasEven(y) || x !== r) return false;
        return true;
      } catch (error) {
        return false;
      }
    }
    exports2.schnorr = (() => {
      const size = 32;
      const seedLength = 48;
      const randomSecretKey = (
        seed = (0, utils_js_1.randomBytes)(seedLength)
      ) => {
        return (0, modular_ts_1.mapHashToField)(seed, secp256k1_CURVE.n);
      };
      exports2.secp256k1.utils.randomSecretKey;
      function keygen(seed) {
        const secretKey = randomSecretKey(seed);
        return { secretKey, publicKey: schnorrGetPublicKey(secretKey) };
      }
      return {
        keygen,
        getPublicKey: schnorrGetPublicKey,
        sign: schnorrSign,
        verify: schnorrVerify,
        Point: Pointk1,
        utils: {
          randomSecretKey,
          randomPrivateKey: randomSecretKey,
          taggedHash,
          // TODO: remove
          lift_x,
          pointToBytes,
          numberToBytesBE: utils_ts_1.numberToBytesBE,
          bytesToNumberBE: utils_ts_1.bytesToNumberBE,
          mod: modular_ts_1.mod,
        },
        lengths: {
          secretKey: size,
          publicKey: size,
          publicKeyHasPrefix: false,
          signature: size * 2,
          seed: seedLength,
        },
      };
    })();
    var isoMap = /* @__PURE__ */ (() =>
      (0, hash_to_curve_ts_1.isogenyMap)(
        Fpk1,
        [
          // xNum
          [
            "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
            "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
            "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
            "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c",
          ],
          // xDen
          [
            "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
            "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
            "0x0000000000000000000000000000000000000000000000000000000000000001",
            // LAST 1
          ],
          // yNum
          [
            "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
            "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
            "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
            "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84",
          ],
          // yDen
          [
            "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
            "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
            "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
            "0x0000000000000000000000000000000000000000000000000000000000000001",
            // LAST 1
          ],
        ].map((i) => i.map((j) => BigInt(j)))
      ))();
    var mapSWU = /* @__PURE__ */ (() =>
      (0, weierstrass_ts_1.mapToCurveSimpleSWU)(Fpk1, {
        A: BigInt(
          "0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"
        ),
        B: BigInt("1771"),
        Z: Fpk1.create(BigInt("-11")),
      }))();
    exports2.secp256k1_hasher = (() =>
      (0, hash_to_curve_ts_1.createHasher)(
        exports2.secp256k1.Point,
        (scalars) => {
          const { x, y } = mapSWU(Fpk1.create(scalars[0]));
          return isoMap(x, y);
        },
        {
          DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
          encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
          p: Fpk1.ORDER,
          m: 1,
          k: 128,
          expand: "xmd",
          hash: sha2_js_1.sha256,
        }
      ))();
    exports2.hashToCurve = (() => exports2.secp256k1_hasher.hashToCurve)();
    exports2.encodeToCurve = (() => exports2.secp256k1_hasher.encodeToCurve)();
  },
});

// node_modules/@noble/curves/abstract/utils.js
var require_utils8 = __commonJS({
  "node_modules/@noble/curves/abstract/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isHash =
      exports2.validateObject =
      exports2.memoized =
      exports2.notImplemented =
      exports2.createHmacDrbg =
      exports2.bitMask =
      exports2.bitSet =
      exports2.bitGet =
      exports2.bitLen =
      exports2.aInRange =
      exports2.inRange =
      exports2.asciiToBytes =
      exports2.copyBytes =
      exports2.equalBytes =
      exports2.ensureBytes =
      exports2.numberToVarBytesBE =
      exports2.numberToBytesLE =
      exports2.numberToBytesBE =
      exports2.bytesToNumberLE =
      exports2.bytesToNumberBE =
      exports2.hexToNumber =
      exports2.numberToHexUnpadded =
      exports2.abool =
      exports2.utf8ToBytes =
      exports2.randomBytes =
      exports2.isBytes =
      exports2.hexToBytes =
      exports2.concatBytes =
      exports2.bytesToUtf8 =
      exports2.bytesToHex =
      exports2.anumber =
      exports2.abytes =
        void 0;
    var u = require_utils7();
    exports2.abytes = u.abytes;
    exports2.anumber = u.anumber;
    exports2.bytesToHex = u.bytesToHex;
    exports2.bytesToUtf8 = u.bytesToUtf8;
    exports2.concatBytes = u.concatBytes;
    exports2.hexToBytes = u.hexToBytes;
    exports2.isBytes = u.isBytes;
    exports2.randomBytes = u.randomBytes;
    exports2.utf8ToBytes = u.utf8ToBytes;
    exports2.abool = u.abool;
    exports2.numberToHexUnpadded = u.numberToHexUnpadded;
    exports2.hexToNumber = u.hexToNumber;
    exports2.bytesToNumberBE = u.bytesToNumberBE;
    exports2.bytesToNumberLE = u.bytesToNumberLE;
    exports2.numberToBytesBE = u.numberToBytesBE;
    exports2.numberToBytesLE = u.numberToBytesLE;
    exports2.numberToVarBytesBE = u.numberToVarBytesBE;
    exports2.ensureBytes = u.ensureBytes;
    exports2.equalBytes = u.equalBytes;
    exports2.copyBytes = u.copyBytes;
    exports2.asciiToBytes = u.asciiToBytes;
    exports2.inRange = u.inRange;
    exports2.aInRange = u.aInRange;
    exports2.bitLen = u.bitLen;
    exports2.bitGet = u.bitGet;
    exports2.bitSet = u.bitSet;
    exports2.bitMask = u.bitMask;
    exports2.createHmacDrbg = u.createHmacDrbg;
    exports2.notImplemented = u.notImplemented;
    exports2.memoized = u.memoized;
    exports2.validateObject = u.validateObject;
    exports2.isHash = u.isHash;
  },
});

// node_modules/ripple-keypairs/dist/utils/Sha512.js
var require_Sha512 = __commonJS({
  "node_modules/ripple-keypairs/dist/utils/Sha512.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var sha512_1 = require_sha512();
    var utils_1 = require_utils8();
    var Sha512 = class _Sha512 {
      constructor() {
        this.hash = sha512_1.sha512.create();
      }
      static half(input) {
        return new _Sha512().add(input).first256();
      }
      add(bytes) {
        this.hash.update(bytes);
        return this;
      }
      addU32(i) {
        const buffer = new Uint8Array(4);
        new DataView(buffer.buffer).setUint32(0, i);
        return this.add(buffer);
      }
      finish() {
        return this.hash.digest();
      }
      first256() {
        return this.finish().slice(0, 32);
      }
      first256BigInt() {
        return (0, utils_1.bytesToNumberBE)(this.first256());
      }
    };
    exports2.default = Sha512;
  },
});

// node_modules/ripple-keypairs/dist/signing-schemes/secp256k1/utils.js
var require_utils9 = __commonJS({
  "node_modules/ripple-keypairs/dist/signing-schemes/secp256k1/utils.js"(
    exports2
  ) {
    "use strict";
    var __importDefault =
      (exports2 && exports2.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.accountPublicFromPublicGenerator = exports2.derivePrivateKey =
      void 0;
    var secp256k1_1 = require_secp256k1();
    var Sha512_1 = __importDefault(require_Sha512());
    var ZERO = BigInt(0);
    function deriveScalar(bytes, discrim) {
      const order = secp256k1_1.secp256k1.CURVE.n;
      for (let i = 0; i <= 4294967295; i++) {
        const hasher = new Sha512_1.default().add(bytes);
        if (discrim !== void 0) {
          hasher.addU32(discrim);
        }
        hasher.addU32(i);
        const key = hasher.first256BigInt();
        if (key > ZERO && key < order) {
          return key;
        }
      }
      throw new Error("impossible unicorn ;)");
    }
    function derivePrivateKey(seed, opts = {}) {
      const root = opts.validator;
      const order = secp256k1_1.secp256k1.CURVE.n;
      const privateGen = deriveScalar(seed);
      if (root) {
        return privateGen;
      }
      const publicGen =
        secp256k1_1.secp256k1.ProjectivePoint.BASE.multiply(
          privateGen
        ).toRawBytes(true);
      const accountIndex = opts.accountIndex || 0;
      return (deriveScalar(publicGen, accountIndex) + privateGen) % order;
    }
    exports2.derivePrivateKey = derivePrivateKey;
    function accountPublicFromPublicGenerator(publicGenBytes) {
      const rootPubPoint =
        secp256k1_1.secp256k1.ProjectivePoint.fromHex(publicGenBytes);
      const scalar = deriveScalar(publicGenBytes, 0);
      const point = secp256k1_1.secp256k1.ProjectivePoint.BASE.multiply(scalar);
      const offset = rootPubPoint.add(point);
      return offset.toRawBytes(true);
    }
    exports2.accountPublicFromPublicGenerator =
      accountPublicFromPublicGenerator;
  },
});

// node_modules/ripple-keypairs/dist/utils/assert.js
var require_assert = __commonJS({
  "node_modules/ripple-keypairs/dist/utils/assert.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var assertHelper = {
      ok(cond, message) {
        if (!cond) {
          throw new Error(message);
        }
      },
    };
    exports2.default = assertHelper;
  },
});

// node_modules/ripple-keypairs/dist/utils/getAlgorithmFromKey.js
var require_getAlgorithmFromKey = __commonJS({
  "node_modules/ripple-keypairs/dist/utils/getAlgorithmFromKey.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getAlgorithmFromPrivateKey =
      exports2.getAlgorithmFromPublicKey =
      exports2.getAlgorithmFromKey =
        void 0;
    var Prefix;
    (function (Prefix2) {
      Prefix2[(Prefix2["NONE"] = -1)] = "NONE";
      Prefix2[(Prefix2["ED25519"] = 237)] = "ED25519";
      Prefix2[(Prefix2["SECP256K1_PUB_X"] = 2)] = "SECP256K1_PUB_X";
      Prefix2[(Prefix2["SECP256K1_PUB_X_ODD_Y"] = 3)] = "SECP256K1_PUB_X_ODD_Y";
      Prefix2[(Prefix2["SECP256K1_PUB_XY"] = 4)] = "SECP256K1_PUB_XY";
      Prefix2[(Prefix2["SECP256K1_PRIVATE"] = 0)] = "SECP256K1_PRIVATE";
    })(Prefix || (Prefix = {}));
    var KEY_TYPES = {
      [`private_${Prefix.NONE}_32`]: "ecdsa-secp256k1",
      [`private_${Prefix.SECP256K1_PRIVATE}_33`]: "ecdsa-secp256k1",
      [`private_${Prefix.ED25519}_33`]: "ed25519",
      [`public_${Prefix.ED25519}_33`]: "ed25519",
      [`public_${Prefix.SECP256K1_PUB_X}_33`]: "ecdsa-secp256k1",
      [`public_${Prefix.SECP256K1_PUB_X_ODD_Y}_33`]: "ecdsa-secp256k1",
      [`public_${Prefix.SECP256K1_PUB_XY}_65`]: "ecdsa-secp256k1",
    };
    function getKeyInfo(key) {
      return {
        prefix: key.length < 2 ? Prefix.NONE : parseInt(key.slice(0, 2), 16),
        len: key.length / 2,
      };
    }
    function prefixRepr(prefix) {
      return prefix === Prefix.NONE
        ? "None"
        : `0x${prefix.toString(16).padStart(2, "0")}`;
    }
    function getValidFormatsTable(type) {
      const padding = 2;
      const colWidth = {
        algorithm: "ecdsa-secp256k1".length + padding,
        prefix: "0x00".length + padding,
      };
      return Object.entries(KEY_TYPES)
        .filter(([key]) => key.startsWith(type))
        .map(([key, algorithm]) => {
          const [, prefix, length] = key.split("_");
          const paddedAlgo = algorithm.padEnd(colWidth.algorithm);
          const paddedPrefix = prefixRepr(Number(prefix)).padEnd(
            colWidth.prefix
          );
          return `${paddedAlgo} - Prefix: ${paddedPrefix} Length: ${length} bytes`;
        })
        .join("\n");
    }
    function keyError({ key, type, prefix, len }) {
      const validFormats = getValidFormatsTable(type);
      return `invalid_key:

Type: ${type}
Key: ${key}
Prefix: ${prefixRepr(prefix)} 
Length: ${len} bytes

Acceptable ${type} formats are:
${validFormats}
`;
    }
    function getAlgorithmFromKey(key, type) {
      const { prefix, len } = getKeyInfo(key);
      const usedPrefix =
        type === "private" && len === 32 ? Prefix.NONE : prefix;
      const algorithm = KEY_TYPES[`${type}_${usedPrefix}_${len}`];
      if (!algorithm) {
        throw new Error(keyError({ key, type, len, prefix: usedPrefix }));
      }
      return algorithm;
    }
    exports2.getAlgorithmFromKey = getAlgorithmFromKey;
    function getAlgorithmFromPublicKey(key) {
      return getAlgorithmFromKey(key, "public");
    }
    exports2.getAlgorithmFromPublicKey = getAlgorithmFromPublicKey;
    function getAlgorithmFromPrivateKey(key) {
      return getAlgorithmFromKey(key, "private");
    }
    exports2.getAlgorithmFromPrivateKey = getAlgorithmFromPrivateKey;
  },
});

// node_modules/ripple-keypairs/dist/signing-schemes/secp256k1/index.js
var require_secp256k12 = __commonJS({
  "node_modules/ripple-keypairs/dist/signing-schemes/secp256k1/index.js"(
    exports2
  ) {
    "use strict";
    var __importDefault =
      (exports2 && exports2.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils_1 = require_utils8();
    var secp256k1_1 = require_secp256k1();
    var utils_2 = require_utils2();
    var utils_3 = require_utils9();
    var assert_1 = __importDefault(require_assert());
    var Sha512_1 = __importDefault(require_Sha512());
    var SECP256K1_PREFIX = "00";
    var secp256k1 = {
      deriveKeypair(entropy, options) {
        const derived = (0, utils_3.derivePrivateKey)(entropy, options);
        const privateKey =
          SECP256K1_PREFIX +
          (0, utils_2.bytesToHex)((0, utils_1.numberToBytesBE)(derived, 32));
        const publicKey = (0, utils_2.bytesToHex)(
          secp256k1_1.secp256k1.getPublicKey(derived, true)
        );
        return { privateKey, publicKey };
      },
      sign(message, privateKey) {
        assert_1.default.ok(
          (privateKey.length === 66 &&
            privateKey.startsWith(SECP256K1_PREFIX)) ||
            privateKey.length === 64
        );
        const normedPrivateKey =
          privateKey.length === 66 ? privateKey.slice(2) : privateKey;
        return secp256k1_1.secp256k1
          .sign(Sha512_1.default.half(message), normedPrivateKey, {
            // "Canonical" signatures
            lowS: true,
            // Would fail tests if signatures aren't deterministic
            extraEntropy: void 0,
          })
          .toDERHex(true)
          .toUpperCase();
      },
      verify(message, signature, publicKey) {
        const decoded = secp256k1_1.secp256k1.Signature.fromDER(signature);
        return secp256k1_1.secp256k1.verify(
          decoded,
          Sha512_1.default.half(message),
          publicKey
        );
      },
    };
    exports2.default = secp256k1;
  },
});

// node_modules/@noble/curves/abstract/edwards.js
var require_edwards = __commonJS({
  "node_modules/@noble/curves/abstract/edwards.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PrimeEdwardsPoint = void 0;
    exports2.edwards = edwards;
    exports2.eddsa = eddsa;
    exports2.twistedEdwards = twistedEdwards;
    var utils_ts_1 = require_utils7();
    var curve_ts_1 = require_curve();
    var modular_ts_1 = require_modular();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _8n = BigInt(8);
    function isEdValidXY(Fp, CURVE, x, y) {
      const x2 = Fp.sqr(x);
      const y2 = Fp.sqr(y);
      const left = Fp.add(Fp.mul(CURVE.a, x2), y2);
      const right = Fp.add(Fp.ONE, Fp.mul(CURVE.d, Fp.mul(x2, y2)));
      return Fp.eql(left, right);
    }
    function edwards(params, extraOpts = {}) {
      const validated = (0, curve_ts_1._createCurveFields)(
        "edwards",
        params,
        extraOpts,
        extraOpts.FpFnLE
      );
      const { Fp, Fn } = validated;
      let CURVE = validated.CURVE;
      const { h: cofactor } = CURVE;
      (0, utils_ts_1._validateObject)(extraOpts, {}, { uvRatio: "function" });
      const MASK = _2n << (BigInt(Fn.BYTES * 8) - _1n);
      const modP = (n) => Fp.create(n);
      const uvRatio =
        extraOpts.uvRatio ||
        ((u, v) => {
          try {
            return { isValid: true, value: Fp.sqrt(Fp.div(u, v)) };
          } catch (e) {
            return { isValid: false, value: _0n };
          }
        });
      if (!isEdValidXY(Fp, CURVE, CURVE.Gx, CURVE.Gy))
        throw new Error("bad curve params: generator point");
      function acoord(title, n, banZero = false) {
        const min = banZero ? _1n : _0n;
        (0, utils_ts_1.aInRange)("coordinate " + title, n, min, MASK);
        return n;
      }
      function aextpoint(other) {
        if (!(other instanceof Point))
          throw new Error("ExtendedPoint expected");
      }
      const toAffineMemo = (0, utils_ts_1.memoized)((p, iz) => {
        const { X, Y, Z } = p;
        const is0 = p.is0();
        if (iz == null) iz = is0 ? _8n : Fp.inv(Z);
        const x = modP(X * iz);
        const y = modP(Y * iz);
        const zz = Fp.mul(Z, iz);
        if (is0) return { x: _0n, y: _1n };
        if (zz !== _1n) throw new Error("invZ was invalid");
        return { x, y };
      });
      const assertValidMemo = (0, utils_ts_1.memoized)((p) => {
        const { a, d } = CURVE;
        if (p.is0()) throw new Error("bad point: ZERO");
        const { X, Y, Z, T } = p;
        const X2 = modP(X * X);
        const Y2 = modP(Y * Y);
        const Z2 = modP(Z * Z);
        const Z4 = modP(Z2 * Z2);
        const aX2 = modP(X2 * a);
        const left = modP(Z2 * modP(aX2 + Y2));
        const right = modP(Z4 + modP(d * modP(X2 * Y2)));
        if (left !== right)
          throw new Error("bad point: equation left != right (1)");
        const XY = modP(X * Y);
        const ZT = modP(Z * T);
        if (XY !== ZT) throw new Error("bad point: equation left != right (2)");
        return true;
      });
      class Point {
        constructor(X, Y, Z, T) {
          this.X = acoord("x", X);
          this.Y = acoord("y", Y);
          this.Z = acoord("z", Z, true);
          this.T = acoord("t", T);
          Object.freeze(this);
        }
        static CURVE() {
          return CURVE;
        }
        static fromAffine(p) {
          if (p instanceof Point) throw new Error("extended point not allowed");
          const { x, y } = p || {};
          acoord("x", x);
          acoord("y", y);
          return new Point(x, y, _1n, modP(x * y));
        }
        // Uses algo from RFC8032 5.1.3.
        static fromBytes(bytes, zip215 = false) {
          const len = Fp.BYTES;
          const { a, d } = CURVE;
          bytes = (0, utils_ts_1.copyBytes)(
            (0, utils_ts_1._abytes2)(bytes, len, "point")
          );
          (0, utils_ts_1._abool2)(zip215, "zip215");
          const normed = (0, utils_ts_1.copyBytes)(bytes);
          const lastByte = bytes[len - 1];
          normed[len - 1] = lastByte & ~128;
          const y = (0, utils_ts_1.bytesToNumberLE)(normed);
          const max = zip215 ? MASK : Fp.ORDER;
          (0, utils_ts_1.aInRange)("point.y", y, _0n, max);
          const y2 = modP(y * y);
          const u = modP(y2 - _1n);
          const v = modP(d * y2 - a);
          let { isValid, value: x } = uvRatio(u, v);
          if (!isValid) throw new Error("bad point: invalid y coordinate");
          const isXOdd = (x & _1n) === _1n;
          const isLastByteOdd = (lastByte & 128) !== 0;
          if (!zip215 && x === _0n && isLastByteOdd)
            throw new Error("bad point: x=0 and x_0=1");
          if (isLastByteOdd !== isXOdd) x = modP(-x);
          return Point.fromAffine({ x, y });
        }
        static fromHex(bytes, zip215 = false) {
          return Point.fromBytes(
            (0, utils_ts_1.ensureBytes)("point", bytes),
            zip215
          );
        }
        get x() {
          return this.toAffine().x;
        }
        get y() {
          return this.toAffine().y;
        }
        precompute(windowSize = 8, isLazy = true) {
          wnaf.createCache(this, windowSize);
          if (!isLazy) this.multiply(_2n);
          return this;
        }
        // Useful in fromAffine() - not for fromBytes(), which always created valid points.
        assertValidity() {
          assertValidMemo(this);
        }
        // Compare one point to another.
        equals(other) {
          aextpoint(other);
          const { X: X1, Y: Y1, Z: Z1 } = this;
          const { X: X2, Y: Y2, Z: Z2 } = other;
          const X1Z2 = modP(X1 * Z2);
          const X2Z1 = modP(X2 * Z1);
          const Y1Z2 = modP(Y1 * Z2);
          const Y2Z1 = modP(Y2 * Z1);
          return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
        }
        is0() {
          return this.equals(Point.ZERO);
        }
        negate() {
          return new Point(modP(-this.X), this.Y, this.Z, modP(-this.T));
        }
        // Fast algo for doubling Extended Point.
        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
        // Cost: 4M + 4S + 1*a + 6add + 1*2.
        double() {
          const { a } = CURVE;
          const { X: X1, Y: Y1, Z: Z1 } = this;
          const A = modP(X1 * X1);
          const B = modP(Y1 * Y1);
          const C = modP(_2n * modP(Z1 * Z1));
          const D = modP(a * A);
          const x1y1 = X1 + Y1;
          const E = modP(modP(x1y1 * x1y1) - A - B);
          const G = D + B;
          const F = G - C;
          const H = D - B;
          const X3 = modP(E * F);
          const Y3 = modP(G * H);
          const T3 = modP(E * H);
          const Z3 = modP(F * G);
          return new Point(X3, Y3, Z3, T3);
        }
        // Fast algo for adding 2 Extended Points.
        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
        // Cost: 9M + 1*a + 1*d + 7add.
        add(other) {
          aextpoint(other);
          const { a, d } = CURVE;
          const { X: X1, Y: Y1, Z: Z1, T: T1 } = this;
          const { X: X2, Y: Y2, Z: Z2, T: T2 } = other;
          const A = modP(X1 * X2);
          const B = modP(Y1 * Y2);
          const C = modP(T1 * d * T2);
          const D = modP(Z1 * Z2);
          const E = modP((X1 + Y1) * (X2 + Y2) - A - B);
          const F = D - C;
          const G = D + C;
          const H = modP(B - a * A);
          const X3 = modP(E * F);
          const Y3 = modP(G * H);
          const T3 = modP(E * H);
          const Z3 = modP(F * G);
          return new Point(X3, Y3, Z3, T3);
        }
        subtract(other) {
          return this.add(other.negate());
        }
        // Constant-time multiplication.
        multiply(scalar) {
          if (!Fn.isValidNot0(scalar))
            throw new Error("invalid scalar: expected 1 <= sc < curve.n");
          const { p, f } = wnaf.cached(this, scalar, (p2) =>
            (0, curve_ts_1.normalizeZ)(Point, p2)
          );
          return (0, curve_ts_1.normalizeZ)(Point, [p, f])[0];
        }
        // Non-constant-time multiplication. Uses double-and-add algorithm.
        // It's faster, but should only be used when you don't care about
        // an exposed private key e.g. sig verification.
        // Does NOT allow scalars higher than CURVE.n.
        // Accepts optional accumulator to merge with multiply (important for sparse scalars)
        multiplyUnsafe(scalar, acc = Point.ZERO) {
          if (!Fn.isValid(scalar))
            throw new Error("invalid scalar: expected 0 <= sc < curve.n");
          if (scalar === _0n) return Point.ZERO;
          if (this.is0() || scalar === _1n) return this;
          return wnaf.unsafe(
            this,
            scalar,
            (p) => (0, curve_ts_1.normalizeZ)(Point, p),
            acc
          );
        }
        // Checks if point is of small order.
        // If you add something to small order point, you will have "dirty"
        // point with torsion component.
        // Multiplies point by cofactor and checks if the result is 0.
        isSmallOrder() {
          return this.multiplyUnsafe(cofactor).is0();
        }
        // Multiplies point by curve order and checks if the result is 0.
        // Returns `false` is the point is dirty.
        isTorsionFree() {
          return wnaf.unsafe(this, CURVE.n).is0();
        }
        // Converts Extended point to default (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        toAffine(invertedZ) {
          return toAffineMemo(this, invertedZ);
        }
        clearCofactor() {
          if (cofactor === _1n) return this;
          return this.multiplyUnsafe(cofactor);
        }
        toBytes() {
          const { x, y } = this.toAffine();
          const bytes = Fp.toBytes(y);
          bytes[bytes.length - 1] |= x & _1n ? 128 : 0;
          return bytes;
        }
        toHex() {
          return (0, utils_ts_1.bytesToHex)(this.toBytes());
        }
        toString() {
          return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
        }
        // TODO: remove
        get ex() {
          return this.X;
        }
        get ey() {
          return this.Y;
        }
        get ez() {
          return this.Z;
        }
        get et() {
          return this.T;
        }
        static normalizeZ(points) {
          return (0, curve_ts_1.normalizeZ)(Point, points);
        }
        static msm(points, scalars) {
          return (0, curve_ts_1.pippenger)(Point, Fn, points, scalars);
        }
        _setWindowSize(windowSize) {
          this.precompute(windowSize);
        }
        toRawBytes() {
          return this.toBytes();
        }
      }
      Point.BASE = new Point(
        CURVE.Gx,
        CURVE.Gy,
        _1n,
        modP(CURVE.Gx * CURVE.Gy)
      );
      Point.ZERO = new Point(_0n, _1n, _1n, _0n);
      Point.Fp = Fp;
      Point.Fn = Fn;
      const wnaf = new curve_ts_1.wNAF(Point, Fn.BITS);
      Point.BASE.precompute(8);
      return Point;
    }
    var PrimeEdwardsPoint = class {
      constructor(ep) {
        this.ep = ep;
      }
      // Static methods that must be implemented by subclasses
      static fromBytes(_bytes) {
        (0, utils_ts_1.notImplemented)();
      }
      static fromHex(_hex) {
        (0, utils_ts_1.notImplemented)();
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      // Common implementations
      clearCofactor() {
        return this;
      }
      assertValidity() {
        this.ep.assertValidity();
      }
      toAffine(invertedZ) {
        return this.ep.toAffine(invertedZ);
      }
      toHex() {
        return (0, utils_ts_1.bytesToHex)(this.toBytes());
      }
      toString() {
        return this.toHex();
      }
      isTorsionFree() {
        return true;
      }
      isSmallOrder() {
        return false;
      }
      add(other) {
        this.assertSame(other);
        return this.init(this.ep.add(other.ep));
      }
      subtract(other) {
        this.assertSame(other);
        return this.init(this.ep.subtract(other.ep));
      }
      multiply(scalar) {
        return this.init(this.ep.multiply(scalar));
      }
      multiplyUnsafe(scalar) {
        return this.init(this.ep.multiplyUnsafe(scalar));
      }
      double() {
        return this.init(this.ep.double());
      }
      negate() {
        return this.init(this.ep.negate());
      }
      precompute(windowSize, isLazy) {
        return this.init(this.ep.precompute(windowSize, isLazy));
      }
      /** @deprecated use `toBytes` */
      toRawBytes() {
        return this.toBytes();
      }
    };
    exports2.PrimeEdwardsPoint = PrimeEdwardsPoint;
    function eddsa(Point, cHash, eddsaOpts = {}) {
      if (typeof cHash !== "function")
        throw new Error('"hash" function param is required');
      (0, utils_ts_1._validateObject)(
        eddsaOpts,
        {},
        {
          adjustScalarBytes: "function",
          randomBytes: "function",
          domain: "function",
          prehash: "function",
          mapToCurve: "function",
        }
      );
      const { prehash } = eddsaOpts;
      const { BASE, Fp, Fn } = Point;
      const randomBytes = eddsaOpts.randomBytes || utils_ts_1.randomBytes;
      const adjustScalarBytes =
        eddsaOpts.adjustScalarBytes || ((bytes) => bytes);
      const domain =
        eddsaOpts.domain ||
        ((data, ctx, phflag) => {
          (0, utils_ts_1._abool2)(phflag, "phflag");
          if (ctx.length || phflag)
            throw new Error("Contexts/pre-hash are not supported");
          return data;
        });
      function modN_LE(hash) {
        return Fn.create((0, utils_ts_1.bytesToNumberLE)(hash));
      }
      function getPrivateScalar(key) {
        const len = lengths.secretKey;
        key = (0, utils_ts_1.ensureBytes)("private key", key, len);
        const hashed = (0, utils_ts_1.ensureBytes)(
          "hashed private key",
          cHash(key),
          2 * len
        );
        const head = adjustScalarBytes(hashed.slice(0, len));
        const prefix = hashed.slice(len, 2 * len);
        const scalar = modN_LE(head);
        return { head, prefix, scalar };
      }
      function getExtendedPublicKey(secretKey) {
        const { head, prefix, scalar } = getPrivateScalar(secretKey);
        const point = BASE.multiply(scalar);
        const pointBytes = point.toBytes();
        return { head, prefix, scalar, point, pointBytes };
      }
      function getPublicKey(secretKey) {
        return getExtendedPublicKey(secretKey).pointBytes;
      }
      function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {
        const msg = (0, utils_ts_1.concatBytes)(...msgs);
        return modN_LE(
          cHash(
            domain(
              msg,
              (0, utils_ts_1.ensureBytes)("context", context),
              !!prehash
            )
          )
        );
      }
      function sign(msg, secretKey, options = {}) {
        msg = (0, utils_ts_1.ensureBytes)("message", msg);
        if (prehash) msg = prehash(msg);
        const { prefix, scalar, pointBytes } = getExtendedPublicKey(secretKey);
        const r = hashDomainToScalar(options.context, prefix, msg);
        const R = BASE.multiply(r).toBytes();
        const k = hashDomainToScalar(options.context, R, pointBytes, msg);
        const s = Fn.create(r + k * scalar);
        if (!Fn.isValid(s)) throw new Error("sign failed: invalid s");
        const rs = (0, utils_ts_1.concatBytes)(R, Fn.toBytes(s));
        return (0, utils_ts_1._abytes2)(rs, lengths.signature, "result");
      }
      const verifyOpts = { zip215: true };
      function verify(sig, msg, publicKey, options = verifyOpts) {
        const { context, zip215 } = options;
        const len = lengths.signature;
        sig = (0, utils_ts_1.ensureBytes)("signature", sig, len);
        msg = (0, utils_ts_1.ensureBytes)("message", msg);
        publicKey = (0, utils_ts_1.ensureBytes)(
          "publicKey",
          publicKey,
          lengths.publicKey
        );
        if (zip215 !== void 0) (0, utils_ts_1._abool2)(zip215, "zip215");
        if (prehash) msg = prehash(msg);
        const mid = len / 2;
        const r = sig.subarray(0, mid);
        const s = (0, utils_ts_1.bytesToNumberLE)(sig.subarray(mid, len));
        let A, R, SB;
        try {
          A = Point.fromBytes(publicKey, zip215);
          R = Point.fromBytes(r, zip215);
          SB = BASE.multiplyUnsafe(s);
        } catch (error) {
          return false;
        }
        if (!zip215 && A.isSmallOrder()) return false;
        const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);
        const RkA = R.add(A.multiplyUnsafe(k));
        return RkA.subtract(SB).clearCofactor().is0();
      }
      const _size = Fp.BYTES;
      const lengths = {
        secretKey: _size,
        publicKey: _size,
        signature: 2 * _size,
        seed: _size,
      };
      function randomSecretKey(seed = randomBytes(lengths.seed)) {
        return (0, utils_ts_1._abytes2)(seed, lengths.seed, "seed");
      }
      function keygen(seed) {
        const secretKey = utils.randomSecretKey(seed);
        return { secretKey, publicKey: getPublicKey(secretKey) };
      }
      function isValidSecretKey(key) {
        return (0, utils_ts_1.isBytes)(key) && key.length === Fn.BYTES;
      }
      function isValidPublicKey(key, zip215) {
        try {
          return !!Point.fromBytes(key, zip215);
        } catch (error) {
          return false;
        }
      }
      const utils = {
        getExtendedPublicKey,
        randomSecretKey,
        isValidSecretKey,
        isValidPublicKey,
        /**
         * Converts ed public key to x public key. Uses formula:
         * - ed25519:
         *   - `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`
         *   - `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`
         * - ed448:
         *   - `(u, v) = ((y-1)/(y+1), sqrt(156324)*u/x)`
         *   - `(x, y) = (sqrt(156324)*u/v, (1+u)/(1-u))`
         */
        toMontgomery(publicKey) {
          const { y } = Point.fromBytes(publicKey);
          const size = lengths.publicKey;
          const is25519 = size === 32;
          if (!is25519 && size !== 57)
            throw new Error("only defined for 25519 and 448");
          const u = is25519
            ? Fp.div(_1n + y, _1n - y)
            : Fp.div(y - _1n, y + _1n);
          return Fp.toBytes(u);
        },
        toMontgomerySecret(secretKey) {
          const size = lengths.secretKey;
          (0, utils_ts_1._abytes2)(secretKey, size);
          const hashed = cHash(secretKey.subarray(0, size));
          return adjustScalarBytes(hashed).subarray(0, size);
        },
        /** @deprecated */
        randomPrivateKey: randomSecretKey,
        /** @deprecated */
        precompute(windowSize = 8, point = Point.BASE) {
          return point.precompute(windowSize, false);
        },
      };
      return Object.freeze({
        keygen,
        getPublicKey,
        sign,
        verify,
        utils,
        Point,
        lengths,
      });
    }
    function _eddsa_legacy_opts_to_new(c) {
      const CURVE = {
        a: c.a,
        d: c.d,
        p: c.Fp.ORDER,
        n: c.n,
        h: c.h,
        Gx: c.Gx,
        Gy: c.Gy,
      };
      const Fp = c.Fp;
      const Fn = (0, modular_ts_1.Field)(CURVE.n, c.nBitLength, true);
      const curveOpts = { Fp, Fn, uvRatio: c.uvRatio };
      const eddsaOpts = {
        randomBytes: c.randomBytes,
        adjustScalarBytes: c.adjustScalarBytes,
        domain: c.domain,
        prehash: c.prehash,
        mapToCurve: c.mapToCurve,
      };
      return { CURVE, curveOpts, hash: c.hash, eddsaOpts };
    }
    function _eddsa_new_output_to_legacy(c, eddsa2) {
      const Point = eddsa2.Point;
      const legacy = Object.assign({}, eddsa2, {
        ExtendedPoint: Point,
        CURVE: c,
        nBitLength: Point.Fn.BITS,
        nByteLength: Point.Fn.BYTES,
      });
      return legacy;
    }
    function twistedEdwards(c) {
      const { CURVE, curveOpts, hash, eddsaOpts } =
        _eddsa_legacy_opts_to_new(c);
      const Point = edwards(CURVE, curveOpts);
      const EDDSA = eddsa(Point, hash, eddsaOpts);
      return _eddsa_new_output_to_legacy(c, EDDSA);
    }
  },
});

// node_modules/@noble/curves/abstract/montgomery.js
var require_montgomery = __commonJS({
  "node_modules/@noble/curves/abstract/montgomery.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.montgomery = montgomery;
    var utils_ts_1 = require_utils7();
    var modular_ts_1 = require_modular();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    function validateOpts(curve) {
      (0, utils_ts_1._validateObject)(curve, {
        adjustScalarBytes: "function",
        powPminus2: "function",
      });
      return Object.freeze({ ...curve });
    }
    function montgomery(curveDef) {
      const CURVE = validateOpts(curveDef);
      const {
        P,
        type,
        adjustScalarBytes,
        powPminus2,
        randomBytes: rand,
      } = CURVE;
      const is25519 = type === "x25519";
      if (!is25519 && type !== "x448") throw new Error("invalid type");
      const randomBytes_ = rand || utils_ts_1.randomBytes;
      const montgomeryBits = is25519 ? 255 : 448;
      const fieldLen = is25519 ? 32 : 56;
      const Gu = is25519 ? BigInt(9) : BigInt(5);
      const a24 = is25519 ? BigInt(121665) : BigInt(39081);
      const minScalar = is25519 ? _2n ** BigInt(254) : _2n ** BigInt(447);
      const maxAdded = is25519
        ? BigInt(8) * _2n ** BigInt(251) - _1n
        : BigInt(4) * _2n ** BigInt(445) - _1n;
      const maxScalar = minScalar + maxAdded + _1n;
      const modP = (n) => (0, modular_ts_1.mod)(n, P);
      const GuBytes = encodeU(Gu);
      function encodeU(u) {
        return (0, utils_ts_1.numberToBytesLE)(modP(u), fieldLen);
      }
      function decodeU(u) {
        const _u = (0, utils_ts_1.ensureBytes)("u coordinate", u, fieldLen);
        if (is25519) _u[31] &= 127;
        return modP((0, utils_ts_1.bytesToNumberLE)(_u));
      }
      function decodeScalar(scalar) {
        return (0, utils_ts_1.bytesToNumberLE)(
          adjustScalarBytes(
            (0, utils_ts_1.ensureBytes)("scalar", scalar, fieldLen)
          )
        );
      }
      function scalarMult(scalar, u) {
        const pu = montgomeryLadder(decodeU(u), decodeScalar(scalar));
        if (pu === _0n)
          throw new Error("invalid private or public key received");
        return encodeU(pu);
      }
      function scalarMultBase(scalar) {
        return scalarMult(scalar, GuBytes);
      }
      function cswap(swap, x_2, x_3) {
        const dummy = modP(swap * (x_2 - x_3));
        x_2 = modP(x_2 - dummy);
        x_3 = modP(x_3 + dummy);
        return { x_2, x_3 };
      }
      function montgomeryLadder(u, scalar) {
        (0, utils_ts_1.aInRange)("u", u, _0n, P);
        (0, utils_ts_1.aInRange)("scalar", scalar, minScalar, maxScalar);
        const k = scalar;
        const x_1 = u;
        let x_2 = _1n;
        let z_2 = _0n;
        let x_3 = u;
        let z_3 = _1n;
        let swap = _0n;
        for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {
          const k_t = (k >> t) & _1n;
          swap ^= k_t;
          ({ x_2, x_3 } = cswap(swap, x_2, x_3));
          ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
          swap = k_t;
          const A = x_2 + z_2;
          const AA = modP(A * A);
          const B = x_2 - z_2;
          const BB = modP(B * B);
          const E = AA - BB;
          const C = x_3 + z_3;
          const D = x_3 - z_3;
          const DA = modP(D * A);
          const CB = modP(C * B);
          const dacb = DA + CB;
          const da_cb = DA - CB;
          x_3 = modP(dacb * dacb);
          z_3 = modP(x_1 * modP(da_cb * da_cb));
          x_2 = modP(AA * BB);
          z_2 = modP(E * (AA + modP(a24 * E)));
        }
        ({ x_2, x_3 } = cswap(swap, x_2, x_3));
        ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
        const z2 = powPminus2(z_2);
        return modP(x_2 * z2);
      }
      const lengths = {
        secretKey: fieldLen,
        publicKey: fieldLen,
        seed: fieldLen,
      };
      const randomSecretKey = (seed = randomBytes_(fieldLen)) => {
        (0, utils_ts_1.abytes)(seed, lengths.seed);
        return seed;
      };
      function keygen(seed) {
        const secretKey = randomSecretKey(seed);
        return { secretKey, publicKey: scalarMultBase(secretKey) };
      }
      const utils = {
        randomSecretKey,
        randomPrivateKey: randomSecretKey,
      };
      return {
        keygen,
        getSharedSecret: (secretKey, publicKey) =>
          scalarMult(secretKey, publicKey),
        getPublicKey: (secretKey) => scalarMultBase(secretKey),
        scalarMult,
        scalarMultBase,
        utils,
        GuBytes: GuBytes.slice(),
        lengths,
      };
    }
  },
});

// node_modules/@noble/curves/ed25519.js
var require_ed25519 = __commonJS({
  "node_modules/@noble/curves/ed25519.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hash_to_ristretto255 =
      exports2.hashToRistretto255 =
      exports2.encodeToCurve =
      exports2.hashToCurve =
      exports2.RistrettoPoint =
      exports2.edwardsToMontgomery =
      exports2.ED25519_TORSION_SUBGROUP =
      exports2.ristretto255_hasher =
      exports2.ristretto255 =
      exports2.ed25519_hasher =
      exports2.x25519 =
      exports2.ed25519ph =
      exports2.ed25519ctx =
      exports2.ed25519 =
        void 0;
    exports2.edwardsToMontgomeryPub = edwardsToMontgomeryPub;
    exports2.edwardsToMontgomeryPriv = edwardsToMontgomeryPriv;
    var sha2_js_1 = require_sha2();
    var utils_js_1 = require_utils();
    var curve_ts_1 = require_curve();
    var edwards_ts_1 = require_edwards();
    var hash_to_curve_ts_1 = require_hash_to_curve();
    var modular_ts_1 = require_modular();
    var montgomery_ts_1 = require_montgomery();
    var utils_ts_1 = require_utils7();
    var _0n = /* @__PURE__ */ BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _5n = BigInt(5);
    var _8n = BigInt(8);
    var ed25519_CURVE_p = BigInt(
      "0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"
    );
    var ed25519_CURVE = /* @__PURE__ */ (() => ({
      p: ed25519_CURVE_p,
      n: BigInt(
        "0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"
      ),
      h: _8n,
      a: BigInt(
        "0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"
      ),
      d: BigInt(
        "0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"
      ),
      Gx: BigInt(
        "0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"
      ),
      Gy: BigInt(
        "0x6666666666666666666666666666666666666666666666666666666666666658"
      ),
    }))();
    function ed25519_pow_2_252_3(x) {
      const _10n = BigInt(10),
        _20n = BigInt(20),
        _40n = BigInt(40),
        _80n = BigInt(80);
      const P = ed25519_CURVE_p;
      const x2 = (x * x) % P;
      const b2 = (x2 * x) % P;
      const b4 = ((0, modular_ts_1.pow2)(b2, _2n, P) * b2) % P;
      const b5 = ((0, modular_ts_1.pow2)(b4, _1n, P) * x) % P;
      const b10 = ((0, modular_ts_1.pow2)(b5, _5n, P) * b5) % P;
      const b20 = ((0, modular_ts_1.pow2)(b10, _10n, P) * b10) % P;
      const b40 = ((0, modular_ts_1.pow2)(b20, _20n, P) * b20) % P;
      const b80 = ((0, modular_ts_1.pow2)(b40, _40n, P) * b40) % P;
      const b160 = ((0, modular_ts_1.pow2)(b80, _80n, P) * b80) % P;
      const b240 = ((0, modular_ts_1.pow2)(b160, _80n, P) * b80) % P;
      const b250 = ((0, modular_ts_1.pow2)(b240, _10n, P) * b10) % P;
      const pow_p_5_8 = ((0, modular_ts_1.pow2)(b250, _2n, P) * x) % P;
      return { pow_p_5_8, b2 };
    }
    function adjustScalarBytes(bytes) {
      bytes[0] &= 248;
      bytes[31] &= 127;
      bytes[31] |= 64;
      return bytes;
    }
    var ED25519_SQRT_M1 = /* @__PURE__ */ BigInt(
      "19681161376707505956807079304988542015446066515923890162744021073123829784752"
    );
    function uvRatio(u, v) {
      const P = ed25519_CURVE_p;
      const v3 = (0, modular_ts_1.mod)(v * v * v, P);
      const v7 = (0, modular_ts_1.mod)(v3 * v3 * v, P);
      const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
      let x = (0, modular_ts_1.mod)(u * v3 * pow, P);
      const vx2 = (0, modular_ts_1.mod)(v * x * x, P);
      const root1 = x;
      const root2 = (0, modular_ts_1.mod)(x * ED25519_SQRT_M1, P);
      const useRoot1 = vx2 === u;
      const useRoot2 = vx2 === (0, modular_ts_1.mod)(-u, P);
      const noRoot = vx2 === (0, modular_ts_1.mod)(-u * ED25519_SQRT_M1, P);
      if (useRoot1) x = root1;
      if (useRoot2 || noRoot) x = root2;
      if ((0, modular_ts_1.isNegativeLE)(x, P))
        x = (0, modular_ts_1.mod)(-x, P);
      return { isValid: useRoot1 || useRoot2, value: x };
    }
    var Fp = /* @__PURE__ */ (() =>
      (0, modular_ts_1.Field)(ed25519_CURVE.p, { isLE: true }))();
    var Fn = /* @__PURE__ */ (() =>
      (0, modular_ts_1.Field)(ed25519_CURVE.n, { isLE: true }))();
    var ed25519Defaults = /* @__PURE__ */ (() => ({
      ...ed25519_CURVE,
      Fp,
      hash: sha2_js_1.sha512,
      adjustScalarBytes,
      // dom2
      // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
      // Constant-time, u/v
      uvRatio,
    }))();
    exports2.ed25519 = (() =>
      (0, edwards_ts_1.twistedEdwards)(ed25519Defaults))();
    function ed25519_domain(data, ctx, phflag) {
      if (ctx.length > 255) throw new Error("Context is too big");
      return (0, utils_js_1.concatBytes)(
        (0, utils_js_1.utf8ToBytes)("SigEd25519 no Ed25519 collisions"),
        new Uint8Array([phflag ? 1 : 0, ctx.length]),
        ctx,
        data
      );
    }
    exports2.ed25519ctx = (() =>
      (0, edwards_ts_1.twistedEdwards)({
        ...ed25519Defaults,
        domain: ed25519_domain,
      }))();
    exports2.ed25519ph = (() =>
      (0, edwards_ts_1.twistedEdwards)(
        Object.assign({}, ed25519Defaults, {
          domain: ed25519_domain,
          prehash: sha2_js_1.sha512,
        })
      ))();
    exports2.x25519 = (() => {
      const P = Fp.ORDER;
      return (0, montgomery_ts_1.montgomery)({
        P,
        type: "x25519",
        powPminus2: (x) => {
          const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);
          return (0, modular_ts_1.mod)(
            (0, modular_ts_1.pow2)(pow_p_5_8, _3n, P) * b2,
            P
          );
        },
        adjustScalarBytes,
      });
    })();
    var ELL2_C1 = /* @__PURE__ */ (() => (ed25519_CURVE_p + _3n) / _8n)();
    var ELL2_C2 = /* @__PURE__ */ (() => Fp.pow(_2n, ELL2_C1))();
    var ELL2_C3 = /* @__PURE__ */ (() => Fp.sqrt(Fp.neg(Fp.ONE)))();
    function map_to_curve_elligator2_curve25519(u) {
      const ELL2_C4 = (ed25519_CURVE_p - _5n) / _8n;
      const ELL2_J = BigInt(486662);
      let tv1 = Fp.sqr(u);
      tv1 = Fp.mul(tv1, _2n);
      let xd = Fp.add(tv1, Fp.ONE);
      let x1n = Fp.neg(ELL2_J);
      let tv2 = Fp.sqr(xd);
      let gxd = Fp.mul(tv2, xd);
      let gx1 = Fp.mul(tv1, ELL2_J);
      gx1 = Fp.mul(gx1, x1n);
      gx1 = Fp.add(gx1, tv2);
      gx1 = Fp.mul(gx1, x1n);
      let tv3 = Fp.sqr(gxd);
      tv2 = Fp.sqr(tv3);
      tv3 = Fp.mul(tv3, gxd);
      tv3 = Fp.mul(tv3, gx1);
      tv2 = Fp.mul(tv2, tv3);
      let y11 = Fp.pow(tv2, ELL2_C4);
      y11 = Fp.mul(y11, tv3);
      let y12 = Fp.mul(y11, ELL2_C3);
      tv2 = Fp.sqr(y11);
      tv2 = Fp.mul(tv2, gxd);
      let e1 = Fp.eql(tv2, gx1);
      let y1 = Fp.cmov(y12, y11, e1);
      let x2n = Fp.mul(x1n, tv1);
      let y21 = Fp.mul(y11, u);
      y21 = Fp.mul(y21, ELL2_C2);
      let y22 = Fp.mul(y21, ELL2_C3);
      let gx2 = Fp.mul(gx1, tv1);
      tv2 = Fp.sqr(y21);
      tv2 = Fp.mul(tv2, gxd);
      let e2 = Fp.eql(tv2, gx2);
      let y2 = Fp.cmov(y22, y21, e2);
      tv2 = Fp.sqr(y1);
      tv2 = Fp.mul(tv2, gxd);
      let e3 = Fp.eql(tv2, gx1);
      let xn = Fp.cmov(x2n, x1n, e3);
      let y = Fp.cmov(y2, y1, e3);
      let e4 = Fp.isOdd(y);
      y = Fp.cmov(y, Fp.neg(y), e3 !== e4);
      return { xMn: xn, xMd: xd, yMn: y, yMd: _1n };
    }
    var ELL2_C1_EDWARDS = /* @__PURE__ */ (() =>
      (0, modular_ts_1.FpSqrtEven)(Fp, Fp.neg(BigInt(486664))))();
    function map_to_curve_elligator2_edwards25519(u) {
      const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u);
      let xn = Fp.mul(xMn, yMd);
      xn = Fp.mul(xn, ELL2_C1_EDWARDS);
      let xd = Fp.mul(xMd, yMn);
      let yn = Fp.sub(xMn, xMd);
      let yd = Fp.add(xMn, xMd);
      let tv1 = Fp.mul(xd, yd);
      let e = Fp.eql(tv1, Fp.ZERO);
      xn = Fp.cmov(xn, Fp.ZERO, e);
      xd = Fp.cmov(xd, Fp.ONE, e);
      yn = Fp.cmov(yn, Fp.ONE, e);
      yd = Fp.cmov(yd, Fp.ONE, e);
      const [xd_inv, yd_inv] = (0, modular_ts_1.FpInvertBatch)(
        Fp,
        [xd, yd],
        true
      );
      return { x: Fp.mul(xn, xd_inv), y: Fp.mul(yn, yd_inv) };
    }
    exports2.ed25519_hasher = (() =>
      (0, hash_to_curve_ts_1.createHasher)(
        exports2.ed25519.Point,
        (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]),
        {
          DST: "edwards25519_XMD:SHA-512_ELL2_RO_",
          encodeDST: "edwards25519_XMD:SHA-512_ELL2_NU_",
          p: ed25519_CURVE_p,
          m: 1,
          k: 128,
          expand: "xmd",
          hash: sha2_js_1.sha512,
        }
      ))();
    var SQRT_M1 = ED25519_SQRT_M1;
    var SQRT_AD_MINUS_ONE = /* @__PURE__ */ BigInt(
      "25063068953384623474111414158702152701244531502492656460079210482610430750235"
    );
    var INVSQRT_A_MINUS_D = /* @__PURE__ */ BigInt(
      "54469307008909316920995813868745141605393597292927456921205312896311721017578"
    );
    var ONE_MINUS_D_SQ = /* @__PURE__ */ BigInt(
      "1159843021668779879193775521855586647937357759715417654439879720876111806838"
    );
    var D_MINUS_ONE_SQ = /* @__PURE__ */ BigInt(
      "40440834346308536858101042469323190826248399146238708352240133220865137265952"
    );
    var invertSqrt = (number) => uvRatio(_1n, number);
    var MAX_255B = /* @__PURE__ */ BigInt(
      "0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
    );
    var bytes255ToNumberLE = (bytes) =>
      exports2.ed25519.Point.Fp.create(
        (0, utils_ts_1.bytesToNumberLE)(bytes) & MAX_255B
      );
    function calcElligatorRistrettoMap(r0) {
      const { d } = ed25519_CURVE;
      const P = ed25519_CURVE_p;
      const mod = (n) => Fp.create(n);
      const r = mod(SQRT_M1 * r0 * r0);
      const Ns = mod((r + _1n) * ONE_MINUS_D_SQ);
      let c = BigInt(-1);
      const D = mod((c - d * r) * mod(r + d));
      let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);
      let s_ = mod(s * r0);
      if (!(0, modular_ts_1.isNegativeLE)(s_, P)) s_ = mod(-s_);
      if (!Ns_D_is_sq) s = s_;
      if (!Ns_D_is_sq) c = r;
      const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D);
      const s2 = s * s;
      const W0 = mod((s + s) * D);
      const W1 = mod(Nt * SQRT_AD_MINUS_ONE);
      const W2 = mod(_1n - s2);
      const W3 = mod(_1n + s2);
      return new exports2.ed25519.Point(
        mod(W0 * W3),
        mod(W2 * W1),
        mod(W1 * W3),
        mod(W0 * W2)
      );
    }
    function ristretto255_map(bytes) {
      (0, utils_js_1.abytes)(bytes, 64);
      const r1 = bytes255ToNumberLE(bytes.subarray(0, 32));
      const R1 = calcElligatorRistrettoMap(r1);
      const r2 = bytes255ToNumberLE(bytes.subarray(32, 64));
      const R2 = calcElligatorRistrettoMap(r2);
      return new _RistrettoPoint(R1.add(R2));
    }
    var _RistrettoPoint = class __RistrettoPoint extends edwards_ts_1.PrimeEdwardsPoint {
      constructor(ep) {
        super(ep);
      }
      static fromAffine(ap) {
        return new __RistrettoPoint(exports2.ed25519.Point.fromAffine(ap));
      }
      assertSame(other) {
        if (!(other instanceof __RistrettoPoint))
          throw new Error("RistrettoPoint expected");
      }
      init(ep) {
        return new __RistrettoPoint(ep);
      }
      /** @deprecated use `import { ristretto255_hasher } from '@noble/curves/ed25519.js';` */
      static hashToCurve(hex) {
        return ristretto255_map(
          (0, utils_ts_1.ensureBytes)("ristrettoHash", hex, 64)
        );
      }
      static fromBytes(bytes) {
        (0, utils_js_1.abytes)(bytes, 32);
        const { a, d } = ed25519_CURVE;
        const P = ed25519_CURVE_p;
        const mod = (n) => Fp.create(n);
        const s = bytes255ToNumberLE(bytes);
        if (
          !(0, utils_ts_1.equalBytes)(Fp.toBytes(s), bytes) ||
          (0, modular_ts_1.isNegativeLE)(s, P)
        )
          throw new Error("invalid ristretto255 encoding 1");
        const s2 = mod(s * s);
        const u1 = mod(_1n + a * s2);
        const u2 = mod(_1n - a * s2);
        const u1_2 = mod(u1 * u1);
        const u2_2 = mod(u2 * u2);
        const v = mod(a * d * u1_2 - u2_2);
        const { isValid, value: I } = invertSqrt(mod(v * u2_2));
        const Dx = mod(I * u2);
        const Dy = mod(I * Dx * v);
        let x = mod((s + s) * Dx);
        if ((0, modular_ts_1.isNegativeLE)(x, P)) x = mod(-x);
        const y = mod(u1 * Dy);
        const t = mod(x * y);
        if (!isValid || (0, modular_ts_1.isNegativeLE)(t, P) || y === _0n)
          throw new Error("invalid ristretto255 encoding 2");
        return new __RistrettoPoint(new exports2.ed25519.Point(x, y, _1n, t));
      }
      /**
       * Converts ristretto-encoded string to ristretto point.
       * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-decode).
       * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding
       */
      static fromHex(hex) {
        return __RistrettoPoint.fromBytes(
          (0, utils_ts_1.ensureBytes)("ristrettoHex", hex, 32)
        );
      }
      static msm(points, scalars) {
        return (0, curve_ts_1.pippenger)(
          __RistrettoPoint,
          exports2.ed25519.Point.Fn,
          points,
          scalars
        );
      }
      /**
       * Encodes ristretto point to Uint8Array.
       * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-encode).
       */
      toBytes() {
        let { X, Y, Z, T } = this.ep;
        const P = ed25519_CURVE_p;
        const mod = (n) => Fp.create(n);
        const u1 = mod(mod(Z + Y) * mod(Z - Y));
        const u2 = mod(X * Y);
        const u2sq = mod(u2 * u2);
        const { value: invsqrt } = invertSqrt(mod(u1 * u2sq));
        const D1 = mod(invsqrt * u1);
        const D2 = mod(invsqrt * u2);
        const zInv = mod(D1 * D2 * T);
        let D;
        if ((0, modular_ts_1.isNegativeLE)(T * zInv, P)) {
          let _x = mod(Y * SQRT_M1);
          let _y = mod(X * SQRT_M1);
          X = _x;
          Y = _y;
          D = mod(D1 * INVSQRT_A_MINUS_D);
        } else {
          D = D2;
        }
        if ((0, modular_ts_1.isNegativeLE)(X * zInv, P)) Y = mod(-Y);
        let s = mod((Z - Y) * D);
        if ((0, modular_ts_1.isNegativeLE)(s, P)) s = mod(-s);
        return Fp.toBytes(s);
      }
      /**
       * Compares two Ristretto points.
       * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-equals).
       */
      equals(other) {
        this.assertSame(other);
        const { X: X1, Y: Y1 } = this.ep;
        const { X: X2, Y: Y2 } = other.ep;
        const mod = (n) => Fp.create(n);
        const one = mod(X1 * Y2) === mod(Y1 * X2);
        const two = mod(Y1 * Y2) === mod(X1 * X2);
        return one || two;
      }
      is0() {
        return this.equals(__RistrettoPoint.ZERO);
      }
    };
    _RistrettoPoint.BASE = /* @__PURE__ */ (() =>
      new _RistrettoPoint(exports2.ed25519.Point.BASE))();
    _RistrettoPoint.ZERO = /* @__PURE__ */ (() =>
      new _RistrettoPoint(exports2.ed25519.Point.ZERO))();
    _RistrettoPoint.Fp = /* @__PURE__ */ (() => Fp)();
    _RistrettoPoint.Fn = /* @__PURE__ */ (() => Fn)();
    exports2.ristretto255 = { Point: _RistrettoPoint };
    exports2.ristretto255_hasher = {
      hashToCurve(msg, options) {
        const DST = options?.DST || "ristretto255_XMD:SHA-512_R255MAP_RO_";
        const xmd = (0, hash_to_curve_ts_1.expand_message_xmd)(
          msg,
          DST,
          64,
          sha2_js_1.sha512
        );
        return ristretto255_map(xmd);
      },
      hashToScalar(msg, options = { DST: hash_to_curve_ts_1._DST_scalar }) {
        const xmd = (0, hash_to_curve_ts_1.expand_message_xmd)(
          msg,
          options.DST,
          64,
          sha2_js_1.sha512
        );
        return Fn.create((0, utils_ts_1.bytesToNumberLE)(xmd));
      },
    };
    exports2.ED25519_TORSION_SUBGROUP = [
      "0100000000000000000000000000000000000000000000000000000000000000",
      "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a",
      "0000000000000000000000000000000000000000000000000000000000000080",
      "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05",
      "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
      "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85",
      "0000000000000000000000000000000000000000000000000000000000000000",
      "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa",
    ];
    function edwardsToMontgomeryPub(edwardsPub) {
      return exports2.ed25519.utils.toMontgomery(
        (0, utils_ts_1.ensureBytes)("pub", edwardsPub)
      );
    }
    exports2.edwardsToMontgomery = edwardsToMontgomeryPub;
    function edwardsToMontgomeryPriv(edwardsPriv) {
      return exports2.ed25519.utils.toMontgomerySecret(
        (0, utils_ts_1.ensureBytes)("pub", edwardsPriv)
      );
    }
    exports2.RistrettoPoint = _RistrettoPoint;
    exports2.hashToCurve = (() => exports2.ed25519_hasher.hashToCurve)();
    exports2.encodeToCurve = (() => exports2.ed25519_hasher.encodeToCurve)();
    exports2.hashToRistretto255 = (() =>
      exports2.ristretto255_hasher.hashToCurve)();
    exports2.hash_to_ristretto255 = (() =>
      exports2.ristretto255_hasher.hashToCurve)();
  },
});

// node_modules/ripple-keypairs/dist/signing-schemes/ed25519/index.js
var require_ed255192 = __commonJS({
  "node_modules/ripple-keypairs/dist/signing-schemes/ed25519/index.js"(
    exports2
  ) {
    "use strict";
    var __importDefault =
      (exports2 && exports2.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ed25519_1 = require_ed25519();
    var utils_1 = require_utils2();
    var assert_1 = __importDefault(require_assert());
    var Sha512_1 = __importDefault(require_Sha512());
    var ED_PREFIX = "ED";
    var ed25519 = {
      deriveKeypair(entropy) {
        const rawPrivateKey = Sha512_1.default.half(entropy);
        const privateKey = ED_PREFIX + (0, utils_1.bytesToHex)(rawPrivateKey);
        const publicKey =
          ED_PREFIX +
          (0, utils_1.bytesToHex)(
            ed25519_1.ed25519.getPublicKey(rawPrivateKey)
          );
        return { privateKey, publicKey };
      },
      sign(message, privateKey) {
        assert_1.default.ok(
          message instanceof Uint8Array,
          "message must be array of octets"
        );
        assert_1.default.ok(
          privateKey.length === 66,
          "private key must be 33 bytes including prefix"
        );
        return (0, utils_1.bytesToHex)(
          ed25519_1.ed25519.sign(message, privateKey.slice(2))
        );
      },
      verify(message, signature, publicKey) {
        assert_1.default.ok(
          publicKey.length === 66,
          "public key must be 33 bytes including prefix"
        );
        return ed25519_1.ed25519.verify(
          signature,
          message,
          // Remove the 0xED prefix
          publicKey.slice(2),
          // By default, set zip215 to false for compatibility reasons.
          // ZIP 215 is a stricter Ed25519 signature verification scheme.
          // However, setting it to false adheres to the more commonly used
          // RFC8032 / NIST186-5 standards, making it compatible with systems
          // like the XRP Ledger.
          { zip215: false }
        );
      },
    };
    exports2.default = ed25519;
  },
});

// node_modules/ripple-keypairs/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/ripple-keypairs/dist/index.js"(exports2) {
    "use strict";
    var __importDefault =
      (exports2 && exports2.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeSeed =
      exports2.deriveNodeAddress =
      exports2.deriveAddress =
      exports2.verify =
      exports2.sign =
      exports2.deriveKeypair =
      exports2.generateSeed =
        void 0;
    var ripple_address_codec_1 = require_dist();
    Object.defineProperty(exports2, "decodeSeed", {
      enumerable: true,
      get: function () {
        return ripple_address_codec_1.decodeSeed;
      },
    });
    var ripemd160_1 = require_ripemd160();
    var sha256_1 = require_sha256();
    var utils_1 = require_utils2();
    var utils_2 = require_utils9();
    var Sha512_1 = __importDefault(require_Sha512());
    var assert_1 = __importDefault(require_assert());
    var getAlgorithmFromKey_1 = require_getAlgorithmFromKey();
    var secp256k1_1 = __importDefault(require_secp256k12());
    var ed25519_1 = __importDefault(require_ed255192());
    function getSigningScheme(algorithm) {
      const schemes = {
        "ecdsa-secp256k1": secp256k1_1.default,
        ed25519: ed25519_1.default,
      };
      return schemes[algorithm];
    }
    function generateSeed(options = {}) {
      assert_1.default.ok(
        !options.entropy || options.entropy.length >= 16,
        "entropy too short"
      );
      const entropy = options.entropy
        ? options.entropy.slice(0, 16)
        : (0, utils_1.randomBytes)(16);
      const type = options.algorithm === "ed25519" ? "ed25519" : "secp256k1";
      return (0, ripple_address_codec_1.encodeSeed)(entropy, type);
    }
    exports2.generateSeed = generateSeed;
    function deriveKeypair(seed, options) {
      var _a;
      const decoded = (0, ripple_address_codec_1.decodeSeed)(seed);
      const proposedAlgorithm =
        (_a =
          options === null || options === void 0
            ? void 0
            : options.algorithm) !== null && _a !== void 0
          ? _a
          : decoded.type;
      const algorithm =
        proposedAlgorithm === "ed25519" ? "ed25519" : "ecdsa-secp256k1";
      const scheme = getSigningScheme(algorithm);
      const keypair = scheme.deriveKeypair(decoded.bytes, options);
      const messageToVerify = Sha512_1.default.half(
        "This test message should verify."
      );
      const signature = scheme.sign(messageToVerify, keypair.privateKey);
      if (!scheme.verify(messageToVerify, signature, keypair.publicKey)) {
        throw new Error(
          "derived keypair did not generate verifiable signature"
        );
      }
      return keypair;
    }
    exports2.deriveKeypair = deriveKeypair;
    function sign(messageHex, privateKey) {
      const algorithm = (0, getAlgorithmFromKey_1.getAlgorithmFromPrivateKey)(
        privateKey
      );
      return getSigningScheme(algorithm).sign(
        (0, utils_1.hexToBytes)(messageHex),
        privateKey
      );
    }
    exports2.sign = sign;
    function verify(messageHex, signature, publicKey) {
      const algorithm = (0, getAlgorithmFromKey_1.getAlgorithmFromPublicKey)(
        publicKey
      );
      return getSigningScheme(algorithm).verify(
        (0, utils_1.hexToBytes)(messageHex),
        signature,
        publicKey
      );
    }
    exports2.verify = verify;
    function computePublicKeyHash(publicKeyBytes) {
      return (0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(publicKeyBytes));
    }
    function deriveAddressFromBytes(publicKeyBytes) {
      return (0, ripple_address_codec_1.encodeAccountID)(
        computePublicKeyHash(publicKeyBytes)
      );
    }
    function deriveAddress(publicKey) {
      return deriveAddressFromBytes((0, utils_1.hexToBytes)(publicKey));
    }
    exports2.deriveAddress = deriveAddress;
    function deriveNodeAddress(publicKey) {
      const generatorBytes = (0, ripple_address_codec_1.decodeNodePublic)(
        publicKey
      );
      const accountPublicBytes = (0, utils_2.accountPublicFromPublicGenerator)(
        generatorBytes
      );
      return deriveAddressFromBytes(accountPublicBytes);
    }
    exports2.deriveNodeAddress = deriveNodeAddress;
  },
});

// node_modules/xrpl/dist/npm/utils/derive.js
var require_derive = __commonJS({
  "node_modules/xrpl/dist/npm/utils/derive.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.deriveXAddress =
      exports2.deriveAddress =
      exports2.deriveKeypair =
        void 0;
    var ripple_address_codec_1 = require_dist();
    var ripple_keypairs_1 = require_dist3();
    Object.defineProperty(exports2, "deriveKeypair", {
      enumerable: true,
      get: function () {
        return ripple_keypairs_1.deriveKeypair;
      },
    });
    Object.defineProperty(exports2, "deriveAddress", {
      enumerable: true,
      get: function () {
        return ripple_keypairs_1.deriveAddress;
      },
    });
    function deriveXAddress(options) {
      const classicAddress = (0, ripple_keypairs_1.deriveAddress)(
        options.publicKey
      );
      return (0, ripple_address_codec_1.classicAddressToXAddress)(
        classicAddress,
        options.tag,
        options.test
      );
    }
    exports2.deriveXAddress = deriveXAddress;
  },
});

// node_modules/xrpl/dist/npm/utils/collections.js
var require_collections = __commonJS({
  "node_modules/xrpl/dist/npm/utils/collections.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.omitBy = exports2.groupBy = void 0;
    function groupBy(array, iteratee) {
      function predicate(acc, value, index, arrayReference) {
        const key = iteratee(value, index, arrayReference) || 0;
        const group = acc[key] || [];
        group.push(value);
        acc[key] = group;
        return acc;
      }
      return array.reduce(predicate, {});
    }
    exports2.groupBy = groupBy;
    function omitBy(obj, predicate) {
      const keys = Object.keys(obj);
      const keysToKeep = keys.filter((kb) => !predicate(obj[kb], kb));
      return keysToKeep.reduce((acc, key) => {
        acc[key] = obj[key];
        return acc;
      }, {});
    }
    exports2.omitBy = omitBy;
  },
});

// node_modules/xrpl/dist/npm/utils/xrpConversion.js
var require_xrpConversion = __commonJS({
  "node_modules/xrpl/dist/npm/utils/xrpConversion.js"(exports2) {
    "use strict";
    var __importDefault =
      (exports2 && exports2.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.xrpToDrops = exports2.dropsToXrp = void 0;
    var bignumber_js_1 = __importDefault(require_bignumber());
    var errors_1 = require_errors();
    var DROPS_PER_XRP = 1e6;
    var MAX_FRACTION_LENGTH = 6;
    var BASE_TEN = 10;
    var SANITY_CHECK = /^-?[0-9.]+$/u;
    function dropsToXrp(dropsToConvert) {
      const drops = new bignumber_js_1.default(dropsToConvert).toString(
        BASE_TEN
      );
      if (typeof dropsToConvert === "string" && drops === "NaN") {
        throw new errors_1.ValidationError(
          `dropsToXrp: invalid value '${dropsToConvert}', should be a BigNumber or string-encoded number.`
        );
      }
      if (drops.includes(".")) {
        throw new errors_1.ValidationError(
          `dropsToXrp: value '${drops}' has too many decimal places.`
        );
      }
      if (!SANITY_CHECK.exec(drops)) {
        throw new errors_1.ValidationError(
          `dropsToXrp: failed sanity check - value '${drops}', does not match (^-?[0-9]+$).`
        );
      }
      return new bignumber_js_1.default(drops)
        .dividedBy(DROPS_PER_XRP)
        .toNumber();
    }
    exports2.dropsToXrp = dropsToXrp;
    function xrpToDrops(xrpToConvert) {
      const xrp = new bignumber_js_1.default(xrpToConvert).toString(BASE_TEN);
      if (typeof xrpToConvert === "string" && xrp === "NaN") {
        throw new errors_1.ValidationError(
          `xrpToDrops: invalid value '${xrpToConvert}', should be a BigNumber or string-encoded number.`
        );
      }
      if (!SANITY_CHECK.exec(xrp)) {
        throw new errors_1.ValidationError(
          `xrpToDrops: failed sanity check - value '${xrp}', does not match (^-?[0-9.]+$).`
        );
      }
      const components = xrp.split(".");
      if (components.length > 2) {
        throw new errors_1.ValidationError(
          `xrpToDrops: failed sanity check - value '${xrp}' has too many decimal points.`
        );
      }
      const fraction = components[1] || "0";
      if (fraction.length > MAX_FRACTION_LENGTH) {
        throw new errors_1.ValidationError(
          `xrpToDrops: value '${xrp}' has too many decimal places.`
        );
      }
      return new bignumber_js_1.default(xrp)
        .times(DROPS_PER_XRP)
        .integerValue(bignumber_js_1.default.ROUND_FLOOR)
        .toString(BASE_TEN);
    }
    exports2.xrpToDrops = xrpToDrops;
  },
});

// node_modules/xrpl/dist/npm/utils/getBalanceChanges.js
var require_getBalanceChanges = __commonJS({
  "node_modules/xrpl/dist/npm/utils/getBalanceChanges.js"(exports2) {
    "use strict";
    var __importDefault =
      (exports2 && exports2.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bignumber_js_1 = __importDefault(require_bignumber());
    var collections_1 = require_collections();
    var xrpConversion_1 = require_xrpConversion();
    function normalizeNode(affectedNode) {
      const diffType = Object.keys(affectedNode)[0];
      const node = affectedNode[diffType];
      return Object.assign(Object.assign({}, node), {
        NodeType: diffType,
        LedgerEntryType: node.LedgerEntryType,
        LedgerIndex: node.LedgerIndex,
        NewFields: node.NewFields,
        FinalFields: node.FinalFields,
        PreviousFields: node.PreviousFields,
      });
    }
    function normalizeNodes(metadata) {
      if (metadata.AffectedNodes.length === 0) {
        return [];
      }
      return metadata.AffectedNodes.map(normalizeNode);
    }
    function groupByAccount(balanceChanges) {
      const grouped = (0, collections_1.groupBy)(
        balanceChanges,
        (node) => node.account
      );
      return Object.entries(grouped).map(([account, items]) => {
        return { account, balances: items.map((item) => item.balance) };
      });
    }
    function getValue(balance) {
      if (typeof balance === "string") {
        return new bignumber_js_1.default(balance);
      }
      return new bignumber_js_1.default(balance.value);
    }
    function computeBalanceChange(node) {
      var _a, _b, _c;
      let value = null;
      if (
        (_a = node.NewFields) === null || _a === void 0 ? void 0 : _a.Balance
      ) {
        value = getValue(node.NewFields.Balance);
      } else if (
        ((_b = node.PreviousFields) === null || _b === void 0
          ? void 0
          : _b.Balance) &&
        ((_c = node.FinalFields) === null || _c === void 0
          ? void 0
          : _c.Balance)
      ) {
        value = getValue(node.FinalFields.Balance).minus(
          getValue(node.PreviousFields.Balance)
        );
      }
      if (value === null || value.isZero()) {
        return null;
      }
      return value;
    }
    function getXRPQuantity(node) {
      var _a, _b, _c;
      const value = computeBalanceChange(node);
      if (value === null) {
        return null;
      }
      return {
        account:
          (_b =
            (_a = node.FinalFields) === null || _a === void 0
              ? void 0
              : _a.Account) !== null && _b !== void 0
            ? _b
            : (_c = node.NewFields) === null || _c === void 0
            ? void 0
            : _c.Account,
        balance: {
          currency: "XRP",
          value: (0, xrpConversion_1.dropsToXrp)(value).toString(),
        },
      };
    }
    function flipTrustlinePerspective(balanceChange) {
      const negatedBalance = new bignumber_js_1.default(
        balanceChange.balance.value
      ).negated();
      return {
        account: balanceChange.balance.issuer,
        balance: {
          issuer: balanceChange.account,
          currency: balanceChange.balance.currency,
          value: negatedBalance.toString(),
        },
      };
    }
    function getTrustlineQuantity(node) {
      var _a, _b;
      const value = computeBalanceChange(node);
      if (value === null) {
        return null;
      }
      const fields = node.NewFields == null ? node.FinalFields : node.NewFields;
      const result = {
        account:
          (_a =
            fields === null || fields === void 0 ? void 0 : fields.LowLimit) ===
            null || _a === void 0
            ? void 0
            : _a.issuer,
        balance: {
          issuer:
            (_b =
              fields === null || fields === void 0
                ? void 0
                : fields.HighLimit) === null || _b === void 0
              ? void 0
              : _b.issuer,
          currency: (fields === null || fields === void 0
            ? void 0
            : fields.Balance
          ).currency,
          value: value.toString(),
        },
      };
      return [result, flipTrustlinePerspective(result)];
    }
    function getBalanceChanges(metadata) {
      const quantities = normalizeNodes(metadata).map((node) => {
        if (node.LedgerEntryType === "AccountRoot") {
          const xrpQuantity = getXRPQuantity(node);
          if (xrpQuantity == null) {
            return [];
          }
          return [xrpQuantity];
        }
        if (node.LedgerEntryType === "RippleState") {
          const trustlineQuantity = getTrustlineQuantity(node);
          if (trustlineQuantity == null) {
            return [];
          }
          return trustlineQuantity;
        }
        return [];
      });
      return groupByAccount(quantities.flat());
    }
    exports2.default = getBalanceChanges;
  },
});

// node_modules/xrpl/dist/npm/models/transactions/metadata.js
var require_metadata = __commonJS({
  "node_modules/xrpl/dist/npm/models/transactions/metadata.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isDeletedNode =
      exports2.isModifiedNode =
      exports2.isCreatedNode =
        void 0;
    function isCreatedNode(node) {
      return Object.prototype.hasOwnProperty.call(node, `CreatedNode`);
    }
    exports2.isCreatedNode = isCreatedNode;
    function isModifiedNode(node) {
      return Object.prototype.hasOwnProperty.call(node, `ModifiedNode`);
    }
    exports2.isModifiedNode = isModifiedNode;
    function isDeletedNode(node) {
      return Object.prototype.hasOwnProperty.call(node, `DeletedNode`);
    }
    exports2.isDeletedNode = isDeletedNode;
  },
});

// node_modules/xrpl/dist/npm/utils/getNFTokenID.js
var require_getNFTokenID = __commonJS({
  "node_modules/xrpl/dist/npm/utils/getNFTokenID.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ripple_binary_codec_1 = require_dist2();
    var metadata_1 = require_metadata();
    function ensureDecodedMeta(meta) {
      if (typeof meta === "string") {
        return (0, ripple_binary_codec_1.decode)(meta);
      }
      return meta;
    }
    function getNFTokenID(meta) {
      if (
        typeof meta !== "string" &&
        (meta === null || meta === void 0 ? void 0 : meta.AffectedNodes) ===
          void 0
      ) {
        throw new TypeError(`Unable to parse the parameter given to getNFTokenID.
      'meta' must be the metadata from an NFTokenMint transaction. Received ${JSON.stringify(
        meta
      )} instead.`);
      }
      const decodedMeta = ensureDecodedMeta(meta);
      const affectedNodes = decodedMeta.AffectedNodes.filter((node) => {
        var _a;
        if ((0, metadata_1.isCreatedNode)(node)) {
          return node.CreatedNode.LedgerEntryType === "NFTokenPage";
        }
        if ((0, metadata_1.isModifiedNode)(node)) {
          return (
            node.ModifiedNode.LedgerEntryType === "NFTokenPage" &&
            Boolean(
              (_a = node.ModifiedNode.PreviousFields) === null || _a === void 0
                ? void 0
                : _a.NFTokens
            )
          );
        }
        return false;
      });
      const previousTokenIDSet = new Set(
        affectedNodes
          .flatMap((node) => {
            var _a;
            const nftokens = (0, metadata_1.isModifiedNode)(node)
              ? (_a = node.ModifiedNode.PreviousFields) === null ||
                _a === void 0
                ? void 0
                : _a.NFTokens
              : [];
            return nftokens.map((token) => token.NFToken.NFTokenID);
          })
          .filter((id) => Boolean(id))
      );
      const finalTokenIDs = affectedNodes
        .flatMap((node) => {
          var _a, _b, _c, _d, _e, _f;
          return (
            (_f =
              (_c =
                (_b =
                  (_a = node.ModifiedNode) === null || _a === void 0
                    ? void 0
                    : _a.FinalFields) === null || _b === void 0
                  ? void 0
                  : _b.NFTokens) !== null && _c !== void 0
                ? _c
                : (_e =
                    (_d = node.CreatedNode) === null || _d === void 0
                      ? void 0
                      : _d.NewFields) === null || _e === void 0
                ? void 0
                : _e.NFTokens) !== null && _f !== void 0
              ? _f
              : []
          ).map((token) => token.NFToken.NFTokenID);
        })
        .filter((nftokenID2) => Boolean(nftokenID2));
      const nftokenID = finalTokenIDs.find((id) => !previousTokenIDSet.has(id));
      return nftokenID;
    }
    exports2.default = getNFTokenID;
  },
});

// node_modules/xrpl/dist/npm/utils/getXChainClaimID.js
var require_getXChainClaimID = __commonJS({
  "node_modules/xrpl/dist/npm/utils/getXChainClaimID.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ripple_binary_codec_1 = require_dist2();
    var metadata_1 = require_metadata();
    function ensureDecodedMeta(meta) {
      if (typeof meta === "string") {
        return (0, ripple_binary_codec_1.decode)(meta);
      }
      return meta;
    }
    function getXChainClaimID(meta) {
      if (
        typeof meta !== "string" &&
        (meta === null || meta === void 0 ? void 0 : meta.AffectedNodes) ===
          void 0
      ) {
        throw new TypeError(`Unable to parse the parameter given to getXChainClaimID.
      'meta' must be the metadata from an XChainCreateClaimID transaction. Received ${JSON.stringify(
        meta
      )} instead.`);
      }
      const decodedMeta = ensureDecodedMeta(meta);
      if (!decodedMeta.TransactionResult) {
        throw new TypeError(
          "Cannot get XChainClaimID from un-validated transaction"
        );
      }
      if (decodedMeta.TransactionResult !== "tesSUCCESS") {
        return void 0;
      }
      const createdNode = decodedMeta.AffectedNodes.find(
        (node) =>
          (0, metadata_1.isCreatedNode)(node) &&
          node.CreatedNode.LedgerEntryType === "XChainOwnedClaimID"
      );
      return createdNode.CreatedNode.NewFields.XChainClaimID;
    }
    exports2.default = getXChainClaimID;
  },
});

// node_modules/xrpl/dist/npm/utils/hashes/HashPrefix.js
var require_HashPrefix = __commonJS({
  "node_modules/xrpl/dist/npm/utils/hashes/HashPrefix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var HashPrefix;
    (function (HashPrefix2) {
      HashPrefix2[(HashPrefix2["TRANSACTION_ID"] = 1415073280)] =
        "TRANSACTION_ID";
      HashPrefix2[(HashPrefix2["TRANSACTION_NODE"] = 1397638144)] =
        "TRANSACTION_NODE";
      HashPrefix2[(HashPrefix2["INNER_NODE"] = 1296649728)] = "INNER_NODE";
      HashPrefix2[(HashPrefix2["LEAF_NODE"] = 1296846336)] = "LEAF_NODE";
      HashPrefix2[(HashPrefix2["TRANSACTION_SIGN"] = 1398036480)] =
        "TRANSACTION_SIGN";
      HashPrefix2[(HashPrefix2["TRANSACTION_SIGN_TESTNET"] = 1937012736)] =
        "TRANSACTION_SIGN_TESTNET";
      HashPrefix2[(HashPrefix2["TRANSACTION_MULTISIGN"] = 1397576704)] =
        "TRANSACTION_MULTISIGN";
      HashPrefix2[(HashPrefix2["LEDGER"] = 1280791040)] = "LEDGER";
    })(HashPrefix || (HashPrefix = {}));
    exports2.default = HashPrefix;
  },
});

// node_modules/xrpl/dist/npm/utils/hashes/sha512Half.js
var require_sha512Half = __commonJS({
  "node_modules/xrpl/dist/npm/utils/hashes/sha512Half.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var sha512_1 = require_sha512();
    var utils_1 = require_utils2();
    var HASH_BYTES = 32;
    function sha512Half(hex) {
      return (0, utils_1.bytesToHex)(
        (0, sha512_1.sha512)((0, utils_1.hexToBytes)(hex)).slice(0, HASH_BYTES)
      );
    }
    exports2.default = sha512Half;
  },
});

// node_modules/xrpl/dist/npm/utils/hashes/SHAMap/node.js
var require_node = __commonJS({
  "node_modules/xrpl/dist/npm/utils/hashes/SHAMap/node.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Node = exports2.NodeType = void 0;
    var NodeType;
    (function (NodeType2) {
      NodeType2[(NodeType2["INNER"] = 1)] = "INNER";
      NodeType2[(NodeType2["TRANSACTION_NO_METADATA"] = 2)] =
        "TRANSACTION_NO_METADATA";
      NodeType2[(NodeType2["TRANSACTION_METADATA"] = 3)] =
        "TRANSACTION_METADATA";
      NodeType2[(NodeType2["ACCOUNT_STATE"] = 4)] = "ACCOUNT_STATE";
    })(NodeType || (exports2.NodeType = NodeType = {}));
    var Node = class {};
    exports2.Node = Node;
  },
});

// node_modules/xrpl/dist/npm/utils/hashes/SHAMap/LeafNode.js
var require_LeafNode = __commonJS({
  "node_modules/xrpl/dist/npm/utils/hashes/SHAMap/LeafNode.js"(exports2) {
    "use strict";
    var __importDefault =
      (exports2 && exports2.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var errors_1 = require_errors();
    var HashPrefix_1 = __importDefault(require_HashPrefix());
    var sha512Half_1 = __importDefault(require_sha512Half());
    var node_1 = require_node();
    var HEX = 16;
    var LeafNode = class extends node_1.Node {
      constructor(tag, data, type) {
        super();
        this.tag = tag;
        this.type = type;
        this.data = data;
      }
      get hash() {
        switch (this.type) {
          case node_1.NodeType.ACCOUNT_STATE: {
            const leafPrefix = HashPrefix_1.default.LEAF_NODE.toString(HEX);
            return (0, sha512Half_1.default)(leafPrefix + this.data + this.tag);
          }
          case node_1.NodeType.TRANSACTION_NO_METADATA: {
            const txIDPrefix =
              HashPrefix_1.default.TRANSACTION_ID.toString(HEX);
            return (0, sha512Half_1.default)(txIDPrefix + this.data);
          }
          case node_1.NodeType.TRANSACTION_METADATA: {
            const txNodePrefix =
              HashPrefix_1.default.TRANSACTION_NODE.toString(HEX);
            return (0, sha512Half_1.default)(
              txNodePrefix + this.data + this.tag
            );
          }
          default:
            throw new errors_1.XrplError(
              "Tried to hash a SHAMap node of unknown type."
            );
        }
      }
      addItem(tag, node) {
        throw new errors_1.XrplError("Cannot call addItem on a LeafNode");
        this.addItem(tag, node);
      }
    };
    exports2.default = LeafNode;
  },
});

// node_modules/xrpl/dist/npm/utils/hashes/SHAMap/InnerNode.js
var require_InnerNode = __commonJS({
  "node_modules/xrpl/dist/npm/utils/hashes/SHAMap/InnerNode.js"(exports2) {
    "use strict";
    var __importDefault =
      (exports2 && exports2.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var errors_1 = require_errors();
    var HashPrefix_1 = __importDefault(require_HashPrefix());
    var sha512Half_1 = __importDefault(require_sha512Half());
    var LeafNode_1 = __importDefault(require_LeafNode());
    var node_1 = require_node();
    var HEX_ZERO =
      "0000000000000000000000000000000000000000000000000000000000000000";
    var SLOT_MAX = 15;
    var HEX = 16;
    var InnerNode = class _InnerNode extends node_1.Node {
      constructor(depth = 0) {
        super();
        this.leaves = {};
        this.type = node_1.NodeType.INNER;
        this.depth = depth;
        this.empty = true;
      }
      get hash() {
        if (this.empty) {
          return HEX_ZERO;
        }
        let hex = "";
        for (let iter = 0; iter <= SLOT_MAX; iter++) {
          const child = this.leaves[iter];
          const hash = child == null ? HEX_ZERO : child.hash;
          hex += hash;
        }
        const prefix = HashPrefix_1.default.INNER_NODE.toString(HEX);
        return (0, sha512Half_1.default)(prefix + hex);
      }
      addItem(tag, node) {
        const existingNode = this.getNode(parseInt(tag[this.depth], HEX));
        if (existingNode === void 0) {
          this.setNode(parseInt(tag[this.depth], HEX), node);
          return;
        }
        if (existingNode instanceof _InnerNode) {
          existingNode.addItem(tag, node);
        } else if (existingNode instanceof LeafNode_1.default) {
          if (existingNode.tag === tag) {
            throw new errors_1.XrplError(
              "Tried to add a node to a SHAMap that was already in there."
            );
          } else {
            const newInnerNode = new _InnerNode(this.depth + 1);
            newInnerNode.addItem(existingNode.tag, existingNode);
            newInnerNode.addItem(tag, node);
            this.setNode(parseInt(tag[this.depth], HEX), newInnerNode);
          }
        }
      }
      setNode(slot, node) {
        if (slot < 0 || slot > SLOT_MAX) {
          throw new errors_1.XrplError(
            "Invalid slot: slot must be between 0-15."
          );
        }
        this.leaves[slot] = node;
        this.empty = false;
      }
      getNode(slot) {
        if (slot < 0 || slot > SLOT_MAX) {
          throw new errors_1.XrplError(
            "Invalid slot: slot must be between 0-15."
          );
        }
        return this.leaves[slot];
      }
    };
    exports2.default = InnerNode;
  },
});

// node_modules/xrpl/dist/npm/utils/hashes/SHAMap/index.js
var require_SHAMap = __commonJS({
  "node_modules/xrpl/dist/npm/utils/hashes/SHAMap/index.js"(exports2) {
    "use strict";
    var __createBinding =
      (exports2 && exports2.__createBinding) ||
      (Object.create
        ? function (o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);
            if (
              !desc ||
              ("get" in desc
                ? !m.__esModule
                : desc.writable || desc.configurable)
            ) {
              desc = {
                enumerable: true,
                get: function () {
                  return m[k];
                },
              };
            }
            Object.defineProperty(o, k2, desc);
          }
        : function (o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            o[k2] = m[k];
          });
    var __exportStar =
      (exports2 && exports2.__exportStar) ||
      function (m, exports3) {
        for (var p in m)
          if (
            p !== "default" &&
            !Object.prototype.hasOwnProperty.call(exports3, p)
          )
            __createBinding(exports3, m, p);
      };
    var __importDefault =
      (exports2 && exports2.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var InnerNode_1 = __importDefault(require_InnerNode());
    var LeafNode_1 = __importDefault(require_LeafNode());
    var SHAMap = class {
      constructor() {
        this.root = new InnerNode_1.default(0);
      }
      get hash() {
        return this.root.hash;
      }
      addItem(tag, data, type) {
        this.root.addItem(tag, new LeafNode_1.default(tag, data, type));
      }
    };
    __exportStar(require_node(), exports2);
    exports2.default = SHAMap;
  },
});

// node_modules/xrpl/dist/npm/utils/hashes/hashLedger.js
var require_hashLedger = __commonJS({
  "node_modules/xrpl/dist/npm/utils/hashes/hashLedger.js"(exports2) {
    "use strict";
    var __createBinding =
      (exports2 && exports2.__createBinding) ||
      (Object.create
        ? function (o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);
            if (
              !desc ||
              ("get" in desc
                ? !m.__esModule
                : desc.writable || desc.configurable)
            ) {
              desc = {
                enumerable: true,
                get: function () {
                  return m[k];
                },
              };
            }
            Object.defineProperty(o, k2, desc);
          }
        : function (o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            o[k2] = m[k];
          });
    var __setModuleDefault =
      (exports2 && exports2.__setModuleDefault) ||
      (Object.create
        ? function (o, v) {
            Object.defineProperty(o, "default", { enumerable: true, value: v });
          }
        : function (o, v) {
            o["default"] = v;
          });
    var __importStar =
      (exports2 && exports2.__importStar) ||
      function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    var __importDefault =
      (exports2 && exports2.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hashStateTree =
      exports2.hashTxTree =
      exports2.hashLedgerHeader =
      exports2.hashSignedTx =
        void 0;
    var utils_1 = require_utils2();
    var bignumber_js_1 = __importDefault(require_bignumber());
    var ripple_binary_codec_1 = require_dist2();
    var errors_1 = require_errors();
    var HashPrefix_1 = __importDefault(require_HashPrefix());
    var sha512Half_1 = __importDefault(require_sha512Half());
    var SHAMap_1 = __importStar(require_SHAMap());
    var HEX = 16;
    function intToHex(integer, byteLength) {
      const foo = Number(integer)
        .toString(HEX)
        .padStart(byteLength * 2, "0");
      return foo;
    }
    function bigintToHex(integerString, byteLength) {
      const hex = new bignumber_js_1.default(integerString).toString(HEX);
      return hex.padStart(byteLength * 2, "0");
    }
    function addLengthPrefix(hex) {
      const length = hex.length / 2;
      if (length <= 192) {
        return (0, utils_1.bytesToHex)([length]) + hex;
      }
      if (length <= 12480) {
        const prefix = length - 193;
        return (
          (0, utils_1.bytesToHex)([193 + (prefix >>> 8), prefix & 255]) + hex
        );
      }
      if (length <= 918744) {
        const prefix = length - 12481;
        return (
          (0, utils_1.bytesToHex)([
            241 + (prefix >>> 16),
            (prefix >>> 8) & 255,
            prefix & 255,
          ]) + hex
        );
      }
      throw new errors_1.XrplError("Variable integer overflow.");
    }
    function hashSignedTx(tx) {
      let txBlob;
      let txObject;
      if (typeof tx === "string") {
        txBlob = tx;
        txObject = (0, ripple_binary_codec_1.decode)(tx);
      } else {
        txBlob = (0, ripple_binary_codec_1.encode)(tx);
        txObject = tx;
      }
      if (
        txObject.TxnSignature === void 0 &&
        txObject.Signers === void 0 &&
        txObject.SigningPubKey === void 0
      ) {
        throw new errors_1.ValidationError(
          "The transaction must be signed to hash it."
        );
      }
      const prefix =
        HashPrefix_1.default.TRANSACTION_ID.toString(16).toUpperCase();
      return (0, sha512Half_1.default)(prefix.concat(txBlob));
    }
    exports2.hashSignedTx = hashSignedTx;
    function hashLedgerHeader(ledgerHeader) {
      const prefix = HashPrefix_1.default.LEDGER.toString(HEX).toUpperCase();
      const ledger =
        prefix +
        intToHex(Number(ledgerHeader.ledger_index), 4) +
        bigintToHex(ledgerHeader.total_coins, 8) +
        ledgerHeader.parent_hash +
        ledgerHeader.transaction_hash +
        ledgerHeader.account_hash +
        intToHex(ledgerHeader.parent_close_time, 4) +
        intToHex(ledgerHeader.close_time, 4) +
        intToHex(ledgerHeader.close_time_resolution, 1) +
        intToHex(ledgerHeader.close_flags, 1);
      return (0, sha512Half_1.default)(ledger);
    }
    exports2.hashLedgerHeader = hashLedgerHeader;
    function hashTxTree(transactions) {
      var _a;
      const shamap = new SHAMap_1.default();
      for (const txJSON of transactions) {
        const txBlobHex = (0, ripple_binary_codec_1.encode)(txJSON);
        const metaHex = (0, ripple_binary_codec_1.encode)(
          (_a = txJSON.metaData) !== null && _a !== void 0 ? _a : {}
        );
        const txHash = hashSignedTx(txBlobHex);
        const data = addLengthPrefix(txBlobHex) + addLengthPrefix(metaHex);
        shamap.addItem(txHash, data, SHAMap_1.NodeType.TRANSACTION_METADATA);
      }
      return shamap.hash;
    }
    exports2.hashTxTree = hashTxTree;
    function hashStateTree(entries) {
      const shamap = new SHAMap_1.default();
      entries.forEach((ledgerEntry) => {
        const data = (0, ripple_binary_codec_1.encode)(ledgerEntry);
        shamap.addItem(
          ledgerEntry.index,
          data,
          SHAMap_1.NodeType.ACCOUNT_STATE
        );
      });
      return shamap.hash;
    }
    exports2.hashStateTree = hashStateTree;
    function computeTransactionHash(ledger, options) {
      const { transaction_hash } = ledger;
      if (!options.computeTreeHashes) {
        return transaction_hash;
      }
      if (ledger.transactions == null) {
        throw new errors_1.ValidationError(
          "transactions is missing from the ledger"
        );
      }
      const transactionHash = hashTxTree(ledger.transactions);
      if (transaction_hash !== transactionHash) {
        throw new errors_1.ValidationError(
          "transactionHash in header does not match computed hash of transactions",
          {
            transactionHashInHeader: transaction_hash,
            computedHashOfTransactions: transactionHash,
          }
        );
      }
      return transactionHash;
    }
    function computeStateHash(ledger, options) {
      const { account_hash } = ledger;
      if (!options.computeTreeHashes) {
        return account_hash;
      }
      if (ledger.accountState == null) {
        throw new errors_1.ValidationError(
          "accountState is missing from the ledger"
        );
      }
      const stateHash = hashStateTree(ledger.accountState);
      if (account_hash !== stateHash) {
        throw new errors_1.ValidationError(
          "stateHash in header does not match computed hash of state"
        );
      }
      return stateHash;
    }
    function hashLedger(ledger, options = {}) {
      const subhashes = {
        transaction_hash: computeTransactionHash(ledger, options),
        account_hash: computeStateHash(ledger, options),
      };
      return hashLedgerHeader(
        Object.assign(Object.assign({}, ledger), subhashes)
      );
    }
    exports2.default = hashLedger;
  },
});

// node_modules/xrpl/dist/npm/utils/hashes/ledgerSpaces.js
var require_ledgerSpaces = __commonJS({
  "node_modules/xrpl/dist/npm/utils/hashes/ledgerSpaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ledgerSpaces = {
      account: "a",
      dirNode: "d",
      generatorMap: "g",
      rippleState: "r",
      offer: "o",
      ownerDir: "O",
      bookDir: "B",
      contract: "c",
      skipList: "s",
      escrow: "u",
      amendment: "f",
      feeSettings: "e",
      ticket: "T",
      signerList: "S",
      paychan: "x",
      check: "C",
      depositPreauth: "p",
    };
    exports2.default = ledgerSpaces;
  },
});

// node_modules/xrpl/dist/npm/utils/hashes/index.js
var require_hashes2 = __commonJS({
  "node_modules/xrpl/dist/npm/utils/hashes/index.js"(exports2) {
    "use strict";
    var __createBinding =
      (exports2 && exports2.__createBinding) ||
      (Object.create
        ? function (o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);
            if (
              !desc ||
              ("get" in desc
                ? !m.__esModule
                : desc.writable || desc.configurable)
            ) {
              desc = {
                enumerable: true,
                get: function () {
                  return m[k];
                },
              };
            }
            Object.defineProperty(o, k2, desc);
          }
        : function (o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            o[k2] = m[k];
          });
    var __setModuleDefault =
      (exports2 && exports2.__setModuleDefault) ||
      (Object.create
        ? function (o, v) {
            Object.defineProperty(o, "default", { enumerable: true, value: v });
          }
        : function (o, v) {
            o["default"] = v;
          });
    var __importStar =
      (exports2 && exports2.__importStar) ||
      function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    var __importDefault =
      (exports2 && exports2.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hashTxTree =
      exports2.hashStateTree =
      exports2.hashLedger =
      exports2.hashSignedTx =
      exports2.hashLedgerHeader =
      exports2.hashPaymentChannel =
      exports2.hashEscrow =
      exports2.hashTrustline =
      exports2.hashOfferId =
      exports2.hashSignerListId =
      exports2.hashAccountRoot =
      exports2.hashTx =
        void 0;
    var utils_1 = require_utils2();
    var bignumber_js_1 = __importDefault(require_bignumber());
    var ripple_address_codec_1 = require_dist();
    var hashLedger_1 = __importStar(require_hashLedger());
    exports2.hashLedger = hashLedger_1.default;
    Object.defineProperty(exports2, "hashLedgerHeader", {
      enumerable: true,
      get: function () {
        return hashLedger_1.hashLedgerHeader;
      },
    });
    Object.defineProperty(exports2, "hashSignedTx", {
      enumerable: true,
      get: function () {
        return hashLedger_1.hashSignedTx;
      },
    });
    Object.defineProperty(exports2, "hashTxTree", {
      enumerable: true,
      get: function () {
        return hashLedger_1.hashTxTree;
      },
    });
    Object.defineProperty(exports2, "hashStateTree", {
      enumerable: true,
      get: function () {
        return hashLedger_1.hashStateTree;
      },
    });
    var HashPrefix_1 = __importDefault(require_HashPrefix());
    var ledgerSpaces_1 = __importDefault(require_ledgerSpaces());
    var sha512Half_1 = __importDefault(require_sha512Half());
    var HEX = 16;
    var BYTE_LENGTH = 4;
    function addressToHex(address) {
      return (0, utils_1.bytesToHex)(
        (0, ripple_address_codec_1.decodeAccountID)(address)
      );
    }
    function ledgerSpaceHex(name) {
      return ledgerSpaces_1.default[name]
        .charCodeAt(0)
        .toString(HEX)
        .padStart(4, "0");
    }
    var MASK = 255;
    function currencyToHex(currency) {
      if (currency.length !== 3) {
        return currency;
      }
      const bytes = Array(20).fill(0);
      bytes[12] = currency.charCodeAt(0) & MASK;
      bytes[13] = currency.charCodeAt(1) & MASK;
      bytes[14] = currency.charCodeAt(2) & MASK;
      return (0, utils_1.bytesToHex)(Uint8Array.from(bytes));
    }
    function hashTx(txBlobHex) {
      const prefix =
        HashPrefix_1.default.TRANSACTION_SIGN.toString(HEX).toUpperCase();
      return (0, sha512Half_1.default)(prefix + txBlobHex);
    }
    exports2.hashTx = hashTx;
    function hashAccountRoot(address) {
      return (0, sha512Half_1.default)(
        ledgerSpaceHex("account") + addressToHex(address)
      );
    }
    exports2.hashAccountRoot = hashAccountRoot;
    function hashSignerListId(address) {
      return (0, sha512Half_1.default)(
        `${ledgerSpaceHex("signerList") + addressToHex(address)}00000000`
      );
    }
    exports2.hashSignerListId = hashSignerListId;
    function hashOfferId(address, sequence) {
      const hexPrefix = ledgerSpaces_1.default.offer
        .charCodeAt(0)
        .toString(HEX)
        .padStart(2, "0");
      const hexSequence = sequence.toString(HEX).padStart(8, "0");
      const prefix = `00${hexPrefix}`;
      return (0, sha512Half_1.default)(
        prefix + addressToHex(address) + hexSequence
      );
    }
    exports2.hashOfferId = hashOfferId;
    function hashTrustline(address1, address2, currency) {
      const address1Hex = addressToHex(address1);
      const address2Hex = addressToHex(address2);
      const swap = new bignumber_js_1.default(address1Hex, 16).isGreaterThan(
        new bignumber_js_1.default(address2Hex, 16)
      );
      const lowAddressHex = swap ? address2Hex : address1Hex;
      const highAddressHex = swap ? address1Hex : address2Hex;
      const prefix = ledgerSpaceHex("rippleState");
      return (0, sha512Half_1.default)(
        prefix + lowAddressHex + highAddressHex + currencyToHex(currency)
      );
    }
    exports2.hashTrustline = hashTrustline;
    function hashEscrow(address, sequence) {
      return (0, sha512Half_1.default)(
        ledgerSpaceHex("escrow") +
          addressToHex(address) +
          sequence.toString(HEX).padStart(BYTE_LENGTH * 2, "0")
      );
    }
    exports2.hashEscrow = hashEscrow;
    function hashPaymentChannel(address, dstAddress, sequence) {
      return (0, sha512Half_1.default)(
        ledgerSpaceHex("paychan") +
          addressToHex(address) +
          addressToHex(dstAddress) +
          sequence.toString(HEX).padStart(BYTE_LENGTH * 2, "0")
      );
    }
    exports2.hashPaymentChannel = hashPaymentChannel;
  },
});

// node_modules/xrpl/dist/npm/utils/parseNFTokenID.js
var require_parseNFTokenID = __commonJS({
  "node_modules/xrpl/dist/npm/utils/parseNFTokenID.js"(exports2) {
    "use strict";
    var __importDefault =
      (exports2 && exports2.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils_1 = require_utils2();
    var bignumber_js_1 = __importDefault(require_bignumber());
    var ripple_address_codec_1 = require_dist();
    var errors_1 = require_errors();
    function unscrambleTaxon(taxon, tokenSeq) {
      const seed = 384160001;
      const increment = 2459;
      const max = 4294967296;
      const scramble = new bignumber_js_1.default(seed)
        .multipliedBy(tokenSeq)
        .modulo(max)
        .plus(increment)
        .modulo(max)
        .toNumber();
      return (taxon ^ scramble) >>> 0;
    }
    function parseNFTokenID(nftokenID) {
      const expectedLength = 64;
      if (nftokenID.length !== expectedLength) {
        throw new errors_1.XrplError(`Attempting to parse a nftokenID with length ${nftokenID.length}
    , but expected a token with length ${expectedLength}`);
      }
      const scrambledTaxon = new bignumber_js_1.default(
        nftokenID.substring(48, 56),
        16
      ).toNumber();
      const sequence = new bignumber_js_1.default(
        nftokenID.substring(56, 64),
        16
      ).toNumber();
      const NFTokenIDData = {
        NFTokenID: nftokenID,
        Flags: new bignumber_js_1.default(
          nftokenID.substring(0, 4),
          16
        ).toNumber(),
        TransferFee: new bignumber_js_1.default(
          nftokenID.substring(4, 8),
          16
        ).toNumber(),
        Issuer: (0, ripple_address_codec_1.encodeAccountID)(
          (0, utils_1.hexToBytes)(nftokenID.substring(8, 48))
        ),
        Taxon: unscrambleTaxon(scrambledTaxon, sequence),
        Sequence: sequence,
      };
      return NFTokenIDData;
    }
    exports2.default = parseNFTokenID;
  },
});

// node_modules/xrpl/dist/npm/utils/quality.js
var require_quality2 = __commonJS({
  "node_modules/xrpl/dist/npm/utils/quality.js"(exports2) {
    "use strict";
    var __importDefault =
      (exports2 && exports2.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.percentToQuality =
      exports2.transferRateToDecimal =
      exports2.qualityToDecimal =
      exports2.decimalToQuality =
      exports2.percentToTransferRate =
      exports2.decimalToTransferRate =
        void 0;
    var bignumber_js_1 = __importDefault(require_bignumber());
    var errors_1 = require_errors();
    var BASE_TEN = 10;
    var ONE_BILLION = "1000000000";
    var TWO_BILLION = "2000000000";
    function percentToDecimal(percent) {
      if (!percent.endsWith("%")) {
        throw new errors_1.ValidationError(`Value ${percent} must end with %`);
      }
      const split = percent.split("%").filter((str) => str !== "");
      if (split.length !== 1) {
        throw new errors_1.ValidationError(
          `Value ${percent} contains too many % signs`
        );
      }
      return new bignumber_js_1.default(split[0])
        .dividedBy("100")
        .toString(BASE_TEN);
    }
    function decimalToTransferRate(decimal) {
      const rate = new bignumber_js_1.default(decimal)
        .times(ONE_BILLION)
        .plus(ONE_BILLION);
      if (rate.isLessThan(ONE_BILLION) || rate.isGreaterThan(TWO_BILLION)) {
        throw new errors_1.ValidationError(
          `Decimal value must be between 0 and 1.00.`
        );
      }
      const billionths = rate.toString(BASE_TEN);
      if (billionths === ONE_BILLION) {
        return 0;
      }
      if (billionths === "NaN") {
        throw new errors_1.ValidationError(`Value is not a number`);
      }
      if (billionths.includes(".")) {
        throw new errors_1.ValidationError(
          `Decimal exceeds maximum precision.`
        );
      }
      return Number(billionths);
    }
    exports2.decimalToTransferRate = decimalToTransferRate;
    function percentToTransferRate(percent) {
      return decimalToTransferRate(percentToDecimal(percent));
    }
    exports2.percentToTransferRate = percentToTransferRate;
    function decimalToQuality(decimal) {
      const rate = new bignumber_js_1.default(decimal).times(ONE_BILLION);
      const billionths = rate.toString(BASE_TEN);
      if (billionths === "NaN") {
        throw new errors_1.ValidationError(`Value is not a number`);
      }
      if (billionths.includes("-")) {
        throw new errors_1.ValidationError("Cannot have negative Quality");
      }
      if (billionths === ONE_BILLION) {
        return 0;
      }
      if (billionths.includes(".")) {
        throw new errors_1.ValidationError(
          `Decimal exceeds maximum precision.`
        );
      }
      return Number(billionths);
    }
    exports2.decimalToQuality = decimalToQuality;
    function qualityToDecimal(quality) {
      if (!Number.isInteger(quality)) {
        throw new errors_1.ValidationError("Quality must be an integer");
      }
      if (quality < 0) {
        throw new errors_1.ValidationError("Negative quality not allowed");
      }
      if (quality === 0) {
        return "1";
      }
      const decimal = new bignumber_js_1.default(quality).dividedBy(
        ONE_BILLION
      );
      return decimal.toString(BASE_TEN);
    }
    exports2.qualityToDecimal = qualityToDecimal;
    function transferRateToDecimal(rate) {
      if (!Number.isInteger(rate)) {
        throw new errors_1.ValidationError(
          "Error decoding, transfer Rate must be an integer"
        );
      }
      if (rate === 0) {
        return "0";
      }
      const decimal = new bignumber_js_1.default(rate)
        .minus(ONE_BILLION)
        .dividedBy(ONE_BILLION);
      if (decimal.isLessThan(0)) {
        throw new errors_1.ValidationError(
          "Error decoding, negative transfer rate"
        );
      }
      return decimal.toString(BASE_TEN);
    }
    exports2.transferRateToDecimal = transferRateToDecimal;
    function percentToQuality(percent) {
      return decimalToQuality(percentToDecimal(percent));
    }
    exports2.percentToQuality = percentToQuality;
  },
});

// node_modules/xrpl/dist/npm/utils/signPaymentChannelClaim.js
var require_signPaymentChannelClaim = __commonJS({
  "node_modules/xrpl/dist/npm/utils/signPaymentChannelClaim.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ripple_binary_codec_1 = require_dist2();
    var ripple_keypairs_1 = require_dist3();
    var xrpConversion_1 = require_xrpConversion();
    function signPaymentChannelClaim(channel, xrpAmount, privateKey) {
      const signingData = (0, ripple_binary_codec_1.encodeForSigningClaim)({
        channel,
        amount: (0, xrpConversion_1.xrpToDrops)(xrpAmount),
      });
      return (0, ripple_keypairs_1.sign)(signingData, privateKey);
    }
    exports2.default = signPaymentChannelClaim;
  },
});

// node_modules/xrpl/dist/npm/utils/stringConversion.js
var require_stringConversion = __commonJS({
  "node_modules/xrpl/dist/npm/utils/stringConversion.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.convertStringToHex = exports2.convertHexToString = void 0;
    var utils_1 = require_utils2();
    function convertStringToHex(string) {
      return (0, utils_1.stringToHex)(string);
    }
    exports2.convertStringToHex = convertStringToHex;
    function convertHexToString(hex, encoding = "utf8") {
      return (0, utils_1.hexToString)(hex, encoding);
    }
    exports2.convertHexToString = convertHexToString;
  },
});

// node_modules/xrpl/dist/npm/utils/timeConversion.js
var require_timeConversion = __commonJS({
  "node_modules/xrpl/dist/npm/utils/timeConversion.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isoTimeToRippleTime =
      exports2.rippleTimeToISOTime =
      exports2.unixTimeToRippleTime =
      exports2.rippleTimeToUnixTime =
        void 0;
    var RIPPLE_EPOCH_DIFF = 946684800;
    function rippleTimeToUnixTime(rpepoch) {
      return (rpepoch + RIPPLE_EPOCH_DIFF) * 1e3;
    }
    exports2.rippleTimeToUnixTime = rippleTimeToUnixTime;
    function unixTimeToRippleTime(timestamp) {
      return Math.round(timestamp / 1e3) - RIPPLE_EPOCH_DIFF;
    }
    exports2.unixTimeToRippleTime = unixTimeToRippleTime;
    function rippleTimeToISOTime(rippleTime) {
      return new Date(rippleTimeToUnixTime(rippleTime)).toISOString();
    }
    exports2.rippleTimeToISOTime = rippleTimeToISOTime;
    function isoTimeToRippleTime(iso8601) {
      const isoDate = typeof iso8601 === "string" ? new Date(iso8601) : iso8601;
      return unixTimeToRippleTime(isoDate.getTime());
    }
    exports2.isoTimeToRippleTime = isoTimeToRippleTime;
  },
});

// node_modules/xrpl/dist/npm/utils/verifyPaymentChannelClaim.js
var require_verifyPaymentChannelClaim = __commonJS({
  "node_modules/xrpl/dist/npm/utils/verifyPaymentChannelClaim.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ripple_binary_codec_1 = require_dist2();
    var ripple_keypairs_1 = require_dist3();
    var xrpConversion_1 = require_xrpConversion();
    function verifyPaymentChannelClaim(
      channel,
      xrpAmount,
      signature,
      publicKey
    ) {
      const signingData = (0, ripple_binary_codec_1.encodeForSigningClaim)({
        channel,
        amount: (0, xrpConversion_1.xrpToDrops)(xrpAmount),
      });
      return (0, ripple_keypairs_1.verify)(signingData, signature, publicKey);
    }
    exports2.default = verifyPaymentChannelClaim;
  },
});

// node_modules/xrpl/dist/npm/utils/index.js
var require_utils10 = __commonJS({
  "node_modules/xrpl/dist/npm/utils/index.js"(exports2) {
    "use strict";
    var __importDefault =
      (exports2 && exports2.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getXChainClaimID =
      exports2.parseNFTokenID =
      exports2.getNFTokenID =
      exports2.encodeForSigningClaim =
      exports2.encodeForSigning =
      exports2.encodeForMultiSigning =
      exports2.decode =
      exports2.encode =
      exports2.decodeXAddress =
      exports2.encodeXAddress =
      exports2.decodeAccountPublic =
      exports2.encodeAccountPublic =
      exports2.decodeNodePublic =
      exports2.encodeNodePublic =
      exports2.decodeAccountID =
      exports2.encodeAccountID =
      exports2.decodeSeed =
      exports2.encodeSeed =
      exports2.isValidClassicAddress =
      exports2.isValidXAddress =
      exports2.xAddressToClassicAddress =
      exports2.classicAddressToXAddress =
      exports2.convertHexToString =
      exports2.convertStringToHex =
      exports2.verifyPaymentChannelClaim =
      exports2.verifyKeypairSignature =
      exports2.signPaymentChannelClaim =
      exports2.deriveXAddress =
      exports2.deriveAddress =
      exports2.deriveKeypair =
      exports2.hashes =
      exports2.isValidAddress =
      exports2.isValidSecret =
      exports2.qualityToDecimal =
      exports2.transferRateToDecimal =
      exports2.decimalToTransferRate =
      exports2.percentToTransferRate =
      exports2.decimalToQuality =
      exports2.percentToQuality =
      exports2.unixTimeToRippleTime =
      exports2.rippleTimeToUnixTime =
      exports2.isoTimeToRippleTime =
      exports2.rippleTimeToISOTime =
      exports2.hasNextPage =
      exports2.xrpToDrops =
      exports2.dropsToXrp =
      exports2.getBalanceChanges =
        void 0;
    var ripple_address_codec_1 = require_dist();
    Object.defineProperty(exports2, "classicAddressToXAddress", {
      enumerable: true,
      get: function () {
        return ripple_address_codec_1.classicAddressToXAddress;
      },
    });
    Object.defineProperty(exports2, "decodeAccountID", {
      enumerable: true,
      get: function () {
        return ripple_address_codec_1.decodeAccountID;
      },
    });
    Object.defineProperty(exports2, "decodeAccountPublic", {
      enumerable: true,
      get: function () {
        return ripple_address_codec_1.decodeAccountPublic;
      },
    });
    Object.defineProperty(exports2, "decodeNodePublic", {
      enumerable: true,
      get: function () {
        return ripple_address_codec_1.decodeNodePublic;
      },
    });
    Object.defineProperty(exports2, "decodeSeed", {
      enumerable: true,
      get: function () {
        return ripple_address_codec_1.decodeSeed;
      },
    });
    Object.defineProperty(exports2, "decodeXAddress", {
      enumerable: true,
      get: function () {
        return ripple_address_codec_1.decodeXAddress;
      },
    });
    Object.defineProperty(exports2, "encodeAccountID", {
      enumerable: true,
      get: function () {
        return ripple_address_codec_1.encodeAccountID;
      },
    });
    Object.defineProperty(exports2, "encodeAccountPublic", {
      enumerable: true,
      get: function () {
        return ripple_address_codec_1.encodeAccountPublic;
      },
    });
    Object.defineProperty(exports2, "encodeNodePublic", {
      enumerable: true,
      get: function () {
        return ripple_address_codec_1.encodeNodePublic;
      },
    });
    Object.defineProperty(exports2, "encodeSeed", {
      enumerable: true,
      get: function () {
        return ripple_address_codec_1.encodeSeed;
      },
    });
    Object.defineProperty(exports2, "encodeXAddress", {
      enumerable: true,
      get: function () {
        return ripple_address_codec_1.encodeXAddress;
      },
    });
    Object.defineProperty(exports2, "isValidClassicAddress", {
      enumerable: true,
      get: function () {
        return ripple_address_codec_1.isValidClassicAddress;
      },
    });
    Object.defineProperty(exports2, "isValidXAddress", {
      enumerable: true,
      get: function () {
        return ripple_address_codec_1.isValidXAddress;
      },
    });
    Object.defineProperty(exports2, "xAddressToClassicAddress", {
      enumerable: true,
      get: function () {
        return ripple_address_codec_1.xAddressToClassicAddress;
      },
    });
    var ripple_binary_codec_1 = require_dist2();
    var ripple_keypairs_1 = require_dist3();
    Object.defineProperty(exports2, "verifyKeypairSignature", {
      enumerable: true,
      get: function () {
        return ripple_keypairs_1.verify;
      },
    });
    var derive_1 = require_derive();
    Object.defineProperty(exports2, "deriveKeypair", {
      enumerable: true,
      get: function () {
        return derive_1.deriveKeypair;
      },
    });
    Object.defineProperty(exports2, "deriveAddress", {
      enumerable: true,
      get: function () {
        return derive_1.deriveAddress;
      },
    });
    Object.defineProperty(exports2, "deriveXAddress", {
      enumerable: true,
      get: function () {
        return derive_1.deriveXAddress;
      },
    });
    var getBalanceChanges_1 = __importDefault(require_getBalanceChanges());
    exports2.getBalanceChanges = getBalanceChanges_1.default;
    var getNFTokenID_1 = __importDefault(require_getNFTokenID());
    exports2.getNFTokenID = getNFTokenID_1.default;
    var getXChainClaimID_1 = __importDefault(require_getXChainClaimID());
    exports2.getXChainClaimID = getXChainClaimID_1.default;
    var hashes_1 = require_hashes2();
    var parseNFTokenID_1 = __importDefault(require_parseNFTokenID());
    exports2.parseNFTokenID = parseNFTokenID_1.default;
    var quality_1 = require_quality2();
    Object.defineProperty(exports2, "percentToTransferRate", {
      enumerable: true,
      get: function () {
        return quality_1.percentToTransferRate;
      },
    });
    Object.defineProperty(exports2, "decimalToTransferRate", {
      enumerable: true,
      get: function () {
        return quality_1.decimalToTransferRate;
      },
    });
    Object.defineProperty(exports2, "transferRateToDecimal", {
      enumerable: true,
      get: function () {
        return quality_1.transferRateToDecimal;
      },
    });
    Object.defineProperty(exports2, "percentToQuality", {
      enumerable: true,
      get: function () {
        return quality_1.percentToQuality;
      },
    });
    Object.defineProperty(exports2, "decimalToQuality", {
      enumerable: true,
      get: function () {
        return quality_1.decimalToQuality;
      },
    });
    Object.defineProperty(exports2, "qualityToDecimal", {
      enumerable: true,
      get: function () {
        return quality_1.qualityToDecimal;
      },
    });
    var signPaymentChannelClaim_1 = __importDefault(
      require_signPaymentChannelClaim()
    );
    exports2.signPaymentChannelClaim = signPaymentChannelClaim_1.default;
    var stringConversion_1 = require_stringConversion();
    Object.defineProperty(exports2, "convertHexToString", {
      enumerable: true,
      get: function () {
        return stringConversion_1.convertHexToString;
      },
    });
    Object.defineProperty(exports2, "convertStringToHex", {
      enumerable: true,
      get: function () {
        return stringConversion_1.convertStringToHex;
      },
    });
    var timeConversion_1 = require_timeConversion();
    Object.defineProperty(exports2, "rippleTimeToISOTime", {
      enumerable: true,
      get: function () {
        return timeConversion_1.rippleTimeToISOTime;
      },
    });
    Object.defineProperty(exports2, "isoTimeToRippleTime", {
      enumerable: true,
      get: function () {
        return timeConversion_1.isoTimeToRippleTime;
      },
    });
    Object.defineProperty(exports2, "rippleTimeToUnixTime", {
      enumerable: true,
      get: function () {
        return timeConversion_1.rippleTimeToUnixTime;
      },
    });
    Object.defineProperty(exports2, "unixTimeToRippleTime", {
      enumerable: true,
      get: function () {
        return timeConversion_1.unixTimeToRippleTime;
      },
    });
    var verifyPaymentChannelClaim_1 = __importDefault(
      require_verifyPaymentChannelClaim()
    );
    exports2.verifyPaymentChannelClaim = verifyPaymentChannelClaim_1.default;
    var xrpConversion_1 = require_xrpConversion();
    Object.defineProperty(exports2, "xrpToDrops", {
      enumerable: true,
      get: function () {
        return xrpConversion_1.xrpToDrops;
      },
    });
    Object.defineProperty(exports2, "dropsToXrp", {
      enumerable: true,
      get: function () {
        return xrpConversion_1.dropsToXrp;
      },
    });
    function isValidSecret(secret) {
      try {
        (0, derive_1.deriveKeypair)(secret);
        return true;
      } catch (_err) {
        return false;
      }
    }
    exports2.isValidSecret = isValidSecret;
    function encode(object) {
      return (0, ripple_binary_codec_1.encode)(object);
    }
    exports2.encode = encode;
    function encodeForSigning(object) {
      return (0, ripple_binary_codec_1.encodeForSigning)(object);
    }
    exports2.encodeForSigning = encodeForSigning;
    function encodeForSigningClaim(object) {
      return (0, ripple_binary_codec_1.encodeForSigningClaim)(object);
    }
    exports2.encodeForSigningClaim = encodeForSigningClaim;
    function encodeForMultiSigning(object, signer) {
      return (0, ripple_binary_codec_1.encodeForMultisigning)(object, signer);
    }
    exports2.encodeForMultiSigning = encodeForMultiSigning;
    function decode(hex) {
      return (0, ripple_binary_codec_1.decode)(hex);
    }
    exports2.decode = decode;
    function isValidAddress(address) {
      return (
        (0, ripple_address_codec_1.isValidXAddress)(address) ||
        (0, ripple_address_codec_1.isValidClassicAddress)(address)
      );
    }
    exports2.isValidAddress = isValidAddress;
    function hasNextPage(response) {
      return Boolean(response.result["marker"]);
    }
    exports2.hasNextPage = hasNextPage;
    var hashes = {
      hashSignedTx: hashes_1.hashSignedTx,
      hashTx: hashes_1.hashTx,
      hashAccountRoot: hashes_1.hashAccountRoot,
      hashSignerListId: hashes_1.hashSignerListId,
      hashOfferId: hashes_1.hashOfferId,
      hashTrustline: hashes_1.hashTrustline,
      hashTxTree: hashes_1.hashTxTree,
      hashStateTree: hashes_1.hashStateTree,
      hashLedger: hashes_1.hashLedger,
      hashLedgerHeader: hashes_1.hashLedgerHeader,
      hashEscrow: hashes_1.hashEscrow,
      hashPaymentChannel: hashes_1.hashPaymentChannel,
    };
    exports2.hashes = hashes;
  },
});

// node_modules/xrpl/dist/npm/sugar/getFeeXrp.js
var require_getFeeXrp = __commonJS({
  "node_modules/xrpl/dist/npm/sugar/getFeeXrp.js"(exports2) {
    "use strict";
    var __awaiter =
      (exports2 && exports2.__awaiter) ||
      function (thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P
            ? value
            : new P(function (resolve) {
                resolve(value);
              });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done
              ? resolve(result.value)
              : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
    var __importDefault =
      (exports2 && exports2.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bignumber_js_1 = __importDefault(require_bignumber());
    var errors_1 = require_errors();
    var NUM_DECIMAL_PLACES = 6;
    var BASE_10 = 10;
    function getFeeXrp(client, cushion) {
      var _a;
      return __awaiter(this, void 0, void 0, function* () {
        const feeCushion =
          cushion !== null && cushion !== void 0 ? cushion : client.feeCushion;
        const serverInfo = (yield client.request({ command: "server_info" }))
          .result.info;
        const baseFee =
          (_a = serverInfo.validated_ledger) === null || _a === void 0
            ? void 0
            : _a.base_fee_xrp;
        if (baseFee == null) {
          throw new errors_1.XrplError(
            "getFeeXrp: Could not get base_fee_xrp from server_info"
          );
        }
        const baseFeeXrp = new bignumber_js_1.default(baseFee);
        if (serverInfo.load_factor == null) {
          serverInfo.load_factor = 1;
        }
        let fee = baseFeeXrp.times(serverInfo.load_factor).times(feeCushion);
        fee = bignumber_js_1.default.min(fee, client.maxFeeXRP);
        return new bignumber_js_1.default(
          fee.toFixed(NUM_DECIMAL_PLACES)
        ).toString(BASE_10);
      });
    }
    exports2.default = getFeeXrp;
  },
});

// node_modules/xrpl/dist/npm/sugar/autofill.js
var require_autofill = __commonJS({
  "node_modules/xrpl/dist/npm/sugar/autofill.js"(exports2) {
    "use strict";
    var __awaiter =
      (exports2 && exports2.__awaiter) ||
      function (thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P
            ? value
            : new P(function (resolve) {
                resolve(value);
              });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done
              ? resolve(result.value)
              : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
    var __importDefault =
      (exports2 && exports2.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.checkAccountDeleteBlockers =
      exports2.setLatestValidatedLedgerSequence =
      exports2.calculateFeePerTransactionType =
      exports2.setNextValidSequenceNumber =
      exports2.setValidAddresses =
      exports2.txNeedsNetworkID =
        void 0;
    var bignumber_js_1 = __importDefault(require_bignumber());
    var ripple_address_codec_1 = require_dist();
    var errors_1 = require_errors();
    var utils_1 = require_utils10();
    var getFeeXrp_1 = __importDefault(require_getFeeXrp());
    var LEDGER_OFFSET = 20;
    var RESTRICTED_NETWORKS = 1024;
    var REQUIRED_NETWORKID_VERSION = "1.11.0";
    var HOOKS_TESTNET_ID = 21338;
    function isNotLaterRippledVersion(source, target) {
      if (source === target) {
        return true;
      }
      const sourceDecomp = source.split(".");
      const targetDecomp = target.split(".");
      const sourceMajor = parseInt(sourceDecomp[0], 10);
      const sourceMinor = parseInt(sourceDecomp[1], 10);
      const targetMajor = parseInt(targetDecomp[0], 10);
      const targetMinor = parseInt(targetDecomp[1], 10);
      if (sourceMajor !== targetMajor) {
        return sourceMajor < targetMajor;
      }
      if (sourceMinor !== targetMinor) {
        return sourceMinor < targetMinor;
      }
      const sourcePatch = sourceDecomp[2].split("-");
      const targetPatch = targetDecomp[2].split("-");
      const sourcePatchVersion = parseInt(sourcePatch[0], 10);
      const targetPatchVersion = parseInt(targetPatch[0], 10);
      if (sourcePatchVersion !== targetPatchVersion) {
        return sourcePatchVersion < targetPatchVersion;
      }
      if (sourcePatch.length !== targetPatch.length) {
        return sourcePatch.length > targetPatch.length;
      }
      if (sourcePatch.length === 2) {
        if (!sourcePatch[1][0].startsWith(targetPatch[1][0])) {
          return sourcePatch[1] < targetPatch[1];
        }
        if (sourcePatch[1].startsWith("b")) {
          return (
            parseInt(sourcePatch[1].slice(1), 10) <
            parseInt(targetPatch[1].slice(1), 10)
          );
        }
        return (
          parseInt(sourcePatch[1].slice(2), 10) <
          parseInt(targetPatch[1].slice(2), 10)
        );
      }
      return false;
    }
    function txNeedsNetworkID(client) {
      if (
        client.networkID !== void 0 &&
        client.networkID > RESTRICTED_NETWORKS
      ) {
        if (
          (client.buildVersion &&
            isNotLaterRippledVersion(
              REQUIRED_NETWORKID_VERSION,
              client.buildVersion
            )) ||
          client.networkID === HOOKS_TESTNET_ID
        ) {
          return true;
        }
      }
      return false;
    }
    exports2.txNeedsNetworkID = txNeedsNetworkID;
    function setValidAddresses(tx) {
      validateAccountAddress(tx, "Account", "SourceTag");
      if (tx["Destination"] != null) {
        validateAccountAddress(tx, "Destination", "DestinationTag");
      }
      convertToClassicAddress(tx, "Authorize");
      convertToClassicAddress(tx, "Unauthorize");
      convertToClassicAddress(tx, "Owner");
      convertToClassicAddress(tx, "RegularKey");
    }
    exports2.setValidAddresses = setValidAddresses;
    function validateAccountAddress(tx, accountField, tagField) {
      const { classicAccount, tag } = getClassicAccountAndTag(tx[accountField]);
      tx[accountField] = classicAccount;
      if (tag != null && tag !== false) {
        if (tx[tagField] && tx[tagField] !== tag) {
          throw new errors_1.ValidationError(
            `The ${tagField}, if present, must match the tag of the ${accountField} X-address`
          );
        }
        tx[tagField] = tag;
      }
    }
    function getClassicAccountAndTag(Account, expectedTag) {
      if ((0, ripple_address_codec_1.isValidXAddress)(Account)) {
        const classic = (0, ripple_address_codec_1.xAddressToClassicAddress)(
          Account
        );
        if (expectedTag != null && classic.tag !== expectedTag) {
          throw new errors_1.ValidationError(
            "address includes a tag that does not match the tag specified in the transaction"
          );
        }
        return {
          classicAccount: classic.classicAddress,
          tag: classic.tag,
        };
      }
      return {
        classicAccount: Account,
        tag: expectedTag,
      };
    }
    function convertToClassicAddress(tx, fieldName) {
      const account = tx[fieldName];
      if (typeof account === "string") {
        const { classicAccount } = getClassicAccountAndTag(account);
        tx[fieldName] = classicAccount;
      }
    }
    function setNextValidSequenceNumber(client, tx) {
      return __awaiter(this, void 0, void 0, function* () {
        const request = {
          command: "account_info",
          account: tx.Account,
          ledger_index: "current",
        };
        const data = yield client.request(request);
        tx.Sequence = data.result.account_data.Sequence;
      });
    }
    exports2.setNextValidSequenceNumber = setNextValidSequenceNumber;
    function fetchAccountDeleteFee(client) {
      var _a;
      return __awaiter(this, void 0, void 0, function* () {
        const response = yield client.request({ command: "server_state" });
        const fee =
          (_a = response.result.state.validated_ledger) === null ||
          _a === void 0
            ? void 0
            : _a.reserve_inc;
        if (fee == null) {
          return Promise.reject(new Error("Could not fetch Owner Reserve."));
        }
        return new bignumber_js_1.default(fee);
      });
    }
    function calculateFeePerTransactionType(client, tx, signersCount = 0) {
      return __awaiter(this, void 0, void 0, function* () {
        const netFeeXRP = yield (0, getFeeXrp_1.default)(client);
        const netFeeDrops = (0, utils_1.xrpToDrops)(netFeeXRP);
        let baseFee = new bignumber_js_1.default(netFeeDrops);
        if (tx.TransactionType === "EscrowFinish" && tx.Fulfillment != null) {
          const fulfillmentBytesSize = Math.ceil(tx.Fulfillment.length / 2);
          const product = new bignumber_js_1.default(
            scaleValue(netFeeDrops, 33 + fulfillmentBytesSize / 16)
          );
          baseFee = product.dp(0, bignumber_js_1.default.ROUND_CEIL);
        }
        if (
          tx.TransactionType === "AccountDelete" ||
          tx.TransactionType === "AMMCreate"
        ) {
          baseFee = yield fetchAccountDeleteFee(client);
        }
        if (signersCount > 0) {
          baseFee = bignumber_js_1.default.sum(
            baseFee,
            scaleValue(netFeeDrops, 1 + signersCount)
          );
        }
        const maxFeeDrops = (0, utils_1.xrpToDrops)(client.maxFeeXRP);
        const totalFee =
          tx.TransactionType === "AccountDelete"
            ? baseFee
            : bignumber_js_1.default.min(baseFee, maxFeeDrops);
        tx.Fee = totalFee.dp(0, bignumber_js_1.default.ROUND_CEIL).toString(10);
      });
    }
    exports2.calculateFeePerTransactionType = calculateFeePerTransactionType;
    function scaleValue(value, multiplier) {
      return new bignumber_js_1.default(value).times(multiplier).toString();
    }
    function setLatestValidatedLedgerSequence(client, tx) {
      return __awaiter(this, void 0, void 0, function* () {
        const ledgerSequence = yield client.getLedgerIndex();
        tx.LastLedgerSequence = ledgerSequence + LEDGER_OFFSET;
      });
    }
    exports2.setLatestValidatedLedgerSequence =
      setLatestValidatedLedgerSequence;
    function checkAccountDeleteBlockers(client, tx) {
      return __awaiter(this, void 0, void 0, function* () {
        const request = {
          command: "account_objects",
          account: tx.Account,
          ledger_index: "validated",
          deletion_blockers_only: true,
        };
        const response = yield client.request(request);
        return new Promise((resolve, reject) => {
          if (response.result.account_objects.length > 0) {
            reject(
              new errors_1.XrplError(
                `Account ${tx.Account} cannot be deleted; there are Escrows, PayChannels, RippleStates, or Checks associated with the account.`,
                response.result.account_objects
              )
            );
          }
          resolve();
        });
      });
    }
    exports2.checkAccountDeleteBlockers = checkAccountDeleteBlockers;
  },
});

// node_modules/xrpl/dist/npm/sugar/balances.js
var require_balances = __commonJS({
  "node_modules/xrpl/dist/npm/sugar/balances.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.formatBalances = void 0;
    function formatBalances(trustlines) {
      return trustlines.map((trustline) => ({
        value: trustline.balance,
        currency: trustline.currency,
        issuer: trustline.account,
      }));
    }
    exports2.formatBalances = formatBalances;
  },
});

// node_modules/xrpl/dist/npm/models/ledger/Offer.js
var require_Offer = __commonJS({
  "node_modules/xrpl/dist/npm/models/ledger/Offer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OfferFlags = void 0;
    var OfferFlags;
    (function (OfferFlags2) {
      OfferFlags2[(OfferFlags2["lsfPassive"] = 65536)] = "lsfPassive";
      OfferFlags2[(OfferFlags2["lsfSell"] = 131072)] = "lsfSell";
    })(OfferFlags || (exports2.OfferFlags = OfferFlags = {}));
  },
});

// node_modules/xrpl/dist/npm/sugar/getOrderbook.js
var require_getOrderbook = __commonJS({
  "node_modules/xrpl/dist/npm/sugar/getOrderbook.js"(exports2) {
    "use strict";
    var __awaiter =
      (exports2 && exports2.__awaiter) ||
      function (thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P
            ? value
            : new P(function (resolve) {
                resolve(value);
              });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done
              ? resolve(result.value)
              : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
    var __importDefault =
      (exports2 && exports2.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sortAndLimitOffers =
      exports2.separateBuySellOrders =
      exports2.combineOrders =
      exports2.extractOffers =
      exports2.reverseRequest =
      exports2.requestAllOffers =
      exports2.createBookOffersRequest =
      exports2.validateOrderbookOptions =
        void 0;
    var bignumber_js_1 = __importDefault(require_bignumber());
    var errors_1 = require_errors();
    var Offer_1 = require_Offer();
    var DEFAULT_LIMIT = 20;
    function sortOffers(offers) {
      return offers.sort((offerA, offerB) => {
        var _a, _b;
        const qualityA =
          (_a = offerA.quality) !== null && _a !== void 0 ? _a : 0;
        const qualityB =
          (_b = offerB.quality) !== null && _b !== void 0 ? _b : 0;
        return new bignumber_js_1.default(qualityA).comparedTo(qualityB);
      });
    }
    var getOrderbookOptionsSet = /* @__PURE__ */ new Set([
      "limit",
      "ledger_index",
      "ledger_hash",
      "taker",
    ]);
    function validateOrderbookOptions(options) {
      for (const key of Object.keys(options)) {
        if (!getOrderbookOptionsSet.has(key)) {
          throw new errors_1.ValidationError(
            `Unexpected option: ${key}`,
            options
          );
        }
      }
      if (options.limit && typeof options.limit !== "number") {
        throw new errors_1.ValidationError(
          "limit must be a number",
          options.limit
        );
      }
      if (
        options.ledger_index &&
        !(
          typeof options.ledger_index === "number" ||
          (typeof options.ledger_index === "string" &&
            ["validated", "closed", "current"].includes(options.ledger_index))
        )
      ) {
        throw new errors_1.ValidationError(
          'ledger_index must be a number or a string of "validated", "closed", or "current"',
          options.ledger_index
        );
      }
      if (
        options.ledger_hash !== void 0 &&
        options.ledger_hash !== null &&
        typeof options.ledger_hash !== "string"
      ) {
        throw new errors_1.ValidationError(
          "ledger_hash must be a string",
          options.ledger_hash
        );
      }
      if (options.taker !== void 0 && typeof options.taker !== "string") {
        throw new errors_1.ValidationError(
          "taker must be a string",
          options.taker
        );
      }
    }
    exports2.validateOrderbookOptions = validateOrderbookOptions;
    function createBookOffersRequest(currency1, currency2, options) {
      var _a, _b;
      const request = {
        command: "book_offers",
        taker_pays: currency1,
        taker_gets: currency2,
        ledger_index:
          (_a = options.ledger_index) !== null && _a !== void 0
            ? _a
            : "validated",
        ledger_hash:
          options.ledger_hash === null ? void 0 : options.ledger_hash,
        limit:
          (_b = options.limit) !== null && _b !== void 0 ? _b : DEFAULT_LIMIT,
        taker: options.taker ? options.taker : void 0,
      };
      return request;
    }
    exports2.createBookOffersRequest = createBookOffersRequest;
    function requestAllOffers(client, request) {
      return __awaiter(this, void 0, void 0, function* () {
        const results = yield client.requestAll(request);
        return results.map((result) => result.result.offers);
      });
    }
    exports2.requestAllOffers = requestAllOffers;
    function reverseRequest(request) {
      return Object.assign(Object.assign({}, request), {
        taker_pays: request.taker_gets,
        taker_gets: request.taker_pays,
      });
    }
    exports2.reverseRequest = reverseRequest;
    function extractOffers(offerResults) {
      return offerResults.flatMap((offerResult) => offerResult);
    }
    exports2.extractOffers = extractOffers;
    function combineOrders(directOffers, reverseOffers) {
      return [...directOffers, ...reverseOffers];
    }
    exports2.combineOrders = combineOrders;
    function separateBuySellOrders(orders) {
      const buy = [];
      const sell = [];
      orders.forEach((order) => {
        if ((order.Flags & Offer_1.OfferFlags.lsfSell) === 0) {
          buy.push(order);
        } else {
          sell.push(order);
        }
      });
      return { buy, sell };
    }
    exports2.separateBuySellOrders = separateBuySellOrders;
    function sortAndLimitOffers(offers, limit) {
      const sortedOffers = sortOffers(offers);
      return sortedOffers.slice(0, limit);
    }
    exports2.sortAndLimitOffers = sortAndLimitOffers;
  },
});

// node_modules/@noble/hashes/legacy.js
var require_legacy = __commonJS({
  "node_modules/@noble/hashes/legacy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ripemd160 =
      exports2.RIPEMD160 =
      exports2.md5 =
      exports2.MD5 =
      exports2.sha1 =
      exports2.SHA1 =
        void 0;
    var _md_ts_1 = require_md();
    var utils_ts_1 = require_utils();
    var SHA1_IV = /* @__PURE__ */ Uint32Array.from([
      1732584193, 4023233417, 2562383102, 271733878, 3285377520,
    ]);
    var SHA1_W = /* @__PURE__ */ new Uint32Array(80);
    var SHA1 = class extends _md_ts_1.HashMD {
      constructor() {
        super(64, 20, 8, false);
        this.A = SHA1_IV[0] | 0;
        this.B = SHA1_IV[1] | 0;
        this.C = SHA1_IV[2] | 0;
        this.D = SHA1_IV[3] | 0;
        this.E = SHA1_IV[4] | 0;
      }
      get() {
        const { A, B, C, D, E } = this;
        return [A, B, C, D, E];
      }
      set(A, B, C, D, E) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          SHA1_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 80; i++)
          SHA1_W[i] = (0, utils_ts_1.rotl)(
            SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16],
            1
          );
        let { A, B, C, D, E } = this;
        for (let i = 0; i < 80; i++) {
          let F, K2;
          if (i < 20) {
            F = (0, _md_ts_1.Chi)(B, C, D);
            K2 = 1518500249;
          } else if (i < 40) {
            F = B ^ C ^ D;
            K2 = 1859775393;
          } else if (i < 60) {
            F = (0, _md_ts_1.Maj)(B, C, D);
            K2 = 2400959708;
          } else {
            F = B ^ C ^ D;
            K2 = 3395469782;
          }
          const T = ((0, utils_ts_1.rotl)(A, 5) + F + E + K2 + SHA1_W[i]) | 0;
          E = D;
          D = C;
          C = (0, utils_ts_1.rotl)(B, 30);
          B = A;
          A = T;
        }
        A = (A + this.A) | 0;
        B = (B + this.B) | 0;
        C = (C + this.C) | 0;
        D = (D + this.D) | 0;
        E = (E + this.E) | 0;
        this.set(A, B, C, D, E);
      }
      roundClean() {
        (0, utils_ts_1.clean)(SHA1_W);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0);
        (0, utils_ts_1.clean)(this.buffer);
      }
    };
    exports2.SHA1 = SHA1;
    exports2.sha1 = (0, utils_ts_1.createHasher)(() => new SHA1());
    var p32 = /* @__PURE__ */ Math.pow(2, 32);
    var K = /* @__PURE__ */ Array.from({ length: 64 }, (_, i) =>
      Math.floor(p32 * Math.abs(Math.sin(i + 1)))
    );
    var MD5_IV = /* @__PURE__ */ SHA1_IV.slice(0, 4);
    var MD5_W = /* @__PURE__ */ new Uint32Array(16);
    var MD5 = class extends _md_ts_1.HashMD {
      constructor() {
        super(64, 16, 8, true);
        this.A = MD5_IV[0] | 0;
        this.B = MD5_IV[1] | 0;
        this.C = MD5_IV[2] | 0;
        this.D = MD5_IV[3] | 0;
      }
      get() {
        const { A, B, C, D } = this;
        return [A, B, C, D];
      }
      set(A, B, C, D) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          MD5_W[i] = view.getUint32(offset, true);
        let { A, B, C, D } = this;
        for (let i = 0; i < 64; i++) {
          let F, g, s;
          if (i < 16) {
            F = (0, _md_ts_1.Chi)(B, C, D);
            g = i;
            s = [7, 12, 17, 22];
          } else if (i < 32) {
            F = (0, _md_ts_1.Chi)(D, B, C);
            g = (5 * i + 1) % 16;
            s = [5, 9, 14, 20];
          } else if (i < 48) {
            F = B ^ C ^ D;
            g = (3 * i + 5) % 16;
            s = [4, 11, 16, 23];
          } else {
            F = C ^ (B | ~D);
            g = (7 * i) % 16;
            s = [6, 10, 15, 21];
          }
          F = F + A + K[i] + MD5_W[g];
          A = D;
          D = C;
          C = B;
          B = B + (0, utils_ts_1.rotl)(F, s[i % 4]);
        }
        A = (A + this.A) | 0;
        B = (B + this.B) | 0;
        C = (C + this.C) | 0;
        D = (D + this.D) | 0;
        this.set(A, B, C, D);
      }
      roundClean() {
        (0, utils_ts_1.clean)(MD5_W);
      }
      destroy() {
        this.set(0, 0, 0, 0);
        (0, utils_ts_1.clean)(this.buffer);
      }
    };
    exports2.MD5 = MD5;
    exports2.md5 = (0, utils_ts_1.createHasher)(() => new MD5());
    var Rho160 = /* @__PURE__ */ Uint8Array.from([
      7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
    ]);
    var Id160 = /* @__PURE__ */ (() =>
      Uint8Array.from(new Array(16).fill(0).map((_, i) => i)))();
    var Pi160 = /* @__PURE__ */ (() => Id160.map((i) => (9 * i + 5) % 16))();
    var idxLR = /* @__PURE__ */ (() => {
      const L = [Id160];
      const R = [Pi160];
      const res = [L, R];
      for (let i = 0; i < 4; i++)
        for (let j of res) j.push(j[i].map((k) => Rho160[k]));
      return res;
    })();
    var idxL = /* @__PURE__ */ (() => idxLR[0])();
    var idxR = /* @__PURE__ */ (() => idxLR[1])();
    var shifts160 = /* @__PURE__ */ [
      [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
      [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
      [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
      [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
      [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],
    ].map((i) => Uint8Array.from(i));
    var shiftsL160 = /* @__PURE__ */ idxL.map((idx, i) =>
      idx.map((j) => shifts160[i][j])
    );
    var shiftsR160 = /* @__PURE__ */ idxR.map((idx, i) =>
      idx.map((j) => shifts160[i][j])
    );
    var Kl160 = /* @__PURE__ */ Uint32Array.from([
      0, 1518500249, 1859775393, 2400959708, 2840853838,
    ]);
    var Kr160 = /* @__PURE__ */ Uint32Array.from([
      1352829926, 1548603684, 1836072691, 2053994217, 0,
    ]);
    function ripemd_f(group, x, y, z) {
      if (group === 0) return x ^ y ^ z;
      if (group === 1) return (x & y) | (~x & z);
      if (group === 2) return (x | ~y) ^ z;
      if (group === 3) return (x & z) | (y & ~z);
      return x ^ (y | ~z);
    }
    var BUF_160 = /* @__PURE__ */ new Uint32Array(16);
    var RIPEMD160 = class extends _md_ts_1.HashMD {
      constructor() {
        super(64, 20, 8, true);
        this.h0 = 1732584193 | 0;
        this.h1 = 4023233417 | 0;
        this.h2 = 2562383102 | 0;
        this.h3 = 271733878 | 0;
        this.h4 = 3285377520 | 0;
      }
      get() {
        const { h0, h1, h2, h3, h4 } = this;
        return [h0, h1, h2, h3, h4];
      }
      set(h0, h1, h2, h3, h4) {
        this.h0 = h0 | 0;
        this.h1 = h1 | 0;
        this.h2 = h2 | 0;
        this.h3 = h3 | 0;
        this.h4 = h4 | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          BUF_160[i] = view.getUint32(offset, true);
        let al = this.h0 | 0,
          ar = al,
          bl = this.h1 | 0,
          br = bl,
          cl = this.h2 | 0,
          cr = cl,
          dl = this.h3 | 0,
          dr = dl,
          el = this.h4 | 0,
          er = el;
        for (let group = 0; group < 5; group++) {
          const rGroup = 4 - group;
          const hbl = Kl160[group],
            hbr = Kr160[group];
          const rl = idxL[group],
            rr = idxR[group];
          const sl = shiftsL160[group],
            sr = shiftsR160[group];
          for (let i = 0; i < 16; i++) {
            const tl =
              ((0, utils_ts_1.rotl)(
                al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i]] + hbl,
                sl[i]
              ) +
                el) |
              0;
            (al = el),
              (el = dl),
              (dl = (0, utils_ts_1.rotl)(cl, 10) | 0),
              (cl = bl),
              (bl = tl);
          }
          for (let i = 0; i < 16; i++) {
            const tr =
              ((0, utils_ts_1.rotl)(
                ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i]] + hbr,
                sr[i]
              ) +
                er) |
              0;
            (ar = er),
              (er = dr),
              (dr = (0, utils_ts_1.rotl)(cr, 10) | 0),
              (cr = br),
              (br = tr);
          }
        }
        this.set(
          (this.h1 + cl + dr) | 0,
          (this.h2 + dl + er) | 0,
          (this.h3 + el + ar) | 0,
          (this.h4 + al + br) | 0,
          (this.h0 + bl + cr) | 0
        );
      }
      roundClean() {
        (0, utils_ts_1.clean)(BUF_160);
      }
      destroy() {
        this.destroyed = true;
        (0, utils_ts_1.clean)(this.buffer);
        this.set(0, 0, 0, 0, 0);
      }
    };
    exports2.RIPEMD160 = RIPEMD160;
    exports2.ripemd160 = (0, utils_ts_1.createHasher)(() => new RIPEMD160());
  },
});

// node_modules/@scure/bip32/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/@scure/bip32/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HDKey = exports2.HARDENED_OFFSET = void 0;
    var modular_1 = require_modular();
    var secp256k1_1 = require_secp256k1();
    var hmac_1 = require_hmac();
    var legacy_1 = require_legacy();
    var sha2_1 = require_sha2();
    var utils_1 = require_utils();
    var base_1 = require_lib();
    var Point = secp256k1_1.secp256k1.ProjectivePoint;
    var base58check = (0, base_1.createBase58check)(sha2_1.sha256);
    function bytesToNumber(bytes) {
      (0, utils_1.abytes)(bytes);
      const h = bytes.length === 0 ? "0" : (0, utils_1.bytesToHex)(bytes);
      return BigInt("0x" + h);
    }
    function numberToBytes(num) {
      if (typeof num !== "bigint") throw new Error("bigint expected");
      return (0, utils_1.hexToBytes)(num.toString(16).padStart(64, "0"));
    }
    var MASTER_SECRET = (0, utils_1.utf8ToBytes)("Bitcoin seed");
    var BITCOIN_VERSIONS = { private: 76066276, public: 76067358 };
    exports2.HARDENED_OFFSET = 2147483648;
    var hash160 = (data) => (0, legacy_1.ripemd160)((0, sha2_1.sha256)(data));
    var fromU32 = (data) => (0, utils_1.createView)(data).getUint32(0, false);
    var toU32 = (n) => {
      if (!Number.isSafeInteger(n) || n < 0 || n > 2 ** 32 - 1) {
        throw new Error(
          "invalid number, should be from 0 to 2**32-1, got " + n
        );
      }
      const buf = new Uint8Array(4);
      (0, utils_1.createView)(buf).setUint32(0, n, false);
      return buf;
    };
    var HDKey = class _HDKey {
      get fingerprint() {
        if (!this.pubHash) {
          throw new Error("No publicKey set!");
        }
        return fromU32(this.pubHash);
      }
      get identifier() {
        return this.pubHash;
      }
      get pubKeyHash() {
        return this.pubHash;
      }
      get privateKey() {
        return this.privKeyBytes || null;
      }
      get publicKey() {
        return this.pubKey || null;
      }
      get privateExtendedKey() {
        const priv = this.privateKey;
        if (!priv) {
          throw new Error("No private key");
        }
        return base58check.encode(
          this.serialize(
            this.versions.private,
            (0, utils_1.concatBytes)(new Uint8Array([0]), priv)
          )
        );
      }
      get publicExtendedKey() {
        if (!this.pubKey) {
          throw new Error("No public key");
        }
        return base58check.encode(
          this.serialize(this.versions.public, this.pubKey)
        );
      }
      static fromMasterSeed(seed, versions = BITCOIN_VERSIONS) {
        (0, utils_1.abytes)(seed);
        if (8 * seed.length < 128 || 8 * seed.length > 512) {
          throw new Error(
            "HDKey: seed length must be between 128 and 512 bits; 256 bits is advised, got " +
              seed.length
          );
        }
        const I = (0, hmac_1.hmac)(sha2_1.sha512, MASTER_SECRET, seed);
        return new _HDKey({
          versions,
          chainCode: I.slice(32),
          privateKey: I.slice(0, 32),
        });
      }
      static fromExtendedKey(base58key, versions = BITCOIN_VERSIONS) {
        const keyBuffer = base58check.decode(base58key);
        const keyView = (0, utils_1.createView)(keyBuffer);
        const version = keyView.getUint32(0, false);
        const opt = {
          versions,
          depth: keyBuffer[4],
          parentFingerprint: keyView.getUint32(5, false),
          index: keyView.getUint32(9, false),
          chainCode: keyBuffer.slice(13, 45),
        };
        const key = keyBuffer.slice(45);
        const isPriv = key[0] === 0;
        if (version !== versions[isPriv ? "private" : "public"]) {
          throw new Error("Version mismatch");
        }
        if (isPriv) {
          return new _HDKey({ ...opt, privateKey: key.slice(1) });
        } else {
          return new _HDKey({ ...opt, publicKey: key });
        }
      }
      static fromJSON(json) {
        return _HDKey.fromExtendedKey(json.xpriv);
      }
      constructor(opt) {
        this.depth = 0;
        this.index = 0;
        this.chainCode = null;
        this.parentFingerprint = 0;
        if (!opt || typeof opt !== "object") {
          throw new Error("HDKey.constructor must not be called directly");
        }
        this.versions = opt.versions || BITCOIN_VERSIONS;
        this.depth = opt.depth || 0;
        this.chainCode = opt.chainCode || null;
        this.index = opt.index || 0;
        this.parentFingerprint = opt.parentFingerprint || 0;
        if (!this.depth) {
          if (this.parentFingerprint || this.index) {
            throw new Error(
              "HDKey: zero depth with non-zero index/parent fingerprint"
            );
          }
        }
        if (opt.publicKey && opt.privateKey) {
          throw new Error("HDKey: publicKey and privateKey at same time.");
        }
        if (opt.privateKey) {
          if (!secp256k1_1.secp256k1.utils.isValidPrivateKey(opt.privateKey)) {
            throw new Error("Invalid private key");
          }
          this.privKey =
            typeof opt.privateKey === "bigint"
              ? opt.privateKey
              : bytesToNumber(opt.privateKey);
          this.privKeyBytes = numberToBytes(this.privKey);
          this.pubKey = secp256k1_1.secp256k1.getPublicKey(
            opt.privateKey,
            true
          );
        } else if (opt.publicKey) {
          this.pubKey = Point.fromHex(opt.publicKey).toRawBytes(true);
        } else {
          throw new Error("HDKey: no public or private key provided");
        }
        this.pubHash = hash160(this.pubKey);
      }
      derive(path) {
        if (!/^[mM]'?/.test(path)) {
          throw new Error('Path must start with "m" or "M"');
        }
        if (/^[mM]'?$/.test(path)) {
          return this;
        }
        const parts = path.replace(/^[mM]'?\//, "").split("/");
        let child = this;
        for (const c of parts) {
          const m = /^(\d+)('?)$/.exec(c);
          const m1 = m && m[1];
          if (!m || m.length !== 3 || typeof m1 !== "string")
            throw new Error("invalid child index: " + c);
          let idx = +m1;
          if (!Number.isSafeInteger(idx) || idx >= exports2.HARDENED_OFFSET) {
            throw new Error("Invalid index");
          }
          if (m[2] === "'") {
            idx += exports2.HARDENED_OFFSET;
          }
          child = child.deriveChild(idx);
        }
        return child;
      }
      deriveChild(index) {
        if (!this.pubKey || !this.chainCode) {
          throw new Error("No publicKey or chainCode set");
        }
        let data = toU32(index);
        if (index >= exports2.HARDENED_OFFSET) {
          const priv = this.privateKey;
          if (!priv) {
            throw new Error("Could not derive hardened child key");
          }
          data = (0, utils_1.concatBytes)(new Uint8Array([0]), priv, data);
        } else {
          data = (0, utils_1.concatBytes)(this.pubKey, data);
        }
        const I = (0, hmac_1.hmac)(sha2_1.sha512, this.chainCode, data);
        const childTweak = bytesToNumber(I.slice(0, 32));
        const chainCode = I.slice(32);
        if (!secp256k1_1.secp256k1.utils.isValidPrivateKey(childTweak)) {
          throw new Error("Tweak bigger than curve order");
        }
        const opt = {
          versions: this.versions,
          chainCode,
          depth: this.depth + 1,
          parentFingerprint: this.fingerprint,
          index,
        };
        try {
          if (this.privateKey) {
            const added = (0, modular_1.mod)(
              this.privKey + childTweak,
              secp256k1_1.secp256k1.CURVE.n
            );
            if (!secp256k1_1.secp256k1.utils.isValidPrivateKey(added)) {
              throw new Error(
                "The tweak was out of range or the resulted private key is invalid"
              );
            }
            opt.privateKey = added;
          } else {
            const added = Point.fromHex(this.pubKey).add(
              Point.fromPrivateKey(childTweak)
            );
            if (added.equals(Point.ZERO)) {
              throw new Error(
                "The tweak was equal to negative P, which made the result key invalid"
              );
            }
            opt.publicKey = added.toRawBytes(true);
          }
          return new _HDKey(opt);
        } catch (err) {
          return this.deriveChild(index + 1);
        }
      }
      sign(hash) {
        if (!this.privateKey) {
          throw new Error("No privateKey set!");
        }
        (0, utils_1.abytes)(hash, 32);
        return secp256k1_1.secp256k1
          .sign(hash, this.privKey)
          .toCompactRawBytes();
      }
      verify(hash, signature) {
        (0, utils_1.abytes)(hash, 32);
        (0, utils_1.abytes)(signature, 64);
        if (!this.publicKey) {
          throw new Error("No publicKey set!");
        }
        let sig;
        try {
          sig = secp256k1_1.secp256k1.Signature.fromCompact(signature);
        } catch (error) {
          return false;
        }
        return secp256k1_1.secp256k1.verify(sig, hash, this.publicKey);
      }
      wipePrivateData() {
        this.privKey = void 0;
        if (this.privKeyBytes) {
          this.privKeyBytes.fill(0);
          this.privKeyBytes = void 0;
        }
        return this;
      }
      toJSON() {
        return {
          xpriv: this.privateExtendedKey,
          xpub: this.publicExtendedKey,
        };
      }
      serialize(version, key) {
        if (!this.chainCode) {
          throw new Error("No chainCode set");
        }
        (0, utils_1.abytes)(key, 33);
        return (0, utils_1.concatBytes)(
          toU32(version),
          new Uint8Array([this.depth]),
          toU32(this.parentFingerprint),
          toU32(this.index),
          this.chainCode,
          key
        );
      }
    };
    exports2.HDKey = HDKey;
  },
});

// node_modules/@noble/hashes/pbkdf2.js
var require_pbkdf2 = __commonJS({
  "node_modules/@noble/hashes/pbkdf2.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.pbkdf2 = pbkdf2;
    exports2.pbkdf2Async = pbkdf2Async;
    var hmac_ts_1 = require_hmac();
    var utils_ts_1 = require_utils();
    function pbkdf2Init(hash, _password, _salt, _opts) {
      (0, utils_ts_1.ahash)(hash);
      const opts = (0, utils_ts_1.checkOpts)(
        { dkLen: 32, asyncTick: 10 },
        _opts
      );
      const { c, dkLen, asyncTick } = opts;
      (0, utils_ts_1.anumber)(c);
      (0, utils_ts_1.anumber)(dkLen);
      (0, utils_ts_1.anumber)(asyncTick);
      if (c < 1) throw new Error("iterations (c) should be >= 1");
      const password = (0, utils_ts_1.kdfInputToBytes)(_password);
      const salt = (0, utils_ts_1.kdfInputToBytes)(_salt);
      const DK = new Uint8Array(dkLen);
      const PRF = hmac_ts_1.hmac.create(hash, password);
      const PRFSalt = PRF._cloneInto().update(salt);
      return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
    }
    function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
      PRF.destroy();
      PRFSalt.destroy();
      if (prfW) prfW.destroy();
      (0, utils_ts_1.clean)(u);
      return DK;
    }
    function pbkdf2(hash, password, salt, opts) {
      const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(
        hash,
        password,
        salt,
        opts
      );
      let prfW;
      const arr = new Uint8Array(4);
      const view = (0, utils_ts_1.createView)(arr);
      const u = new Uint8Array(PRF.outputLen);
      for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        for (let ui = 1; ui < c; ui++) {
          PRF._cloneInto(prfW).update(u).digestInto(u);
          for (let i = 0; i < Ti.length; i++) Ti[i] ^= u[i];
        }
      }
      return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
    }
    async function pbkdf2Async(hash, password, salt, opts) {
      const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(
        hash,
        password,
        salt,
        opts
      );
      let prfW;
      const arr = new Uint8Array(4);
      const view = (0, utils_ts_1.createView)(arr);
      const u = new Uint8Array(PRF.outputLen);
      for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        await (0, utils_ts_1.asyncLoop)(c - 1, asyncTick, () => {
          PRF._cloneInto(prfW).update(u).digestInto(u);
          for (let i = 0; i < Ti.length; i++) Ti[i] ^= u[i];
        });
      }
      return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
    }
  },
});

// node_modules/@scure/bip39/index.js
var require_bip39 = __commonJS({
  "node_modules/@scure/bip39/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generateMnemonic = generateMnemonic;
    exports2.mnemonicToEntropy = mnemonicToEntropy;
    exports2.entropyToMnemonic = entropyToMnemonic;
    exports2.validateMnemonic = validateMnemonic;
    exports2.mnemonicToSeed = mnemonicToSeed;
    exports2.mnemonicToSeedSync = mnemonicToSeedSync;
    var pbkdf2_1 = require_pbkdf2();
    var sha2_1 = require_sha2();
    var utils_1 = require_utils();
    var base_1 = require_lib();
    var isJapanese = (wordlist) =>
      wordlist[0] === "\u3042\u3044\u3053\u304F\u3057\u3093";
    function nfkd(str) {
      if (typeof str !== "string")
        throw new TypeError("invalid mnemonic type: " + typeof str);
      return str.normalize("NFKD");
    }
    function normalize(str) {
      const norm = nfkd(str);
      const words = norm.split(" ");
      if (![12, 15, 18, 21, 24].includes(words.length))
        throw new Error("Invalid mnemonic");
      return { nfkd: norm, words };
    }
    function aentropy(ent) {
      (0, utils_1.abytes)(ent, 16, 20, 24, 28, 32);
    }
    function generateMnemonic(wordlist, strength = 128) {
      (0, utils_1.anumber)(strength);
      if (strength % 32 !== 0 || strength > 256)
        throw new TypeError("Invalid entropy");
      return entropyToMnemonic(
        (0, utils_1.randomBytes)(strength / 8),
        wordlist
      );
    }
    var calcChecksum = (entropy) => {
      const bitsLeft = 8 - entropy.length / 4;
      return new Uint8Array([
        ((0, sha2_1.sha256)(entropy)[0] >> bitsLeft) << bitsLeft,
      ]);
    };
    function getCoder(wordlist) {
      if (
        !Array.isArray(wordlist) ||
        wordlist.length !== 2048 ||
        typeof wordlist[0] !== "string"
      )
        throw new Error("Wordlist: expected array of 2048 strings");
      wordlist.forEach((i) => {
        if (typeof i !== "string")
          throw new Error("wordlist: non-string element: " + i);
      });
      return base_1.utils.chain(
        base_1.utils.checksum(1, calcChecksum),
        base_1.utils.radix2(11, true),
        base_1.utils.alphabet(wordlist)
      );
    }
    function mnemonicToEntropy(mnemonic, wordlist) {
      const { words } = normalize(mnemonic);
      const entropy = getCoder(wordlist).decode(words);
      aentropy(entropy);
      return entropy;
    }
    function entropyToMnemonic(entropy, wordlist) {
      aentropy(entropy);
      const words = getCoder(wordlist).encode(entropy);
      return words.join(isJapanese(wordlist) ? "\u3000" : " ");
    }
    function validateMnemonic(mnemonic, wordlist) {
      try {
        mnemonicToEntropy(mnemonic, wordlist);
      } catch (e) {
        return false;
      }
      return true;
    }
    var psalt = (passphrase) => nfkd("mnemonic" + passphrase);
    function mnemonicToSeed(mnemonic, passphrase = "") {
      return (0, pbkdf2_1.pbkdf2Async)(
        sha2_1.sha512,
        normalize(mnemonic).nfkd,
        psalt(passphrase),
        { c: 2048, dkLen: 64 }
      );
    }
    function mnemonicToSeedSync(mnemonic, passphrase = "") {
      return (0, pbkdf2_1.pbkdf2)(
        sha2_1.sha512,
        normalize(mnemonic).nfkd,
        psalt(passphrase),
        { c: 2048, dkLen: 64 }
      );
    }
  },
});

// node_modules/@scure/bip39/wordlists/english.js
var require_english = __commonJS({
  "node_modules/@scure/bip39/wordlists/english.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.wordlist = void 0;
    exports2.wordlist = `abandon
ability
able
about
above
absent
absorb
abstract
absurd
abuse
access
accident
account
accuse
achieve
acid
acoustic
acquire
across
act
action
actor
actress
actual
adapt
add
addict
address
adjust
admit
adult
advance
advice
aerobic
affair
afford
afraid
again
age
agent
agree
ahead
aim
air
airport
aisle
alarm
album
alcohol
alert
alien
all
alley
allow
almost
alone
alpha
already
also
alter
always
amateur
amazing
among
amount
amused
analyst
anchor
ancient
anger
angle
angry
animal
ankle
announce
annual
another
answer
antenna
antique
anxiety
any
apart
apology
appear
apple
approve
april
arch
arctic
area
arena
argue
arm
armed
armor
army
around
arrange
arrest
arrive
arrow
art
artefact
artist
artwork
ask
aspect
assault
asset
assist
assume
asthma
athlete
atom
attack
attend
attitude
attract
auction
audit
august
aunt
author
auto
autumn
average
avocado
avoid
awake
aware
away
awesome
awful
awkward
axis
baby
bachelor
bacon
badge
bag
balance
balcony
ball
bamboo
banana
banner
bar
barely
bargain
barrel
base
basic
basket
battle
beach
bean
beauty
because
become
beef
before
begin
behave
behind
believe
below
belt
bench
benefit
best
betray
better
between
beyond
bicycle
bid
bike
bind
biology
bird
birth
bitter
black
blade
blame
blanket
blast
bleak
bless
blind
blood
blossom
blouse
blue
blur
blush
board
boat
body
boil
bomb
bone
bonus
book
boost
border
boring
borrow
boss
bottom
bounce
box
boy
bracket
brain
brand
brass
brave
bread
breeze
brick
bridge
brief
bright
bring
brisk
broccoli
broken
bronze
broom
brother
brown
brush
bubble
buddy
budget
buffalo
build
bulb
bulk
bullet
bundle
bunker
burden
burger
burst
bus
business
busy
butter
buyer
buzz
cabbage
cabin
cable
cactus
cage
cake
call
calm
camera
camp
can
canal
cancel
candy
cannon
canoe
canvas
canyon
capable
capital
captain
car
carbon
card
cargo
carpet
carry
cart
case
cash
casino
castle
casual
cat
catalog
catch
category
cattle
caught
cause
caution
cave
ceiling
celery
cement
census
century
cereal
certain
chair
chalk
champion
change
chaos
chapter
charge
chase
chat
cheap
check
cheese
chef
cherry
chest
chicken
chief
child
chimney
choice
choose
chronic
chuckle
chunk
churn
cigar
cinnamon
circle
citizen
city
civil
claim
clap
clarify
claw
clay
clean
clerk
clever
click
client
cliff
climb
clinic
clip
clock
clog
close
cloth
cloud
clown
club
clump
cluster
clutch
coach
coast
coconut
code
coffee
coil
coin
collect
color
column
combine
come
comfort
comic
common
company
concert
conduct
confirm
congress
connect
consider
control
convince
cook
cool
copper
copy
coral
core
corn
correct
cost
cotton
couch
country
couple
course
cousin
cover
coyote
crack
cradle
craft
cram
crane
crash
crater
crawl
crazy
cream
credit
creek
crew
cricket
crime
crisp
critic
crop
cross
crouch
crowd
crucial
cruel
cruise
crumble
crunch
crush
cry
crystal
cube
culture
cup
cupboard
curious
current
curtain
curve
cushion
custom
cute
cycle
dad
damage
damp
dance
danger
daring
dash
daughter
dawn
day
deal
debate
debris
decade
december
decide
decline
decorate
decrease
deer
defense
define
defy
degree
delay
deliver
demand
demise
denial
dentist
deny
depart
depend
deposit
depth
deputy
derive
describe
desert
design
desk
despair
destroy
detail
detect
develop
device
devote
diagram
dial
diamond
diary
dice
diesel
diet
differ
digital
dignity
dilemma
dinner
dinosaur
direct
dirt
disagree
discover
disease
dish
dismiss
disorder
display
distance
divert
divide
divorce
dizzy
doctor
document
dog
doll
dolphin
domain
donate
donkey
donor
door
dose
double
dove
draft
dragon
drama
drastic
draw
dream
dress
drift
drill
drink
drip
drive
drop
drum
dry
duck
dumb
dune
during
dust
dutch
duty
dwarf
dynamic
eager
eagle
early
earn
earth
easily
east
easy
echo
ecology
economy
edge
edit
educate
effort
egg
eight
either
elbow
elder
electric
elegant
element
elephant
elevator
elite
else
embark
embody
embrace
emerge
emotion
employ
empower
empty
enable
enact
end
endless
endorse
enemy
energy
enforce
engage
engine
enhance
enjoy
enlist
enough
enrich
enroll
ensure
enter
entire
entry
envelope
episode
equal
equip
era
erase
erode
erosion
error
erupt
escape
essay
essence
estate
eternal
ethics
evidence
evil
evoke
evolve
exact
example
excess
exchange
excite
exclude
excuse
execute
exercise
exhaust
exhibit
exile
exist
exit
exotic
expand
expect
expire
explain
expose
express
extend
extra
eye
eyebrow
fabric
face
faculty
fade
faint
faith
fall
false
fame
family
famous
fan
fancy
fantasy
farm
fashion
fat
fatal
father
fatigue
fault
favorite
feature
february
federal
fee
feed
feel
female
fence
festival
fetch
fever
few
fiber
fiction
field
figure
file
film
filter
final
find
fine
finger
finish
fire
firm
first
fiscal
fish
fit
fitness
fix
flag
flame
flash
flat
flavor
flee
flight
flip
float
flock
floor
flower
fluid
flush
fly
foam
focus
fog
foil
fold
follow
food
foot
force
forest
forget
fork
fortune
forum
forward
fossil
foster
found
fox
fragile
frame
frequent
fresh
friend
fringe
frog
front
frost
frown
frozen
fruit
fuel
fun
funny
furnace
fury
future
gadget
gain
galaxy
gallery
game
gap
garage
garbage
garden
garlic
garment
gas
gasp
gate
gather
gauge
gaze
general
genius
genre
gentle
genuine
gesture
ghost
giant
gift
giggle
ginger
giraffe
girl
give
glad
glance
glare
glass
glide
glimpse
globe
gloom
glory
glove
glow
glue
goat
goddess
gold
good
goose
gorilla
gospel
gossip
govern
gown
grab
grace
grain
grant
grape
grass
gravity
great
green
grid
grief
grit
grocery
group
grow
grunt
guard
guess
guide
guilt
guitar
gun
gym
habit
hair
half
hammer
hamster
hand
happy
harbor
hard
harsh
harvest
hat
have
hawk
hazard
head
health
heart
heavy
hedgehog
height
hello
helmet
help
hen
hero
hidden
high
hill
hint
hip
hire
history
hobby
hockey
hold
hole
holiday
hollow
home
honey
hood
hope
horn
horror
horse
hospital
host
hotel
hour
hover
hub
huge
human
humble
humor
hundred
hungry
hunt
hurdle
hurry
hurt
husband
hybrid
ice
icon
idea
identify
idle
ignore
ill
illegal
illness
image
imitate
immense
immune
impact
impose
improve
impulse
inch
include
income
increase
index
indicate
indoor
industry
infant
inflict
inform
inhale
inherit
initial
inject
injury
inmate
inner
innocent
input
inquiry
insane
insect
inside
inspire
install
intact
interest
into
invest
invite
involve
iron
island
isolate
issue
item
ivory
jacket
jaguar
jar
jazz
jealous
jeans
jelly
jewel
job
join
joke
journey
joy
judge
juice
jump
jungle
junior
junk
just
kangaroo
keen
keep
ketchup
key
kick
kid
kidney
kind
kingdom
kiss
kit
kitchen
kite
kitten
kiwi
knee
knife
knock
know
lab
label
labor
ladder
lady
lake
lamp
language
laptop
large
later
latin
laugh
laundry
lava
law
lawn
lawsuit
layer
lazy
leader
leaf
learn
leave
lecture
left
leg
legal
legend
leisure
lemon
lend
length
lens
leopard
lesson
letter
level
liar
liberty
library
license
life
lift
light
like
limb
limit
link
lion
liquid
list
little
live
lizard
load
loan
lobster
local
lock
logic
lonely
long
loop
lottery
loud
lounge
love
loyal
lucky
luggage
lumber
lunar
lunch
luxury
lyrics
machine
mad
magic
magnet
maid
mail
main
major
make
mammal
man
manage
mandate
mango
mansion
manual
maple
marble
march
margin
marine
market
marriage
mask
mass
master
match
material
math
matrix
matter
maximum
maze
meadow
mean
measure
meat
mechanic
medal
media
melody
melt
member
memory
mention
menu
mercy
merge
merit
merry
mesh
message
metal
method
middle
midnight
milk
million
mimic
mind
minimum
minor
minute
miracle
mirror
misery
miss
mistake
mix
mixed
mixture
mobile
model
modify
mom
moment
monitor
monkey
monster
month
moon
moral
more
morning
mosquito
mother
motion
motor
mountain
mouse
move
movie
much
muffin
mule
multiply
muscle
museum
mushroom
music
must
mutual
myself
mystery
myth
naive
name
napkin
narrow
nasty
nation
nature
near
neck
need
negative
neglect
neither
nephew
nerve
nest
net
network
neutral
never
news
next
nice
night
noble
noise
nominee
noodle
normal
north
nose
notable
note
nothing
notice
novel
now
nuclear
number
nurse
nut
oak
obey
object
oblige
obscure
observe
obtain
obvious
occur
ocean
october
odor
off
offer
office
often
oil
okay
old
olive
olympic
omit
once
one
onion
online
only
open
opera
opinion
oppose
option
orange
orbit
orchard
order
ordinary
organ
orient
original
orphan
ostrich
other
outdoor
outer
output
outside
oval
oven
over
own
owner
oxygen
oyster
ozone
pact
paddle
page
pair
palace
palm
panda
panel
panic
panther
paper
parade
parent
park
parrot
party
pass
patch
path
patient
patrol
pattern
pause
pave
payment
peace
peanut
pear
peasant
pelican
pen
penalty
pencil
people
pepper
perfect
permit
person
pet
phone
photo
phrase
physical
piano
picnic
picture
piece
pig
pigeon
pill
pilot
pink
pioneer
pipe
pistol
pitch
pizza
place
planet
plastic
plate
play
please
pledge
pluck
plug
plunge
poem
poet
point
polar
pole
police
pond
pony
pool
popular
portion
position
possible
post
potato
pottery
poverty
powder
power
practice
praise
predict
prefer
prepare
present
pretty
prevent
price
pride
primary
print
priority
prison
private
prize
problem
process
produce
profit
program
project
promote
proof
property
prosper
protect
proud
provide
public
pudding
pull
pulp
pulse
pumpkin
punch
pupil
puppy
purchase
purity
purpose
purse
push
put
puzzle
pyramid
quality
quantum
quarter
question
quick
quit
quiz
quote
rabbit
raccoon
race
rack
radar
radio
rail
rain
raise
rally
ramp
ranch
random
range
rapid
rare
rate
rather
raven
raw
razor
ready
real
reason
rebel
rebuild
recall
receive
recipe
record
recycle
reduce
reflect
reform
refuse
region
regret
regular
reject
relax
release
relief
rely
remain
remember
remind
remove
render
renew
rent
reopen
repair
repeat
replace
report
require
rescue
resemble
resist
resource
response
result
retire
retreat
return
reunion
reveal
review
reward
rhythm
rib
ribbon
rice
rich
ride
ridge
rifle
right
rigid
ring
riot
ripple
risk
ritual
rival
river
road
roast
robot
robust
rocket
romance
roof
rookie
room
rose
rotate
rough
round
route
royal
rubber
rude
rug
rule
run
runway
rural
sad
saddle
sadness
safe
sail
salad
salmon
salon
salt
salute
same
sample
sand
satisfy
satoshi
sauce
sausage
save
say
scale
scan
scare
scatter
scene
scheme
school
science
scissors
scorpion
scout
scrap
screen
script
scrub
sea
search
season
seat
second
secret
section
security
seed
seek
segment
select
sell
seminar
senior
sense
sentence
series
service
session
settle
setup
seven
shadow
shaft
shallow
share
shed
shell
sheriff
shield
shift
shine
ship
shiver
shock
shoe
shoot
shop
short
shoulder
shove
shrimp
shrug
shuffle
shy
sibling
sick
side
siege
sight
sign
silent
silk
silly
silver
similar
simple
since
sing
siren
sister
situate
six
size
skate
sketch
ski
skill
skin
skirt
skull
slab
slam
sleep
slender
slice
slide
slight
slim
slogan
slot
slow
slush
small
smart
smile
smoke
smooth
snack
snake
snap
sniff
snow
soap
soccer
social
sock
soda
soft
solar
soldier
solid
solution
solve
someone
song
soon
sorry
sort
soul
sound
soup
source
south
space
spare
spatial
spawn
speak
special
speed
spell
spend
sphere
spice
spider
spike
spin
spirit
split
spoil
sponsor
spoon
sport
spot
spray
spread
spring
spy
square
squeeze
squirrel
stable
stadium
staff
stage
stairs
stamp
stand
start
state
stay
steak
steel
stem
step
stereo
stick
still
sting
stock
stomach
stone
stool
story
stove
strategy
street
strike
strong
struggle
student
stuff
stumble
style
subject
submit
subway
success
such
sudden
suffer
sugar
suggest
suit
summer
sun
sunny
sunset
super
supply
supreme
sure
surface
surge
surprise
surround
survey
suspect
sustain
swallow
swamp
swap
swarm
swear
sweet
swift
swim
swing
switch
sword
symbol
symptom
syrup
system
table
tackle
tag
tail
talent
talk
tank
tape
target
task
taste
tattoo
taxi
teach
team
tell
ten
tenant
tennis
tent
term
test
text
thank
that
theme
then
theory
there
they
thing
this
thought
three
thrive
throw
thumb
thunder
ticket
tide
tiger
tilt
timber
time
tiny
tip
tired
tissue
title
toast
tobacco
today
toddler
toe
together
toilet
token
tomato
tomorrow
tone
tongue
tonight
tool
tooth
top
topic
topple
torch
tornado
tortoise
toss
total
tourist
toward
tower
town
toy
track
trade
traffic
tragic
train
transfer
trap
trash
travel
tray
treat
tree
trend
trial
tribe
trick
trigger
trim
trip
trophy
trouble
truck
true
truly
trumpet
trust
truth
try
tube
tuition
tumble
tuna
tunnel
turkey
turn
turtle
twelve
twenty
twice
twin
twist
two
type
typical
ugly
umbrella
unable
unaware
uncle
uncover
under
undo
unfair
unfold
unhappy
uniform
unique
unit
universe
unknown
unlock
until
unusual
unveil
update
upgrade
uphold
upon
upper
upset
urban
urge
usage
use
used
useful
useless
usual
utility
vacant
vacuum
vague
valid
valley
valve
van
vanish
vapor
various
vast
vault
vehicle
velvet
vendor
venture
venue
verb
verify
version
very
vessel
veteran
viable
vibrant
vicious
victory
video
view
village
vintage
violin
virtual
virus
visa
visit
visual
vital
vivid
vocal
voice
void
volcano
volume
vote
voyage
wage
wagon
wait
walk
wall
walnut
want
warfare
warm
warrior
wash
wasp
waste
water
wave
way
wealth
weapon
wear
weasel
weather
web
wedding
weekend
weird
welcome
west
wet
whale
what
wheat
wheel
when
where
whip
whisper
wide
width
wife
wild
will
win
window
wine
wing
wink
winner
winter
wire
wisdom
wise
wish
witness
wolf
woman
wonder
wood
wool
word
work
world
worry
worth
wrap
wreck
wrestle
wrist
write
wrong
yard
year
yellow
you
young
youth
zebra
zero
zone
zoo`.split("\n");
  },
});

// node_modules/xrpl/dist/npm/ECDSA.js
var require_ECDSA = __commonJS({
  "node_modules/xrpl/dist/npm/ECDSA.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ECDSA;
    (function (ECDSA2) {
      ECDSA2["ed25519"] = "ed25519";
      ECDSA2["secp256k1"] = "ecdsa-secp256k1";
    })(ECDSA || (ECDSA = {}));
    exports2.default = ECDSA;
  },
});

// node_modules/xrpl/dist/npm/models/transactions/accountDelete.js
var require_accountDelete = __commonJS({
  "node_modules/xrpl/dist/npm/models/transactions/accountDelete.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateAccountDelete = void 0;
    var common_1 = require_common();
    function validateAccountDelete(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(
        tx,
        "Destination",
        common_1.isAccount
      );
      (0, common_1.validateOptionalField)(
        tx,
        "DestinationTag",
        common_1.isNumber
      );
    }
    exports2.validateAccountDelete = validateAccountDelete;
  },
});

// node_modules/xrpl/dist/npm/models/transactions/AMMBid.js
var require_AMMBid = __commonJS({
  "node_modules/xrpl/dist/npm/models/transactions/AMMBid.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateAMMBid = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common();
    var MAX_AUTH_ACCOUNTS = 4;
    function validateAMMBid(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.Asset == null) {
        throw new errors_1.ValidationError("AMMBid: missing field Asset");
      }
      if (!(0, common_1.isCurrency)(tx.Asset)) {
        throw new errors_1.ValidationError("AMMBid: Asset must be a Currency");
      }
      if (tx.Asset2 == null) {
        throw new errors_1.ValidationError("AMMBid: missing field Asset2");
      }
      if (!(0, common_1.isCurrency)(tx.Asset2)) {
        throw new errors_1.ValidationError("AMMBid: Asset2 must be a Currency");
      }
      if (tx.BidMin != null && !(0, common_1.isAmount)(tx.BidMin)) {
        throw new errors_1.ValidationError("AMMBid: BidMin must be an Amount");
      }
      if (tx.BidMax != null && !(0, common_1.isAmount)(tx.BidMax)) {
        throw new errors_1.ValidationError("AMMBid: BidMax must be an Amount");
      }
      if (tx.AuthAccounts != null) {
        if (!Array.isArray(tx.AuthAccounts)) {
          throw new errors_1.ValidationError(
            `AMMBid: AuthAccounts must be an AuthAccount array`
          );
        }
        if (tx.AuthAccounts.length > MAX_AUTH_ACCOUNTS) {
          throw new errors_1.ValidationError(
            `AMMBid: AuthAccounts length must not be greater than ${MAX_AUTH_ACCOUNTS}`
          );
        }
        validateAuthAccounts(tx.Account, tx.AuthAccounts);
      }
    }
    exports2.validateAMMBid = validateAMMBid;
    function validateAuthAccounts(senderAddress, authAccounts) {
      for (const authAccount of authAccounts) {
        if (
          authAccount.AuthAccount == null ||
          typeof authAccount.AuthAccount !== "object"
        ) {
          throw new errors_1.ValidationError(`AMMBid: invalid AuthAccounts`);
        }
        if (authAccount.AuthAccount.Account == null) {
          throw new errors_1.ValidationError(`AMMBid: invalid AuthAccounts`);
        }
        if (typeof authAccount.AuthAccount.Account !== "string") {
          throw new errors_1.ValidationError(`AMMBid: invalid AuthAccounts`);
        }
        if (authAccount.AuthAccount.Account === senderAddress) {
          throw new errors_1.ValidationError(
            `AMMBid: AuthAccounts must not include sender's address`
          );
        }
      }
      return true;
    }
  },
});

// node_modules/xrpl/dist/npm/models/transactions/AMMCreate.js
var require_AMMCreate = __commonJS({
  "node_modules/xrpl/dist/npm/models/transactions/AMMCreate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateAMMCreate = exports2.AMM_MAX_TRADING_FEE = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common();
    exports2.AMM_MAX_TRADING_FEE = 1e3;
    function validateAMMCreate(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.Amount == null) {
        throw new errors_1.ValidationError("AMMCreate: missing field Amount");
      }
      if (!(0, common_1.isAmount)(tx.Amount)) {
        throw new errors_1.ValidationError(
          "AMMCreate: Amount must be an Amount"
        );
      }
      if (tx.Amount2 == null) {
        throw new errors_1.ValidationError("AMMCreate: missing field Amount2");
      }
      if (!(0, common_1.isAmount)(tx.Amount2)) {
        throw new errors_1.ValidationError(
          "AMMCreate: Amount2 must be an Amount"
        );
      }
      if (tx.TradingFee == null) {
        throw new errors_1.ValidationError(
          "AMMCreate: missing field TradingFee"
        );
      }
      if (typeof tx.TradingFee !== "number") {
        throw new errors_1.ValidationError(
          "AMMCreate: TradingFee must be a number"
        );
      }
      if (tx.TradingFee < 0 || tx.TradingFee > exports2.AMM_MAX_TRADING_FEE) {
        throw new errors_1.ValidationError(
          `AMMCreate: TradingFee must be between 0 and ${exports2.AMM_MAX_TRADING_FEE}`
        );
      }
    }
    exports2.validateAMMCreate = validateAMMCreate;
  },
});

// node_modules/xrpl/dist/npm/models/transactions/AMMDelete.js
var require_AMMDelete = __commonJS({
  "node_modules/xrpl/dist/npm/models/transactions/AMMDelete.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateAMMDelete = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common();
    function validateAMMDelete(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.Asset == null) {
        throw new errors_1.ValidationError("AMMDelete: missing field Asset");
      }
      if (!(0, common_1.isCurrency)(tx.Asset)) {
        throw new errors_1.ValidationError(
          "AMMDelete: Asset must be a Currency"
        );
      }
      if (tx.Asset2 == null) {
        throw new errors_1.ValidationError("AMMDelete: missing field Asset2");
      }
      if (!(0, common_1.isCurrency)(tx.Asset2)) {
        throw new errors_1.ValidationError(
          "AMMDelete: Asset2 must be a Currency"
        );
      }
    }
    exports2.validateAMMDelete = validateAMMDelete;
  },
});

// node_modules/xrpl/dist/npm/models/transactions/AMMVote.js
var require_AMMVote = __commonJS({
  "node_modules/xrpl/dist/npm/models/transactions/AMMVote.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateAMMVote = void 0;
    var errors_1 = require_errors();
    var AMMCreate_1 = require_AMMCreate();
    var common_1 = require_common();
    function validateAMMVote(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.Asset == null) {
        throw new errors_1.ValidationError("AMMVote: missing field Asset");
      }
      if (!(0, common_1.isCurrency)(tx.Asset)) {
        throw new errors_1.ValidationError("AMMVote: Asset must be a Currency");
      }
      if (tx.Asset2 == null) {
        throw new errors_1.ValidationError("AMMVote: missing field Asset2");
      }
      if (!(0, common_1.isCurrency)(tx.Asset2)) {
        throw new errors_1.ValidationError(
          "AMMVote: Asset2 must be a Currency"
        );
      }
      if (tx.TradingFee == null) {
        throw new errors_1.ValidationError("AMMVote: missing field TradingFee");
      }
      if (typeof tx.TradingFee !== "number") {
        throw new errors_1.ValidationError(
          "AMMVote: TradingFee must be a number"
        );
      }
      if (
        tx.TradingFee < 0 ||
        tx.TradingFee > AMMCreate_1.AMM_MAX_TRADING_FEE
      ) {
        throw new errors_1.ValidationError(
          `AMMVote: TradingFee must be between 0 and ${AMMCreate_1.AMM_MAX_TRADING_FEE}`
        );
      }
    }
    exports2.validateAMMVote = validateAMMVote;
  },
});

// node_modules/xrpl/dist/npm/models/transactions/checkCancel.js
var require_checkCancel = __commonJS({
  "node_modules/xrpl/dist/npm/models/transactions/checkCancel.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateCheckCancel = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common();
    function validateCheckCancel(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.CheckID !== void 0 && typeof tx.CheckID !== "string") {
        throw new errors_1.ValidationError("CheckCancel: invalid CheckID");
      }
    }
    exports2.validateCheckCancel = validateCheckCancel;
  },
});

// node_modules/xrpl/dist/npm/models/transactions/checkCash.js
var require_checkCash = __commonJS({
  "node_modules/xrpl/dist/npm/models/transactions/checkCash.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateCheckCash = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common();
    function validateCheckCash(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.Amount == null && tx.DeliverMin == null) {
        throw new errors_1.ValidationError(
          "CheckCash: must have either Amount or DeliverMin"
        );
      }
      if (tx.Amount != null && tx.DeliverMin != null) {
        throw new errors_1.ValidationError(
          "CheckCash: cannot have both Amount and DeliverMin"
        );
      }
      if (
        tx.Amount != null &&
        tx.Amount !== void 0 &&
        !(0, common_1.isAmount)(tx.Amount)
      ) {
        throw new errors_1.ValidationError("CheckCash: invalid Amount");
      }
      if (
        tx.DeliverMin != null &&
        tx.DeliverMin !== void 0 &&
        !(0, common_1.isAmount)(tx.DeliverMin)
      ) {
        throw new errors_1.ValidationError("CheckCash: invalid DeliverMin");
      }
      if (tx.CheckID !== void 0 && typeof tx.CheckID !== "string") {
        throw new errors_1.ValidationError("CheckCash: invalid CheckID");
      }
    }
    exports2.validateCheckCash = validateCheckCash;
  },
});

// node_modules/xrpl/dist/npm/models/transactions/checkCreate.js
var require_checkCreate = __commonJS({
  "node_modules/xrpl/dist/npm/models/transactions/checkCreate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateCheckCreate = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common();
    function validateCheckCreate(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.SendMax === void 0) {
        throw new errors_1.ValidationError(
          "CheckCreate: missing field SendMax"
        );
      }
      (0, common_1.validateRequiredField)(
        tx,
        "Destination",
        common_1.isAccount
      );
      (0, common_1.validateOptionalField)(
        tx,
        "DestinationTag",
        common_1.isNumber
      );
      if (
        typeof tx.SendMax !== "string" &&
        !(0, common_1.isIssuedCurrency)(tx.SendMax)
      ) {
        throw new errors_1.ValidationError("CheckCreate: invalid SendMax");
      }
      if (tx.Expiration !== void 0 && typeof tx.Expiration !== "number") {
        throw new errors_1.ValidationError("CheckCreate: invalid Expiration");
      }
      if (tx.InvoiceID !== void 0 && typeof tx.InvoiceID !== "string") {
        throw new errors_1.ValidationError("CheckCreate: invalid InvoiceID");
      }
    }
    exports2.validateCheckCreate = validateCheckCreate;
  },
});

// node_modules/xrpl/dist/npm/models/transactions/clawback.js
var require_clawback = __commonJS({
  "node_modules/xrpl/dist/npm/models/transactions/clawback.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateClawback = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common();
    function validateClawback(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.Amount == null) {
        throw new errors_1.ValidationError("Clawback: missing field Amount");
      }
      if (!(0, common_1.isIssuedCurrency)(tx.Amount)) {
        throw new errors_1.ValidationError("Clawback: invalid Amount");
      }
      if (
        (0, common_1.isIssuedCurrency)(tx.Amount) &&
        tx.Account === tx.Amount.issuer
      ) {
        throw new errors_1.ValidationError("Clawback: invalid holder Account");
      }
    }
    exports2.validateClawback = validateClawback;
  },
});

// node_modules/xrpl/dist/npm/models/transactions/depositPreauth.js
var require_depositPreauth = __commonJS({
  "node_modules/xrpl/dist/npm/models/transactions/depositPreauth.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateDepositPreauth = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common();
    function validateDepositPreauth(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.Authorize !== void 0 && tx.Unauthorize !== void 0) {
        throw new errors_1.ValidationError(
          "DepositPreauth: can't provide both Authorize and Unauthorize fields"
        );
      }
      if (tx.Authorize === void 0 && tx.Unauthorize === void 0) {
        throw new errors_1.ValidationError(
          "DepositPreauth: must provide either Authorize or Unauthorize field"
        );
      }
      if (tx.Authorize !== void 0) {
        if (typeof tx.Authorize !== "string") {
          throw new errors_1.ValidationError(
            "DepositPreauth: Authorize must be a string"
          );
        }
        if (tx.Account === tx.Authorize) {
          throw new errors_1.ValidationError(
            "DepositPreauth: Account can't preauthorize its own address"
          );
        }
      }
      if (tx.Unauthorize !== void 0) {
        if (typeof tx.Unauthorize !== "string") {
          throw new errors_1.ValidationError(
            "DepositPreauth: Unauthorize must be a string"
          );
        }
        if (tx.Account === tx.Unauthorize) {
          throw new errors_1.ValidationError(
            "DepositPreauth: Account can't unauthorize its own address"
          );
        }
      }
    }
    exports2.validateDepositPreauth = validateDepositPreauth;
  },
});

// node_modules/xrpl/dist/npm/models/transactions/DIDDelete.js
var require_DIDDelete = __commonJS({
  "node_modules/xrpl/dist/npm/models/transactions/DIDDelete.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateDIDDelete = void 0;
    var common_1 = require_common();
    function validateDIDDelete(tx) {
      (0, common_1.validateBaseTransaction)(tx);
    }
    exports2.validateDIDDelete = validateDIDDelete;
  },
});

// node_modules/xrpl/dist/npm/models/transactions/DIDSet.js
var require_DIDSet = __commonJS({
  "node_modules/xrpl/dist/npm/models/transactions/DIDSet.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateDIDSet = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common();
    function validateDIDSet(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateOptionalField)(tx, "Data", common_1.isString);
      (0, common_1.validateOptionalField)(tx, "DIDDocument", common_1.isString);
      (0, common_1.validateOptionalField)(tx, "URI", common_1.isString);
      if (
        tx.Data === void 0 &&
        tx.DIDDocument === void 0 &&
        tx.URI === void 0
      ) {
        throw new errors_1.ValidationError(
          "DIDSet: Must have at least one of `Data`, `DIDDocument`, and `URI`"
        );
      }
    }
    exports2.validateDIDSet = validateDIDSet;
  },
});

// node_modules/xrpl/dist/npm/models/transactions/escrowCancel.js
var require_escrowCancel = __commonJS({
  "node_modules/xrpl/dist/npm/models/transactions/escrowCancel.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateEscrowCancel = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common();
    function validateEscrowCancel(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "Owner", common_1.isAccount);
      if (tx.OfferSequence == null) {
        throw new errors_1.ValidationError(
          "EscrowCancel: missing OfferSequence"
        );
      }
      if (
        (typeof tx.OfferSequence !== "number" &&
          typeof tx.OfferSequence !== "string") ||
        Number.isNaN(Number(tx.OfferSequence))
      ) {
        throw new errors_1.ValidationError(
          "EscrowCancel: OfferSequence must be a number"
        );
      }
    }
    exports2.validateEscrowCancel = validateEscrowCancel;
  },
});

// node_modules/xrpl/dist/npm/models/transactions/escrowCreate.js
var require_escrowCreate = __commonJS({
  "node_modules/xrpl/dist/npm/models/transactions/escrowCreate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateEscrowCreate = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common();
    function validateEscrowCreate(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.Amount === void 0) {
        throw new errors_1.ValidationError(
          "EscrowCreate: missing field Amount"
        );
      }
      if (typeof tx.Amount !== "string") {
        throw new errors_1.ValidationError(
          "EscrowCreate: Amount must be a string"
        );
      }
      (0, common_1.validateRequiredField)(
        tx,
        "Destination",
        common_1.isAccount
      );
      (0, common_1.validateOptionalField)(
        tx,
        "DestinationTag",
        common_1.isNumber
      );
      if (tx.CancelAfter === void 0 && tx.FinishAfter === void 0) {
        throw new errors_1.ValidationError(
          "EscrowCreate: Either CancelAfter or FinishAfter must be specified"
        );
      }
      if (tx.FinishAfter === void 0 && tx.Condition === void 0) {
        throw new errors_1.ValidationError(
          "EscrowCreate: Either Condition or FinishAfter must be specified"
        );
      }
      if (tx.CancelAfter !== void 0 && typeof tx.CancelAfter !== "number") {
        throw new errors_1.ValidationError(
          "EscrowCreate: CancelAfter must be a number"
        );
      }
      if (tx.FinishAfter !== void 0 && typeof tx.FinishAfter !== "number") {
        throw new errors_1.ValidationError(
          "EscrowCreate: FinishAfter must be a number"
        );
      }
      if (tx.Condition !== void 0 && typeof tx.Condition !== "string") {
        throw new errors_1.ValidationError(
          "EscrowCreate: Condition must be a string"
        );
      }
    }
    exports2.validateEscrowCreate = validateEscrowCreate;
  },
});

// node_modules/xrpl/dist/npm/models/transactions/escrowFinish.js
var require_escrowFinish = __commonJS({
  "node_modules/xrpl/dist/npm/models/transactions/escrowFinish.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateEscrowFinish = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common();
    function validateEscrowFinish(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "Owner", common_1.isAccount);
      if (tx.OfferSequence == null) {
        throw new errors_1.ValidationError(
          "EscrowFinish: missing field OfferSequence"
        );
      }
      if (
        (typeof tx.OfferSequence !== "number" &&
          typeof tx.OfferSequence !== "string") ||
        Number.isNaN(Number(tx.OfferSequence))
      ) {
        throw new errors_1.ValidationError(
          "EscrowFinish: OfferSequence must be a number"
        );
      }
      if (tx.Condition !== void 0 && typeof tx.Condition !== "string") {
        throw new errors_1.ValidationError(
          "EscrowFinish: Condition must be a string"
        );
      }
      if (tx.Fulfillment !== void 0 && typeof tx.Fulfillment !== "string") {
        throw new errors_1.ValidationError(
          "EscrowFinish: Fulfillment must be a string"
        );
      }
    }
    exports2.validateEscrowFinish = validateEscrowFinish;
  },
});

// node_modules/xrpl/dist/npm/models/transactions/NFTokenAcceptOffer.js
var require_NFTokenAcceptOffer = __commonJS({
  "node_modules/xrpl/dist/npm/models/transactions/NFTokenAcceptOffer.js"(
    exports2
  ) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateNFTokenAcceptOffer = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common();
    function validateNFTokenBrokerFee(tx) {
      const value = (0, common_1.parseAmountValue)(tx.NFTokenBrokerFee);
      if (Number.isNaN(value)) {
        throw new errors_1.ValidationError(
          "NFTokenAcceptOffer: invalid NFTokenBrokerFee"
        );
      }
      if (value <= 0) {
        throw new errors_1.ValidationError(
          "NFTokenAcceptOffer: NFTokenBrokerFee must be greater than 0; omit if there is no fee"
        );
      }
      if (tx.NFTokenSellOffer == null || tx.NFTokenBuyOffer == null) {
        throw new errors_1.ValidationError(
          "NFTokenAcceptOffer: both NFTokenSellOffer and NFTokenBuyOffer must be set if using brokered mode"
        );
      }
    }
    function validateNFTokenAcceptOffer(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.NFTokenBrokerFee != null) {
        validateNFTokenBrokerFee(tx);
      }
      if (tx.NFTokenSellOffer == null && tx.NFTokenBuyOffer == null) {
        throw new errors_1.ValidationError(
          "NFTokenAcceptOffer: must set either NFTokenSellOffer or NFTokenBuyOffer"
        );
      }
    }
    exports2.validateNFTokenAcceptOffer = validateNFTokenAcceptOffer;
  },
});

// node_modules/xrpl/dist/npm/models/transactions/NFTokenBurn.js
var require_NFTokenBurn = __commonJS({
  "node_modules/xrpl/dist/npm/models/transactions/NFTokenBurn.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateNFTokenBurn = void 0;
    var common_1 = require_common();
    function validateNFTokenBurn(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "NFTokenID", common_1.isString);
      (0, common_1.validateOptionalField)(tx, "Owner", common_1.isAccount);
    }
    exports2.validateNFTokenBurn = validateNFTokenBurn;
  },
});

// node_modules/xrpl/dist/npm/models/transactions/NFTokenCancelOffer.js
var require_NFTokenCancelOffer = __commonJS({
  "node_modules/xrpl/dist/npm/models/transactions/NFTokenCancelOffer.js"(
    exports2
  ) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateNFTokenCancelOffer = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common();
    function validateNFTokenCancelOffer(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (!Array.isArray(tx.NFTokenOffers)) {
        throw new errors_1.ValidationError(
          "NFTokenCancelOffer: missing field NFTokenOffers"
        );
      }
      if (tx.NFTokenOffers.length < 1) {
        throw new errors_1.ValidationError(
          "NFTokenCancelOffer: empty field NFTokenOffers"
        );
      }
    }
    exports2.validateNFTokenCancelOffer = validateNFTokenCancelOffer;
  },
});

// node_modules/xrpl/dist/npm/models/transactions/offerCancel.js
var require_offerCancel = __commonJS({
  "node_modules/xrpl/dist/npm/models/transactions/offerCancel.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateOfferCancel = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common();
    function validateOfferCancel(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.OfferSequence === void 0) {
        throw new errors_1.ValidationError(
          "OfferCancel: missing field OfferSequence"
        );
      }
      if (typeof tx.OfferSequence !== "number") {
        throw new errors_1.ValidationError(
          "OfferCancel: OfferSequence must be a number"
        );
      }
    }
    exports2.validateOfferCancel = validateOfferCancel;
  },
});

// node_modules/xrpl/dist/npm/models/transactions/oracleDelete.js
var require_oracleDelete = __commonJS({
  "node_modules/xrpl/dist/npm/models/transactions/oracleDelete.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateOracleDelete = void 0;
    var common_1 = require_common();
    function validateOracleDelete(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(
        tx,
        "OracleDocumentID",
        common_1.isNumber
      );
    }
    exports2.validateOracleDelete = validateOracleDelete;
  },
});

// node_modules/xrpl/dist/npm/models/transactions/oracleSet.js
var require_oracleSet = __commonJS({
  "node_modules/xrpl/dist/npm/models/transactions/oracleSet.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateOracleSet = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common();
    var PRICE_DATA_SERIES_MAX_LENGTH = 10;
    var SCALE_MAX = 10;
    function validateOracleSet(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(
        tx,
        "OracleDocumentID",
        common_1.isNumber
      );
      (0, common_1.validateRequiredField)(
        tx,
        "LastUpdateTime",
        common_1.isNumber
      );
      (0, common_1.validateOptionalField)(tx, "Provider", common_1.isString);
      (0, common_1.validateOptionalField)(tx, "URI", common_1.isString);
      (0, common_1.validateOptionalField)(tx, "AssetClass", common_1.isString);
      (0, common_1.validateRequiredField)(tx, "PriceDataSeries", (value) => {
        if (!Array.isArray(value)) {
          throw new errors_1.ValidationError(
            "OracleSet: PriceDataSeries must be an array"
          );
        }
        if (value.length > PRICE_DATA_SERIES_MAX_LENGTH) {
          throw new errors_1.ValidationError(
            `OracleSet: PriceDataSeries must have at most ${PRICE_DATA_SERIES_MAX_LENGTH} PriceData objects`
          );
        }
        for (const priceData of value) {
          if (typeof priceData !== "object") {
            throw new errors_1.ValidationError(
              "OracleSet: PriceDataSeries must be an array of objects"
            );
          }
          if (priceData.PriceData == null) {
            throw new errors_1.ValidationError(
              "OracleSet: PriceDataSeries must have a `PriceData` object"
            );
          }
          if (Object.keys(priceData).length !== 1) {
            throw new errors_1.ValidationError(
              "OracleSet: PriceDataSeries must only have a single PriceData object"
            );
          }
          if (typeof priceData.PriceData.BaseAsset !== "string") {
            throw new errors_1.ValidationError(
              "OracleSet: PriceDataSeries must have a `BaseAsset` string"
            );
          }
          if (typeof priceData.PriceData.QuoteAsset !== "string") {
            throw new errors_1.ValidationError(
              "OracleSet: PriceDataSeries must have a `QuoteAsset` string"
            );
          }
          if (
            (priceData.PriceData.AssetPrice == null) !==
            (priceData.PriceData.Scale == null)
          ) {
            throw new errors_1.ValidationError(
              "OracleSet: PriceDataSeries must have both `AssetPrice` and `Scale` if any are present"
            );
          }
          if (
            "AssetPrice" in priceData.PriceData &&
            !(0, common_1.isNumber)(priceData.PriceData.AssetPrice)
          ) {
            throw new errors_1.ValidationError(
              "OracleSet: invalid field AssetPrice"
            );
          }
          if (
            "Scale" in priceData.PriceData &&
            !(0, common_1.isNumber)(priceData.PriceData.Scale)
          ) {
            throw new errors_1.ValidationError(
              "OracleSet: invalid field Scale"
            );
          }
          if (
            priceData.PriceData.Scale < 0 ||
            priceData.PriceData.Scale > SCALE_MAX
          ) {
            throw new errors_1.ValidationError(
              `OracleSet: Scale must be in range 0-${SCALE_MAX}`
            );
          }
        }
        return true;
      });
    }
    exports2.validateOracleSet = validateOracleSet;
  },
});

// node_modules/xrpl/dist/npm/models/transactions/paymentChannelCreate.js
var require_paymentChannelCreate = __commonJS({
  "node_modules/xrpl/dist/npm/models/transactions/paymentChannelCreate.js"(
    exports2
  ) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validatePaymentChannelCreate = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common();
    function validatePaymentChannelCreate(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.Amount === void 0) {
        throw new errors_1.ValidationError(
          "PaymentChannelCreate: missing Amount"
        );
      }
      if (typeof tx.Amount !== "string") {
        throw new errors_1.ValidationError(
          "PaymentChannelCreate: Amount must be a string"
        );
      }
      (0, common_1.validateRequiredField)(
        tx,
        "Destination",
        common_1.isAccount
      );
      (0, common_1.validateOptionalField)(
        tx,
        "DestinationTag",
        common_1.isNumber
      );
      if (tx.SettleDelay === void 0) {
        throw new errors_1.ValidationError(
          "PaymentChannelCreate: missing SettleDelay"
        );
      }
      if (typeof tx.SettleDelay !== "number") {
        throw new errors_1.ValidationError(
          "PaymentChannelCreate: SettleDelay must be a number"
        );
      }
      if (tx.PublicKey === void 0) {
        throw new errors_1.ValidationError(
          "PaymentChannelCreate: missing PublicKey"
        );
      }
      if (typeof tx.PublicKey !== "string") {
        throw new errors_1.ValidationError(
          "PaymentChannelCreate: PublicKey must be a string"
        );
      }
      if (tx.CancelAfter !== void 0 && typeof tx.CancelAfter !== "number") {
        throw new errors_1.ValidationError(
          "PaymentChannelCreate: CancelAfter must be a number"
        );
      }
    }
    exports2.validatePaymentChannelCreate = validatePaymentChannelCreate;
  },
});

// node_modules/xrpl/dist/npm/models/transactions/paymentChannelFund.js
var require_paymentChannelFund = __commonJS({
  "node_modules/xrpl/dist/npm/models/transactions/paymentChannelFund.js"(
    exports2
  ) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validatePaymentChannelFund = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common();
    function validatePaymentChannelFund(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.Channel === void 0) {
        throw new errors_1.ValidationError(
          "PaymentChannelFund: missing Channel"
        );
      }
      if (typeof tx.Channel !== "string") {
        throw new errors_1.ValidationError(
          "PaymentChannelFund: Channel must be a string"
        );
      }
      if (tx.Amount === void 0) {
        throw new errors_1.ValidationError(
          "PaymentChannelFund: missing Amount"
        );
      }
      if (typeof tx.Amount !== "string") {
        throw new errors_1.ValidationError(
          "PaymentChannelFund: Amount must be a string"
        );
      }
      if (tx.Expiration !== void 0 && typeof tx.Expiration !== "number") {
        throw new errors_1.ValidationError(
          "PaymentChannelFund: Expiration must be a number"
        );
      }
    }
    exports2.validatePaymentChannelFund = validatePaymentChannelFund;
  },
});

// node_modules/xrpl/dist/npm/models/transactions/setRegularKey.js
var require_setRegularKey = __commonJS({
  "node_modules/xrpl/dist/npm/models/transactions/setRegularKey.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateSetRegularKey = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common();
    function validateSetRegularKey(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.RegularKey !== void 0 && typeof tx.RegularKey !== "string") {
        throw new errors_1.ValidationError(
          "SetRegularKey: RegularKey must be a string"
        );
      }
    }
    exports2.validateSetRegularKey = validateSetRegularKey;
  },
});

// node_modules/xrpl/dist/npm/models/transactions/signerListSet.js
var require_signerListSet = __commonJS({
  "node_modules/xrpl/dist/npm/models/transactions/signerListSet.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateSignerListSet = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common();
    var MAX_SIGNERS = 32;
    var HEX_WALLET_LOCATOR_REGEX = /^[0-9A-Fa-f]{64}$/u;
    function validateSignerListSet(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      if (tx.SignerQuorum === void 0) {
        throw new errors_1.ValidationError(
          "SignerListSet: missing field SignerQuorum"
        );
      }
      if (typeof tx.SignerQuorum !== "number") {
        throw new errors_1.ValidationError(
          "SignerListSet: invalid SignerQuorum"
        );
      }
      if (tx.SignerQuorum === 0) {
        return;
      }
      if (tx.SignerEntries === void 0) {
        throw new errors_1.ValidationError(
          "SignerListSet: missing field SignerEntries"
        );
      }
      if (!Array.isArray(tx.SignerEntries)) {
        throw new errors_1.ValidationError(
          "SignerListSet: invalid SignerEntries"
        );
      }
      if (tx.SignerEntries.length === 0) {
        throw new errors_1.ValidationError(
          "SignerListSet: need at least 1 member in SignerEntries"
        );
      }
      if (tx.SignerEntries.length > MAX_SIGNERS) {
        throw new errors_1.ValidationError(
          `SignerListSet: maximum of ${MAX_SIGNERS} members allowed in SignerEntries`
        );
      }
      for (const entry of tx.SignerEntries) {
        const signerEntry = entry;
        const { WalletLocator } = signerEntry.SignerEntry;
        if (
          WalletLocator !== void 0 &&
          !HEX_WALLET_LOCATOR_REGEX.test(WalletLocator)
        ) {
          throw new errors_1.ValidationError(
            `SignerListSet: WalletLocator in SignerEntry must be a 256-bit (32-byte) hexadecimal value`
          );
        }
      }
    }
    exports2.validateSignerListSet = validateSignerListSet;
  },
});

// node_modules/xrpl/dist/npm/models/transactions/ticketCreate.js
var require_ticketCreate = __commonJS({
  "node_modules/xrpl/dist/npm/models/transactions/ticketCreate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateTicketCreate = void 0;
    var errors_1 = require_errors();
    var common_1 = require_common();
    var MAX_TICKETS = 250;
    function validateTicketCreate(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      const { TicketCount } = tx;
      if (TicketCount === void 0) {
        throw new errors_1.ValidationError(
          "TicketCreate: missing field TicketCount"
        );
      }
      if (typeof TicketCount !== "number") {
        throw new errors_1.ValidationError(
          "TicketCreate: TicketCount must be a number"
        );
      }
      if (
        !Number.isInteger(TicketCount) ||
        TicketCount < 1 ||
        TicketCount > MAX_TICKETS
      ) {
        throw new errors_1.ValidationError(
          "TicketCreate: TicketCount must be an integer from 1 to 250"
        );
      }
    }
    exports2.validateTicketCreate = validateTicketCreate;
  },
});

// node_modules/xrpl/dist/npm/models/transactions/XChainAccountCreateCommit.js
var require_XChainAccountCreateCommit = __commonJS({
  "node_modules/xrpl/dist/npm/models/transactions/XChainAccountCreateCommit.js"(
    exports2
  ) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateXChainAccountCreateCommit = void 0;
    var common_1 = require_common();
    function validateXChainAccountCreateCommit(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(
        tx,
        "XChainBridge",
        common_1.isXChainBridge
      );
      (0, common_1.validateRequiredField)(
        tx,
        "SignatureReward",
        common_1.isAmount
      );
      (0, common_1.validateRequiredField)(
        tx,
        "Destination",
        common_1.isAccount
      );
      (0, common_1.validateRequiredField)(tx, "Amount", common_1.isAmount);
    }
    exports2.validateXChainAccountCreateCommit =
      validateXChainAccountCreateCommit;
  },
});

// node_modules/xrpl/dist/npm/models/transactions/XChainAddAccountCreateAttestation.js
var require_XChainAddAccountCreateAttestation = __commonJS({
  "node_modules/xrpl/dist/npm/models/transactions/XChainAddAccountCreateAttestation.js"(
    exports2
  ) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateXChainAddAccountCreateAttestation = void 0;
    var common_1 = require_common();
    function validateXChainAddAccountCreateAttestation(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "Amount", common_1.isAmount);
      (0, common_1.validateRequiredField)(
        tx,
        "AttestationRewardAccount",
        common_1.isAccount
      );
      (0, common_1.validateRequiredField)(
        tx,
        "AttestationSignerAccount",
        common_1.isAccount
      );
      (0, common_1.validateRequiredField)(
        tx,
        "Destination",
        common_1.isAccount
      );
      (0, common_1.validateRequiredField)(
        tx,
        "OtherChainSource",
        common_1.isAccount
      );
      (0, common_1.validateRequiredField)(tx, "PublicKey", common_1.isString);
      (0, common_1.validateRequiredField)(tx, "Signature", common_1.isString);
      (0, common_1.validateRequiredField)(
        tx,
        "SignatureReward",
        common_1.isAmount
      );
      (0, common_1.validateRequiredField)(
        tx,
        "WasLockingChainSend",
        (inp) => inp === 0 || inp === 1
      );
      (0, common_1.validateRequiredField)(
        tx,
        "XChainAccountCreateCount",
        (inp) => (0, common_1.isNumber)(inp) || (0, common_1.isString)(inp)
      );
      (0, common_1.validateRequiredField)(
        tx,
        "XChainBridge",
        common_1.isXChainBridge
      );
    }
    exports2.validateXChainAddAccountCreateAttestation =
      validateXChainAddAccountCreateAttestation;
  },
});

// node_modules/xrpl/dist/npm/models/transactions/XChainAddClaimAttestation.js
var require_XChainAddClaimAttestation = __commonJS({
  "node_modules/xrpl/dist/npm/models/transactions/XChainAddClaimAttestation.js"(
    exports2
  ) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateXChainAddClaimAttestation = void 0;
    var common_1 = require_common();
    function validateXChainAddClaimAttestation(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(tx, "Amount", common_1.isAmount);
      (0, common_1.validateRequiredField)(
        tx,
        "AttestationRewardAccount",
        common_1.isAccount
      );
      (0, common_1.validateRequiredField)(
        tx,
        "AttestationSignerAccount",
        common_1.isAccount
      );
      (0, common_1.validateOptionalField)(
        tx,
        "Destination",
        common_1.isAccount
      );
      (0, common_1.validateRequiredField)(
        tx,
        "OtherChainSource",
        common_1.isAccount
      );
      (0, common_1.validateRequiredField)(tx, "PublicKey", common_1.isString);
      (0, common_1.validateRequiredField)(tx, "Signature", common_1.isString);
      (0, common_1.validateRequiredField)(
        tx,
        "WasLockingChainSend",
        (inp) => inp === 0 || inp === 1
      );
      (0, common_1.validateRequiredField)(
        tx,
        "XChainBridge",
        common_1.isXChainBridge
      );
      (0, common_1.validateRequiredField)(
        tx,
        "XChainClaimID",
        (inp) => (0, common_1.isNumber)(inp) || (0, common_1.isString)(inp)
      );
    }
    exports2.validateXChainAddClaimAttestation =
      validateXChainAddClaimAttestation;
  },
});

// node_modules/xrpl/dist/npm/models/transactions/XChainClaim.js
var require_XChainClaim = __commonJS({
  "node_modules/xrpl/dist/npm/models/transactions/XChainClaim.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateXChainClaim = void 0;
    var common_1 = require_common();
    function validateXChainClaim(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(
        tx,
        "XChainBridge",
        common_1.isXChainBridge
      );
      (0, common_1.validateRequiredField)(
        tx,
        "XChainClaimID",
        (inp) => (0, common_1.isNumber)(inp) || (0, common_1.isString)(inp)
      );
      (0, common_1.validateRequiredField)(
        tx,
        "Destination",
        common_1.isAccount
      );
      (0, common_1.validateOptionalField)(
        tx,
        "DestinationTag",
        common_1.isNumber
      );
      (0, common_1.validateRequiredField)(tx, "Amount", common_1.isAmount);
    }
    exports2.validateXChainClaim = validateXChainClaim;
  },
});

// node_modules/xrpl/dist/npm/models/transactions/XChainCommit.js
var require_XChainCommit = __commonJS({
  "node_modules/xrpl/dist/npm/models/transactions/XChainCommit.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateXChainCommit = void 0;
    var common_1 = require_common();
    function validateXChainCommit(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(
        tx,
        "XChainBridge",
        common_1.isXChainBridge
      );
      (0, common_1.validateRequiredField)(
        tx,
        "XChainClaimID",
        (inp) => (0, common_1.isNumber)(inp) || (0, common_1.isString)(inp)
      );
      (0, common_1.validateOptionalField)(
        tx,
        "OtherChainDestination",
        common_1.isAccount
      );
      (0, common_1.validateRequiredField)(tx, "Amount", common_1.isAmount);
    }
    exports2.validateXChainCommit = validateXChainCommit;
  },
});

// node_modules/xrpl/dist/npm/models/transactions/XChainCreateBridge.js
var require_XChainCreateBridge = __commonJS({
  "node_modules/xrpl/dist/npm/models/transactions/XChainCreateBridge.js"(
    exports2
  ) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateXChainCreateBridge = void 0;
    var common_1 = require_common();
    function validateXChainCreateBridge(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(
        tx,
        "XChainBridge",
        common_1.isXChainBridge
      );
      (0, common_1.validateRequiredField)(
        tx,
        "SignatureReward",
        common_1.isAmount
      );
      (0, common_1.validateOptionalField)(
        tx,
        "MinAccountCreateAmount",
        common_1.isAmount
      );
    }
    exports2.validateXChainCreateBridge = validateXChainCreateBridge;
  },
});

// node_modules/xrpl/dist/npm/models/transactions/XChainCreateClaimID.js
var require_XChainCreateClaimID = __commonJS({
  "node_modules/xrpl/dist/npm/models/transactions/XChainCreateClaimID.js"(
    exports2
  ) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateXChainCreateClaimID = void 0;
    var common_1 = require_common();
    function validateXChainCreateClaimID(tx) {
      (0, common_1.validateBaseTransaction)(tx);
      (0, common_1.validateRequiredField)(
        tx,
        "XChainBridge",
        common_1.isXChainBridge
      );
      (0, common_1.validateRequiredField)(
        tx,
        "SignatureReward",
        common_1.isAmount
      );
      (0, common_1.validateRequiredField)(
        tx,
        "OtherChainSource",
        common_1.isAccount
      );
    }
    exports2.validateXChainCreateClaimID = validateXChainCreateClaimID;
  },
});

// node_modules/xrpl/dist/npm/models/transactions/transaction.js
var require_transaction = __commonJS({
  "node_modules/xrpl/dist/npm/models/transactions/transaction.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validate = void 0;
    var errors_1 = require_errors();
    var utils_1 = require_utils5();
    var flags_1 = require_flags();
    var accountDelete_1 = require_accountDelete();
    var accountSet_1 = require_accountSet();
    var AMMBid_1 = require_AMMBid();
    var AMMCreate_1 = require_AMMCreate();
    var AMMDelete_1 = require_AMMDelete();
    var AMMDeposit_1 = require_AMMDeposit();
    var AMMVote_1 = require_AMMVote();
    var AMMWithdraw_1 = require_AMMWithdraw();
    var checkCancel_1 = require_checkCancel();
    var checkCash_1 = require_checkCash();
    var checkCreate_1 = require_checkCreate();
    var clawback_1 = require_clawback();
    var common_1 = require_common();
    var depositPreauth_1 = require_depositPreauth();
    var DIDDelete_1 = require_DIDDelete();
    var DIDSet_1 = require_DIDSet();
    var escrowCancel_1 = require_escrowCancel();
    var escrowCreate_1 = require_escrowCreate();
    var escrowFinish_1 = require_escrowFinish();
    var NFTokenAcceptOffer_1 = require_NFTokenAcceptOffer();
    var NFTokenBurn_1 = require_NFTokenBurn();
    var NFTokenCancelOffer_1 = require_NFTokenCancelOffer();
    var NFTokenCreateOffer_1 = require_NFTokenCreateOffer();
    var NFTokenMint_1 = require_NFTokenMint();
    var offerCancel_1 = require_offerCancel();
    var offerCreate_1 = require_offerCreate();
    var oracleDelete_1 = require_oracleDelete();
    var oracleSet_1 = require_oracleSet();
    var payment_1 = require_payment();
    var paymentChannelClaim_1 = require_paymentChannelClaim();
    var paymentChannelCreate_1 = require_paymentChannelCreate();
    var paymentChannelFund_1 = require_paymentChannelFund();
    var setRegularKey_1 = require_setRegularKey();
    var signerListSet_1 = require_signerListSet();
    var ticketCreate_1 = require_ticketCreate();
    var trustSet_1 = require_trustSet();
    var XChainAccountCreateCommit_1 = require_XChainAccountCreateCommit();
    var XChainAddAccountCreateAttestation_1 =
      require_XChainAddAccountCreateAttestation();
    var XChainAddClaimAttestation_1 = require_XChainAddClaimAttestation();
    var XChainClaim_1 = require_XChainClaim();
    var XChainCommit_1 = require_XChainCommit();
    var XChainCreateBridge_1 = require_XChainCreateBridge();
    var XChainCreateClaimID_1 = require_XChainCreateClaimID();
    var XChainModifyBridge_1 = require_XChainModifyBridge();
    function validate(transaction) {
      const tx = Object.assign({}, transaction);
      if (tx.TransactionType == null) {
        throw new errors_1.ValidationError(
          "Object does not have a `TransactionType`"
        );
      }
      if (typeof tx.TransactionType !== "string") {
        throw new errors_1.ValidationError(
          "Object's `TransactionType` is not a string"
        );
      }
      if (tx.Memos != null && typeof tx.Memos !== "object") {
        throw new errors_1.ValidationError("Memo must be array");
      }
      if (tx.Memos != null) {
        tx.Memos.forEach((memo) => {
          if ((memo === null || memo === void 0 ? void 0 : memo.Memo) == null) {
            throw new errors_1.ValidationError(
              "Memo data must be in a `Memo` field"
            );
          }
          if (memo.Memo.MemoData) {
            if (!(0, utils_1.isHex)(memo.Memo.MemoData)) {
              throw new errors_1.ValidationError(
                "MemoData field must be a hex value"
              );
            }
          }
          if (memo.Memo.MemoType) {
            if (!(0, utils_1.isHex)(memo.Memo.MemoType)) {
              throw new errors_1.ValidationError(
                "MemoType field must be a hex value"
              );
            }
          }
          if (memo.Memo.MemoFormat) {
            if (!(0, utils_1.isHex)(memo.Memo.MemoFormat)) {
              throw new errors_1.ValidationError(
                "MemoFormat field must be a hex value"
              );
            }
          }
        });
      }
      Object.keys(tx).forEach((key) => {
        const standard_currency_code_len = 3;
        if (tx[key] && (0, common_1.isIssuedCurrency)(tx[key])) {
          const txCurrency = tx[key].currency;
          if (
            txCurrency.length === standard_currency_code_len &&
            txCurrency.toUpperCase() === "XRP"
          ) {
            throw new errors_1.ValidationError(
              `Cannot have an issued currency with a similar standard code to XRP (received '${txCurrency}'). XRP is not an issued currency.`
            );
          }
        }
      });
      (0, flags_1.setTransactionFlagsToNumber)(tx);
      switch (tx.TransactionType) {
        case "AMMBid":
          (0, AMMBid_1.validateAMMBid)(tx);
          break;
        case "AMMCreate":
          (0, AMMCreate_1.validateAMMCreate)(tx);
          break;
        case "AMMDelete":
          (0, AMMDelete_1.validateAMMDelete)(tx);
          break;
        case "AMMDeposit":
          (0, AMMDeposit_1.validateAMMDeposit)(tx);
          break;
        case "AMMVote":
          (0, AMMVote_1.validateAMMVote)(tx);
          break;
        case "AMMWithdraw":
          (0, AMMWithdraw_1.validateAMMWithdraw)(tx);
          break;
        case "AccountDelete":
          (0, accountDelete_1.validateAccountDelete)(tx);
          break;
        case "AccountSet":
          (0, accountSet_1.validateAccountSet)(tx);
          break;
        case "CheckCancel":
          (0, checkCancel_1.validateCheckCancel)(tx);
          break;
        case "CheckCash":
          (0, checkCash_1.validateCheckCash)(tx);
          break;
        case "CheckCreate":
          (0, checkCreate_1.validateCheckCreate)(tx);
          break;
        case "Clawback":
          (0, clawback_1.validateClawback)(tx);
          break;
        case "DIDDelete":
          (0, DIDDelete_1.validateDIDDelete)(tx);
          break;
        case "DIDSet":
          (0, DIDSet_1.validateDIDSet)(tx);
          break;
        case "DepositPreauth":
          (0, depositPreauth_1.validateDepositPreauth)(tx);
          break;
        case "EscrowCancel":
          (0, escrowCancel_1.validateEscrowCancel)(tx);
          break;
        case "EscrowCreate":
          (0, escrowCreate_1.validateEscrowCreate)(tx);
          break;
        case "EscrowFinish":
          (0, escrowFinish_1.validateEscrowFinish)(tx);
          break;
        case "NFTokenAcceptOffer":
          (0, NFTokenAcceptOffer_1.validateNFTokenAcceptOffer)(tx);
          break;
        case "NFTokenBurn":
          (0, NFTokenBurn_1.validateNFTokenBurn)(tx);
          break;
        case "NFTokenCancelOffer":
          (0, NFTokenCancelOffer_1.validateNFTokenCancelOffer)(tx);
          break;
        case "NFTokenCreateOffer":
          (0, NFTokenCreateOffer_1.validateNFTokenCreateOffer)(tx);
          break;
        case "NFTokenMint":
          (0, NFTokenMint_1.validateNFTokenMint)(tx);
          break;
        case "OfferCancel":
          (0, offerCancel_1.validateOfferCancel)(tx);
          break;
        case "OfferCreate":
          (0, offerCreate_1.validateOfferCreate)(tx);
          break;
        case "OracleDelete":
          (0, oracleDelete_1.validateOracleDelete)(tx);
          break;
        case "OracleSet":
          (0, oracleSet_1.validateOracleSet)(tx);
          break;
        case "Payment":
          (0, payment_1.validatePayment)(tx);
          break;
        case "PaymentChannelClaim":
          (0, paymentChannelClaim_1.validatePaymentChannelClaim)(tx);
          break;
        case "PaymentChannelCreate":
          (0, paymentChannelCreate_1.validatePaymentChannelCreate)(tx);
          break;
        case "PaymentChannelFund":
          (0, paymentChannelFund_1.validatePaymentChannelFund)(tx);
          break;
        case "SetRegularKey":
          (0, setRegularKey_1.validateSetRegularKey)(tx);
          break;
        case "SignerListSet":
          (0, signerListSet_1.validateSignerListSet)(tx);
          break;
        case "TicketCreate":
          (0, ticketCreate_1.validateTicketCreate)(tx);
          break;
        case "TrustSet":
          (0, trustSet_1.validateTrustSet)(tx);
          break;
        case "XChainAccountCreateCommit":
          (0, XChainAccountCreateCommit_1.validateXChainAccountCreateCommit)(
            tx
          );
          break;
        case "XChainAddAccountCreateAttestation":
          (0,
          XChainAddAccountCreateAttestation_1.validateXChainAddAccountCreateAttestation)(
            tx
          );
          break;
        case "XChainAddClaimAttestation":
          (0, XChainAddClaimAttestation_1.validateXChainAddClaimAttestation)(
            tx
          );
          break;
        case "XChainClaim":
          (0, XChainClaim_1.validateXChainClaim)(tx);
          break;
        case "XChainCommit":
          (0, XChainCommit_1.validateXChainCommit)(tx);
          break;
        case "XChainCreateBridge":
          (0, XChainCreateBridge_1.validateXChainCreateBridge)(tx);
          break;
        case "XChainCreateClaimID":
          (0, XChainCreateClaimID_1.validateXChainCreateClaimID)(tx);
          break;
        case "XChainModifyBridge":
          (0, XChainModifyBridge_1.validateXChainModifyBridge)(tx);
          break;
        default:
          throw new errors_1.ValidationError(
            `Invalid field TransactionType: ${tx.TransactionType}`
          );
      }
    }
    exports2.validate = validate;
  },
});

// node_modules/xrpl/dist/npm/models/transactions/enableAmendment.js
var require_enableAmendment = __commonJS({
  "node_modules/xrpl/dist/npm/models/transactions/enableAmendment.js"(
    exports2
  ) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EnableAmendmentFlags = void 0;
    var EnableAmendmentFlags;
    (function (EnableAmendmentFlags2) {
      EnableAmendmentFlags2[(EnableAmendmentFlags2["tfGotMajority"] = 65536)] =
        "tfGotMajority";
      EnableAmendmentFlags2[
        (EnableAmendmentFlags2["tfLostMajority"] = 131072)
      ] = "tfLostMajority";
    })(
      EnableAmendmentFlags ||
        (exports2.EnableAmendmentFlags = EnableAmendmentFlags = {})
    );
  },
});

// node_modules/xrpl/dist/npm/models/transactions/index.js
var require_transactions = __commonJS({
  "node_modules/xrpl/dist/npm/models/transactions/index.js"(exports2) {
    "use strict";
    var __createBinding =
      (exports2 && exports2.__createBinding) ||
      (Object.create
        ? function (o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);
            if (
              !desc ||
              ("get" in desc
                ? !m.__esModule
                : desc.writable || desc.configurable)
            ) {
              desc = {
                enumerable: true,
                get: function () {
                  return m[k];
                },
              };
            }
            Object.defineProperty(o, k2, desc);
          }
        : function (o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            o[k2] = m[k];
          });
    var __exportStar =
      (exports2 && exports2.__exportStar) ||
      function (m, exports3) {
        for (var p in m)
          if (
            p !== "default" &&
            !Object.prototype.hasOwnProperty.call(exports3, p)
          )
            __createBinding(exports3, m, p);
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.XChainModifyBridgeFlags =
      exports2.TrustSetFlags =
      exports2.PaymentChannelClaimFlags =
      exports2.PaymentFlags =
      exports2.OfferCreateFlags =
      exports2.NFTokenMintFlags =
      exports2.NFTokenCreateOfferFlags =
      exports2.EnableAmendmentFlags =
      exports2.AMMWithdrawFlags =
      exports2.AMMDepositFlags =
      exports2.AccountSetTfFlags =
      exports2.AccountSetAsfFlags =
      exports2.validate =
        void 0;
    var transaction_1 = require_transaction();
    Object.defineProperty(exports2, "validate", {
      enumerable: true,
      get: function () {
        return transaction_1.validate;
      },
    });
    __exportStar(require_metadata(), exports2);
    var accountSet_1 = require_accountSet();
    Object.defineProperty(exports2, "AccountSetAsfFlags", {
      enumerable: true,
      get: function () {
        return accountSet_1.AccountSetAsfFlags;
      },
    });
    Object.defineProperty(exports2, "AccountSetTfFlags", {
      enumerable: true,
      get: function () {
        return accountSet_1.AccountSetTfFlags;
      },
    });
    var AMMDeposit_1 = require_AMMDeposit();
    Object.defineProperty(exports2, "AMMDepositFlags", {
      enumerable: true,
      get: function () {
        return AMMDeposit_1.AMMDepositFlags;
      },
    });
    var AMMWithdraw_1 = require_AMMWithdraw();
    Object.defineProperty(exports2, "AMMWithdrawFlags", {
      enumerable: true,
      get: function () {
        return AMMWithdraw_1.AMMWithdrawFlags;
      },
    });
    var enableAmendment_1 = require_enableAmendment();
    Object.defineProperty(exports2, "EnableAmendmentFlags", {
      enumerable: true,
      get: function () {
        return enableAmendment_1.EnableAmendmentFlags;
      },
    });
    var NFTokenCreateOffer_1 = require_NFTokenCreateOffer();
    Object.defineProperty(exports2, "NFTokenCreateOfferFlags", {
      enumerable: true,
      get: function () {
        return NFTokenCreateOffer_1.NFTokenCreateOfferFlags;
      },
    });
    var NFTokenMint_1 = require_NFTokenMint();
    Object.defineProperty(exports2, "NFTokenMintFlags", {
      enumerable: true,
      get: function () {
        return NFTokenMint_1.NFTokenMintFlags;
      },
    });
    var offerCreate_1 = require_offerCreate();
    Object.defineProperty(exports2, "OfferCreateFlags", {
      enumerable: true,
      get: function () {
        return offerCreate_1.OfferCreateFlags;
      },
    });
    var payment_1 = require_payment();
    Object.defineProperty(exports2, "PaymentFlags", {
      enumerable: true,
      get: function () {
        return payment_1.PaymentFlags;
      },
    });
    var paymentChannelClaim_1 = require_paymentChannelClaim();
    Object.defineProperty(exports2, "PaymentChannelClaimFlags", {
      enumerable: true,
      get: function () {
        return paymentChannelClaim_1.PaymentChannelClaimFlags;
      },
    });
    var trustSet_1 = require_trustSet();
    Object.defineProperty(exports2, "TrustSetFlags", {
      enumerable: true,
      get: function () {
        return trustSet_1.TrustSetFlags;
      },
    });
    var XChainModifyBridge_1 = require_XChainModifyBridge();
    Object.defineProperty(exports2, "XChainModifyBridgeFlags", {
      enumerable: true,
      get: function () {
        return XChainModifyBridge_1.XChainModifyBridgeFlags;
      },
    });
  },
});

// node_modules/xrpl/dist/npm/Wallet/rfc1751Words.json
var require_rfc1751Words = __commonJS({
  "node_modules/xrpl/dist/npm/Wallet/rfc1751Words.json"(exports2, module2) {
    module2.exports = [
      "A",
      "ABE",
      "ACE",
      "ACT",
      "AD",
      "ADA",
      "ADD",
      "AGO",
      "AID",
      "AIM",
      "AIR",
      "ALL",
      "ALP",
      "AM",
      "AMY",
      "AN",
      "ANA",
      "AND",
      "ANN",
      "ANT",
      "ANY",
      "APE",
      "APS",
      "APT",
      "ARC",
      "ARE",
      "ARK",
      "ARM",
      "ART",
      "AS",
      "ASH",
      "ASK",
      "AT",
      "ATE",
      "AUG",
      "AUK",
      "AVE",
      "AWE",
      "AWK",
      "AWL",
      "AWN",
      "AX",
      "AYE",
      "BAD",
      "BAG",
      "BAH",
      "BAM",
      "BAN",
      "BAR",
      "BAT",
      "BAY",
      "BE",
      "BED",
      "BEE",
      "BEG",
      "BEN",
      "BET",
      "BEY",
      "BIB",
      "BID",
      "BIG",
      "BIN",
      "BIT",
      "BOB",
      "BOG",
      "BON",
      "BOO",
      "BOP",
      "BOW",
      "BOY",
      "BUB",
      "BUD",
      "BUG",
      "BUM",
      "BUN",
      "BUS",
      "BUT",
      "BUY",
      "BY",
      "BYE",
      "CAB",
      "CAL",
      "CAM",
      "CAN",
      "CAP",
      "CAR",
      "CAT",
      "CAW",
      "COD",
      "COG",
      "COL",
      "CON",
      "COO",
      "COP",
      "COT",
      "COW",
      "COY",
      "CRY",
      "CUB",
      "CUE",
      "CUP",
      "CUR",
      "CUT",
      "DAB",
      "DAD",
      "DAM",
      "DAN",
      "DAR",
      "DAY",
      "DEE",
      "DEL",
      "DEN",
      "DES",
      "DEW",
      "DID",
      "DIE",
      "DIG",
      "DIN",
      "DIP",
      "DO",
      "DOE",
      "DOG",
      "DON",
      "DOT",
      "DOW",
      "DRY",
      "DUB",
      "DUD",
      "DUE",
      "DUG",
      "DUN",
      "EAR",
      "EAT",
      "ED",
      "EEL",
      "EGG",
      "EGO",
      "ELI",
      "ELK",
      "ELM",
      "ELY",
      "EM",
      "END",
      "EST",
      "ETC",
      "EVA",
      "EVE",
      "EWE",
      "EYE",
      "FAD",
      "FAN",
      "FAR",
      "FAT",
      "FAY",
      "FED",
      "FEE",
      "FEW",
      "FIB",
      "FIG",
      "FIN",
      "FIR",
      "FIT",
      "FLO",
      "FLY",
      "FOE",
      "FOG",
      "FOR",
      "FRY",
      "FUM",
      "FUN",
      "FUR",
      "GAB",
      "GAD",
      "GAG",
      "GAL",
      "GAM",
      "GAP",
      "GAS",
      "GAY",
      "GEE",
      "GEL",
      "GEM",
      "GET",
      "GIG",
      "GIL",
      "GIN",
      "GO",
      "GOT",
      "GUM",
      "GUN",
      "GUS",
      "GUT",
      "GUY",
      "GYM",
      "GYP",
      "HA",
      "HAD",
      "HAL",
      "HAM",
      "HAN",
      "HAP",
      "HAS",
      "HAT",
      "HAW",
      "HAY",
      "HE",
      "HEM",
      "HEN",
      "HER",
      "HEW",
      "HEY",
      "HI",
      "HID",
      "HIM",
      "HIP",
      "HIS",
      "HIT",
      "HO",
      "HOB",
      "HOC",
      "HOE",
      "HOG",
      "HOP",
      "HOT",
      "HOW",
      "HUB",
      "HUE",
      "HUG",
      "HUH",
      "HUM",
      "HUT",
      "I",
      "ICY",
      "IDA",
      "IF",
      "IKE",
      "ILL",
      "INK",
      "INN",
      "IO",
      "ION",
      "IQ",
      "IRA",
      "IRE",
      "IRK",
      "IS",
      "IT",
      "ITS",
      "IVY",
      "JAB",
      "JAG",
      "JAM",
      "JAN",
      "JAR",
      "JAW",
      "JAY",
      "JET",
      "JIG",
      "JIM",
      "JO",
      "JOB",
      "JOE",
      "JOG",
      "JOT",
      "JOY",
      "JUG",
      "JUT",
      "KAY",
      "KEG",
      "KEN",
      "KEY",
      "KID",
      "KIM",
      "KIN",
      "KIT",
      "LA",
      "LAB",
      "LAC",
      "LAD",
      "LAG",
      "LAM",
      "LAP",
      "LAW",
      "LAY",
      "LEA",
      "LED",
      "LEE",
      "LEG",
      "LEN",
      "LEO",
      "LET",
      "LEW",
      "LID",
      "LIE",
      "LIN",
      "LIP",
      "LIT",
      "LO",
      "LOB",
      "LOG",
      "LOP",
      "LOS",
      "LOT",
      "LOU",
      "LOW",
      "LOY",
      "LUG",
      "LYE",
      "MA",
      "MAC",
      "MAD",
      "MAE",
      "MAN",
      "MAO",
      "MAP",
      "MAT",
      "MAW",
      "MAY",
      "ME",
      "MEG",
      "MEL",
      "MEN",
      "MET",
      "MEW",
      "MID",
      "MIN",
      "MIT",
      "MOB",
      "MOD",
      "MOE",
      "MOO",
      "MOP",
      "MOS",
      "MOT",
      "MOW",
      "MUD",
      "MUG",
      "MUM",
      "MY",
      "NAB",
      "NAG",
      "NAN",
      "NAP",
      "NAT",
      "NAY",
      "NE",
      "NED",
      "NEE",
      "NET",
      "NEW",
      "NIB",
      "NIL",
      "NIP",
      "NIT",
      "NO",
      "NOB",
      "NOD",
      "NON",
      "NOR",
      "NOT",
      "NOV",
      "NOW",
      "NU",
      "NUN",
      "NUT",
      "O",
      "OAF",
      "OAK",
      "OAR",
      "OAT",
      "ODD",
      "ODE",
      "OF",
      "OFF",
      "OFT",
      "OH",
      "OIL",
      "OK",
      "OLD",
      "ON",
      "ONE",
      "OR",
      "ORB",
      "ORE",
      "ORR",
      "OS",
      "OTT",
      "OUR",
      "OUT",
      "OVA",
      "OW",
      "OWE",
      "OWL",
      "OWN",
      "OX",
      "PA",
      "PAD",
      "PAL",
      "PAM",
      "PAN",
      "PAP",
      "PAR",
      "PAT",
      "PAW",
      "PAY",
      "PEA",
      "PEG",
      "PEN",
      "PEP",
      "PER",
      "PET",
      "PEW",
      "PHI",
      "PI",
      "PIE",
      "PIN",
      "PIT",
      "PLY",
      "PO",
      "POD",
      "POE",
      "POP",
      "POT",
      "POW",
      "PRO",
      "PRY",
      "PUB",
      "PUG",
      "PUN",
      "PUP",
      "PUT",
      "QUO",
      "RAG",
      "RAM",
      "RAN",
      "RAP",
      "RAT",
      "RAW",
      "RAY",
      "REB",
      "RED",
      "REP",
      "RET",
      "RIB",
      "RID",
      "RIG",
      "RIM",
      "RIO",
      "RIP",
      "ROB",
      "ROD",
      "ROE",
      "RON",
      "ROT",
      "ROW",
      "ROY",
      "RUB",
      "RUE",
      "RUG",
      "RUM",
      "RUN",
      "RYE",
      "SAC",
      "SAD",
      "SAG",
      "SAL",
      "SAM",
      "SAN",
      "SAP",
      "SAT",
      "SAW",
      "SAY",
      "SEA",
      "SEC",
      "SEE",
      "SEN",
      "SET",
      "SEW",
      "SHE",
      "SHY",
      "SIN",
      "SIP",
      "SIR",
      "SIS",
      "SIT",
      "SKI",
      "SKY",
      "SLY",
      "SO",
      "SOB",
      "SOD",
      "SON",
      "SOP",
      "SOW",
      "SOY",
      "SPA",
      "SPY",
      "SUB",
      "SUD",
      "SUE",
      "SUM",
      "SUN",
      "SUP",
      "TAB",
      "TAD",
      "TAG",
      "TAN",
      "TAP",
      "TAR",
      "TEA",
      "TED",
      "TEE",
      "TEN",
      "THE",
      "THY",
      "TIC",
      "TIE",
      "TIM",
      "TIN",
      "TIP",
      "TO",
      "TOE",
      "TOG",
      "TOM",
      "TON",
      "TOO",
      "TOP",
      "TOW",
      "TOY",
      "TRY",
      "TUB",
      "TUG",
      "TUM",
      "TUN",
      "TWO",
      "UN",
      "UP",
      "US",
      "USE",
      "VAN",
      "VAT",
      "VET",
      "VIE",
      "WAD",
      "WAG",
      "WAR",
      "WAS",
      "WAY",
      "WE",
      "WEB",
      "WED",
      "WEE",
      "WET",
      "WHO",
      "WHY",
      "WIN",
      "WIT",
      "WOK",
      "WON",
      "WOO",
      "WOW",
      "WRY",
      "WU",
      "YAM",
      "YAP",
      "YAW",
      "YE",
      "YEA",
      "YES",
      "YET",
      "YOU",
      "ABED",
      "ABEL",
      "ABET",
      "ABLE",
      "ABUT",
      "ACHE",
      "ACID",
      "ACME",
      "ACRE",
      "ACTA",
      "ACTS",
      "ADAM",
      "ADDS",
      "ADEN",
      "AFAR",
      "AFRO",
      "AGEE",
      "AHEM",
      "AHOY",
      "AIDA",
      "AIDE",
      "AIDS",
      "AIRY",
      "AJAR",
      "AKIN",
      "ALAN",
      "ALEC",
      "ALGA",
      "ALIA",
      "ALLY",
      "ALMA",
      "ALOE",
      "ALSO",
      "ALTO",
      "ALUM",
      "ALVA",
      "AMEN",
      "AMES",
      "AMID",
      "AMMO",
      "AMOK",
      "AMOS",
      "AMRA",
      "ANDY",
      "ANEW",
      "ANNA",
      "ANNE",
      "ANTE",
      "ANTI",
      "AQUA",
      "ARAB",
      "ARCH",
      "AREA",
      "ARGO",
      "ARID",
      "ARMY",
      "ARTS",
      "ARTY",
      "ASIA",
      "ASKS",
      "ATOM",
      "AUNT",
      "AURA",
      "AUTO",
      "AVER",
      "AVID",
      "AVIS",
      "AVON",
      "AVOW",
      "AWAY",
      "AWRY",
      "BABE",
      "BABY",
      "BACH",
      "BACK",
      "BADE",
      "BAIL",
      "BAIT",
      "BAKE",
      "BALD",
      "BALE",
      "BALI",
      "BALK",
      "BALL",
      "BALM",
      "BAND",
      "BANE",
      "BANG",
      "BANK",
      "BARB",
      "BARD",
      "BARE",
      "BARK",
      "BARN",
      "BARR",
      "BASE",
      "BASH",
      "BASK",
      "BASS",
      "BATE",
      "BATH",
      "BAWD",
      "BAWL",
      "BEAD",
      "BEAK",
      "BEAM",
      "BEAN",
      "BEAR",
      "BEAT",
      "BEAU",
      "BECK",
      "BEEF",
      "BEEN",
      "BEER",
      "BEET",
      "BELA",
      "BELL",
      "BELT",
      "BEND",
      "BENT",
      "BERG",
      "BERN",
      "BERT",
      "BESS",
      "BEST",
      "BETA",
      "BETH",
      "BHOY",
      "BIAS",
      "BIDE",
      "BIEN",
      "BILE",
      "BILK",
      "BILL",
      "BIND",
      "BING",
      "BIRD",
      "BITE",
      "BITS",
      "BLAB",
      "BLAT",
      "BLED",
      "BLEW",
      "BLOB",
      "BLOC",
      "BLOT",
      "BLOW",
      "BLUE",
      "BLUM",
      "BLUR",
      "BOAR",
      "BOAT",
      "BOCA",
      "BOCK",
      "BODE",
      "BODY",
      "BOGY",
      "BOHR",
      "BOIL",
      "BOLD",
      "BOLO",
      "BOLT",
      "BOMB",
      "BONA",
      "BOND",
      "BONE",
      "BONG",
      "BONN",
      "BONY",
      "BOOK",
      "BOOM",
      "BOON",
      "BOOT",
      "BORE",
      "BORG",
      "BORN",
      "BOSE",
      "BOSS",
      "BOTH",
      "BOUT",
      "BOWL",
      "BOYD",
      "BRAD",
      "BRAE",
      "BRAG",
      "BRAN",
      "BRAY",
      "BRED",
      "BREW",
      "BRIG",
      "BRIM",
      "BROW",
      "BUCK",
      "BUDD",
      "BUFF",
      "BULB",
      "BULK",
      "BULL",
      "BUNK",
      "BUNT",
      "BUOY",
      "BURG",
      "BURL",
      "BURN",
      "BURR",
      "BURT",
      "BURY",
      "BUSH",
      "BUSS",
      "BUST",
      "BUSY",
      "BYTE",
      "CADY",
      "CAFE",
      "CAGE",
      "CAIN",
      "CAKE",
      "CALF",
      "CALL",
      "CALM",
      "CAME",
      "CANE",
      "CANT",
      "CARD",
      "CARE",
      "CARL",
      "CARR",
      "CART",
      "CASE",
      "CASH",
      "CASK",
      "CAST",
      "CAVE",
      "CEIL",
      "CELL",
      "CENT",
      "CERN",
      "CHAD",
      "CHAR",
      "CHAT",
      "CHAW",
      "CHEF",
      "CHEN",
      "CHEW",
      "CHIC",
      "CHIN",
      "CHOU",
      "CHOW",
      "CHUB",
      "CHUG",
      "CHUM",
      "CITE",
      "CITY",
      "CLAD",
      "CLAM",
      "CLAN",
      "CLAW",
      "CLAY",
      "CLOD",
      "CLOG",
      "CLOT",
      "CLUB",
      "CLUE",
      "COAL",
      "COAT",
      "COCA",
      "COCK",
      "COCO",
      "CODA",
      "CODE",
      "CODY",
      "COED",
      "COIL",
      "COIN",
      "COKE",
      "COLA",
      "COLD",
      "COLT",
      "COMA",
      "COMB",
      "COME",
      "COOK",
      "COOL",
      "COON",
      "COOT",
      "CORD",
      "CORE",
      "CORK",
      "CORN",
      "COST",
      "COVE",
      "COWL",
      "CRAB",
      "CRAG",
      "CRAM",
      "CRAY",
      "CREW",
      "CRIB",
      "CROW",
      "CRUD",
      "CUBA",
      "CUBE",
      "CUFF",
      "CULL",
      "CULT",
      "CUNY",
      "CURB",
      "CURD",
      "CURE",
      "CURL",
      "CURT",
      "CUTS",
      "DADE",
      "DALE",
      "DAME",
      "DANA",
      "DANE",
      "DANG",
      "DANK",
      "DARE",
      "DARK",
      "DARN",
      "DART",
      "DASH",
      "DATA",
      "DATE",
      "DAVE",
      "DAVY",
      "DAWN",
      "DAYS",
      "DEAD",
      "DEAF",
      "DEAL",
      "DEAN",
      "DEAR",
      "DEBT",
      "DECK",
      "DEED",
      "DEEM",
      "DEER",
      "DEFT",
      "DEFY",
      "DELL",
      "DENT",
      "DENY",
      "DESK",
      "DIAL",
      "DICE",
      "DIED",
      "DIET",
      "DIME",
      "DINE",
      "DING",
      "DINT",
      "DIRE",
      "DIRT",
      "DISC",
      "DISH",
      "DISK",
      "DIVE",
      "DOCK",
      "DOES",
      "DOLE",
      "DOLL",
      "DOLT",
      "DOME",
      "DONE",
      "DOOM",
      "DOOR",
      "DORA",
      "DOSE",
      "DOTE",
      "DOUG",
      "DOUR",
      "DOVE",
      "DOWN",
      "DRAB",
      "DRAG",
      "DRAM",
      "DRAW",
      "DREW",
      "DRUB",
      "DRUG",
      "DRUM",
      "DUAL",
      "DUCK",
      "DUCT",
      "DUEL",
      "DUET",
      "DUKE",
      "DULL",
      "DUMB",
      "DUNE",
      "DUNK",
      "DUSK",
      "DUST",
      "DUTY",
      "EACH",
      "EARL",
      "EARN",
      "EASE",
      "EAST",
      "EASY",
      "EBEN",
      "ECHO",
      "EDDY",
      "EDEN",
      "EDGE",
      "EDGY",
      "EDIT",
      "EDNA",
      "EGAN",
      "ELAN",
      "ELBA",
      "ELLA",
      "ELSE",
      "EMIL",
      "EMIT",
      "EMMA",
      "ENDS",
      "ERIC",
      "EROS",
      "EVEN",
      "EVER",
      "EVIL",
      "EYED",
      "FACE",
      "FACT",
      "FADE",
      "FAIL",
      "FAIN",
      "FAIR",
      "FAKE",
      "FALL",
      "FAME",
      "FANG",
      "FARM",
      "FAST",
      "FATE",
      "FAWN",
      "FEAR",
      "FEAT",
      "FEED",
      "FEEL",
      "FEET",
      "FELL",
      "FELT",
      "FEND",
      "FERN",
      "FEST",
      "FEUD",
      "FIEF",
      "FIGS",
      "FILE",
      "FILL",
      "FILM",
      "FIND",
      "FINE",
      "FINK",
      "FIRE",
      "FIRM",
      "FISH",
      "FISK",
      "FIST",
      "FITS",
      "FIVE",
      "FLAG",
      "FLAK",
      "FLAM",
      "FLAT",
      "FLAW",
      "FLEA",
      "FLED",
      "FLEW",
      "FLIT",
      "FLOC",
      "FLOG",
      "FLOW",
      "FLUB",
      "FLUE",
      "FOAL",
      "FOAM",
      "FOGY",
      "FOIL",
      "FOLD",
      "FOLK",
      "FOND",
      "FONT",
      "FOOD",
      "FOOL",
      "FOOT",
      "FORD",
      "FORE",
      "FORK",
      "FORM",
      "FORT",
      "FOSS",
      "FOUL",
      "FOUR",
      "FOWL",
      "FRAU",
      "FRAY",
      "FRED",
      "FREE",
      "FRET",
      "FREY",
      "FROG",
      "FROM",
      "FUEL",
      "FULL",
      "FUME",
      "FUND",
      "FUNK",
      "FURY",
      "FUSE",
      "FUSS",
      "GAFF",
      "GAGE",
      "GAIL",
      "GAIN",
      "GAIT",
      "GALA",
      "GALE",
      "GALL",
      "GALT",
      "GAME",
      "GANG",
      "GARB",
      "GARY",
      "GASH",
      "GATE",
      "GAUL",
      "GAUR",
      "GAVE",
      "GAWK",
      "GEAR",
      "GELD",
      "GENE",
      "GENT",
      "GERM",
      "GETS",
      "GIBE",
      "GIFT",
      "GILD",
      "GILL",
      "GILT",
      "GINA",
      "GIRD",
      "GIRL",
      "GIST",
      "GIVE",
      "GLAD",
      "GLEE",
      "GLEN",
      "GLIB",
      "GLOB",
      "GLOM",
      "GLOW",
      "GLUE",
      "GLUM",
      "GLUT",
      "GOAD",
      "GOAL",
      "GOAT",
      "GOER",
      "GOES",
      "GOLD",
      "GOLF",
      "GONE",
      "GONG",
      "GOOD",
      "GOOF",
      "GORE",
      "GORY",
      "GOSH",
      "GOUT",
      "GOWN",
      "GRAB",
      "GRAD",
      "GRAY",
      "GREG",
      "GREW",
      "GREY",
      "GRID",
      "GRIM",
      "GRIN",
      "GRIT",
      "GROW",
      "GRUB",
      "GULF",
      "GULL",
      "GUNK",
      "GURU",
      "GUSH",
      "GUST",
      "GWEN",
      "GWYN",
      "HAAG",
      "HAAS",
      "HACK",
      "HAIL",
      "HAIR",
      "HALE",
      "HALF",
      "HALL",
      "HALO",
      "HALT",
      "HAND",
      "HANG",
      "HANK",
      "HANS",
      "HARD",
      "HARK",
      "HARM",
      "HART",
      "HASH",
      "HAST",
      "HATE",
      "HATH",
      "HAUL",
      "HAVE",
      "HAWK",
      "HAYS",
      "HEAD",
      "HEAL",
      "HEAR",
      "HEAT",
      "HEBE",
      "HECK",
      "HEED",
      "HEEL",
      "HEFT",
      "HELD",
      "HELL",
      "HELM",
      "HERB",
      "HERD",
      "HERE",
      "HERO",
      "HERS",
      "HESS",
      "HEWN",
      "HICK",
      "HIDE",
      "HIGH",
      "HIKE",
      "HILL",
      "HILT",
      "HIND",
      "HINT",
      "HIRE",
      "HISS",
      "HIVE",
      "HOBO",
      "HOCK",
      "HOFF",
      "HOLD",
      "HOLE",
      "HOLM",
      "HOLT",
      "HOME",
      "HONE",
      "HONK",
      "HOOD",
      "HOOF",
      "HOOK",
      "HOOT",
      "HORN",
      "HOSE",
      "HOST",
      "HOUR",
      "HOVE",
      "HOWE",
      "HOWL",
      "HOYT",
      "HUCK",
      "HUED",
      "HUFF",
      "HUGE",
      "HUGH",
      "HUGO",
      "HULK",
      "HULL",
      "HUNK",
      "HUNT",
      "HURD",
      "HURL",
      "HURT",
      "HUSH",
      "HYDE",
      "HYMN",
      "IBIS",
      "ICON",
      "IDEA",
      "IDLE",
      "IFFY",
      "INCA",
      "INCH",
      "INTO",
      "IONS",
      "IOTA",
      "IOWA",
      "IRIS",
      "IRMA",
      "IRON",
      "ISLE",
      "ITCH",
      "ITEM",
      "IVAN",
      "JACK",
      "JADE",
      "JAIL",
      "JAKE",
      "JANE",
      "JAVA",
      "JEAN",
      "JEFF",
      "JERK",
      "JESS",
      "JEST",
      "JIBE",
      "JILL",
      "JILT",
      "JIVE",
      "JOAN",
      "JOBS",
      "JOCK",
      "JOEL",
      "JOEY",
      "JOHN",
      "JOIN",
      "JOKE",
      "JOLT",
      "JOVE",
      "JUDD",
      "JUDE",
      "JUDO",
      "JUDY",
      "JUJU",
      "JUKE",
      "JULY",
      "JUNE",
      "JUNK",
      "JUNO",
      "JURY",
      "JUST",
      "JUTE",
      "KAHN",
      "KALE",
      "KANE",
      "KANT",
      "KARL",
      "KATE",
      "KEEL",
      "KEEN",
      "KENO",
      "KENT",
      "KERN",
      "KERR",
      "KEYS",
      "KICK",
      "KILL",
      "KIND",
      "KING",
      "KIRK",
      "KISS",
      "KITE",
      "KLAN",
      "KNEE",
      "KNEW",
      "KNIT",
      "KNOB",
      "KNOT",
      "KNOW",
      "KOCH",
      "KONG",
      "KUDO",
      "KURD",
      "KURT",
      "KYLE",
      "LACE",
      "LACK",
      "LACY",
      "LADY",
      "LAID",
      "LAIN",
      "LAIR",
      "LAKE",
      "LAMB",
      "LAME",
      "LAND",
      "LANE",
      "LANG",
      "LARD",
      "LARK",
      "LASS",
      "LAST",
      "LATE",
      "LAUD",
      "LAVA",
      "LAWN",
      "LAWS",
      "LAYS",
      "LEAD",
      "LEAF",
      "LEAK",
      "LEAN",
      "LEAR",
      "LEEK",
      "LEER",
      "LEFT",
      "LEND",
      "LENS",
      "LENT",
      "LEON",
      "LESK",
      "LESS",
      "LEST",
      "LETS",
      "LIAR",
      "LICE",
      "LICK",
      "LIED",
      "LIEN",
      "LIES",
      "LIEU",
      "LIFE",
      "LIFT",
      "LIKE",
      "LILA",
      "LILT",
      "LILY",
      "LIMA",
      "LIMB",
      "LIME",
      "LIND",
      "LINE",
      "LINK",
      "LINT",
      "LION",
      "LISA",
      "LIST",
      "LIVE",
      "LOAD",
      "LOAF",
      "LOAM",
      "LOAN",
      "LOCK",
      "LOFT",
      "LOGE",
      "LOIS",
      "LOLA",
      "LONE",
      "LONG",
      "LOOK",
      "LOON",
      "LOOT",
      "LORD",
      "LORE",
      "LOSE",
      "LOSS",
      "LOST",
      "LOUD",
      "LOVE",
      "LOWE",
      "LUCK",
      "LUCY",
      "LUGE",
      "LUKE",
      "LULU",
      "LUND",
      "LUNG",
      "LURA",
      "LURE",
      "LURK",
      "LUSH",
      "LUST",
      "LYLE",
      "LYNN",
      "LYON",
      "LYRA",
      "MACE",
      "MADE",
      "MAGI",
      "MAID",
      "MAIL",
      "MAIN",
      "MAKE",
      "MALE",
      "MALI",
      "MALL",
      "MALT",
      "MANA",
      "MANN",
      "MANY",
      "MARC",
      "MARE",
      "MARK",
      "MARS",
      "MART",
      "MARY",
      "MASH",
      "MASK",
      "MASS",
      "MAST",
      "MATE",
      "MATH",
      "MAUL",
      "MAYO",
      "MEAD",
      "MEAL",
      "MEAN",
      "MEAT",
      "MEEK",
      "MEET",
      "MELD",
      "MELT",
      "MEMO",
      "MEND",
      "MENU",
      "MERT",
      "MESH",
      "MESS",
      "MICE",
      "MIKE",
      "MILD",
      "MILE",
      "MILK",
      "MILL",
      "MILT",
      "MIMI",
      "MIND",
      "MINE",
      "MINI",
      "MINK",
      "MINT",
      "MIRE",
      "MISS",
      "MIST",
      "MITE",
      "MITT",
      "MOAN",
      "MOAT",
      "MOCK",
      "MODE",
      "MOLD",
      "MOLE",
      "MOLL",
      "MOLT",
      "MONA",
      "MONK",
      "MONT",
      "MOOD",
      "MOON",
      "MOOR",
      "MOOT",
      "MORE",
      "MORN",
      "MORT",
      "MOSS",
      "MOST",
      "MOTH",
      "MOVE",
      "MUCH",
      "MUCK",
      "MUDD",
      "MUFF",
      "MULE",
      "MULL",
      "MURK",
      "MUSH",
      "MUST",
      "MUTE",
      "MUTT",
      "MYRA",
      "MYTH",
      "NAGY",
      "NAIL",
      "NAIR",
      "NAME",
      "NARY",
      "NASH",
      "NAVE",
      "NAVY",
      "NEAL",
      "NEAR",
      "NEAT",
      "NECK",
      "NEED",
      "NEIL",
      "NELL",
      "NEON",
      "NERO",
      "NESS",
      "NEST",
      "NEWS",
      "NEWT",
      "NIBS",
      "NICE",
      "NICK",
      "NILE",
      "NINA",
      "NINE",
      "NOAH",
      "NODE",
      "NOEL",
      "NOLL",
      "NONE",
      "NOOK",
      "NOON",
      "NORM",
      "NOSE",
      "NOTE",
      "NOUN",
      "NOVA",
      "NUDE",
      "NULL",
      "NUMB",
      "OATH",
      "OBEY",
      "OBOE",
      "ODIN",
      "OHIO",
      "OILY",
      "OINT",
      "OKAY",
      "OLAF",
      "OLDY",
      "OLGA",
      "OLIN",
      "OMAN",
      "OMEN",
      "OMIT",
      "ONCE",
      "ONES",
      "ONLY",
      "ONTO",
      "ONUS",
      "ORAL",
      "ORGY",
      "OSLO",
      "OTIS",
      "OTTO",
      "OUCH",
      "OUST",
      "OUTS",
      "OVAL",
      "OVEN",
      "OVER",
      "OWLY",
      "OWNS",
      "QUAD",
      "QUIT",
      "QUOD",
      "RACE",
      "RACK",
      "RACY",
      "RAFT",
      "RAGE",
      "RAID",
      "RAIL",
      "RAIN",
      "RAKE",
      "RANK",
      "RANT",
      "RARE",
      "RASH",
      "RATE",
      "RAVE",
      "RAYS",
      "READ",
      "REAL",
      "REAM",
      "REAR",
      "RECK",
      "REED",
      "REEF",
      "REEK",
      "REEL",
      "REID",
      "REIN",
      "RENA",
      "REND",
      "RENT",
      "REST",
      "RICE",
      "RICH",
      "RICK",
      "RIDE",
      "RIFT",
      "RILL",
      "RIME",
      "RING",
      "RINK",
      "RISE",
      "RISK",
      "RITE",
      "ROAD",
      "ROAM",
      "ROAR",
      "ROBE",
      "ROCK",
      "RODE",
      "ROIL",
      "ROLL",
      "ROME",
      "ROOD",
      "ROOF",
      "ROOK",
      "ROOM",
      "ROOT",
      "ROSA",
      "ROSE",
      "ROSS",
      "ROSY",
      "ROTH",
      "ROUT",
      "ROVE",
      "ROWE",
      "ROWS",
      "RUBE",
      "RUBY",
      "RUDE",
      "RUDY",
      "RUIN",
      "RULE",
      "RUNG",
      "RUNS",
      "RUNT",
      "RUSE",
      "RUSH",
      "RUSK",
      "RUSS",
      "RUST",
      "RUTH",
      "SACK",
      "SAFE",
      "SAGE",
      "SAID",
      "SAIL",
      "SALE",
      "SALK",
      "SALT",
      "SAME",
      "SAND",
      "SANE",
      "SANG",
      "SANK",
      "SARA",
      "SAUL",
      "SAVE",
      "SAYS",
      "SCAN",
      "SCAR",
      "SCAT",
      "SCOT",
      "SEAL",
      "SEAM",
      "SEAR",
      "SEAT",
      "SEED",
      "SEEK",
      "SEEM",
      "SEEN",
      "SEES",
      "SELF",
      "SELL",
      "SEND",
      "SENT",
      "SETS",
      "SEWN",
      "SHAG",
      "SHAM",
      "SHAW",
      "SHAY",
      "SHED",
      "SHIM",
      "SHIN",
      "SHOD",
      "SHOE",
      "SHOT",
      "SHOW",
      "SHUN",
      "SHUT",
      "SICK",
      "SIDE",
      "SIFT",
      "SIGH",
      "SIGN",
      "SILK",
      "SILL",
      "SILO",
      "SILT",
      "SINE",
      "SING",
      "SINK",
      "SIRE",
      "SITE",
      "SITS",
      "SITU",
      "SKAT",
      "SKEW",
      "SKID",
      "SKIM",
      "SKIN",
      "SKIT",
      "SLAB",
      "SLAM",
      "SLAT",
      "SLAY",
      "SLED",
      "SLEW",
      "SLID",
      "SLIM",
      "SLIT",
      "SLOB",
      "SLOG",
      "SLOT",
      "SLOW",
      "SLUG",
      "SLUM",
      "SLUR",
      "SMOG",
      "SMUG",
      "SNAG",
      "SNOB",
      "SNOW",
      "SNUB",
      "SNUG",
      "SOAK",
      "SOAR",
      "SOCK",
      "SODA",
      "SOFA",
      "SOFT",
      "SOIL",
      "SOLD",
      "SOME",
      "SONG",
      "SOON",
      "SOOT",
      "SORE",
      "SORT",
      "SOUL",
      "SOUR",
      "SOWN",
      "STAB",
      "STAG",
      "STAN",
      "STAR",
      "STAY",
      "STEM",
      "STEW",
      "STIR",
      "STOW",
      "STUB",
      "STUN",
      "SUCH",
      "SUDS",
      "SUIT",
      "SULK",
      "SUMS",
      "SUNG",
      "SUNK",
      "SURE",
      "SURF",
      "SWAB",
      "SWAG",
      "SWAM",
      "SWAN",
      "SWAT",
      "SWAY",
      "SWIM",
      "SWUM",
      "TACK",
      "TACT",
      "TAIL",
      "TAKE",
      "TALE",
      "TALK",
      "TALL",
      "TANK",
      "TASK",
      "TATE",
      "TAUT",
      "TEAL",
      "TEAM",
      "TEAR",
      "TECH",
      "TEEM",
      "TEEN",
      "TEET",
      "TELL",
      "TEND",
      "TENT",
      "TERM",
      "TERN",
      "TESS",
      "TEST",
      "THAN",
      "THAT",
      "THEE",
      "THEM",
      "THEN",
      "THEY",
      "THIN",
      "THIS",
      "THUD",
      "THUG",
      "TICK",
      "TIDE",
      "TIDY",
      "TIED",
      "TIER",
      "TILE",
      "TILL",
      "TILT",
      "TIME",
      "TINA",
      "TINE",
      "TINT",
      "TINY",
      "TIRE",
      "TOAD",
      "TOGO",
      "TOIL",
      "TOLD",
      "TOLL",
      "TONE",
      "TONG",
      "TONY",
      "TOOK",
      "TOOL",
      "TOOT",
      "TORE",
      "TORN",
      "TOTE",
      "TOUR",
      "TOUT",
      "TOWN",
      "TRAG",
      "TRAM",
      "TRAY",
      "TREE",
      "TREK",
      "TRIG",
      "TRIM",
      "TRIO",
      "TROD",
      "TROT",
      "TROY",
      "TRUE",
      "TUBA",
      "TUBE",
      "TUCK",
      "TUFT",
      "TUNA",
      "TUNE",
      "TUNG",
      "TURF",
      "TURN",
      "TUSK",
      "TWIG",
      "TWIN",
      "TWIT",
      "ULAN",
      "UNIT",
      "URGE",
      "USED",
      "USER",
      "USES",
      "UTAH",
      "VAIL",
      "VAIN",
      "VALE",
      "VARY",
      "VASE",
      "VAST",
      "VEAL",
      "VEDA",
      "VEIL",
      "VEIN",
      "VEND",
      "VENT",
      "VERB",
      "VERY",
      "VETO",
      "VICE",
      "VIEW",
      "VINE",
      "VISE",
      "VOID",
      "VOLT",
      "VOTE",
      "WACK",
      "WADE",
      "WAGE",
      "WAIL",
      "WAIT",
      "WAKE",
      "WALE",
      "WALK",
      "WALL",
      "WALT",
      "WAND",
      "WANE",
      "WANG",
      "WANT",
      "WARD",
      "WARM",
      "WARN",
      "WART",
      "WASH",
      "WAST",
      "WATS",
      "WATT",
      "WAVE",
      "WAVY",
      "WAYS",
      "WEAK",
      "WEAL",
      "WEAN",
      "WEAR",
      "WEED",
      "WEEK",
      "WEIR",
      "WELD",
      "WELL",
      "WELT",
      "WENT",
      "WERE",
      "WERT",
      "WEST",
      "WHAM",
      "WHAT",
      "WHEE",
      "WHEN",
      "WHET",
      "WHOA",
      "WHOM",
      "WICK",
      "WIFE",
      "WILD",
      "WILL",
      "WIND",
      "WINE",
      "WING",
      "WINK",
      "WINO",
      "WIRE",
      "WISE",
      "WISH",
      "WITH",
      "WOLF",
      "WONT",
      "WOOD",
      "WOOL",
      "WORD",
      "WORE",
      "WORK",
      "WORM",
      "WORN",
      "WOVE",
      "WRIT",
      "WYNN",
      "YALE",
      "YANG",
      "YANK",
      "YARD",
      "YARN",
      "YAWL",
      "YAWN",
      "YEAH",
      "YEAR",
      "YELL",
      "YOGA",
      "YOKE",
    ];
  },
});

// node_modules/xrpl/dist/npm/Wallet/rfc1751.js
var require_rfc1751 = __commonJS({
  "node_modules/xrpl/dist/npm/Wallet/rfc1751.js"(exports2) {
    "use strict";
    var __importDefault =
      (exports2 && exports2.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.keyToRFC1751Mnemonic = exports2.rfc1751MnemonicToKey = void 0;
    var utils_1 = require_utils2();
    var rfc1751Words_json_1 = __importDefault(require_rfc1751Words());
    var rfc1751WordList = rfc1751Words_json_1.default;
    var BINARY = [
      "0000",
      "0001",
      "0010",
      "0011",
      "0100",
      "0101",
      "0110",
      "0111",
      "1000",
      "1001",
      "1010",
      "1011",
      "1100",
      "1101",
      "1110",
      "1111",
    ];
    function keyToBinary(key) {
      let res = "";
      for (const num of key) {
        res += BINARY[num >> 4] + BINARY[num & 15];
      }
      return res;
    }
    function extract(key, start, length) {
      const subKey = key.substring(start, start + length);
      let acc = 0;
      for (let index = 0; index < subKey.length; index++) {
        acc = acc * 2 + subKey.charCodeAt(index) - 48;
      }
      return acc;
    }
    function keyToRFC1751Mnemonic(hex_key) {
      const buf = (0, utils_1.hexToBytes)(hex_key.replace(/\s+/gu, ""));
      let key = bufferToArray(swap128(buf));
      const padding = [];
      for (let index = 0; index < (8 - (key.length % 8)) % 8; index++) {
        padding.push(0);
      }
      key = padding.concat(key);
      const english = [];
      for (let index = 0; index < key.length; index += 8) {
        const subKey = key.slice(index, index + 8);
        let skbin = keyToBinary(subKey);
        let parity = 0;
        for (let j = 0; j < 64; j += 2) {
          parity += extract(skbin, j, 2);
        }
        subKey.push((parity << 6) & 255);
        skbin = keyToBinary(subKey);
        for (let j = 0; j < 64; j += 11) {
          english.push(rfc1751WordList[extract(skbin, j, 11)]);
        }
      }
      return english.join(" ");
    }
    exports2.keyToRFC1751Mnemonic = keyToRFC1751Mnemonic;
    function rfc1751MnemonicToKey(english) {
      const words = english.split(" ");
      let key = [];
      for (let index = 0; index < words.length; index += 6) {
        const { subKey, word } = getSubKey(words, index);
        const skbin = keyToBinary(subKey);
        let parity = 0;
        for (let j = 0; j < 64; j += 2) {
          parity += extract(skbin, j, 2);
        }
        const cs0 = extract(skbin, 64, 2);
        const cs1 = parity & 3;
        if (cs0 !== cs1) {
          throw new Error(`Parity error at ${word}`);
        }
        key = key.concat(subKey.slice(0, 8));
      }
      const bufferKey = swap128(Uint8Array.from(key));
      return bufferKey;
    }
    exports2.rfc1751MnemonicToKey = rfc1751MnemonicToKey;
    function getSubKey(words, index) {
      const sublist = words.slice(index, index + 6);
      let bits = 0;
      const ch = [0, 0, 0, 0, 0, 0, 0, 0, 0];
      let word = "";
      for (word of sublist) {
        const idx = rfc1751WordList.indexOf(word.toUpperCase());
        if (idx === -1) {
          throw new TypeError(
            `Expected an RFC1751 word, but received '${word}'. For the full list of words in the RFC1751 encoding see https://datatracker.ietf.org/doc/html/rfc1751`
          );
        }
        const shift = (8 - ((bits + 11) % 8)) % 8;
        const y = idx << shift;
        const cl = y >> 16;
        const cc = (y >> 8) & 255;
        const cr = y & 255;
        const t = Math.floor(bits / 8);
        if (shift > 5) {
          ch[t] |= cl;
          ch[t + 1] |= cc;
          ch[t + 2] |= cr;
        } else if (shift > -3) {
          ch[t] |= cc;
          ch[t + 1] |= cr;
        } else {
          ch[t] |= cr;
        }
        bits += 11;
      }
      const subKey = ch.slice();
      return { subKey, word };
    }
    function bufferToArray(buf) {
      return Array.prototype.slice.call(buf);
    }
    function swap(arr, n, m) {
      const i = arr[n];
      arr[n] = arr[m];
      arr[m] = i;
    }
    function swap64(arr) {
      const len = arr.length;
      for (let i = 0; i < len; i += 8) {
        swap(arr, i, i + 7);
        swap(arr, i + 1, i + 6);
        swap(arr, i + 2, i + 5);
        swap(arr, i + 3, i + 4);
      }
      return arr;
    }
    function swap128(arr) {
      const reversedBytes = swap64(arr);
      return (0, utils_1.concat)([
        reversedBytes.slice(8, 16),
        reversedBytes.slice(0, 8),
      ]);
    }
  },
});

// node_modules/xrpl/dist/npm/Wallet/signer.js
var require_signer = __commonJS({
  "node_modules/xrpl/dist/npm/Wallet/signer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.multisign = exports2.verifySignature = void 0;
    var utils_1 = require_utils2();
    var bignumber_js_1 = require_bignumber();
    var ripple_address_codec_1 = require_dist();
    var ripple_binary_codec_1 = require_dist2();
    var ripple_keypairs_1 = require_dist3();
    var errors_1 = require_errors();
    var transactions_1 = require_transactions();
    function multisign(transactions) {
      if (transactions.length === 0) {
        throw new errors_1.ValidationError(
          "There were 0 transactions to multisign"
        );
      }
      const decodedTransactions = transactions.map((txOrBlob) => {
        return getDecodedTransaction(txOrBlob);
      });
      decodedTransactions.forEach((tx) => {
        (0, transactions_1.validate)(tx);
        if (tx.Signers == null || tx.Signers.length === 0) {
          throw new errors_1.ValidationError(
            "For multisigning all transactions must include a Signers field containing an array of signatures. You may have forgotten to pass the 'forMultisign' parameter when signing."
          );
        }
        if (tx.SigningPubKey !== "") {
          throw new errors_1.ValidationError(
            "SigningPubKey must be an empty string for all transactions when multisigning."
          );
        }
      });
      validateTransactionEquivalence(decodedTransactions);
      return (0, ripple_binary_codec_1.encode)(
        getTransactionWithAllSigners(decodedTransactions)
      );
    }
    exports2.multisign = multisign;
    function verifySignature(tx, publicKey) {
      const decodedTx = getDecodedTransaction(tx);
      let key = publicKey;
      if (
        typeof decodedTx.TxnSignature !== "string" ||
        !decodedTx.TxnSignature
      ) {
        throw new Error("Transaction is missing a signature, TxnSignature");
      }
      if (!key) {
        if (
          typeof decodedTx.SigningPubKey !== "string" ||
          !decodedTx.SigningPubKey
        ) {
          throw new Error("Transaction is missing a public key, SigningPubKey");
        }
        key = decodedTx.SigningPubKey;
      }
      return (0, ripple_keypairs_1.verify)(
        (0, ripple_binary_codec_1.encodeForSigning)(decodedTx),
        decodedTx.TxnSignature,
        key
      );
    }
    exports2.verifySignature = verifySignature;
    function validateTransactionEquivalence(transactions) {
      const exampleTransaction = JSON.stringify(
        Object.assign(Object.assign({}, transactions[0]), { Signers: null })
      );
      if (
        transactions
          .slice(1)
          .some(
            (tx) =>
              JSON.stringify(
                Object.assign(Object.assign({}, tx), { Signers: null })
              ) !== exampleTransaction
          )
      ) {
        throw new errors_1.ValidationError(
          "txJSON is not the same for all signedTransactions"
        );
      }
    }
    function getTransactionWithAllSigners(transactions) {
      const sortedSigners = transactions
        .flatMap((tx) => {
          var _a;
          return (_a = tx.Signers) !== null && _a !== void 0 ? _a : [];
        })
        .sort(compareSigners);
      return Object.assign(Object.assign({}, transactions[0]), {
        Signers: sortedSigners,
      });
    }
    function compareSigners(left, right) {
      return addressToBigNumber(left.Signer.Account).comparedTo(
        addressToBigNumber(right.Signer.Account)
      );
    }
    var NUM_BITS_IN_HEX = 16;
    function addressToBigNumber(address) {
      const hex = (0, utils_1.bytesToHex)(
        (0, ripple_address_codec_1.decodeAccountID)(address)
      );
      return new bignumber_js_1.BigNumber(hex, NUM_BITS_IN_HEX);
    }
    function getDecodedTransaction(txOrBlob) {
      if (typeof txOrBlob === "object") {
        return (0, ripple_binary_codec_1.decode)(
          (0, ripple_binary_codec_1.encode)(txOrBlob)
        );
      }
      return (0, ripple_binary_codec_1.decode)(txOrBlob);
    }
  },
});

// node_modules/xrpl/dist/npm/Wallet/index.js
var require_Wallet = __commonJS({
  "node_modules/xrpl/dist/npm/Wallet/index.js"(exports2) {
    "use strict";
    var __importDefault =
      (exports2 && exports2.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Wallet = void 0;
    var bip32_1 = require_lib2();
    var bip39_1 = require_bip39();
    var english_1 = require_english();
    var utils_1 = require_utils2();
    var bignumber_js_1 = __importDefault(require_bignumber());
    var ripple_address_codec_1 = require_dist();
    var ripple_binary_codec_1 = require_dist2();
    var ripple_keypairs_1 = require_dist3();
    var ECDSA_1 = __importDefault(require_ECDSA());
    var errors_1 = require_errors();
    var transactions_1 = require_transactions();
    var utils_2 = require_utils6();
    var collections_1 = require_collections();
    var hashLedger_1 = require_hashLedger();
    var rfc1751_1 = require_rfc1751();
    var signer_1 = require_signer();
    var DEFAULT_ALGORITHM = ECDSA_1.default.ed25519;
    var DEFAULT_DERIVATION_PATH = "m/44'/144'/0'/0/0";
    function validateKey(node) {
      if (!(node.privateKey instanceof Uint8Array)) {
        throw new errors_1.ValidationError(
          "Unable to derive privateKey from mnemonic input"
        );
      }
      if (!(node.publicKey instanceof Uint8Array)) {
        throw new errors_1.ValidationError(
          "Unable to derive publicKey from mnemonic input"
        );
      }
    }
    var Wallet = class _Wallet {
      constructor(publicKey, privateKey, opts = {}) {
        this.publicKey = publicKey;
        this.privateKey = privateKey;
        this.classicAddress = opts.masterAddress
          ? (0, utils_2.ensureClassicAddress)(opts.masterAddress)
          : (0, ripple_keypairs_1.deriveAddress)(publicKey);
        this.seed = opts.seed;
      }
      get address() {
        return this.classicAddress;
      }
      static generate(algorithm = DEFAULT_ALGORITHM) {
        if (!Object.values(ECDSA_1.default).includes(algorithm)) {
          throw new errors_1.ValidationError(
            "Invalid cryptographic signing algorithm"
          );
        }
        const seed = (0, ripple_keypairs_1.generateSeed)({ algorithm });
        return _Wallet.fromSeed(seed, { algorithm });
      }
      static fromSeed(seed, opts = {}) {
        return _Wallet.deriveWallet(seed, {
          algorithm: opts.algorithm,
          masterAddress: opts.masterAddress,
        });
      }
      static fromEntropy(entropy, opts = {}) {
        var _a;
        const algorithm =
          (_a = opts.algorithm) !== null && _a !== void 0
            ? _a
            : DEFAULT_ALGORITHM;
        const options = {
          entropy: Uint8Array.from(entropy),
          algorithm,
        };
        const seed = (0, ripple_keypairs_1.generateSeed)(options);
        return _Wallet.deriveWallet(seed, {
          algorithm,
          masterAddress: opts.masterAddress,
        });
      }
      static fromMnemonic(mnemonic, opts = {}) {
        var _a;
        if (opts.mnemonicEncoding === "rfc1751") {
          return _Wallet.fromRFC1751Mnemonic(mnemonic, {
            masterAddress: opts.masterAddress,
            algorithm: opts.algorithm,
          });
        }
        if (!(0, bip39_1.validateMnemonic)(mnemonic, english_1.wordlist)) {
          throw new errors_1.ValidationError(
            "Unable to parse the given mnemonic using bip39 encoding"
          );
        }
        const seed = (0, bip39_1.mnemonicToSeedSync)(mnemonic);
        const masterNode = bip32_1.HDKey.fromMasterSeed(seed);
        const node = masterNode.derive(
          (_a = opts.derivationPath) !== null && _a !== void 0
            ? _a
            : DEFAULT_DERIVATION_PATH
        );
        validateKey(node);
        const publicKey = (0, utils_1.bytesToHex)(node.publicKey);
        const privateKey = (0, utils_1.bytesToHex)(node.privateKey);
        return new _Wallet(publicKey, `00${privateKey}`, {
          masterAddress: opts.masterAddress,
        });
      }
      static fromRFC1751Mnemonic(mnemonic, opts) {
        const seed = (0, rfc1751_1.rfc1751MnemonicToKey)(mnemonic);
        let encodeAlgorithm;
        if (opts.algorithm === ECDSA_1.default.ed25519) {
          encodeAlgorithm = "ed25519";
        } else {
          encodeAlgorithm = "secp256k1";
        }
        const encodedSeed = (0, ripple_address_codec_1.encodeSeed)(
          seed,
          encodeAlgorithm
        );
        return _Wallet.fromSeed(encodedSeed, {
          masterAddress: opts.masterAddress,
          algorithm: opts.algorithm,
        });
      }
      static deriveWallet(seed, opts = {}) {
        var _a;
        const { publicKey, privateKey } = (0, ripple_keypairs_1.deriveKeypair)(
          seed,
          {
            algorithm:
              (_a = opts.algorithm) !== null && _a !== void 0
                ? _a
                : DEFAULT_ALGORITHM,
          }
        );
        return new _Wallet(publicKey, privateKey, {
          seed,
          masterAddress: opts.masterAddress,
        });
      }
      sign(transaction, multisign) {
        let multisignAddress = false;
        if (typeof multisign === "string" && multisign.startsWith("X")) {
          multisignAddress = multisign;
        } else if (multisign) {
          multisignAddress = this.classicAddress;
        }
        const tx = (0, collections_1.omitBy)(
          Object.assign({}, transaction),
          (value) => value == null
        );
        if (tx.TxnSignature || tx.Signers) {
          throw new errors_1.ValidationError(
            'txJSON must not contain "TxnSignature" or "Signers" properties'
          );
        }
        removeTrailingZeros(tx);
        (0, transactions_1.validate)(tx);
        const txToSignAndEncode = Object.assign({}, tx);
        txToSignAndEncode.SigningPubKey = multisignAddress
          ? ""
          : this.publicKey;
        if (multisignAddress) {
          const signer = {
            Account: multisignAddress,
            SigningPubKey: this.publicKey,
            TxnSignature: computeSignature(
              txToSignAndEncode,
              this.privateKey,
              multisignAddress
            ),
          };
          txToSignAndEncode.Signers = [{ Signer: signer }];
        } else {
          txToSignAndEncode.TxnSignature = computeSignature(
            txToSignAndEncode,
            this.privateKey
          );
        }
        const serialized = (0, ripple_binary_codec_1.encode)(txToSignAndEncode);
        return {
          tx_blob: serialized,
          hash: (0, hashLedger_1.hashSignedTx)(serialized),
        };
      }
      verifyTransaction(signedTransaction) {
        return (0, signer_1.verifySignature)(signedTransaction, this.publicKey);
      }
      getXAddress(tag = false, isTestnet = false) {
        return (0, ripple_address_codec_1.classicAddressToXAddress)(
          this.classicAddress,
          tag,
          isTestnet
        );
      }
    };
    exports2.Wallet = Wallet;
    Wallet.fromSecret = Wallet.fromSeed;
    function computeSignature(tx, privateKey, signAs) {
      if (signAs) {
        const classicAddress = (0, ripple_address_codec_1.isValidXAddress)(
          signAs
        )
          ? (0, ripple_address_codec_1.xAddressToClassicAddress)(signAs)
              .classicAddress
          : signAs;
        return (0, ripple_keypairs_1.sign)(
          (0, ripple_binary_codec_1.encodeForMultisigning)(tx, classicAddress),
          privateKey
        );
      }
      return (0, ripple_keypairs_1.sign)(
        (0, ripple_binary_codec_1.encodeForSigning)(tx),
        privateKey
      );
    }
    function removeTrailingZeros(tx) {
      if (
        tx.TransactionType === "Payment" &&
        typeof tx.Amount !== "string" &&
        tx.Amount.value.includes(".") &&
        tx.Amount.value.endsWith("0")
      ) {
        tx.Amount = Object.assign({}, tx.Amount);
        tx.Amount.value = new bignumber_js_1.default(
          tx.Amount.value
        ).toString();
      }
    }
  },
});

// node_modules/webidl-conversions/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/webidl-conversions/lib/index.js"(exports2, module2) {
    "use strict";
    var conversions = {};
    module2.exports = conversions;
    function sign(x) {
      return x < 0 ? -1 : 1;
    }
    function evenRound(x) {
      if (x % 1 === 0.5 && (x & 1) === 0) {
        return Math.floor(x);
      } else {
        return Math.round(x);
      }
    }
    function createNumberConversion(bitLength, typeOpts) {
      if (!typeOpts.unsigned) {
        --bitLength;
      }
      const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);
      const upperBound = Math.pow(2, bitLength) - 1;
      const moduloVal = typeOpts.moduloBitLength
        ? Math.pow(2, typeOpts.moduloBitLength)
        : Math.pow(2, bitLength);
      const moduloBound = typeOpts.moduloBitLength
        ? Math.pow(2, typeOpts.moduloBitLength - 1)
        : Math.pow(2, bitLength - 1);
      return function (V, opts) {
        if (!opts) opts = {};
        let x = +V;
        if (opts.enforceRange) {
          if (!Number.isFinite(x)) {
            throw new TypeError("Argument is not a finite number");
          }
          x = sign(x) * Math.floor(Math.abs(x));
          if (x < lowerBound || x > upperBound) {
            throw new TypeError("Argument is not in byte range");
          }
          return x;
        }
        if (!isNaN(x) && opts.clamp) {
          x = evenRound(x);
          if (x < lowerBound) x = lowerBound;
          if (x > upperBound) x = upperBound;
          return x;
        }
        if (!Number.isFinite(x) || x === 0) {
          return 0;
        }
        x = sign(x) * Math.floor(Math.abs(x));
        x = x % moduloVal;
        if (!typeOpts.unsigned && x >= moduloBound) {
          return x - moduloVal;
        } else if (typeOpts.unsigned) {
          if (x < 0) {
            x += moduloVal;
          } else if (x === -0) {
            return 0;
          }
        }
        return x;
      };
    }
    conversions["void"] = function () {
      return void 0;
    };
    conversions["boolean"] = function (val) {
      return !!val;
    };
    conversions["byte"] = createNumberConversion(8, { unsigned: false });
    conversions["octet"] = createNumberConversion(8, { unsigned: true });
    conversions["short"] = createNumberConversion(16, { unsigned: false });
    conversions["unsigned short"] = createNumberConversion(16, {
      unsigned: true,
    });
    conversions["long"] = createNumberConversion(32, { unsigned: false });
    conversions["unsigned long"] = createNumberConversion(32, {
      unsigned: true,
    });
    conversions["long long"] = createNumberConversion(32, {
      unsigned: false,
      moduloBitLength: 64,
    });
    conversions["unsigned long long"] = createNumberConversion(32, {
      unsigned: true,
      moduloBitLength: 64,
    });
    conversions["double"] = function (V) {
      const x = +V;
      if (!Number.isFinite(x)) {
        throw new TypeError("Argument is not a finite floating-point value");
      }
      return x;
    };
    conversions["unrestricted double"] = function (V) {
      const x = +V;
      if (isNaN(x)) {
        throw new TypeError("Argument is NaN");
      }
      return x;
    };
    conversions["float"] = conversions["double"];
    conversions["unrestricted float"] = conversions["unrestricted double"];
    conversions["DOMString"] = function (V, opts) {
      if (!opts) opts = {};
      if (opts.treatNullAsEmptyString && V === null) {
        return "";
      }
      return String(V);
    };
    conversions["ByteString"] = function (V, opts) {
      const x = String(V);
      let c = void 0;
      for (let i = 0; (c = x.codePointAt(i)) !== void 0; ++i) {
        if (c > 255) {
          throw new TypeError("Argument is not a valid bytestring");
        }
      }
      return x;
    };
    conversions["USVString"] = function (V) {
      const S = String(V);
      const n = S.length;
      const U = [];
      for (let i = 0; i < n; ++i) {
        const c = S.charCodeAt(i);
        if (c < 55296 || c > 57343) {
          U.push(String.fromCodePoint(c));
        } else if (56320 <= c && c <= 57343) {
          U.push(String.fromCodePoint(65533));
        } else {
          if (i === n - 1) {
            U.push(String.fromCodePoint(65533));
          } else {
            const d = S.charCodeAt(i + 1);
            if (56320 <= d && d <= 57343) {
              const a = c & 1023;
              const b = d & 1023;
              U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));
              ++i;
            } else {
              U.push(String.fromCodePoint(65533));
            }
          }
        }
      }
      return U.join("");
    };
    conversions["Date"] = function (V, opts) {
      if (!(V instanceof Date)) {
        throw new TypeError("Argument is not a Date object");
      }
      if (isNaN(V)) {
        return void 0;
      }
      return V;
    };
    conversions["RegExp"] = function (V, opts) {
      if (!(V instanceof RegExp)) {
        V = new RegExp(V);
      }
      return V;
    };
  },
});

// node_modules/whatwg-url/lib/utils.js
var require_utils11 = __commonJS({
  "node_modules/whatwg-url/lib/utils.js"(exports2, module2) {
    "use strict";
    module2.exports.mixin = function mixin(target, source) {
      const keys = Object.getOwnPropertyNames(source);
      for (let i = 0; i < keys.length; ++i) {
        Object.defineProperty(
          target,
          keys[i],
          Object.getOwnPropertyDescriptor(source, keys[i])
        );
      }
    };
    module2.exports.wrapperSymbol = Symbol("wrapper");
    module2.exports.implSymbol = Symbol("impl");
    module2.exports.wrapperForImpl = function (impl) {
      return impl[module2.exports.wrapperSymbol];
    };
    module2.exports.implForWrapper = function (wrapper) {
      return wrapper[module2.exports.implSymbol];
    };
  },
});

// node_modules/tr46/lib/mappingTable.json
var require_mappingTable = __commonJS({
  "node_modules/tr46/lib/mappingTable.json"(exports2, module2) {
    module2.exports = [
      [[0, 44], "disallowed_STD3_valid"],
      [[45, 46], "valid"],
      [[47, 47], "disallowed_STD3_valid"],
      [[48, 57], "valid"],
      [[58, 64], "disallowed_STD3_valid"],
      [[65, 65], "mapped", [97]],
      [[66, 66], "mapped", [98]],
      [[67, 67], "mapped", [99]],
      [[68, 68], "mapped", [100]],
      [[69, 69], "mapped", [101]],
      [[70, 70], "mapped", [102]],
      [[71, 71], "mapped", [103]],
      [[72, 72], "mapped", [104]],
      [[73, 73], "mapped", [105]],
      [[74, 74], "mapped", [106]],
      [[75, 75], "mapped", [107]],
      [[76, 76], "mapped", [108]],
      [[77, 77], "mapped", [109]],
      [[78, 78], "mapped", [110]],
      [[79, 79], "mapped", [111]],
      [[80, 80], "mapped", [112]],
      [[81, 81], "mapped", [113]],
      [[82, 82], "mapped", [114]],
      [[83, 83], "mapped", [115]],
      [[84, 84], "mapped", [116]],
      [[85, 85], "mapped", [117]],
      [[86, 86], "mapped", [118]],
      [[87, 87], "mapped", [119]],
      [[88, 88], "mapped", [120]],
      [[89, 89], "mapped", [121]],
      [[90, 90], "mapped", [122]],
      [[91, 96], "disallowed_STD3_valid"],
      [[97, 122], "valid"],
      [[123, 127], "disallowed_STD3_valid"],
      [[128, 159], "disallowed"],
      [[160, 160], "disallowed_STD3_mapped", [32]],
      [[161, 167], "valid", [], "NV8"],
      [[168, 168], "disallowed_STD3_mapped", [32, 776]],
      [[169, 169], "valid", [], "NV8"],
      [[170, 170], "mapped", [97]],
      [[171, 172], "valid", [], "NV8"],
      [[173, 173], "ignored"],
      [[174, 174], "valid", [], "NV8"],
      [[175, 175], "disallowed_STD3_mapped", [32, 772]],
      [[176, 177], "valid", [], "NV8"],
      [[178, 178], "mapped", [50]],
      [[179, 179], "mapped", [51]],
      [[180, 180], "disallowed_STD3_mapped", [32, 769]],
      [[181, 181], "mapped", [956]],
      [[182, 182], "valid", [], "NV8"],
      [[183, 183], "valid"],
      [[184, 184], "disallowed_STD3_mapped", [32, 807]],
      [[185, 185], "mapped", [49]],
      [[186, 186], "mapped", [111]],
      [[187, 187], "valid", [], "NV8"],
      [[188, 188], "mapped", [49, 8260, 52]],
      [[189, 189], "mapped", [49, 8260, 50]],
      [[190, 190], "mapped", [51, 8260, 52]],
      [[191, 191], "valid", [], "NV8"],
      [[192, 192], "mapped", [224]],
      [[193, 193], "mapped", [225]],
      [[194, 194], "mapped", [226]],
      [[195, 195], "mapped", [227]],
      [[196, 196], "mapped", [228]],
      [[197, 197], "mapped", [229]],
      [[198, 198], "mapped", [230]],
      [[199, 199], "mapped", [231]],
      [[200, 200], "mapped", [232]],
      [[201, 201], "mapped", [233]],
      [[202, 202], "mapped", [234]],
      [[203, 203], "mapped", [235]],
      [[204, 204], "mapped", [236]],
      [[205, 205], "mapped", [237]],
      [[206, 206], "mapped", [238]],
      [[207, 207], "mapped", [239]],
      [[208, 208], "mapped", [240]],
      [[209, 209], "mapped", [241]],
      [[210, 210], "mapped", [242]],
      [[211, 211], "mapped", [243]],
      [[212, 212], "mapped", [244]],
      [[213, 213], "mapped", [245]],
      [[214, 214], "mapped", [246]],
      [[215, 215], "valid", [], "NV8"],
      [[216, 216], "mapped", [248]],
      [[217, 217], "mapped", [249]],
      [[218, 218], "mapped", [250]],
      [[219, 219], "mapped", [251]],
      [[220, 220], "mapped", [252]],
      [[221, 221], "mapped", [253]],
      [[222, 222], "mapped", [254]],
      [[223, 223], "deviation", [115, 115]],
      [[224, 246], "valid"],
      [[247, 247], "valid", [], "NV8"],
      [[248, 255], "valid"],
      [[256, 256], "mapped", [257]],
      [[257, 257], "valid"],
      [[258, 258], "mapped", [259]],
      [[259, 259], "valid"],
      [[260, 260], "mapped", [261]],
      [[261, 261], "valid"],
      [[262, 262], "mapped", [263]],
      [[263, 263], "valid"],
      [[264, 264], "mapped", [265]],
      [[265, 265], "valid"],
      [[266, 266], "mapped", [267]],
      [[267, 267], "valid"],
      [[268, 268], "mapped", [269]],
      [[269, 269], "valid"],
      [[270, 270], "mapped", [271]],
      [[271, 271], "valid"],
      [[272, 272], "mapped", [273]],
      [[273, 273], "valid"],
      [[274, 274], "mapped", [275]],
      [[275, 275], "valid"],
      [[276, 276], "mapped", [277]],
      [[277, 277], "valid"],
      [[278, 278], "mapped", [279]],
      [[279, 279], "valid"],
      [[280, 280], "mapped", [281]],
      [[281, 281], "valid"],
      [[282, 282], "mapped", [283]],
      [[283, 283], "valid"],
      [[284, 284], "mapped", [285]],
      [[285, 285], "valid"],
      [[286, 286], "mapped", [287]],
      [[287, 287], "valid"],
      [[288, 288], "mapped", [289]],
      [[289, 289], "valid"],
      [[290, 290], "mapped", [291]],
      [[291, 291], "valid"],
      [[292, 292], "mapped", [293]],
      [[293, 293], "valid"],
      [[294, 294], "mapped", [295]],
      [[295, 295], "valid"],
      [[296, 296], "mapped", [297]],
      [[297, 297], "valid"],
      [[298, 298], "mapped", [299]],
      [[299, 299], "valid"],
      [[300, 300], "mapped", [301]],
      [[301, 301], "valid"],
      [[302, 302], "mapped", [303]],
      [[303, 303], "valid"],
      [[304, 304], "mapped", [105, 775]],
      [[305, 305], "valid"],
      [[306, 307], "mapped", [105, 106]],
      [[308, 308], "mapped", [309]],
      [[309, 309], "valid"],
      [[310, 310], "mapped", [311]],
      [[311, 312], "valid"],
      [[313, 313], "mapped", [314]],
      [[314, 314], "valid"],
      [[315, 315], "mapped", [316]],
      [[316, 316], "valid"],
      [[317, 317], "mapped", [318]],
      [[318, 318], "valid"],
      [[319, 320], "mapped", [108, 183]],
      [[321, 321], "mapped", [322]],
      [[322, 322], "valid"],
      [[323, 323], "mapped", [324]],
      [[324, 324], "valid"],
      [[325, 325], "mapped", [326]],
      [[326, 326], "valid"],
      [[327, 327], "mapped", [328]],
      [[328, 328], "valid"],
      [[329, 329], "mapped", [700, 110]],
      [[330, 330], "mapped", [331]],
      [[331, 331], "valid"],
      [[332, 332], "mapped", [333]],
      [[333, 333], "valid"],
      [[334, 334], "mapped", [335]],
      [[335, 335], "valid"],
      [[336, 336], "mapped", [337]],
      [[337, 337], "valid"],
      [[338, 338], "mapped", [339]],
      [[339, 339], "valid"],
      [[340, 340], "mapped", [341]],
      [[341, 341], "valid"],
      [[342, 342], "mapped", [343]],
      [[343, 343], "valid"],
      [[344, 344], "mapped", [345]],
      [[345, 345], "valid"],
      [[346, 346], "mapped", [347]],
      [[347, 347], "valid"],
      [[348, 348], "mapped", [349]],
      [[349, 349], "valid"],
      [[350, 350], "mapped", [351]],
      [[351, 351], "valid"],
      [[352, 352], "mapped", [353]],
      [[353, 353], "valid"],
      [[354, 354], "mapped", [355]],
      [[355, 355], "valid"],
      [[356, 356], "mapped", [357]],
      [[357, 357], "valid"],
      [[358, 358], "mapped", [359]],
      [[359, 359], "valid"],
      [[360, 360], "mapped", [361]],
      [[361, 361], "valid"],
      [[362, 362], "mapped", [363]],
      [[363, 363], "valid"],
      [[364, 364], "mapped", [365]],
      [[365, 365], "valid"],
      [[366, 366], "mapped", [367]],
      [[367, 367], "valid"],
      [[368, 368], "mapped", [369]],
      [[369, 369], "valid"],
      [[370, 370], "mapped", [371]],
      [[371, 371], "valid"],
      [[372, 372], "mapped", [373]],
      [[373, 373], "valid"],
      [[374, 374], "mapped", [375]],
      [[375, 375], "valid"],
      [[376, 376], "mapped", [255]],
      [[377, 377], "mapped", [378]],
      [[378, 378], "valid"],
      [[379, 379], "mapped", [380]],
      [[380, 380], "valid"],
      [[381, 381], "mapped", [382]],
      [[382, 382], "valid"],
      [[383, 383], "mapped", [115]],
      [[384, 384], "valid"],
      [[385, 385], "mapped", [595]],
      [[386, 386], "mapped", [387]],
      [[387, 387], "valid"],
      [[388, 388], "mapped", [389]],
      [[389, 389], "valid"],
      [[390, 390], "mapped", [596]],
      [[391, 391], "mapped", [392]],
      [[392, 392], "valid"],
      [[393, 393], "mapped", [598]],
      [[394, 394], "mapped", [599]],
      [[395, 395], "mapped", [396]],
      [[396, 397], "valid"],
      [[398, 398], "mapped", [477]],
      [[399, 399], "mapped", [601]],
      [[400, 400], "mapped", [603]],
      [[401, 401], "mapped", [402]],
      [[402, 402], "valid"],
      [[403, 403], "mapped", [608]],
      [[404, 404], "mapped", [611]],
      [[405, 405], "valid"],
      [[406, 406], "mapped", [617]],
      [[407, 407], "mapped", [616]],
      [[408, 408], "mapped", [409]],
      [[409, 411], "valid"],
      [[412, 412], "mapped", [623]],
      [[413, 413], "mapped", [626]],
      [[414, 414], "valid"],
      [[415, 415], "mapped", [629]],
      [[416, 416], "mapped", [417]],
      [[417, 417], "valid"],
      [[418, 418], "mapped", [419]],
      [[419, 419], "valid"],
      [[420, 420], "mapped", [421]],
      [[421, 421], "valid"],
      [[422, 422], "mapped", [640]],
      [[423, 423], "mapped", [424]],
      [[424, 424], "valid"],
      [[425, 425], "mapped", [643]],
      [[426, 427], "valid"],
      [[428, 428], "mapped", [429]],
      [[429, 429], "valid"],
      [[430, 430], "mapped", [648]],
      [[431, 431], "mapped", [432]],
      [[432, 432], "valid"],
      [[433, 433], "mapped", [650]],
      [[434, 434], "mapped", [651]],
      [[435, 435], "mapped", [436]],
      [[436, 436], "valid"],
      [[437, 437], "mapped", [438]],
      [[438, 438], "valid"],
      [[439, 439], "mapped", [658]],
      [[440, 440], "mapped", [441]],
      [[441, 443], "valid"],
      [[444, 444], "mapped", [445]],
      [[445, 451], "valid"],
      [[452, 454], "mapped", [100, 382]],
      [[455, 457], "mapped", [108, 106]],
      [[458, 460], "mapped", [110, 106]],
      [[461, 461], "mapped", [462]],
      [[462, 462], "valid"],
      [[463, 463], "mapped", [464]],
      [[464, 464], "valid"],
      [[465, 465], "mapped", [466]],
      [[466, 466], "valid"],
      [[467, 467], "mapped", [468]],
      [[468, 468], "valid"],
      [[469, 469], "mapped", [470]],
      [[470, 470], "valid"],
      [[471, 471], "mapped", [472]],
      [[472, 472], "valid"],
      [[473, 473], "mapped", [474]],
      [[474, 474], "valid"],
      [[475, 475], "mapped", [476]],
      [[476, 477], "valid"],
      [[478, 478], "mapped", [479]],
      [[479, 479], "valid"],
      [[480, 480], "mapped", [481]],
      [[481, 481], "valid"],
      [[482, 482], "mapped", [483]],
      [[483, 483], "valid"],
      [[484, 484], "mapped", [485]],
      [[485, 485], "valid"],
      [[486, 486], "mapped", [487]],
      [[487, 487], "valid"],
      [[488, 488], "mapped", [489]],
      [[489, 489], "valid"],
      [[490, 490], "mapped", [491]],
      [[491, 491], "valid"],
      [[492, 492], "mapped", [493]],
      [[493, 493], "valid"],
      [[494, 494], "mapped", [495]],
      [[495, 496], "valid"],
      [[497, 499], "mapped", [100, 122]],
      [[500, 500], "mapped", [501]],
      [[501, 501], "valid"],
      [[502, 502], "mapped", [405]],
      [[503, 503], "mapped", [447]],
      [[504, 504], "mapped", [505]],
      [[505, 505], "valid"],
      [[506, 506], "mapped", [507]],
      [[507, 507], "valid"],
      [[508, 508], "mapped", [509]],
      [[509, 509], "valid"],
      [[510, 510], "mapped", [511]],
      [[511, 511], "valid"],
      [[512, 512], "mapped", [513]],
      [[513, 513], "valid"],
      [[514, 514], "mapped", [515]],
      [[515, 515], "valid"],
      [[516, 516], "mapped", [517]],
      [[517, 517], "valid"],
      [[518, 518], "mapped", [519]],
      [[519, 519], "valid"],
      [[520, 520], "mapped", [521]],
      [[521, 521], "valid"],
      [[522, 522], "mapped", [523]],
      [[523, 523], "valid"],
      [[524, 524], "mapped", [525]],
      [[525, 525], "valid"],
      [[526, 526], "mapped", [527]],
      [[527, 527], "valid"],
      [[528, 528], "mapped", [529]],
      [[529, 529], "valid"],
      [[530, 530], "mapped", [531]],
      [[531, 531], "valid"],
      [[532, 532], "mapped", [533]],
      [[533, 533], "valid"],
      [[534, 534], "mapped", [535]],
      [[535, 535], "valid"],
      [[536, 536], "mapped", [537]],
      [[537, 537], "valid"],
      [[538, 538], "mapped", [539]],
      [[539, 539], "valid"],
      [[540, 540], "mapped", [541]],
      [[541, 541], "valid"],
      [[542, 542], "mapped", [543]],
      [[543, 543], "valid"],
      [[544, 544], "mapped", [414]],
      [[545, 545], "valid"],
      [[546, 546], "mapped", [547]],
      [[547, 547], "valid"],
      [[548, 548], "mapped", [549]],
      [[549, 549], "valid"],
      [[550, 550], "mapped", [551]],
      [[551, 551], "valid"],
      [[552, 552], "mapped", [553]],
      [[553, 553], "valid"],
      [[554, 554], "mapped", [555]],
      [[555, 555], "valid"],
      [[556, 556], "mapped", [557]],
      [[557, 557], "valid"],
      [[558, 558], "mapped", [559]],
      [[559, 559], "valid"],
      [[560, 560], "mapped", [561]],
      [[561, 561], "valid"],
      [[562, 562], "mapped", [563]],
      [[563, 563], "valid"],
      [[564, 566], "valid"],
      [[567, 569], "valid"],
      [[570, 570], "mapped", [11365]],
      [[571, 571], "mapped", [572]],
      [[572, 572], "valid"],
      [[573, 573], "mapped", [410]],
      [[574, 574], "mapped", [11366]],
      [[575, 576], "valid"],
      [[577, 577], "mapped", [578]],
      [[578, 578], "valid"],
      [[579, 579], "mapped", [384]],
      [[580, 580], "mapped", [649]],
      [[581, 581], "mapped", [652]],
      [[582, 582], "mapped", [583]],
      [[583, 583], "valid"],
      [[584, 584], "mapped", [585]],
      [[585, 585], "valid"],
      [[586, 586], "mapped", [587]],
      [[587, 587], "valid"],
      [[588, 588], "mapped", [589]],
      [[589, 589], "valid"],
      [[590, 590], "mapped", [591]],
      [[591, 591], "valid"],
      [[592, 680], "valid"],
      [[681, 685], "valid"],
      [[686, 687], "valid"],
      [[688, 688], "mapped", [104]],
      [[689, 689], "mapped", [614]],
      [[690, 690], "mapped", [106]],
      [[691, 691], "mapped", [114]],
      [[692, 692], "mapped", [633]],
      [[693, 693], "mapped", [635]],
      [[694, 694], "mapped", [641]],
      [[695, 695], "mapped", [119]],
      [[696, 696], "mapped", [121]],
      [[697, 705], "valid"],
      [[706, 709], "valid", [], "NV8"],
      [[710, 721], "valid"],
      [[722, 727], "valid", [], "NV8"],
      [[728, 728], "disallowed_STD3_mapped", [32, 774]],
      [[729, 729], "disallowed_STD3_mapped", [32, 775]],
      [[730, 730], "disallowed_STD3_mapped", [32, 778]],
      [[731, 731], "disallowed_STD3_mapped", [32, 808]],
      [[732, 732], "disallowed_STD3_mapped", [32, 771]],
      [[733, 733], "disallowed_STD3_mapped", [32, 779]],
      [[734, 734], "valid", [], "NV8"],
      [[735, 735], "valid", [], "NV8"],
      [[736, 736], "mapped", [611]],
      [[737, 737], "mapped", [108]],
      [[738, 738], "mapped", [115]],
      [[739, 739], "mapped", [120]],
      [[740, 740], "mapped", [661]],
      [[741, 745], "valid", [], "NV8"],
      [[746, 747], "valid", [], "NV8"],
      [[748, 748], "valid"],
      [[749, 749], "valid", [], "NV8"],
      [[750, 750], "valid"],
      [[751, 767], "valid", [], "NV8"],
      [[768, 831], "valid"],
      [[832, 832], "mapped", [768]],
      [[833, 833], "mapped", [769]],
      [[834, 834], "valid"],
      [[835, 835], "mapped", [787]],
      [[836, 836], "mapped", [776, 769]],
      [[837, 837], "mapped", [953]],
      [[838, 846], "valid"],
      [[847, 847], "ignored"],
      [[848, 855], "valid"],
      [[856, 860], "valid"],
      [[861, 863], "valid"],
      [[864, 865], "valid"],
      [[866, 866], "valid"],
      [[867, 879], "valid"],
      [[880, 880], "mapped", [881]],
      [[881, 881], "valid"],
      [[882, 882], "mapped", [883]],
      [[883, 883], "valid"],
      [[884, 884], "mapped", [697]],
      [[885, 885], "valid"],
      [[886, 886], "mapped", [887]],
      [[887, 887], "valid"],
      [[888, 889], "disallowed"],
      [[890, 890], "disallowed_STD3_mapped", [32, 953]],
      [[891, 893], "valid"],
      [[894, 894], "disallowed_STD3_mapped", [59]],
      [[895, 895], "mapped", [1011]],
      [[896, 899], "disallowed"],
      [[900, 900], "disallowed_STD3_mapped", [32, 769]],
      [[901, 901], "disallowed_STD3_mapped", [32, 776, 769]],
      [[902, 902], "mapped", [940]],
      [[903, 903], "mapped", [183]],
      [[904, 904], "mapped", [941]],
      [[905, 905], "mapped", [942]],
      [[906, 906], "mapped", [943]],
      [[907, 907], "disallowed"],
      [[908, 908], "mapped", [972]],
      [[909, 909], "disallowed"],
      [[910, 910], "mapped", [973]],
      [[911, 911], "mapped", [974]],
      [[912, 912], "valid"],
      [[913, 913], "mapped", [945]],
      [[914, 914], "mapped", [946]],
      [[915, 915], "mapped", [947]],
      [[916, 916], "mapped", [948]],
      [[917, 917], "mapped", [949]],
      [[918, 918], "mapped", [950]],
      [[919, 919], "mapped", [951]],
      [[920, 920], "mapped", [952]],
      [[921, 921], "mapped", [953]],
      [[922, 922], "mapped", [954]],
      [[923, 923], "mapped", [955]],
      [[924, 924], "mapped", [956]],
      [[925, 925], "mapped", [957]],
      [[926, 926], "mapped", [958]],
      [[927, 927], "mapped", [959]],
      [[928, 928], "mapped", [960]],
      [[929, 929], "mapped", [961]],
      [[930, 930], "disallowed"],
      [[931, 931], "mapped", [963]],
      [[932, 932], "mapped", [964]],
      [[933, 933], "mapped", [965]],
      [[934, 934], "mapped", [966]],
      [[935, 935], "mapped", [967]],
      [[936, 936], "mapped", [968]],
      [[937, 937], "mapped", [969]],
      [[938, 938], "mapped", [970]],
      [[939, 939], "mapped", [971]],
      [[940, 961], "valid"],
      [[962, 962], "deviation", [963]],
      [[963, 974], "valid"],
      [[975, 975], "mapped", [983]],
      [[976, 976], "mapped", [946]],
      [[977, 977], "mapped", [952]],
      [[978, 978], "mapped", [965]],
      [[979, 979], "mapped", [973]],
      [[980, 980], "mapped", [971]],
      [[981, 981], "mapped", [966]],
      [[982, 982], "mapped", [960]],
      [[983, 983], "valid"],
      [[984, 984], "mapped", [985]],
      [[985, 985], "valid"],
      [[986, 986], "mapped", [987]],
      [[987, 987], "valid"],
      [[988, 988], "mapped", [989]],
      [[989, 989], "valid"],
      [[990, 990], "mapped", [991]],
      [[991, 991], "valid"],
      [[992, 992], "mapped", [993]],
      [[993, 993], "valid"],
      [[994, 994], "mapped", [995]],
      [[995, 995], "valid"],
      [[996, 996], "mapped", [997]],
      [[997, 997], "valid"],
      [[998, 998], "mapped", [999]],
      [[999, 999], "valid"],
      [[1e3, 1e3], "mapped", [1001]],
      [[1001, 1001], "valid"],
      [[1002, 1002], "mapped", [1003]],
      [[1003, 1003], "valid"],
      [[1004, 1004], "mapped", [1005]],
      [[1005, 1005], "valid"],
      [[1006, 1006], "mapped", [1007]],
      [[1007, 1007], "valid"],
      [[1008, 1008], "mapped", [954]],
      [[1009, 1009], "mapped", [961]],
      [[1010, 1010], "mapped", [963]],
      [[1011, 1011], "valid"],
      [[1012, 1012], "mapped", [952]],
      [[1013, 1013], "mapped", [949]],
      [[1014, 1014], "valid", [], "NV8"],
      [[1015, 1015], "mapped", [1016]],
      [[1016, 1016], "valid"],
      [[1017, 1017], "mapped", [963]],
      [[1018, 1018], "mapped", [1019]],
      [[1019, 1019], "valid"],
      [[1020, 1020], "valid"],
      [[1021, 1021], "mapped", [891]],
      [[1022, 1022], "mapped", [892]],
      [[1023, 1023], "mapped", [893]],
      [[1024, 1024], "mapped", [1104]],
      [[1025, 1025], "mapped", [1105]],
      [[1026, 1026], "mapped", [1106]],
      [[1027, 1027], "mapped", [1107]],
      [[1028, 1028], "mapped", [1108]],
      [[1029, 1029], "mapped", [1109]],
      [[1030, 1030], "mapped", [1110]],
      [[1031, 1031], "mapped", [1111]],
      [[1032, 1032], "mapped", [1112]],
      [[1033, 1033], "mapped", [1113]],
      [[1034, 1034], "mapped", [1114]],
      [[1035, 1035], "mapped", [1115]],
      [[1036, 1036], "mapped", [1116]],
      [[1037, 1037], "mapped", [1117]],
      [[1038, 1038], "mapped", [1118]],
      [[1039, 1039], "mapped", [1119]],
      [[1040, 1040], "mapped", [1072]],
      [[1041, 1041], "mapped", [1073]],
      [[1042, 1042], "mapped", [1074]],
      [[1043, 1043], "mapped", [1075]],
      [[1044, 1044], "mapped", [1076]],
      [[1045, 1045], "mapped", [1077]],
      [[1046, 1046], "mapped", [1078]],
      [[1047, 1047], "mapped", [1079]],
      [[1048, 1048], "mapped", [1080]],
      [[1049, 1049], "mapped", [1081]],
      [[1050, 1050], "mapped", [1082]],
      [[1051, 1051], "mapped", [1083]],
      [[1052, 1052], "mapped", [1084]],
      [[1053, 1053], "mapped", [1085]],
      [[1054, 1054], "mapped", [1086]],
      [[1055, 1055], "mapped", [1087]],
      [[1056, 1056], "mapped", [1088]],
      [[1057, 1057], "mapped", [1089]],
      [[1058, 1058], "mapped", [1090]],
      [[1059, 1059], "mapped", [1091]],
      [[1060, 1060], "mapped", [1092]],
      [[1061, 1061], "mapped", [1093]],
      [[1062, 1062], "mapped", [1094]],
      [[1063, 1063], "mapped", [1095]],
      [[1064, 1064], "mapped", [1096]],
      [[1065, 1065], "mapped", [1097]],
      [[1066, 1066], "mapped", [1098]],
      [[1067, 1067], "mapped", [1099]],
      [[1068, 1068], "mapped", [1100]],
      [[1069, 1069], "mapped", [1101]],
      [[1070, 1070], "mapped", [1102]],
      [[1071, 1071], "mapped", [1103]],
      [[1072, 1103], "valid"],
      [[1104, 1104], "valid"],
      [[1105, 1116], "valid"],
      [[1117, 1117], "valid"],
      [[1118, 1119], "valid"],
      [[1120, 1120], "mapped", [1121]],
      [[1121, 1121], "valid"],
      [[1122, 1122], "mapped", [1123]],
      [[1123, 1123], "valid"],
      [[1124, 1124], "mapped", [1125]],
      [[1125, 1125], "valid"],
      [[1126, 1126], "mapped", [1127]],
      [[1127, 1127], "valid"],
      [[1128, 1128], "mapped", [1129]],
      [[1129, 1129], "valid"],
      [[1130, 1130], "mapped", [1131]],
      [[1131, 1131], "valid"],
      [[1132, 1132], "mapped", [1133]],
      [[1133, 1133], "valid"],
      [[1134, 1134], "mapped", [1135]],
      [[1135, 1135], "valid"],
      [[1136, 1136], "mapped", [1137]],
      [[1137, 1137], "valid"],
      [[1138, 1138], "mapped", [1139]],
      [[1139, 1139], "valid"],
      [[1140, 1140], "mapped", [1141]],
      [[1141, 1141], "valid"],
      [[1142, 1142], "mapped", [1143]],
      [[1143, 1143], "valid"],
      [[1144, 1144], "mapped", [1145]],
      [[1145, 1145], "valid"],
      [[1146, 1146], "mapped", [1147]],
      [[1147, 1147], "valid"],
      [[1148, 1148], "mapped", [1149]],
      [[1149, 1149], "valid"],
      [[1150, 1150], "mapped", [1151]],
      [[1151, 1151], "valid"],
      [[1152, 1152], "mapped", [1153]],
      [[1153, 1153], "valid"],
      [[1154, 1154], "valid", [], "NV8"],
      [[1155, 1158], "valid"],
      [[1159, 1159], "valid"],
      [[1160, 1161], "valid", [], "NV8"],
      [[1162, 1162], "mapped", [1163]],
      [[1163, 1163], "valid"],
      [[1164, 1164], "mapped", [1165]],
      [[1165, 1165], "valid"],
      [[1166, 1166], "mapped", [1167]],
      [[1167, 1167], "valid"],
      [[1168, 1168], "mapped", [1169]],
      [[1169, 1169], "valid"],
      [[1170, 1170], "mapped", [1171]],
      [[1171, 1171], "valid"],
      [[1172, 1172], "mapped", [1173]],
      [[1173, 1173], "valid"],
      [[1174, 1174], "mapped", [1175]],
      [[1175, 1175], "valid"],
      [[1176, 1176], "mapped", [1177]],
      [[1177, 1177], "valid"],
      [[1178, 1178], "mapped", [1179]],
      [[1179, 1179], "valid"],
      [[1180, 1180], "mapped", [1181]],
      [[1181, 1181], "valid"],
      [[1182, 1182], "mapped", [1183]],
      [[1183, 1183], "valid"],
      [[1184, 1184], "mapped", [1185]],
      [[1185, 1185], "valid"],
      [[1186, 1186], "mapped", [1187]],
      [[1187, 1187], "valid"],
      [[1188, 1188], "mapped", [1189]],
      [[1189, 1189], "valid"],
      [[1190, 1190], "mapped", [1191]],
      [[1191, 1191], "valid"],
      [[1192, 1192], "mapped", [1193]],
      [[1193, 1193], "valid"],
      [[1194, 1194], "mapped", [1195]],
      [[1195, 1195], "valid"],
      [[1196, 1196], "mapped", [1197]],
      [[1197, 1197], "valid"],
      [[1198, 1198], "mapped", [1199]],
      [[1199, 1199], "valid"],
      [[1200, 1200], "mapped", [1201]],
      [[1201, 1201], "valid"],
      [[1202, 1202], "mapped", [1203]],
      [[1203, 1203], "valid"],
      [[1204, 1204], "mapped", [1205]],
      [[1205, 1205], "valid"],
      [[1206, 1206], "mapped", [1207]],
      [[1207, 1207], "valid"],
      [[1208, 1208], "mapped", [1209]],
      [[1209, 1209], "valid"],
      [[1210, 1210], "mapped", [1211]],
      [[1211, 1211], "valid"],
      [[1212, 1212], "mapped", [1213]],
      [[1213, 1213], "valid"],
      [[1214, 1214], "mapped", [1215]],
      [[1215, 1215], "valid"],
      [[1216, 1216], "disallowed"],
      [[1217, 1217], "mapped", [1218]],
      [[1218, 1218], "valid"],
      [[1219, 1219], "mapped", [1220]],
      [[1220, 1220], "valid"],
      [[1221, 1221], "mapped", [1222]],
      [[1222, 1222], "valid"],
      [[1223, 1223], "mapped", [1224]],
      [[1224, 1224], "valid"],
      [[1225, 1225], "mapped", [1226]],
      [[1226, 1226], "valid"],
      [[1227, 1227], "mapped", [1228]],
      [[1228, 1228], "valid"],
      [[1229, 1229], "mapped", [1230]],
      [[1230, 1230], "valid"],
      [[1231, 1231], "valid"],
      [[1232, 1232], "mapped", [1233]],
      [[1233, 1233], "valid"],
      [[1234, 1234], "mapped", [1235]],
      [[1235, 1235], "valid"],
      [[1236, 1236], "mapped", [1237]],
      [[1237, 1237], "valid"],
      [[1238, 1238], "mapped", [1239]],
      [[1239, 1239], "valid"],
      [[1240, 1240], "mapped", [1241]],
      [[1241, 1241], "valid"],
      [[1242, 1242], "mapped", [1243]],
      [[1243, 1243], "valid"],
      [[1244, 1244], "mapped", [1245]],
      [[1245, 1245], "valid"],
      [[1246, 1246], "mapped", [1247]],
      [[1247, 1247], "valid"],
      [[1248, 1248], "mapped", [1249]],
      [[1249, 1249], "valid"],
      [[1250, 1250], "mapped", [1251]],
      [[1251, 1251], "valid"],
      [[1252, 1252], "mapped", [1253]],
      [[1253, 1253], "valid"],
      [[1254, 1254], "mapped", [1255]],
      [[1255, 1255], "valid"],
      [[1256, 1256], "mapped", [1257]],
      [[1257, 1257], "valid"],
      [[1258, 1258], "mapped", [1259]],
      [[1259, 1259], "valid"],
      [[1260, 1260], "mapped", [1261]],
      [[1261, 1261], "valid"],
      [[1262, 1262], "mapped", [1263]],
      [[1263, 1263], "valid"],
      [[1264, 1264], "mapped", [1265]],
      [[1265, 1265], "valid"],
      [[1266, 1266], "mapped", [1267]],
      [[1267, 1267], "valid"],
      [[1268, 1268], "mapped", [1269]],
      [[1269, 1269], "valid"],
      [[1270, 1270], "mapped", [1271]],
      [[1271, 1271], "valid"],
      [[1272, 1272], "mapped", [1273]],
      [[1273, 1273], "valid"],
      [[1274, 1274], "mapped", [1275]],
      [[1275, 1275], "valid"],
      [[1276, 1276], "mapped", [1277]],
      [[1277, 1277], "valid"],
      [[1278, 1278], "mapped", [1279]],
      [[1279, 1279], "valid"],
      [[1280, 1280], "mapped", [1281]],
      [[1281, 1281], "valid"],
      [[1282, 1282], "mapped", [1283]],
      [[1283, 1283], "valid"],
      [[1284, 1284], "mapped", [1285]],
      [[1285, 1285], "valid"],
      [[1286, 1286], "mapped", [1287]],
      [[1287, 1287], "valid"],
      [[1288, 1288], "mapped", [1289]],
      [[1289, 1289], "valid"],
      [[1290, 1290], "mapped", [1291]],
      [[1291, 1291], "valid"],
      [[1292, 1292], "mapped", [1293]],
      [[1293, 1293], "valid"],
      [[1294, 1294], "mapped", [1295]],
      [[1295, 1295], "valid"],
      [[1296, 1296], "mapped", [1297]],
      [[1297, 1297], "valid"],
      [[1298, 1298], "mapped", [1299]],
      [[1299, 1299], "valid"],
      [[1300, 1300], "mapped", [1301]],
      [[1301, 1301], "valid"],
      [[1302, 1302], "mapped", [1303]],
      [[1303, 1303], "valid"],
      [[1304, 1304], "mapped", [1305]],
      [[1305, 1305], "valid"],
      [[1306, 1306], "mapped", [1307]],
      [[1307, 1307], "valid"],
      [[1308, 1308], "mapped", [1309]],
      [[1309, 1309], "valid"],
      [[1310, 1310], "mapped", [1311]],
      [[1311, 1311], "valid"],
      [[1312, 1312], "mapped", [1313]],
      [[1313, 1313], "valid"],
      [[1314, 1314], "mapped", [1315]],
      [[1315, 1315], "valid"],
      [[1316, 1316], "mapped", [1317]],
      [[1317, 1317], "valid"],
      [[1318, 1318], "mapped", [1319]],
      [[1319, 1319], "valid"],
      [[1320, 1320], "mapped", [1321]],
      [[1321, 1321], "valid"],
      [[1322, 1322], "mapped", [1323]],
      [[1323, 1323], "valid"],
      [[1324, 1324], "mapped", [1325]],
      [[1325, 1325], "valid"],
      [[1326, 1326], "mapped", [1327]],
      [[1327, 1327], "valid"],
      [[1328, 1328], "disallowed"],
      [[1329, 1329], "mapped", [1377]],
      [[1330, 1330], "mapped", [1378]],
      [[1331, 1331], "mapped", [1379]],
      [[1332, 1332], "mapped", [1380]],
      [[1333, 1333], "mapped", [1381]],
      [[1334, 1334], "mapped", [1382]],
      [[1335, 1335], "mapped", [1383]],
      [[1336, 1336], "mapped", [1384]],
      [[1337, 1337], "mapped", [1385]],
      [[1338, 1338], "mapped", [1386]],
      [[1339, 1339], "mapped", [1387]],
      [[1340, 1340], "mapped", [1388]],
      [[1341, 1341], "mapped", [1389]],
      [[1342, 1342], "mapped", [1390]],
      [[1343, 1343], "mapped", [1391]],
      [[1344, 1344], "mapped", [1392]],
      [[1345, 1345], "mapped", [1393]],
      [[1346, 1346], "mapped", [1394]],
      [[1347, 1347], "mapped", [1395]],
      [[1348, 1348], "mapped", [1396]],
      [[1349, 1349], "mapped", [1397]],
      [[1350, 1350], "mapped", [1398]],
      [[1351, 1351], "mapped", [1399]],
      [[1352, 1352], "mapped", [1400]],
      [[1353, 1353], "mapped", [1401]],
      [[1354, 1354], "mapped", [1402]],
      [[1355, 1355], "mapped", [1403]],
      [[1356, 1356], "mapped", [1404]],
      [[1357, 1357], "mapped", [1405]],
      [[1358, 1358], "mapped", [1406]],
      [[1359, 1359], "mapped", [1407]],
      [[1360, 1360], "mapped", [1408]],
      [[1361, 1361], "mapped", [1409]],
      [[1362, 1362], "mapped", [1410]],
      [[1363, 1363], "mapped", [1411]],
      [[1364, 1364], "mapped", [1412]],
      [[1365, 1365], "mapped", [1413]],
      [[1366, 1366], "mapped", [1414]],
      [[1367, 1368], "disallowed"],
      [[1369, 1369], "valid"],
      [[1370, 1375], "valid", [], "NV8"],
      [[1376, 1376], "disallowed"],
      [[1377, 1414], "valid"],
      [[1415, 1415], "mapped", [1381, 1410]],
      [[1416, 1416], "disallowed"],
      [[1417, 1417], "valid", [], "NV8"],
      [[1418, 1418], "valid", [], "NV8"],
      [[1419, 1420], "disallowed"],
      [[1421, 1422], "valid", [], "NV8"],
      [[1423, 1423], "valid", [], "NV8"],
      [[1424, 1424], "disallowed"],
      [[1425, 1441], "valid"],
      [[1442, 1442], "valid"],
      [[1443, 1455], "valid"],
      [[1456, 1465], "valid"],
      [[1466, 1466], "valid"],
      [[1467, 1469], "valid"],
      [[1470, 1470], "valid", [], "NV8"],
      [[1471, 1471], "valid"],
      [[1472, 1472], "valid", [], "NV8"],
      [[1473, 1474], "valid"],
      [[1475, 1475], "valid", [], "NV8"],
      [[1476, 1476], "valid"],
      [[1477, 1477], "valid"],
      [[1478, 1478], "valid", [], "NV8"],
      [[1479, 1479], "valid"],
      [[1480, 1487], "disallowed"],
      [[1488, 1514], "valid"],
      [[1515, 1519], "disallowed"],
      [[1520, 1524], "valid"],
      [[1525, 1535], "disallowed"],
      [[1536, 1539], "disallowed"],
      [[1540, 1540], "disallowed"],
      [[1541, 1541], "disallowed"],
      [[1542, 1546], "valid", [], "NV8"],
      [[1547, 1547], "valid", [], "NV8"],
      [[1548, 1548], "valid", [], "NV8"],
      [[1549, 1551], "valid", [], "NV8"],
      [[1552, 1557], "valid"],
      [[1558, 1562], "valid"],
      [[1563, 1563], "valid", [], "NV8"],
      [[1564, 1564], "disallowed"],
      [[1565, 1565], "disallowed"],
      [[1566, 1566], "valid", [], "NV8"],
      [[1567, 1567], "valid", [], "NV8"],
      [[1568, 1568], "valid"],
      [[1569, 1594], "valid"],
      [[1595, 1599], "valid"],
      [[1600, 1600], "valid", [], "NV8"],
      [[1601, 1618], "valid"],
      [[1619, 1621], "valid"],
      [[1622, 1624], "valid"],
      [[1625, 1630], "valid"],
      [[1631, 1631], "valid"],
      [[1632, 1641], "valid"],
      [[1642, 1645], "valid", [], "NV8"],
      [[1646, 1647], "valid"],
      [[1648, 1652], "valid"],
      [[1653, 1653], "mapped", [1575, 1652]],
      [[1654, 1654], "mapped", [1608, 1652]],
      [[1655, 1655], "mapped", [1735, 1652]],
      [[1656, 1656], "mapped", [1610, 1652]],
      [[1657, 1719], "valid"],
      [[1720, 1721], "valid"],
      [[1722, 1726], "valid"],
      [[1727, 1727], "valid"],
      [[1728, 1742], "valid"],
      [[1743, 1743], "valid"],
      [[1744, 1747], "valid"],
      [[1748, 1748], "valid", [], "NV8"],
      [[1749, 1756], "valid"],
      [[1757, 1757], "disallowed"],
      [[1758, 1758], "valid", [], "NV8"],
      [[1759, 1768], "valid"],
      [[1769, 1769], "valid", [], "NV8"],
      [[1770, 1773], "valid"],
      [[1774, 1775], "valid"],
      [[1776, 1785], "valid"],
      [[1786, 1790], "valid"],
      [[1791, 1791], "valid"],
      [[1792, 1805], "valid", [], "NV8"],
      [[1806, 1806], "disallowed"],
      [[1807, 1807], "disallowed"],
      [[1808, 1836], "valid"],
      [[1837, 1839], "valid"],
      [[1840, 1866], "valid"],
      [[1867, 1868], "disallowed"],
      [[1869, 1871], "valid"],
      [[1872, 1901], "valid"],
      [[1902, 1919], "valid"],
      [[1920, 1968], "valid"],
      [[1969, 1969], "valid"],
      [[1970, 1983], "disallowed"],
      [[1984, 2037], "valid"],
      [[2038, 2042], "valid", [], "NV8"],
      [[2043, 2047], "disallowed"],
      [[2048, 2093], "valid"],
      [[2094, 2095], "disallowed"],
      [[2096, 2110], "valid", [], "NV8"],
      [[2111, 2111], "disallowed"],
      [[2112, 2139], "valid"],
      [[2140, 2141], "disallowed"],
      [[2142, 2142], "valid", [], "NV8"],
      [[2143, 2207], "disallowed"],
      [[2208, 2208], "valid"],
      [[2209, 2209], "valid"],
      [[2210, 2220], "valid"],
      [[2221, 2226], "valid"],
      [[2227, 2228], "valid"],
      [[2229, 2274], "disallowed"],
      [[2275, 2275], "valid"],
      [[2276, 2302], "valid"],
      [[2303, 2303], "valid"],
      [[2304, 2304], "valid"],
      [[2305, 2307], "valid"],
      [[2308, 2308], "valid"],
      [[2309, 2361], "valid"],
      [[2362, 2363], "valid"],
      [[2364, 2381], "valid"],
      [[2382, 2382], "valid"],
      [[2383, 2383], "valid"],
      [[2384, 2388], "valid"],
      [[2389, 2389], "valid"],
      [[2390, 2391], "valid"],
      [[2392, 2392], "mapped", [2325, 2364]],
      [[2393, 2393], "mapped", [2326, 2364]],
      [[2394, 2394], "mapped", [2327, 2364]],
      [[2395, 2395], "mapped", [2332, 2364]],
      [[2396, 2396], "mapped", [2337, 2364]],
      [[2397, 2397], "mapped", [2338, 2364]],
      [[2398, 2398], "mapped", [2347, 2364]],
      [[2399, 2399], "mapped", [2351, 2364]],
      [[2400, 2403], "valid"],
      [[2404, 2405], "valid", [], "NV8"],
      [[2406, 2415], "valid"],
      [[2416, 2416], "valid", [], "NV8"],
      [[2417, 2418], "valid"],
      [[2419, 2423], "valid"],
      [[2424, 2424], "valid"],
      [[2425, 2426], "valid"],
      [[2427, 2428], "valid"],
      [[2429, 2429], "valid"],
      [[2430, 2431], "valid"],
      [[2432, 2432], "valid"],
      [[2433, 2435], "valid"],
      [[2436, 2436], "disallowed"],
      [[2437, 2444], "valid"],
      [[2445, 2446], "disallowed"],
      [[2447, 2448], "valid"],
      [[2449, 2450], "disallowed"],
      [[2451, 2472], "valid"],
      [[2473, 2473], "disallowed"],
      [[2474, 2480], "valid"],
      [[2481, 2481], "disallowed"],
      [[2482, 2482], "valid"],
      [[2483, 2485], "disallowed"],
      [[2486, 2489], "valid"],
      [[2490, 2491], "disallowed"],
      [[2492, 2492], "valid"],
      [[2493, 2493], "valid"],
      [[2494, 2500], "valid"],
      [[2501, 2502], "disallowed"],
      [[2503, 2504], "valid"],
      [[2505, 2506], "disallowed"],
      [[2507, 2509], "valid"],
      [[2510, 2510], "valid"],
      [[2511, 2518], "disallowed"],
      [[2519, 2519], "valid"],
      [[2520, 2523], "disallowed"],
      [[2524, 2524], "mapped", [2465, 2492]],
      [[2525, 2525], "mapped", [2466, 2492]],
      [[2526, 2526], "disallowed"],
      [[2527, 2527], "mapped", [2479, 2492]],
      [[2528, 2531], "valid"],
      [[2532, 2533], "disallowed"],
      [[2534, 2545], "valid"],
      [[2546, 2554], "valid", [], "NV8"],
      [[2555, 2555], "valid", [], "NV8"],
      [[2556, 2560], "disallowed"],
      [[2561, 2561], "valid"],
      [[2562, 2562], "valid"],
      [[2563, 2563], "valid"],
      [[2564, 2564], "disallowed"],
      [[2565, 2570], "valid"],
      [[2571, 2574], "disallowed"],
      [[2575, 2576], "valid"],
      [[2577, 2578], "disallowed"],
      [[2579, 2600], "valid"],
      [[2601, 2601], "disallowed"],
      [[2602, 2608], "valid"],
      [[2609, 2609], "disallowed"],
      [[2610, 2610], "valid"],
      [[2611, 2611], "mapped", [2610, 2620]],
      [[2612, 2612], "disallowed"],
      [[2613, 2613], "valid"],
      [[2614, 2614], "mapped", [2616, 2620]],
      [[2615, 2615], "disallowed"],
      [[2616, 2617], "valid"],
      [[2618, 2619], "disallowed"],
      [[2620, 2620], "valid"],
      [[2621, 2621], "disallowed"],
      [[2622, 2626], "valid"],
      [[2627, 2630], "disallowed"],
      [[2631, 2632], "valid"],
      [[2633, 2634], "disallowed"],
      [[2635, 2637], "valid"],
      [[2638, 2640], "disallowed"],
      [[2641, 2641], "valid"],
      [[2642, 2648], "disallowed"],
      [[2649, 2649], "mapped", [2582, 2620]],
      [[2650, 2650], "mapped", [2583, 2620]],
      [[2651, 2651], "mapped", [2588, 2620]],
      [[2652, 2652], "valid"],
      [[2653, 2653], "disallowed"],
      [[2654, 2654], "mapped", [2603, 2620]],
      [[2655, 2661], "disallowed"],
      [[2662, 2676], "valid"],
      [[2677, 2677], "valid"],
      [[2678, 2688], "disallowed"],
      [[2689, 2691], "valid"],
      [[2692, 2692], "disallowed"],
      [[2693, 2699], "valid"],
      [[2700, 2700], "valid"],
      [[2701, 2701], "valid"],
      [[2702, 2702], "disallowed"],
      [[2703, 2705], "valid"],
      [[2706, 2706], "disallowed"],
      [[2707, 2728], "valid"],
      [[2729, 2729], "disallowed"],
      [[2730, 2736], "valid"],
      [[2737, 2737], "disallowed"],
      [[2738, 2739], "valid"],
      [[2740, 2740], "disallowed"],
      [[2741, 2745], "valid"],
      [[2746, 2747], "disallowed"],
      [[2748, 2757], "valid"],
      [[2758, 2758], "disallowed"],
      [[2759, 2761], "valid"],
      [[2762, 2762], "disallowed"],
      [[2763, 2765], "valid"],
      [[2766, 2767], "disallowed"],
      [[2768, 2768], "valid"],
      [[2769, 2783], "disallowed"],
      [[2784, 2784], "valid"],
      [[2785, 2787], "valid"],
      [[2788, 2789], "disallowed"],
      [[2790, 2799], "valid"],
      [[2800, 2800], "valid", [], "NV8"],
      [[2801, 2801], "valid", [], "NV8"],
      [[2802, 2808], "disallowed"],
      [[2809, 2809], "valid"],
      [[2810, 2816], "disallowed"],
      [[2817, 2819], "valid"],
      [[2820, 2820], "disallowed"],
      [[2821, 2828], "valid"],
      [[2829, 2830], "disallowed"],
      [[2831, 2832], "valid"],
      [[2833, 2834], "disallowed"],
      [[2835, 2856], "valid"],
      [[2857, 2857], "disallowed"],
      [[2858, 2864], "valid"],
      [[2865, 2865], "disallowed"],
      [[2866, 2867], "valid"],
      [[2868, 2868], "disallowed"],
      [[2869, 2869], "valid"],
      [[2870, 2873], "valid"],
      [[2874, 2875], "disallowed"],
      [[2876, 2883], "valid"],
      [[2884, 2884], "valid"],
      [[2885, 2886], "disallowed"],
      [[2887, 2888], "valid"],
      [[2889, 2890], "disallowed"],
      [[2891, 2893], "valid"],
      [[2894, 2901], "disallowed"],
      [[2902, 2903], "valid"],
      [[2904, 2907], "disallowed"],
      [[2908, 2908], "mapped", [2849, 2876]],
      [[2909, 2909], "mapped", [2850, 2876]],
      [[2910, 2910], "disallowed"],
      [[2911, 2913], "valid"],
      [[2914, 2915], "valid"],
      [[2916, 2917], "disallowed"],
      [[2918, 2927], "valid"],
      [[2928, 2928], "valid", [], "NV8"],
      [[2929, 2929], "valid"],
      [[2930, 2935], "valid", [], "NV8"],
      [[2936, 2945], "disallowed"],
      [[2946, 2947], "valid"],
      [[2948, 2948], "disallowed"],
      [[2949, 2954], "valid"],
      [[2955, 2957], "disallowed"],
      [[2958, 2960], "valid"],
      [[2961, 2961], "disallowed"],
      [[2962, 2965], "valid"],
      [[2966, 2968], "disallowed"],
      [[2969, 2970], "valid"],
      [[2971, 2971], "disallowed"],
      [[2972, 2972], "valid"],
      [[2973, 2973], "disallowed"],
      [[2974, 2975], "valid"],
      [[2976, 2978], "disallowed"],
      [[2979, 2980], "valid"],
      [[2981, 2983], "disallowed"],
      [[2984, 2986], "valid"],
      [[2987, 2989], "disallowed"],
      [[2990, 2997], "valid"],
      [[2998, 2998], "valid"],
      [[2999, 3001], "valid"],
      [[3002, 3005], "disallowed"],
      [[3006, 3010], "valid"],
      [[3011, 3013], "disallowed"],
      [[3014, 3016], "valid"],
      [[3017, 3017], "disallowed"],
      [[3018, 3021], "valid"],
      [[3022, 3023], "disallowed"],
      [[3024, 3024], "valid"],
      [[3025, 3030], "disallowed"],
      [[3031, 3031], "valid"],
      [[3032, 3045], "disallowed"],
      [[3046, 3046], "valid"],
      [[3047, 3055], "valid"],
      [[3056, 3058], "valid", [], "NV8"],
      [[3059, 3066], "valid", [], "NV8"],
      [[3067, 3071], "disallowed"],
      [[3072, 3072], "valid"],
      [[3073, 3075], "valid"],
      [[3076, 3076], "disallowed"],
      [[3077, 3084], "valid"],
      [[3085, 3085], "disallowed"],
      [[3086, 3088], "valid"],
      [[3089, 3089], "disallowed"],
      [[3090, 3112], "valid"],
      [[3113, 3113], "disallowed"],
      [[3114, 3123], "valid"],
      [[3124, 3124], "valid"],
      [[3125, 3129], "valid"],
      [[3130, 3132], "disallowed"],
      [[3133, 3133], "valid"],
      [[3134, 3140], "valid"],
      [[3141, 3141], "disallowed"],
      [[3142, 3144], "valid"],
      [[3145, 3145], "disallowed"],
      [[3146, 3149], "valid"],
      [[3150, 3156], "disallowed"],
      [[3157, 3158], "valid"],
      [[3159, 3159], "disallowed"],
      [[3160, 3161], "valid"],
      [[3162, 3162], "valid"],
      [[3163, 3167], "disallowed"],
      [[3168, 3169], "valid"],
      [[3170, 3171], "valid"],
      [[3172, 3173], "disallowed"],
      [[3174, 3183], "valid"],
      [[3184, 3191], "disallowed"],
      [[3192, 3199], "valid", [], "NV8"],
      [[3200, 3200], "disallowed"],
      [[3201, 3201], "valid"],
      [[3202, 3203], "valid"],
      [[3204, 3204], "disallowed"],
      [[3205, 3212], "valid"],
      [[3213, 3213], "disallowed"],
      [[3214, 3216], "valid"],
      [[3217, 3217], "disallowed"],
      [[3218, 3240], "valid"],
      [[3241, 3241], "disallowed"],
      [[3242, 3251], "valid"],
      [[3252, 3252], "disallowed"],
      [[3253, 3257], "valid"],
      [[3258, 3259], "disallowed"],
      [[3260, 3261], "valid"],
      [[3262, 3268], "valid"],
      [[3269, 3269], "disallowed"],
      [[3270, 3272], "valid"],
      [[3273, 3273], "disallowed"],
      [[3274, 3277], "valid"],
      [[3278, 3284], "disallowed"],
      [[3285, 3286], "valid"],
      [[3287, 3293], "disallowed"],
      [[3294, 3294], "valid"],
      [[3295, 3295], "disallowed"],
      [[3296, 3297], "valid"],
      [[3298, 3299], "valid"],
      [[3300, 3301], "disallowed"],
      [[3302, 3311], "valid"],
      [[3312, 3312], "disallowed"],
      [[3313, 3314], "valid"],
      [[3315, 3328], "disallowed"],
      [[3329, 3329], "valid"],
      [[3330, 3331], "valid"],
      [[3332, 3332], "disallowed"],
      [[3333, 3340], "valid"],
      [[3341, 3341], "disallowed"],
      [[3342, 3344], "valid"],
      [[3345, 3345], "disallowed"],
      [[3346, 3368], "valid"],
      [[3369, 3369], "valid"],
      [[3370, 3385], "valid"],
      [[3386, 3386], "valid"],
      [[3387, 3388], "disallowed"],
      [[3389, 3389], "valid"],
      [[3390, 3395], "valid"],
      [[3396, 3396], "valid"],
      [[3397, 3397], "disallowed"],
      [[3398, 3400], "valid"],
      [[3401, 3401], "disallowed"],
      [[3402, 3405], "valid"],
      [[3406, 3406], "valid"],
      [[3407, 3414], "disallowed"],
      [[3415, 3415], "valid"],
      [[3416, 3422], "disallowed"],
      [[3423, 3423], "valid"],
      [[3424, 3425], "valid"],
      [[3426, 3427], "valid"],
      [[3428, 3429], "disallowed"],
      [[3430, 3439], "valid"],
      [[3440, 3445], "valid", [], "NV8"],
      [[3446, 3448], "disallowed"],
      [[3449, 3449], "valid", [], "NV8"],
      [[3450, 3455], "valid"],
      [[3456, 3457], "disallowed"],
      [[3458, 3459], "valid"],
      [[3460, 3460], "disallowed"],
      [[3461, 3478], "valid"],
      [[3479, 3481], "disallowed"],
      [[3482, 3505], "valid"],
      [[3506, 3506], "disallowed"],
      [[3507, 3515], "valid"],
      [[3516, 3516], "disallowed"],
      [[3517, 3517], "valid"],
      [[3518, 3519], "disallowed"],
      [[3520, 3526], "valid"],
      [[3527, 3529], "disallowed"],
      [[3530, 3530], "valid"],
      [[3531, 3534], "disallowed"],
      [[3535, 3540], "valid"],
      [[3541, 3541], "disallowed"],
      [[3542, 3542], "valid"],
      [[3543, 3543], "disallowed"],
      [[3544, 3551], "valid"],
      [[3552, 3557], "disallowed"],
      [[3558, 3567], "valid"],
      [[3568, 3569], "disallowed"],
      [[3570, 3571], "valid"],
      [[3572, 3572], "valid", [], "NV8"],
      [[3573, 3584], "disallowed"],
      [[3585, 3634], "valid"],
      [[3635, 3635], "mapped", [3661, 3634]],
      [[3636, 3642], "valid"],
      [[3643, 3646], "disallowed"],
      [[3647, 3647], "valid", [], "NV8"],
      [[3648, 3662], "valid"],
      [[3663, 3663], "valid", [], "NV8"],
      [[3664, 3673], "valid"],
      [[3674, 3675], "valid", [], "NV8"],
      [[3676, 3712], "disallowed"],
      [[3713, 3714], "valid"],
      [[3715, 3715], "disallowed"],
      [[3716, 3716], "valid"],
      [[3717, 3718], "disallowed"],
      [[3719, 3720], "valid"],
      [[3721, 3721], "disallowed"],
      [[3722, 3722], "valid"],
      [[3723, 3724], "disallowed"],
      [[3725, 3725], "valid"],
      [[3726, 3731], "disallowed"],
      [[3732, 3735], "valid"],
      [[3736, 3736], "disallowed"],
      [[3737, 3743], "valid"],
      [[3744, 3744], "disallowed"],
      [[3745, 3747], "valid"],
      [[3748, 3748], "disallowed"],
      [[3749, 3749], "valid"],
      [[3750, 3750], "disallowed"],
      [[3751, 3751], "valid"],
      [[3752, 3753], "disallowed"],
      [[3754, 3755], "valid"],
      [[3756, 3756], "disallowed"],
      [[3757, 3762], "valid"],
      [[3763, 3763], "mapped", [3789, 3762]],
      [[3764, 3769], "valid"],
      [[3770, 3770], "disallowed"],
      [[3771, 3773], "valid"],
      [[3774, 3775], "disallowed"],
      [[3776, 3780], "valid"],
      [[3781, 3781], "disallowed"],
      [[3782, 3782], "valid"],
      [[3783, 3783], "disallowed"],
      [[3784, 3789], "valid"],
      [[3790, 3791], "disallowed"],
      [[3792, 3801], "valid"],
      [[3802, 3803], "disallowed"],
      [[3804, 3804], "mapped", [3755, 3737]],
      [[3805, 3805], "mapped", [3755, 3745]],
      [[3806, 3807], "valid"],
      [[3808, 3839], "disallowed"],
      [[3840, 3840], "valid"],
      [[3841, 3850], "valid", [], "NV8"],
      [[3851, 3851], "valid"],
      [[3852, 3852], "mapped", [3851]],
      [[3853, 3863], "valid", [], "NV8"],
      [[3864, 3865], "valid"],
      [[3866, 3871], "valid", [], "NV8"],
      [[3872, 3881], "valid"],
      [[3882, 3892], "valid", [], "NV8"],
      [[3893, 3893], "valid"],
      [[3894, 3894], "valid", [], "NV8"],
      [[3895, 3895], "valid"],
      [[3896, 3896], "valid", [], "NV8"],
      [[3897, 3897], "valid"],
      [[3898, 3901], "valid", [], "NV8"],
      [[3902, 3906], "valid"],
      [[3907, 3907], "mapped", [3906, 4023]],
      [[3908, 3911], "valid"],
      [[3912, 3912], "disallowed"],
      [[3913, 3916], "valid"],
      [[3917, 3917], "mapped", [3916, 4023]],
      [[3918, 3921], "valid"],
      [[3922, 3922], "mapped", [3921, 4023]],
      [[3923, 3926], "valid"],
      [[3927, 3927], "mapped", [3926, 4023]],
      [[3928, 3931], "valid"],
      [[3932, 3932], "mapped", [3931, 4023]],
      [[3933, 3944], "valid"],
      [[3945, 3945], "mapped", [3904, 4021]],
      [[3946, 3946], "valid"],
      [[3947, 3948], "valid"],
      [[3949, 3952], "disallowed"],
      [[3953, 3954], "valid"],
      [[3955, 3955], "mapped", [3953, 3954]],
      [[3956, 3956], "valid"],
      [[3957, 3957], "mapped", [3953, 3956]],
      [[3958, 3958], "mapped", [4018, 3968]],
      [[3959, 3959], "mapped", [4018, 3953, 3968]],
      [[3960, 3960], "mapped", [4019, 3968]],
      [[3961, 3961], "mapped", [4019, 3953, 3968]],
      [[3962, 3968], "valid"],
      [[3969, 3969], "mapped", [3953, 3968]],
      [[3970, 3972], "valid"],
      [[3973, 3973], "valid", [], "NV8"],
      [[3974, 3979], "valid"],
      [[3980, 3983], "valid"],
      [[3984, 3986], "valid"],
      [[3987, 3987], "mapped", [3986, 4023]],
      [[3988, 3989], "valid"],
      [[3990, 3990], "valid"],
      [[3991, 3991], "valid"],
      [[3992, 3992], "disallowed"],
      [[3993, 3996], "valid"],
      [[3997, 3997], "mapped", [3996, 4023]],
      [[3998, 4001], "valid"],
      [[4002, 4002], "mapped", [4001, 4023]],
      [[4003, 4006], "valid"],
      [[4007, 4007], "mapped", [4006, 4023]],
      [[4008, 4011], "valid"],
      [[4012, 4012], "mapped", [4011, 4023]],
      [[4013, 4013], "valid"],
      [[4014, 4016], "valid"],
      [[4017, 4023], "valid"],
      [[4024, 4024], "valid"],
      [[4025, 4025], "mapped", [3984, 4021]],
      [[4026, 4028], "valid"],
      [[4029, 4029], "disallowed"],
      [[4030, 4037], "valid", [], "NV8"],
      [[4038, 4038], "valid"],
      [[4039, 4044], "valid", [], "NV8"],
      [[4045, 4045], "disallowed"],
      [[4046, 4046], "valid", [], "NV8"],
      [[4047, 4047], "valid", [], "NV8"],
      [[4048, 4049], "valid", [], "NV8"],
      [[4050, 4052], "valid", [], "NV8"],
      [[4053, 4056], "valid", [], "NV8"],
      [[4057, 4058], "valid", [], "NV8"],
      [[4059, 4095], "disallowed"],
      [[4096, 4129], "valid"],
      [[4130, 4130], "valid"],
      [[4131, 4135], "valid"],
      [[4136, 4136], "valid"],
      [[4137, 4138], "valid"],
      [[4139, 4139], "valid"],
      [[4140, 4146], "valid"],
      [[4147, 4149], "valid"],
      [[4150, 4153], "valid"],
      [[4154, 4159], "valid"],
      [[4160, 4169], "valid"],
      [[4170, 4175], "valid", [], "NV8"],
      [[4176, 4185], "valid"],
      [[4186, 4249], "valid"],
      [[4250, 4253], "valid"],
      [[4254, 4255], "valid", [], "NV8"],
      [[4256, 4293], "disallowed"],
      [[4294, 4294], "disallowed"],
      [[4295, 4295], "mapped", [11559]],
      [[4296, 4300], "disallowed"],
      [[4301, 4301], "mapped", [11565]],
      [[4302, 4303], "disallowed"],
      [[4304, 4342], "valid"],
      [[4343, 4344], "valid"],
      [[4345, 4346], "valid"],
      [[4347, 4347], "valid", [], "NV8"],
      [[4348, 4348], "mapped", [4316]],
      [[4349, 4351], "valid"],
      [[4352, 4441], "valid", [], "NV8"],
      [[4442, 4446], "valid", [], "NV8"],
      [[4447, 4448], "disallowed"],
      [[4449, 4514], "valid", [], "NV8"],
      [[4515, 4519], "valid", [], "NV8"],
      [[4520, 4601], "valid", [], "NV8"],
      [[4602, 4607], "valid", [], "NV8"],
      [[4608, 4614], "valid"],
      [[4615, 4615], "valid"],
      [[4616, 4678], "valid"],
      [[4679, 4679], "valid"],
      [[4680, 4680], "valid"],
      [[4681, 4681], "disallowed"],
      [[4682, 4685], "valid"],
      [[4686, 4687], "disallowed"],
      [[4688, 4694], "valid"],
      [[4695, 4695], "disallowed"],
      [[4696, 4696], "valid"],
      [[4697, 4697], "disallowed"],
      [[4698, 4701], "valid"],
      [[4702, 4703], "disallowed"],
      [[4704, 4742], "valid"],
      [[4743, 4743], "valid"],
      [[4744, 4744], "valid"],
      [[4745, 4745], "disallowed"],
      [[4746, 4749], "valid"],
      [[4750, 4751], "disallowed"],
      [[4752, 4782], "valid"],
      [[4783, 4783], "valid"],
      [[4784, 4784], "valid"],
      [[4785, 4785], "disallowed"],
      [[4786, 4789], "valid"],
      [[4790, 4791], "disallowed"],
      [[4792, 4798], "valid"],
      [[4799, 4799], "disallowed"],
      [[4800, 4800], "valid"],
      [[4801, 4801], "disallowed"],
      [[4802, 4805], "valid"],
      [[4806, 4807], "disallowed"],
      [[4808, 4814], "valid"],
      [[4815, 4815], "valid"],
      [[4816, 4822], "valid"],
      [[4823, 4823], "disallowed"],
      [[4824, 4846], "valid"],
      [[4847, 4847], "valid"],
      [[4848, 4878], "valid"],
      [[4879, 4879], "valid"],
      [[4880, 4880], "valid"],
      [[4881, 4881], "disallowed"],
      [[4882, 4885], "valid"],
      [[4886, 4887], "disallowed"],
      [[4888, 4894], "valid"],
      [[4895, 4895], "valid"],
      [[4896, 4934], "valid"],
      [[4935, 4935], "valid"],
      [[4936, 4954], "valid"],
      [[4955, 4956], "disallowed"],
      [[4957, 4958], "valid"],
      [[4959, 4959], "valid"],
      [[4960, 4960], "valid", [], "NV8"],
      [[4961, 4988], "valid", [], "NV8"],
      [[4989, 4991], "disallowed"],
      [[4992, 5007], "valid"],
      [[5008, 5017], "valid", [], "NV8"],
      [[5018, 5023], "disallowed"],
      [[5024, 5108], "valid"],
      [[5109, 5109], "valid"],
      [[5110, 5111], "disallowed"],
      [[5112, 5112], "mapped", [5104]],
      [[5113, 5113], "mapped", [5105]],
      [[5114, 5114], "mapped", [5106]],
      [[5115, 5115], "mapped", [5107]],
      [[5116, 5116], "mapped", [5108]],
      [[5117, 5117], "mapped", [5109]],
      [[5118, 5119], "disallowed"],
      [[5120, 5120], "valid", [], "NV8"],
      [[5121, 5740], "valid"],
      [[5741, 5742], "valid", [], "NV8"],
      [[5743, 5750], "valid"],
      [[5751, 5759], "valid"],
      [[5760, 5760], "disallowed"],
      [[5761, 5786], "valid"],
      [[5787, 5788], "valid", [], "NV8"],
      [[5789, 5791], "disallowed"],
      [[5792, 5866], "valid"],
      [[5867, 5872], "valid", [], "NV8"],
      [[5873, 5880], "valid"],
      [[5881, 5887], "disallowed"],
      [[5888, 5900], "valid"],
      [[5901, 5901], "disallowed"],
      [[5902, 5908], "valid"],
      [[5909, 5919], "disallowed"],
      [[5920, 5940], "valid"],
      [[5941, 5942], "valid", [], "NV8"],
      [[5943, 5951], "disallowed"],
      [[5952, 5971], "valid"],
      [[5972, 5983], "disallowed"],
      [[5984, 5996], "valid"],
      [[5997, 5997], "disallowed"],
      [[5998, 6e3], "valid"],
      [[6001, 6001], "disallowed"],
      [[6002, 6003], "valid"],
      [[6004, 6015], "disallowed"],
      [[6016, 6067], "valid"],
      [[6068, 6069], "disallowed"],
      [[6070, 6099], "valid"],
      [[6100, 6102], "valid", [], "NV8"],
      [[6103, 6103], "valid"],
      [[6104, 6107], "valid", [], "NV8"],
      [[6108, 6108], "valid"],
      [[6109, 6109], "valid"],
      [[6110, 6111], "disallowed"],
      [[6112, 6121], "valid"],
      [[6122, 6127], "disallowed"],
      [[6128, 6137], "valid", [], "NV8"],
      [[6138, 6143], "disallowed"],
      [[6144, 6149], "valid", [], "NV8"],
      [[6150, 6150], "disallowed"],
      [[6151, 6154], "valid", [], "NV8"],
      [[6155, 6157], "ignored"],
      [[6158, 6158], "disallowed"],
      [[6159, 6159], "disallowed"],
      [[6160, 6169], "valid"],
      [[6170, 6175], "disallowed"],
      [[6176, 6263], "valid"],
      [[6264, 6271], "disallowed"],
      [[6272, 6313], "valid"],
      [[6314, 6314], "valid"],
      [[6315, 6319], "disallowed"],
      [[6320, 6389], "valid"],
      [[6390, 6399], "disallowed"],
      [[6400, 6428], "valid"],
      [[6429, 6430], "valid"],
      [[6431, 6431], "disallowed"],
      [[6432, 6443], "valid"],
      [[6444, 6447], "disallowed"],
      [[6448, 6459], "valid"],
      [[6460, 6463], "disallowed"],
      [[6464, 6464], "valid", [], "NV8"],
      [[6465, 6467], "disallowed"],
      [[6468, 6469], "valid", [], "NV8"],
      [[6470, 6509], "valid"],
      [[6510, 6511], "disallowed"],
      [[6512, 6516], "valid"],
      [[6517, 6527], "disallowed"],
      [[6528, 6569], "valid"],
      [[6570, 6571], "valid"],
      [[6572, 6575], "disallowed"],
      [[6576, 6601], "valid"],
      [[6602, 6607], "disallowed"],
      [[6608, 6617], "valid"],
      [[6618, 6618], "valid", [], "XV8"],
      [[6619, 6621], "disallowed"],
      [[6622, 6623], "valid", [], "NV8"],
      [[6624, 6655], "valid", [], "NV8"],
      [[6656, 6683], "valid"],
      [[6684, 6685], "disallowed"],
      [[6686, 6687], "valid", [], "NV8"],
      [[6688, 6750], "valid"],
      [[6751, 6751], "disallowed"],
      [[6752, 6780], "valid"],
      [[6781, 6782], "disallowed"],
      [[6783, 6793], "valid"],
      [[6794, 6799], "disallowed"],
      [[6800, 6809], "valid"],
      [[6810, 6815], "disallowed"],
      [[6816, 6822], "valid", [], "NV8"],
      [[6823, 6823], "valid"],
      [[6824, 6829], "valid", [], "NV8"],
      [[6830, 6831], "disallowed"],
      [[6832, 6845], "valid"],
      [[6846, 6846], "valid", [], "NV8"],
      [[6847, 6911], "disallowed"],
      [[6912, 6987], "valid"],
      [[6988, 6991], "disallowed"],
      [[6992, 7001], "valid"],
      [[7002, 7018], "valid", [], "NV8"],
      [[7019, 7027], "valid"],
      [[7028, 7036], "valid", [], "NV8"],
      [[7037, 7039], "disallowed"],
      [[7040, 7082], "valid"],
      [[7083, 7085], "valid"],
      [[7086, 7097], "valid"],
      [[7098, 7103], "valid"],
      [[7104, 7155], "valid"],
      [[7156, 7163], "disallowed"],
      [[7164, 7167], "valid", [], "NV8"],
      [[7168, 7223], "valid"],
      [[7224, 7226], "disallowed"],
      [[7227, 7231], "valid", [], "NV8"],
      [[7232, 7241], "valid"],
      [[7242, 7244], "disallowed"],
      [[7245, 7293], "valid"],
      [[7294, 7295], "valid", [], "NV8"],
      [[7296, 7359], "disallowed"],
      [[7360, 7367], "valid", [], "NV8"],
      [[7368, 7375], "disallowed"],
      [[7376, 7378], "valid"],
      [[7379, 7379], "valid", [], "NV8"],
      [[7380, 7410], "valid"],
      [[7411, 7414], "valid"],
      [[7415, 7415], "disallowed"],
      [[7416, 7417], "valid"],
      [[7418, 7423], "disallowed"],
      [[7424, 7467], "valid"],
      [[7468, 7468], "mapped", [97]],
      [[7469, 7469], "mapped", [230]],
      [[7470, 7470], "mapped", [98]],
      [[7471, 7471], "valid"],
      [[7472, 7472], "mapped", [100]],
      [[7473, 7473], "mapped", [101]],
      [[7474, 7474], "mapped", [477]],
      [[7475, 7475], "mapped", [103]],
      [[7476, 7476], "mapped", [104]],
      [[7477, 7477], "mapped", [105]],
      [[7478, 7478], "mapped", [106]],
      [[7479, 7479], "mapped", [107]],
      [[7480, 7480], "mapped", [108]],
      [[7481, 7481], "mapped", [109]],
      [[7482, 7482], "mapped", [110]],
      [[7483, 7483], "valid"],
      [[7484, 7484], "mapped", [111]],
      [[7485, 7485], "mapped", [547]],
      [[7486, 7486], "mapped", [112]],
      [[7487, 7487], "mapped", [114]],
      [[7488, 7488], "mapped", [116]],
      [[7489, 7489], "mapped", [117]],
      [[7490, 7490], "mapped", [119]],
      [[7491, 7491], "mapped", [97]],
      [[7492, 7492], "mapped", [592]],
      [[7493, 7493], "mapped", [593]],
      [[7494, 7494], "mapped", [7426]],
      [[7495, 7495], "mapped", [98]],
      [[7496, 7496], "mapped", [100]],
      [[7497, 7497], "mapped", [101]],
      [[7498, 7498], "mapped", [601]],
      [[7499, 7499], "mapped", [603]],
      [[7500, 7500], "mapped", [604]],
      [[7501, 7501], "mapped", [103]],
      [[7502, 7502], "valid"],
      [[7503, 7503], "mapped", [107]],
      [[7504, 7504], "mapped", [109]],
      [[7505, 7505], "mapped", [331]],
      [[7506, 7506], "mapped", [111]],
      [[7507, 7507], "mapped", [596]],
      [[7508, 7508], "mapped", [7446]],
      [[7509, 7509], "mapped", [7447]],
      [[7510, 7510], "mapped", [112]],
      [[7511, 7511], "mapped", [116]],
      [[7512, 7512], "mapped", [117]],
      [[7513, 7513], "mapped", [7453]],
      [[7514, 7514], "mapped", [623]],
      [[7515, 7515], "mapped", [118]],
      [[7516, 7516], "mapped", [7461]],
      [[7517, 7517], "mapped", [946]],
      [[7518, 7518], "mapped", [947]],
      [[7519, 7519], "mapped", [948]],
      [[7520, 7520], "mapped", [966]],
      [[7521, 7521], "mapped", [967]],
      [[7522, 7522], "mapped", [105]],
      [[7523, 7523], "mapped", [114]],
      [[7524, 7524], "mapped", [117]],
      [[7525, 7525], "mapped", [118]],
      [[7526, 7526], "mapped", [946]],
      [[7527, 7527], "mapped", [947]],
      [[7528, 7528], "mapped", [961]],
      [[7529, 7529], "mapped", [966]],
      [[7530, 7530], "mapped", [967]],
      [[7531, 7531], "valid"],
      [[7532, 7543], "valid"],
      [[7544, 7544], "mapped", [1085]],
      [[7545, 7578], "valid"],
      [[7579, 7579], "mapped", [594]],
      [[7580, 7580], "mapped", [99]],
      [[7581, 7581], "mapped", [597]],
      [[7582, 7582], "mapped", [240]],
      [[7583, 7583], "mapped", [604]],
      [[7584, 7584], "mapped", [102]],
      [[7585, 7585], "mapped", [607]],
      [[7586, 7586], "mapped", [609]],
      [[7587, 7587], "mapped", [613]],
      [[7588, 7588], "mapped", [616]],
      [[7589, 7589], "mapped", [617]],
      [[7590, 7590], "mapped", [618]],
      [[7591, 7591], "mapped", [7547]],
      [[7592, 7592], "mapped", [669]],
      [[7593, 7593], "mapped", [621]],
      [[7594, 7594], "mapped", [7557]],
      [[7595, 7595], "mapped", [671]],
      [[7596, 7596], "mapped", [625]],
      [[7597, 7597], "mapped", [624]],
      [[7598, 7598], "mapped", [626]],
      [[7599, 7599], "mapped", [627]],
      [[7600, 7600], "mapped", [628]],
      [[7601, 7601], "mapped", [629]],
      [[7602, 7602], "mapped", [632]],
      [[7603, 7603], "mapped", [642]],
      [[7604, 7604], "mapped", [643]],
      [[7605, 7605], "mapped", [427]],
      [[7606, 7606], "mapped", [649]],
      [[7607, 7607], "mapped", [650]],
      [[7608, 7608], "mapped", [7452]],
      [[7609, 7609], "mapped", [651]],
      [[7610, 7610], "mapped", [652]],
      [[7611, 7611], "mapped", [122]],
      [[7612, 7612], "mapped", [656]],
      [[7613, 7613], "mapped", [657]],
      [[7614, 7614], "mapped", [658]],
      [[7615, 7615], "mapped", [952]],
      [[7616, 7619], "valid"],
      [[7620, 7626], "valid"],
      [[7627, 7654], "valid"],
      [[7655, 7669], "valid"],
      [[7670, 7675], "disallowed"],
      [[7676, 7676], "valid"],
      [[7677, 7677], "valid"],
      [[7678, 7679], "valid"],
      [[7680, 7680], "mapped", [7681]],
      [[7681, 7681], "valid"],
      [[7682, 7682], "mapped", [7683]],
      [[7683, 7683], "valid"],
      [[7684, 7684], "mapped", [7685]],
      [[7685, 7685], "valid"],
      [[7686, 7686], "mapped", [7687]],
      [[7687, 7687], "valid"],
      [[7688, 7688], "mapped", [7689]],
      [[7689, 7689], "valid"],
      [[7690, 7690], "mapped", [7691]],
      [[7691, 7691], "valid"],
      [[7692, 7692], "mapped", [7693]],
      [[7693, 7693], "valid"],
      [[7694, 7694], "mapped", [7695]],
      [[7695, 7695], "valid"],
      [[7696, 7696], "mapped", [7697]],
      [[7697, 7697], "valid"],
      [[7698, 7698], "mapped", [7699]],
      [[7699, 7699], "valid"],
      [[7700, 7700], "mapped", [7701]],
      [[7701, 7701], "valid"],
      [[7702, 7702], "mapped", [7703]],
      [[7703, 7703], "valid"],
      [[7704, 7704], "mapped", [7705]],
      [[7705, 7705], "valid"],
      [[7706, 7706], "mapped", [7707]],
      [[7707, 7707], "valid"],
      [[7708, 7708], "mapped", [7709]],
      [[7709, 7709], "valid"],
      [[7710, 7710], "mapped", [7711]],
      [[7711, 7711], "valid"],
      [[7712, 7712], "mapped", [7713]],
      [[7713, 7713], "valid"],
      [[7714, 7714], "mapped", [7715]],
      [[7715, 7715], "valid"],
      [[7716, 7716], "mapped", [7717]],
      [[7717, 7717], "valid"],
      [[7718, 7718], "mapped", [7719]],
      [[7719, 7719], "valid"],
      [[7720, 7720], "mapped", [7721]],
      [[7721, 7721], "valid"],
      [[7722, 7722], "mapped", [7723]],
      [[7723, 7723], "valid"],
      [[7724, 7724], "mapped", [7725]],
      [[7725, 7725], "valid"],
      [[7726, 7726], "mapped", [7727]],
      [[7727, 7727], "valid"],
      [[7728, 7728], "mapped", [7729]],
      [[7729, 7729], "valid"],
      [[7730, 7730], "mapped", [7731]],
      [[7731, 7731], "valid"],
      [[7732, 7732], "mapped", [7733]],
      [[7733, 7733], "valid"],
      [[7734, 7734], "mapped", [7735]],
      [[7735, 7735], "valid"],
      [[7736, 7736], "mapped", [7737]],
      [[7737, 7737], "valid"],
      [[7738, 7738], "mapped", [7739]],
      [[7739, 7739], "valid"],
      [[7740, 7740], "mapped", [7741]],
      [[7741, 7741], "valid"],
      [[7742, 7742], "mapped", [7743]],
      [[7743, 7743], "valid"],
      [[7744, 7744], "mapped", [7745]],
      [[7745, 7745], "valid"],
      [[7746, 7746], "mapped", [7747]],
      [[7747, 7747], "valid"],
      [[7748, 7748], "mapped", [7749]],
      [[7749, 7749], "valid"],
      [[7750, 7750], "mapped", [7751]],
      [[7751, 7751], "valid"],
      [[7752, 7752], "mapped", [7753]],
      [[7753, 7753], "valid"],
      [[7754, 7754], "mapped", [7755]],
      [[7755, 7755], "valid"],
      [[7756, 7756], "mapped", [7757]],
      [[7757, 7757], "valid"],
      [[7758, 7758], "mapped", [7759]],
      [[7759, 7759], "valid"],
      [[7760, 7760], "mapped", [7761]],
      [[7761, 7761], "valid"],
      [[7762, 7762], "mapped", [7763]],
      [[7763, 7763], "valid"],
      [[7764, 7764], "mapped", [7765]],
      [[7765, 7765], "valid"],
      [[7766, 7766], "mapped", [7767]],
      [[7767, 7767], "valid"],
      [[7768, 7768], "mapped", [7769]],
      [[7769, 7769], "valid"],
      [[7770, 7770], "mapped", [7771]],
      [[7771, 7771], "valid"],
      [[7772, 7772], "mapped", [7773]],
      [[7773, 7773], "valid"],
      [[7774, 7774], "mapped", [7775]],
      [[7775, 7775], "valid"],
      [[7776, 7776], "mapped", [7777]],
      [[7777, 7777], "valid"],
      [[7778, 7778], "mapped", [7779]],
      [[7779, 7779], "valid"],
      [[7780, 7780], "mapped", [7781]],
      [[7781, 7781], "valid"],
      [[7782, 7782], "mapped", [7783]],
      [[7783, 7783], "valid"],
      [[7784, 7784], "mapped", [7785]],
      [[7785, 7785], "valid"],
      [[7786, 7786], "mapped", [7787]],
      [[7787, 7787], "valid"],
      [[7788, 7788], "mapped", [7789]],
      [[7789, 7789], "valid"],
      [[7790, 7790], "mapped", [7791]],
      [[7791, 7791], "valid"],
      [[7792, 7792], "mapped", [7793]],
      [[7793, 7793], "valid"],
      [[7794, 7794], "mapped", [7795]],
      [[7795, 7795], "valid"],
      [[7796, 7796], "mapped", [7797]],
      [[7797, 7797], "valid"],
      [[7798, 7798], "mapped", [7799]],
      [[7799, 7799], "valid"],
      [[7800, 7800], "mapped", [7801]],
      [[7801, 7801], "valid"],
      [[7802, 7802], "mapped", [7803]],
      [[7803, 7803], "valid"],
      [[7804, 7804], "mapped", [7805]],
      [[7805, 7805], "valid"],
      [[7806, 7806], "mapped", [7807]],
      [[7807, 7807], "valid"],
      [[7808, 7808], "mapped", [7809]],
      [[7809, 7809], "valid"],
      [[7810, 7810], "mapped", [7811]],
      [[7811, 7811], "valid"],
      [[7812, 7812], "mapped", [7813]],
      [[7813, 7813], "valid"],
      [[7814, 7814], "mapped", [7815]],
      [[7815, 7815], "valid"],
      [[7816, 7816], "mapped", [7817]],
      [[7817, 7817], "valid"],
      [[7818, 7818], "mapped", [7819]],
      [[7819, 7819], "valid"],
      [[7820, 7820], "mapped", [7821]],
      [[7821, 7821], "valid"],
      [[7822, 7822], "mapped", [7823]],
      [[7823, 7823], "valid"],
      [[7824, 7824], "mapped", [7825]],
      [[7825, 7825], "valid"],
      [[7826, 7826], "mapped", [7827]],
      [[7827, 7827], "valid"],
      [[7828, 7828], "mapped", [7829]],
      [[7829, 7833], "valid"],
      [[7834, 7834], "mapped", [97, 702]],
      [[7835, 7835], "mapped", [7777]],
      [[7836, 7837], "valid"],
      [[7838, 7838], "mapped", [115, 115]],
      [[7839, 7839], "valid"],
      [[7840, 7840], "mapped", [7841]],
      [[7841, 7841], "valid"],
      [[7842, 7842], "mapped", [7843]],
      [[7843, 7843], "valid"],
      [[7844, 7844], "mapped", [7845]],
      [[7845, 7845], "valid"],
      [[7846, 7846], "mapped", [7847]],
      [[7847, 7847], "valid"],
      [[7848, 7848], "mapped", [7849]],
      [[7849, 7849], "valid"],
      [[7850, 7850], "mapped", [7851]],
      [[7851, 7851], "valid"],
      [[7852, 7852], "mapped", [7853]],
      [[7853, 7853], "valid"],
      [[7854, 7854], "mapped", [7855]],
      [[7855, 7855], "valid"],
      [[7856, 7856], "mapped", [7857]],
      [[7857, 7857], "valid"],
      [[7858, 7858], "mapped", [7859]],
      [[7859, 7859], "valid"],
      [[7860, 7860], "mapped", [7861]],
      [[7861, 7861], "valid"],
      [[7862, 7862], "mapped", [7863]],
      [[7863, 7863], "valid"],
      [[7864, 7864], "mapped", [7865]],
      [[7865, 7865], "valid"],
      [[7866, 7866], "mapped", [7867]],
      [[7867, 7867], "valid"],
      [[7868, 7868], "mapped", [7869]],
      [[7869, 7869], "valid"],
      [[7870, 7870], "mapped", [7871]],
      [[7871, 7871], "valid"],
      [[7872, 7872], "mapped", [7873]],
      [[7873, 7873], "valid"],
      [[7874, 7874], "mapped", [7875]],
      [[7875, 7875], "valid"],
      [[7876, 7876], "mapped", [7877]],
      [[7877, 7877], "valid"],
      [[7878, 7878], "mapped", [7879]],
      [[7879, 7879], "valid"],
      [[7880, 7880], "mapped", [7881]],
      [[7881, 7881], "valid"],
      [[7882, 7882], "mapped", [7883]],
      [[7883, 7883], "valid"],
      [[7884, 7884], "mapped", [7885]],
      [[7885, 7885], "valid"],
      [[7886, 7886], "mapped", [7887]],
      [[7887, 7887], "valid"],
      [[7888, 7888], "mapped", [7889]],
      [[7889, 7889], "valid"],
      [[7890, 7890], "mapped", [7891]],
      [[7891, 7891], "valid"],
      [[7892, 7892], "mapped", [7893]],
      [[7893, 7893], "valid"],
      [[7894, 7894], "mapped", [7895]],
      [[7895, 7895], "valid"],
      [[7896, 7896], "mapped", [7897]],
      [[7897, 7897], "valid"],
      [[7898, 7898], "mapped", [7899]],
      [[7899, 7899], "valid"],
      [[7900, 7900], "mapped", [7901]],
      [[7901, 7901], "valid"],
      [[7902, 7902], "mapped", [7903]],
      [[7903, 7903], "valid"],
      [[7904, 7904], "mapped", [7905]],
      [[7905, 7905], "valid"],
      [[7906, 7906], "mapped", [7907]],
      [[7907, 7907], "valid"],
      [[7908, 7908], "mapped", [7909]],
      [[7909, 7909], "valid"],
      [[7910, 7910], "mapped", [7911]],
      [[7911, 7911], "valid"],
      [[7912, 7912], "mapped", [7913]],
      [[7913, 7913], "valid"],
      [[7914, 7914], "mapped", [7915]],
      [[7915, 7915], "valid"],
      [[7916, 7916], "mapped", [7917]],
      [[7917, 7917], "valid"],
      [[7918, 7918], "mapped", [7919]],
      [[7919, 7919], "valid"],
      [[7920, 7920], "mapped", [7921]],
      [[7921, 7921], "valid"],
      [[7922, 7922], "mapped", [7923]],
      [[7923, 7923], "valid"],
      [[7924, 7924], "mapped", [7925]],
      [[7925, 7925], "valid"],
      [[7926, 7926], "mapped", [7927]],
      [[7927, 7927], "valid"],
      [[7928, 7928], "mapped", [7929]],
      [[7929, 7929], "valid"],
      [[7930, 7930], "mapped", [7931]],
      [[7931, 7931], "valid"],
      [[7932, 7932], "mapped", [7933]],
      [[7933, 7933], "valid"],
      [[7934, 7934], "mapped", [7935]],
      [[7935, 7935], "valid"],
      [[7936, 7943], "valid"],
      [[7944, 7944], "mapped", [7936]],
      [[7945, 7945], "mapped", [7937]],
      [[7946, 7946], "mapped", [7938]],
      [[7947, 7947], "mapped", [7939]],
      [[7948, 7948], "mapped", [7940]],
      [[7949, 7949], "mapped", [7941]],
      [[7950, 7950], "mapped", [7942]],
      [[7951, 7951], "mapped", [7943]],
      [[7952, 7957], "valid"],
      [[7958, 7959], "disallowed"],
      [[7960, 7960], "mapped", [7952]],
      [[7961, 7961], "mapped", [7953]],
      [[7962, 7962], "mapped", [7954]],
      [[7963, 7963], "mapped", [7955]],
      [[7964, 7964], "mapped", [7956]],
      [[7965, 7965], "mapped", [7957]],
      [[7966, 7967], "disallowed"],
      [[7968, 7975], "valid"],
      [[7976, 7976], "mapped", [7968]],
      [[7977, 7977], "mapped", [7969]],
      [[7978, 7978], "mapped", [7970]],
      [[7979, 7979], "mapped", [7971]],
      [[7980, 7980], "mapped", [7972]],
      [[7981, 7981], "mapped", [7973]],
      [[7982, 7982], "mapped", [7974]],
      [[7983, 7983], "mapped", [7975]],
      [[7984, 7991], "valid"],
      [[7992, 7992], "mapped", [7984]],
      [[7993, 7993], "mapped", [7985]],
      [[7994, 7994], "mapped", [7986]],
      [[7995, 7995], "mapped", [7987]],
      [[7996, 7996], "mapped", [7988]],
      [[7997, 7997], "mapped", [7989]],
      [[7998, 7998], "mapped", [7990]],
      [[7999, 7999], "mapped", [7991]],
      [[8e3, 8005], "valid"],
      [[8006, 8007], "disallowed"],
      [[8008, 8008], "mapped", [8e3]],
      [[8009, 8009], "mapped", [8001]],
      [[8010, 8010], "mapped", [8002]],
      [[8011, 8011], "mapped", [8003]],
      [[8012, 8012], "mapped", [8004]],
      [[8013, 8013], "mapped", [8005]],
      [[8014, 8015], "disallowed"],
      [[8016, 8023], "valid"],
      [[8024, 8024], "disallowed"],
      [[8025, 8025], "mapped", [8017]],
      [[8026, 8026], "disallowed"],
      [[8027, 8027], "mapped", [8019]],
      [[8028, 8028], "disallowed"],
      [[8029, 8029], "mapped", [8021]],
      [[8030, 8030], "disallowed"],
      [[8031, 8031], "mapped", [8023]],
      [[8032, 8039], "valid"],
      [[8040, 8040], "mapped", [8032]],
      [[8041, 8041], "mapped", [8033]],
      [[8042, 8042], "mapped", [8034]],
      [[8043, 8043], "mapped", [8035]],
      [[8044, 8044], "mapped", [8036]],
      [[8045, 8045], "mapped", [8037]],
      [[8046, 8046], "mapped", [8038]],
      [[8047, 8047], "mapped", [8039]],
      [[8048, 8048], "valid"],
      [[8049, 8049], "mapped", [940]],
      [[8050, 8050], "valid"],
      [[8051, 8051], "mapped", [941]],
      [[8052, 8052], "valid"],
      [[8053, 8053], "mapped", [942]],
      [[8054, 8054], "valid"],
      [[8055, 8055], "mapped", [943]],
      [[8056, 8056], "valid"],
      [[8057, 8057], "mapped", [972]],
      [[8058, 8058], "valid"],
      [[8059, 8059], "mapped", [973]],
      [[8060, 8060], "valid"],
      [[8061, 8061], "mapped", [974]],
      [[8062, 8063], "disallowed"],
      [[8064, 8064], "mapped", [7936, 953]],
      [[8065, 8065], "mapped", [7937, 953]],
      [[8066, 8066], "mapped", [7938, 953]],
      [[8067, 8067], "mapped", [7939, 953]],
      [[8068, 8068], "mapped", [7940, 953]],
      [[8069, 8069], "mapped", [7941, 953]],
      [[8070, 8070], "mapped", [7942, 953]],
      [[8071, 8071], "mapped", [7943, 953]],
      [[8072, 8072], "mapped", [7936, 953]],
      [[8073, 8073], "mapped", [7937, 953]],
      [[8074, 8074], "mapped", [7938, 953]],
      [[8075, 8075], "mapped", [7939, 953]],
      [[8076, 8076], "mapped", [7940, 953]],
      [[8077, 8077], "mapped", [7941, 953]],
      [[8078, 8078], "mapped", [7942, 953]],
      [[8079, 8079], "mapped", [7943, 953]],
      [[8080, 8080], "mapped", [7968, 953]],
      [[8081, 8081], "mapped", [7969, 953]],
      [[8082, 8082], "mapped", [7970, 953]],
      [[8083, 8083], "mapped", [7971, 953]],
      [[8084, 8084], "mapped", [7972, 953]],
      [[8085, 8085], "mapped", [7973, 953]],
      [[8086, 8086], "mapped", [7974, 953]],
      [[8087, 8087], "mapped", [7975, 953]],
      [[8088, 8088], "mapped", [7968, 953]],
      [[8089, 8089], "mapped", [7969, 953]],
      [[8090, 8090], "mapped", [7970, 953]],
      [[8091, 8091], "mapped", [7971, 953]],
      [[8092, 8092], "mapped", [7972, 953]],
      [[8093, 8093], "mapped", [7973, 953]],
      [[8094, 8094], "mapped", [7974, 953]],
      [[8095, 8095], "mapped", [7975, 953]],
      [[8096, 8096], "mapped", [8032, 953]],
      [[8097, 8097], "mapped", [8033, 953]],
      [[8098, 8098], "mapped", [8034, 953]],
      [[8099, 8099], "mapped", [8035, 953]],
      [[8100, 8100], "mapped", [8036, 953]],
      [[8101, 8101], "mapped", [8037, 953]],
      [[8102, 8102], "mapped", [8038, 953]],
      [[8103, 8103], "mapped", [8039, 953]],
      [[8104, 8104], "mapped", [8032, 953]],
      [[8105, 8105], "mapped", [8033, 953]],
      [[8106, 8106], "mapped", [8034, 953]],
      [[8107, 8107], "mapped", [8035, 953]],
      [[8108, 8108], "mapped", [8036, 953]],
      [[8109, 8109], "mapped", [8037, 953]],
      [[8110, 8110], "mapped", [8038, 953]],
      [[8111, 8111], "mapped", [8039, 953]],
      [[8112, 8113], "valid"],
      [[8114, 8114], "mapped", [8048, 953]],
      [[8115, 8115], "mapped", [945, 953]],
      [[8116, 8116], "mapped", [940, 953]],
      [[8117, 8117], "disallowed"],
      [[8118, 8118], "valid"],
      [[8119, 8119], "mapped", [8118, 953]],
      [[8120, 8120], "mapped", [8112]],
      [[8121, 8121], "mapped", [8113]],
      [[8122, 8122], "mapped", [8048]],
      [[8123, 8123], "mapped", [940]],
      [[8124, 8124], "mapped", [945, 953]],
      [[8125, 8125], "disallowed_STD3_mapped", [32, 787]],
      [[8126, 8126], "mapped", [953]],
      [[8127, 8127], "disallowed_STD3_mapped", [32, 787]],
      [[8128, 8128], "disallowed_STD3_mapped", [32, 834]],
      [[8129, 8129], "disallowed_STD3_mapped", [32, 776, 834]],
      [[8130, 8130], "mapped", [8052, 953]],
      [[8131, 8131], "mapped", [951, 953]],
      [[8132, 8132], "mapped", [942, 953]],
      [[8133, 8133], "disallowed"],
      [[8134, 8134], "valid"],
      [[8135, 8135], "mapped", [8134, 953]],
      [[8136, 8136], "mapped", [8050]],
      [[8137, 8137], "mapped", [941]],
      [[8138, 8138], "mapped", [8052]],
      [[8139, 8139], "mapped", [942]],
      [[8140, 8140], "mapped", [951, 953]],
      [[8141, 8141], "disallowed_STD3_mapped", [32, 787, 768]],
      [[8142, 8142], "disallowed_STD3_mapped", [32, 787, 769]],
      [[8143, 8143], "disallowed_STD3_mapped", [32, 787, 834]],
      [[8144, 8146], "valid"],
      [[8147, 8147], "mapped", [912]],
      [[8148, 8149], "disallowed"],
      [[8150, 8151], "valid"],
      [[8152, 8152], "mapped", [8144]],
      [[8153, 8153], "mapped", [8145]],
      [[8154, 8154], "mapped", [8054]],
      [[8155, 8155], "mapped", [943]],
      [[8156, 8156], "disallowed"],
      [[8157, 8157], "disallowed_STD3_mapped", [32, 788, 768]],
      [[8158, 8158], "disallowed_STD3_mapped", [32, 788, 769]],
      [[8159, 8159], "disallowed_STD3_mapped", [32, 788, 834]],
      [[8160, 8162], "valid"],
      [[8163, 8163], "mapped", [944]],
      [[8164, 8167], "valid"],
      [[8168, 8168], "mapped", [8160]],
      [[8169, 8169], "mapped", [8161]],
      [[8170, 8170], "mapped", [8058]],
      [[8171, 8171], "mapped", [973]],
      [[8172, 8172], "mapped", [8165]],
      [[8173, 8173], "disallowed_STD3_mapped", [32, 776, 768]],
      [[8174, 8174], "disallowed_STD3_mapped", [32, 776, 769]],
      [[8175, 8175], "disallowed_STD3_mapped", [96]],
      [[8176, 8177], "disallowed"],
      [[8178, 8178], "mapped", [8060, 953]],
      [[8179, 8179], "mapped", [969, 953]],
      [[8180, 8180], "mapped", [974, 953]],
      [[8181, 8181], "disallowed"],
      [[8182, 8182], "valid"],
      [[8183, 8183], "mapped", [8182, 953]],
      [[8184, 8184], "mapped", [8056]],
      [[8185, 8185], "mapped", [972]],
      [[8186, 8186], "mapped", [8060]],
      [[8187, 8187], "mapped", [974]],
      [[8188, 8188], "mapped", [969, 953]],
      [[8189, 8189], "disallowed_STD3_mapped", [32, 769]],
      [[8190, 8190], "disallowed_STD3_mapped", [32, 788]],
      [[8191, 8191], "disallowed"],
      [[8192, 8202], "disallowed_STD3_mapped", [32]],
      [[8203, 8203], "ignored"],
      [[8204, 8205], "deviation", []],
      [[8206, 8207], "disallowed"],
      [[8208, 8208], "valid", [], "NV8"],
      [[8209, 8209], "mapped", [8208]],
      [[8210, 8214], "valid", [], "NV8"],
      [[8215, 8215], "disallowed_STD3_mapped", [32, 819]],
      [[8216, 8227], "valid", [], "NV8"],
      [[8228, 8230], "disallowed"],
      [[8231, 8231], "valid", [], "NV8"],
      [[8232, 8238], "disallowed"],
      [[8239, 8239], "disallowed_STD3_mapped", [32]],
      [[8240, 8242], "valid", [], "NV8"],
      [[8243, 8243], "mapped", [8242, 8242]],
      [[8244, 8244], "mapped", [8242, 8242, 8242]],
      [[8245, 8245], "valid", [], "NV8"],
      [[8246, 8246], "mapped", [8245, 8245]],
      [[8247, 8247], "mapped", [8245, 8245, 8245]],
      [[8248, 8251], "valid", [], "NV8"],
      [[8252, 8252], "disallowed_STD3_mapped", [33, 33]],
      [[8253, 8253], "valid", [], "NV8"],
      [[8254, 8254], "disallowed_STD3_mapped", [32, 773]],
      [[8255, 8262], "valid", [], "NV8"],
      [[8263, 8263], "disallowed_STD3_mapped", [63, 63]],
      [[8264, 8264], "disallowed_STD3_mapped", [63, 33]],
      [[8265, 8265], "disallowed_STD3_mapped", [33, 63]],
      [[8266, 8269], "valid", [], "NV8"],
      [[8270, 8274], "valid", [], "NV8"],
      [[8275, 8276], "valid", [], "NV8"],
      [[8277, 8278], "valid", [], "NV8"],
      [[8279, 8279], "mapped", [8242, 8242, 8242, 8242]],
      [[8280, 8286], "valid", [], "NV8"],
      [[8287, 8287], "disallowed_STD3_mapped", [32]],
      [[8288, 8288], "ignored"],
      [[8289, 8291], "disallowed"],
      [[8292, 8292], "ignored"],
      [[8293, 8293], "disallowed"],
      [[8294, 8297], "disallowed"],
      [[8298, 8303], "disallowed"],
      [[8304, 8304], "mapped", [48]],
      [[8305, 8305], "mapped", [105]],
      [[8306, 8307], "disallowed"],
      [[8308, 8308], "mapped", [52]],
      [[8309, 8309], "mapped", [53]],
      [[8310, 8310], "mapped", [54]],
      [[8311, 8311], "mapped", [55]],
      [[8312, 8312], "mapped", [56]],
      [[8313, 8313], "mapped", [57]],
      [[8314, 8314], "disallowed_STD3_mapped", [43]],
      [[8315, 8315], "mapped", [8722]],
      [[8316, 8316], "disallowed_STD3_mapped", [61]],
      [[8317, 8317], "disallowed_STD3_mapped", [40]],
      [[8318, 8318], "disallowed_STD3_mapped", [41]],
      [[8319, 8319], "mapped", [110]],
      [[8320, 8320], "mapped", [48]],
      [[8321, 8321], "mapped", [49]],
      [[8322, 8322], "mapped", [50]],
      [[8323, 8323], "mapped", [51]],
      [[8324, 8324], "mapped", [52]],
      [[8325, 8325], "mapped", [53]],
      [[8326, 8326], "mapped", [54]],
      [[8327, 8327], "mapped", [55]],
      [[8328, 8328], "mapped", [56]],
      [[8329, 8329], "mapped", [57]],
      [[8330, 8330], "disallowed_STD3_mapped", [43]],
      [[8331, 8331], "mapped", [8722]],
      [[8332, 8332], "disallowed_STD3_mapped", [61]],
      [[8333, 8333], "disallowed_STD3_mapped", [40]],
      [[8334, 8334], "disallowed_STD3_mapped", [41]],
      [[8335, 8335], "disallowed"],
      [[8336, 8336], "mapped", [97]],
      [[8337, 8337], "mapped", [101]],
      [[8338, 8338], "mapped", [111]],
      [[8339, 8339], "mapped", [120]],
      [[8340, 8340], "mapped", [601]],
      [[8341, 8341], "mapped", [104]],
      [[8342, 8342], "mapped", [107]],
      [[8343, 8343], "mapped", [108]],
      [[8344, 8344], "mapped", [109]],
      [[8345, 8345], "mapped", [110]],
      [[8346, 8346], "mapped", [112]],
      [[8347, 8347], "mapped", [115]],
      [[8348, 8348], "mapped", [116]],
      [[8349, 8351], "disallowed"],
      [[8352, 8359], "valid", [], "NV8"],
      [[8360, 8360], "mapped", [114, 115]],
      [[8361, 8362], "valid", [], "NV8"],
      [[8363, 8363], "valid", [], "NV8"],
      [[8364, 8364], "valid", [], "NV8"],
      [[8365, 8367], "valid", [], "NV8"],
      [[8368, 8369], "valid", [], "NV8"],
      [[8370, 8373], "valid", [], "NV8"],
      [[8374, 8376], "valid", [], "NV8"],
      [[8377, 8377], "valid", [], "NV8"],
      [[8378, 8378], "valid", [], "NV8"],
      [[8379, 8381], "valid", [], "NV8"],
      [[8382, 8382], "valid", [], "NV8"],
      [[8383, 8399], "disallowed"],
      [[8400, 8417], "valid", [], "NV8"],
      [[8418, 8419], "valid", [], "NV8"],
      [[8420, 8426], "valid", [], "NV8"],
      [[8427, 8427], "valid", [], "NV8"],
      [[8428, 8431], "valid", [], "NV8"],
      [[8432, 8432], "valid", [], "NV8"],
      [[8433, 8447], "disallowed"],
      [[8448, 8448], "disallowed_STD3_mapped", [97, 47, 99]],
      [[8449, 8449], "disallowed_STD3_mapped", [97, 47, 115]],
      [[8450, 8450], "mapped", [99]],
      [[8451, 8451], "mapped", [176, 99]],
      [[8452, 8452], "valid", [], "NV8"],
      [[8453, 8453], "disallowed_STD3_mapped", [99, 47, 111]],
      [[8454, 8454], "disallowed_STD3_mapped", [99, 47, 117]],
      [[8455, 8455], "mapped", [603]],
      [[8456, 8456], "valid", [], "NV8"],
      [[8457, 8457], "mapped", [176, 102]],
      [[8458, 8458], "mapped", [103]],
      [[8459, 8462], "mapped", [104]],
      [[8463, 8463], "mapped", [295]],
      [[8464, 8465], "mapped", [105]],
      [[8466, 8467], "mapped", [108]],
      [[8468, 8468], "valid", [], "NV8"],
      [[8469, 8469], "mapped", [110]],
      [[8470, 8470], "mapped", [110, 111]],
      [[8471, 8472], "valid", [], "NV8"],
      [[8473, 8473], "mapped", [112]],
      [[8474, 8474], "mapped", [113]],
      [[8475, 8477], "mapped", [114]],
      [[8478, 8479], "valid", [], "NV8"],
      [[8480, 8480], "mapped", [115, 109]],
      [[8481, 8481], "mapped", [116, 101, 108]],
      [[8482, 8482], "mapped", [116, 109]],
      [[8483, 8483], "valid", [], "NV8"],
      [[8484, 8484], "mapped", [122]],
      [[8485, 8485], "valid", [], "NV8"],
      [[8486, 8486], "mapped", [969]],
      [[8487, 8487], "valid", [], "NV8"],
      [[8488, 8488], "mapped", [122]],
      [[8489, 8489], "valid", [], "NV8"],
      [[8490, 8490], "mapped", [107]],
      [[8491, 8491], "mapped", [229]],
      [[8492, 8492], "mapped", [98]],
      [[8493, 8493], "mapped", [99]],
      [[8494, 8494], "valid", [], "NV8"],
      [[8495, 8496], "mapped", [101]],
      [[8497, 8497], "mapped", [102]],
      [[8498, 8498], "disallowed"],
      [[8499, 8499], "mapped", [109]],
      [[8500, 8500], "mapped", [111]],
      [[8501, 8501], "mapped", [1488]],
      [[8502, 8502], "mapped", [1489]],
      [[8503, 8503], "mapped", [1490]],
      [[8504, 8504], "mapped", [1491]],
      [[8505, 8505], "mapped", [105]],
      [[8506, 8506], "valid", [], "NV8"],
      [[8507, 8507], "mapped", [102, 97, 120]],
      [[8508, 8508], "mapped", [960]],
      [[8509, 8510], "mapped", [947]],
      [[8511, 8511], "mapped", [960]],
      [[8512, 8512], "mapped", [8721]],
      [[8513, 8516], "valid", [], "NV8"],
      [[8517, 8518], "mapped", [100]],
      [[8519, 8519], "mapped", [101]],
      [[8520, 8520], "mapped", [105]],
      [[8521, 8521], "mapped", [106]],
      [[8522, 8523], "valid", [], "NV8"],
      [[8524, 8524], "valid", [], "NV8"],
      [[8525, 8525], "valid", [], "NV8"],
      [[8526, 8526], "valid"],
      [[8527, 8527], "valid", [], "NV8"],
      [[8528, 8528], "mapped", [49, 8260, 55]],
      [[8529, 8529], "mapped", [49, 8260, 57]],
      [[8530, 8530], "mapped", [49, 8260, 49, 48]],
      [[8531, 8531], "mapped", [49, 8260, 51]],
      [[8532, 8532], "mapped", [50, 8260, 51]],
      [[8533, 8533], "mapped", [49, 8260, 53]],
      [[8534, 8534], "mapped", [50, 8260, 53]],
      [[8535, 8535], "mapped", [51, 8260, 53]],
      [[8536, 8536], "mapped", [52, 8260, 53]],
      [[8537, 8537], "mapped", [49, 8260, 54]],
      [[8538, 8538], "mapped", [53, 8260, 54]],
      [[8539, 8539], "mapped", [49, 8260, 56]],
      [[8540, 8540], "mapped", [51, 8260, 56]],
      [[8541, 8541], "mapped", [53, 8260, 56]],
      [[8542, 8542], "mapped", [55, 8260, 56]],
      [[8543, 8543], "mapped", [49, 8260]],
      [[8544, 8544], "mapped", [105]],
      [[8545, 8545], "mapped", [105, 105]],
      [[8546, 8546], "mapped", [105, 105, 105]],
      [[8547, 8547], "mapped", [105, 118]],
      [[8548, 8548], "mapped", [118]],
      [[8549, 8549], "mapped", [118, 105]],
      [[8550, 8550], "mapped", [118, 105, 105]],
      [[8551, 8551], "mapped", [118, 105, 105, 105]],
      [[8552, 8552], "mapped", [105, 120]],
      [[8553, 8553], "mapped", [120]],
      [[8554, 8554], "mapped", [120, 105]],
      [[8555, 8555], "mapped", [120, 105, 105]],
      [[8556, 8556], "mapped", [108]],
      [[8557, 8557], "mapped", [99]],
      [[8558, 8558], "mapped", [100]],
      [[8559, 8559], "mapped", [109]],
      [[8560, 8560], "mapped", [105]],
      [[8561, 8561], "mapped", [105, 105]],
      [[8562, 8562], "mapped", [105, 105, 105]],
      [[8563, 8563], "mapped", [105, 118]],
      [[8564, 8564], "mapped", [118]],
      [[8565, 8565], "mapped", [118, 105]],
      [[8566, 8566], "mapped", [118, 105, 105]],
      [[8567, 8567], "mapped", [118, 105, 105, 105]],
      [[8568, 8568], "mapped", [105, 120]],
      [[8569, 8569], "mapped", [120]],
      [[8570, 8570], "mapped", [120, 105]],
      [[8571, 8571], "mapped", [120, 105, 105]],
      [[8572, 8572], "mapped", [108]],
      [[8573, 8573], "mapped", [99]],
      [[8574, 8574], "mapped", [100]],
      [[8575, 8575], "mapped", [109]],
      [[8576, 8578], "valid", [], "NV8"],
      [[8579, 8579], "disallowed"],
      [[8580, 8580], "valid"],
      [[8581, 8584], "valid", [], "NV8"],
      [[8585, 8585], "mapped", [48, 8260, 51]],
      [[8586, 8587], "valid", [], "NV8"],
      [[8588, 8591], "disallowed"],
      [[8592, 8682], "valid", [], "NV8"],
      [[8683, 8691], "valid", [], "NV8"],
      [[8692, 8703], "valid", [], "NV8"],
      [[8704, 8747], "valid", [], "NV8"],
      [[8748, 8748], "mapped", [8747, 8747]],
      [[8749, 8749], "mapped", [8747, 8747, 8747]],
      [[8750, 8750], "valid", [], "NV8"],
      [[8751, 8751], "mapped", [8750, 8750]],
      [[8752, 8752], "mapped", [8750, 8750, 8750]],
      [[8753, 8799], "valid", [], "NV8"],
      [[8800, 8800], "disallowed_STD3_valid"],
      [[8801, 8813], "valid", [], "NV8"],
      [[8814, 8815], "disallowed_STD3_valid"],
      [[8816, 8945], "valid", [], "NV8"],
      [[8946, 8959], "valid", [], "NV8"],
      [[8960, 8960], "valid", [], "NV8"],
      [[8961, 8961], "valid", [], "NV8"],
      [[8962, 9e3], "valid", [], "NV8"],
      [[9001, 9001], "mapped", [12296]],
      [[9002, 9002], "mapped", [12297]],
      [[9003, 9082], "valid", [], "NV8"],
      [[9083, 9083], "valid", [], "NV8"],
      [[9084, 9084], "valid", [], "NV8"],
      [[9085, 9114], "valid", [], "NV8"],
      [[9115, 9166], "valid", [], "NV8"],
      [[9167, 9168], "valid", [], "NV8"],
      [[9169, 9179], "valid", [], "NV8"],
      [[9180, 9191], "valid", [], "NV8"],
      [[9192, 9192], "valid", [], "NV8"],
      [[9193, 9203], "valid", [], "NV8"],
      [[9204, 9210], "valid", [], "NV8"],
      [[9211, 9215], "disallowed"],
      [[9216, 9252], "valid", [], "NV8"],
      [[9253, 9254], "valid", [], "NV8"],
      [[9255, 9279], "disallowed"],
      [[9280, 9290], "valid", [], "NV8"],
      [[9291, 9311], "disallowed"],
      [[9312, 9312], "mapped", [49]],
      [[9313, 9313], "mapped", [50]],
      [[9314, 9314], "mapped", [51]],
      [[9315, 9315], "mapped", [52]],
      [[9316, 9316], "mapped", [53]],
      [[9317, 9317], "mapped", [54]],
      [[9318, 9318], "mapped", [55]],
      [[9319, 9319], "mapped", [56]],
      [[9320, 9320], "mapped", [57]],
      [[9321, 9321], "mapped", [49, 48]],
      [[9322, 9322], "mapped", [49, 49]],
      [[9323, 9323], "mapped", [49, 50]],
      [[9324, 9324], "mapped", [49, 51]],
      [[9325, 9325], "mapped", [49, 52]],
      [[9326, 9326], "mapped", [49, 53]],
      [[9327, 9327], "mapped", [49, 54]],
      [[9328, 9328], "mapped", [49, 55]],
      [[9329, 9329], "mapped", [49, 56]],
      [[9330, 9330], "mapped", [49, 57]],
      [[9331, 9331], "mapped", [50, 48]],
      [[9332, 9332], "disallowed_STD3_mapped", [40, 49, 41]],
      [[9333, 9333], "disallowed_STD3_mapped", [40, 50, 41]],
      [[9334, 9334], "disallowed_STD3_mapped", [40, 51, 41]],
      [[9335, 9335], "disallowed_STD3_mapped", [40, 52, 41]],
      [[9336, 9336], "disallowed_STD3_mapped", [40, 53, 41]],
      [[9337, 9337], "disallowed_STD3_mapped", [40, 54, 41]],
      [[9338, 9338], "disallowed_STD3_mapped", [40, 55, 41]],
      [[9339, 9339], "disallowed_STD3_mapped", [40, 56, 41]],
      [[9340, 9340], "disallowed_STD3_mapped", [40, 57, 41]],
      [[9341, 9341], "disallowed_STD3_mapped", [40, 49, 48, 41]],
      [[9342, 9342], "disallowed_STD3_mapped", [40, 49, 49, 41]],
      [[9343, 9343], "disallowed_STD3_mapped", [40, 49, 50, 41]],
      [[9344, 9344], "disallowed_STD3_mapped", [40, 49, 51, 41]],
      [[9345, 9345], "disallowed_STD3_mapped", [40, 49, 52, 41]],
      [[9346, 9346], "disallowed_STD3_mapped", [40, 49, 53, 41]],
      [[9347, 9347], "disallowed_STD3_mapped", [40, 49, 54, 41]],
      [[9348, 9348], "disallowed_STD3_mapped", [40, 49, 55, 41]],
      [[9349, 9349], "disallowed_STD3_mapped", [40, 49, 56, 41]],
      [[9350, 9350], "disallowed_STD3_mapped", [40, 49, 57, 41]],
      [[9351, 9351], "disallowed_STD3_mapped", [40, 50, 48, 41]],
      [[9352, 9371], "disallowed"],
      [[9372, 9372], "disallowed_STD3_mapped", [40, 97, 41]],
      [[9373, 9373], "disallowed_STD3_mapped", [40, 98, 41]],
      [[9374, 9374], "disallowed_STD3_mapped", [40, 99, 41]],
      [[9375, 9375], "disallowed_STD3_mapped", [40, 100, 41]],
      [[9376, 9376], "disallowed_STD3_mapped", [40, 101, 41]],
      [[9377, 9377], "disallowed_STD3_mapped", [40, 102, 41]],
      [[9378, 9378], "disallowed_STD3_mapped", [40, 103, 41]],
      [[9379, 9379], "disallowed_STD3_mapped", [40, 104, 41]],
      [[9380, 9380], "disallowed_STD3_mapped", [40, 105, 41]],
      [[9381, 9381], "disallowed_STD3_mapped", [40, 106, 41]],
      [[9382, 9382], "disallowed_STD3_mapped", [40, 107, 41]],
      [[9383, 9383], "disallowed_STD3_mapped", [40, 108, 41]],
      [[9384, 9384], "disallowed_STD3_mapped", [40, 109, 41]],
      [[9385, 9385], "disallowed_STD3_mapped", [40, 110, 41]],
      [[9386, 9386], "disallowed_STD3_mapped", [40, 111, 41]],
      [[9387, 9387], "disallowed_STD3_mapped", [40, 112, 41]],
      [[9388, 9388], "disallowed_STD3_mapped", [40, 113, 41]],
      [[9389, 9389], "disallowed_STD3_mapped", [40, 114, 41]],
      [[9390, 9390], "disallowed_STD3_mapped", [40, 115, 41]],
      [[9391, 9391], "disallowed_STD3_mapped", [40, 116, 41]],
      [[9392, 9392], "disallowed_STD3_mapped", [40, 117, 41]],
      [[9393, 9393], "disallowed_STD3_mapped", [40, 118, 41]],
      [[9394, 9394], "disallowed_STD3_mapped", [40, 119, 41]],
      [[9395, 9395], "disallowed_STD3_mapped", [40, 120, 41]],
      [[9396, 9396], "disallowed_STD3_mapped", [40, 121, 41]],
      [[9397, 9397], "disallowed_STD3_mapped", [40, 122, 41]],
      [[9398, 9398], "mapped", [97]],
      [[9399, 9399], "mapped", [98]],
      [[9400, 9400], "mapped", [99]],
      [[9401, 9401], "mapped", [100]],
      [[9402, 9402], "mapped", [101]],
      [[9403, 9403], "mapped", [102]],
      [[9404, 9404], "mapped", [103]],
      [[9405, 9405], "mapped", [104]],
      [[9406, 9406], "mapped", [105]],
      [[9407, 9407], "mapped", [106]],
      [[9408, 9408], "mapped", [107]],
      [[9409, 9409], "mapped", [108]],
      [[9410, 9410], "mapped", [109]],
      [[9411, 9411], "mapped", [110]],
      [[9412, 9412], "mapped", [111]],
      [[9413, 9413], "mapped", [112]],
      [[9414, 9414], "mapped", [113]],
      [[9415, 9415], "mapped", [114]],
      [[9416, 9416], "mapped", [115]],
      [[9417, 9417], "mapped", [116]],
      [[9418, 9418], "mapped", [117]],
      [[9419, 9419], "mapped", [118]],
      [[9420, 9420], "mapped", [119]],
      [[9421, 9421], "mapped", [120]],
      [[9422, 9422], "mapped", [121]],
      [[9423, 9423], "mapped", [122]],
      [[9424, 9424], "mapped", [97]],
      [[9425, 9425], "mapped", [98]],
      [[9426, 9426], "mapped", [99]],
      [[9427, 9427], "mapped", [100]],
      [[9428, 9428], "mapped", [101]],
      [[9429, 9429], "mapped", [102]],
      [[9430, 9430], "mapped", [103]],
      [[9431, 9431], "mapped", [104]],
      [[9432, 9432], "mapped", [105]],
      [[9433, 9433], "mapped", [106]],
      [[9434, 9434], "mapped", [107]],
      [[9435, 9435], "mapped", [108]],
      [[9436, 9436], "mapped", [109]],
      [[9437, 9437], "mapped", [110]],
      [[9438, 9438], "mapped", [111]],
      [[9439, 9439], "mapped", [112]],
      [[9440, 9440], "mapped", [113]],
      [[9441, 9441], "mapped", [114]],
      [[9442, 9442], "mapped", [115]],
      [[9443, 9443], "mapped", [116]],
      [[9444, 9444], "mapped", [117]],
      [[9445, 9445], "mapped", [118]],
      [[9446, 9446], "mapped", [119]],
      [[9447, 9447], "mapped", [120]],
      [[9448, 9448], "mapped", [121]],
      [[9449, 9449], "mapped", [122]],
      [[9450, 9450], "mapped", [48]],
      [[9451, 9470], "valid", [], "NV8"],
      [[9471, 9471], "valid", [], "NV8"],
      [[9472, 9621], "valid", [], "NV8"],
      [[9622, 9631], "valid", [], "NV8"],
      [[9632, 9711], "valid", [], "NV8"],
      [[9712, 9719], "valid", [], "NV8"],
      [[9720, 9727], "valid", [], "NV8"],
      [[9728, 9747], "valid", [], "NV8"],
      [[9748, 9749], "valid", [], "NV8"],
      [[9750, 9751], "valid", [], "NV8"],
      [[9752, 9752], "valid", [], "NV8"],
      [[9753, 9753], "valid", [], "NV8"],
      [[9754, 9839], "valid", [], "NV8"],
      [[9840, 9841], "valid", [], "NV8"],
      [[9842, 9853], "valid", [], "NV8"],
      [[9854, 9855], "valid", [], "NV8"],
      [[9856, 9865], "valid", [], "NV8"],
      [[9866, 9873], "valid", [], "NV8"],
      [[9874, 9884], "valid", [], "NV8"],
      [[9885, 9885], "valid", [], "NV8"],
      [[9886, 9887], "valid", [], "NV8"],
      [[9888, 9889], "valid", [], "NV8"],
      [[9890, 9905], "valid", [], "NV8"],
      [[9906, 9906], "valid", [], "NV8"],
      [[9907, 9916], "valid", [], "NV8"],
      [[9917, 9919], "valid", [], "NV8"],
      [[9920, 9923], "valid", [], "NV8"],
      [[9924, 9933], "valid", [], "NV8"],
      [[9934, 9934], "valid", [], "NV8"],
      [[9935, 9953], "valid", [], "NV8"],
      [[9954, 9954], "valid", [], "NV8"],
      [[9955, 9955], "valid", [], "NV8"],
      [[9956, 9959], "valid", [], "NV8"],
      [[9960, 9983], "valid", [], "NV8"],
      [[9984, 9984], "valid", [], "NV8"],
      [[9985, 9988], "valid", [], "NV8"],
      [[9989, 9989], "valid", [], "NV8"],
      [[9990, 9993], "valid", [], "NV8"],
      [[9994, 9995], "valid", [], "NV8"],
      [[9996, 10023], "valid", [], "NV8"],
      [[10024, 10024], "valid", [], "NV8"],
      [[10025, 10059], "valid", [], "NV8"],
      [[10060, 10060], "valid", [], "NV8"],
      [[10061, 10061], "valid", [], "NV8"],
      [[10062, 10062], "valid", [], "NV8"],
      [[10063, 10066], "valid", [], "NV8"],
      [[10067, 10069], "valid", [], "NV8"],
      [[10070, 10070], "valid", [], "NV8"],
      [[10071, 10071], "valid", [], "NV8"],
      [[10072, 10078], "valid", [], "NV8"],
      [[10079, 10080], "valid", [], "NV8"],
      [[10081, 10087], "valid", [], "NV8"],
      [[10088, 10101], "valid", [], "NV8"],
      [[10102, 10132], "valid", [], "NV8"],
      [[10133, 10135], "valid", [], "NV8"],
      [[10136, 10159], "valid", [], "NV8"],
      [[10160, 10160], "valid", [], "NV8"],
      [[10161, 10174], "valid", [], "NV8"],
      [[10175, 10175], "valid", [], "NV8"],
      [[10176, 10182], "valid", [], "NV8"],
      [[10183, 10186], "valid", [], "NV8"],
      [[10187, 10187], "valid", [], "NV8"],
      [[10188, 10188], "valid", [], "NV8"],
      [[10189, 10189], "valid", [], "NV8"],
      [[10190, 10191], "valid", [], "NV8"],
      [[10192, 10219], "valid", [], "NV8"],
      [[10220, 10223], "valid", [], "NV8"],
      [[10224, 10239], "valid", [], "NV8"],
      [[10240, 10495], "valid", [], "NV8"],
      [[10496, 10763], "valid", [], "NV8"],
      [[10764, 10764], "mapped", [8747, 8747, 8747, 8747]],
      [[10765, 10867], "valid", [], "NV8"],
      [[10868, 10868], "disallowed_STD3_mapped", [58, 58, 61]],
      [[10869, 10869], "disallowed_STD3_mapped", [61, 61]],
      [[10870, 10870], "disallowed_STD3_mapped", [61, 61, 61]],
      [[10871, 10971], "valid", [], "NV8"],
      [[10972, 10972], "mapped", [10973, 824]],
      [[10973, 11007], "valid", [], "NV8"],
      [[11008, 11021], "valid", [], "NV8"],
      [[11022, 11027], "valid", [], "NV8"],
      [[11028, 11034], "valid", [], "NV8"],
      [[11035, 11039], "valid", [], "NV8"],
      [[11040, 11043], "valid", [], "NV8"],
      [[11044, 11084], "valid", [], "NV8"],
      [[11085, 11087], "valid", [], "NV8"],
      [[11088, 11092], "valid", [], "NV8"],
      [[11093, 11097], "valid", [], "NV8"],
      [[11098, 11123], "valid", [], "NV8"],
      [[11124, 11125], "disallowed"],
      [[11126, 11157], "valid", [], "NV8"],
      [[11158, 11159], "disallowed"],
      [[11160, 11193], "valid", [], "NV8"],
      [[11194, 11196], "disallowed"],
      [[11197, 11208], "valid", [], "NV8"],
      [[11209, 11209], "disallowed"],
      [[11210, 11217], "valid", [], "NV8"],
      [[11218, 11243], "disallowed"],
      [[11244, 11247], "valid", [], "NV8"],
      [[11248, 11263], "disallowed"],
      [[11264, 11264], "mapped", [11312]],
      [[11265, 11265], "mapped", [11313]],
      [[11266, 11266], "mapped", [11314]],
      [[11267, 11267], "mapped", [11315]],
      [[11268, 11268], "mapped", [11316]],
      [[11269, 11269], "mapped", [11317]],
      [[11270, 11270], "mapped", [11318]],
      [[11271, 11271], "mapped", [11319]],
      [[11272, 11272], "mapped", [11320]],
      [[11273, 11273], "mapped", [11321]],
      [[11274, 11274], "mapped", [11322]],
      [[11275, 11275], "mapped", [11323]],
      [[11276, 11276], "mapped", [11324]],
      [[11277, 11277], "mapped", [11325]],
      [[11278, 11278], "mapped", [11326]],
      [[11279, 11279], "mapped", [11327]],
      [[11280, 11280], "mapped", [11328]],
      [[11281, 11281], "mapped", [11329]],
      [[11282, 11282], "mapped", [11330]],
      [[11283, 11283], "mapped", [11331]],
      [[11284, 11284], "mapped", [11332]],
      [[11285, 11285], "mapped", [11333]],
      [[11286, 11286], "mapped", [11334]],
      [[11287, 11287], "mapped", [11335]],
      [[11288, 11288], "mapped", [11336]],
      [[11289, 11289], "mapped", [11337]],
      [[11290, 11290], "mapped", [11338]],
      [[11291, 11291], "mapped", [11339]],
      [[11292, 11292], "mapped", [11340]],
      [[11293, 11293], "mapped", [11341]],
      [[11294, 11294], "mapped", [11342]],
      [[11295, 11295], "mapped", [11343]],
      [[11296, 11296], "mapped", [11344]],
      [[11297, 11297], "mapped", [11345]],
      [[11298, 11298], "mapped", [11346]],
      [[11299, 11299], "mapped", [11347]],
      [[11300, 11300], "mapped", [11348]],
      [[11301, 11301], "mapped", [11349]],
      [[11302, 11302], "mapped", [11350]],
      [[11303, 11303], "mapped", [11351]],
      [[11304, 11304], "mapped", [11352]],
      [[11305, 11305], "mapped", [11353]],
      [[11306, 11306], "mapped", [11354]],
      [[11307, 11307], "mapped", [11355]],
      [[11308, 11308], "mapped", [11356]],
      [[11309, 11309], "mapped", [11357]],
      [[11310, 11310], "mapped", [11358]],
      [[11311, 11311], "disallowed"],
      [[11312, 11358], "valid"],
      [[11359, 11359], "disallowed"],
      [[11360, 11360], "mapped", [11361]],
      [[11361, 11361], "valid"],
      [[11362, 11362], "mapped", [619]],
      [[11363, 11363], "mapped", [7549]],
      [[11364, 11364], "mapped", [637]],
      [[11365, 11366], "valid"],
      [[11367, 11367], "mapped", [11368]],
      [[11368, 11368], "valid"],
      [[11369, 11369], "mapped", [11370]],
      [[11370, 11370], "valid"],
      [[11371, 11371], "mapped", [11372]],
      [[11372, 11372], "valid"],
      [[11373, 11373], "mapped", [593]],
      [[11374, 11374], "mapped", [625]],
      [[11375, 11375], "mapped", [592]],
      [[11376, 11376], "mapped", [594]],
      [[11377, 11377], "valid"],
      [[11378, 11378], "mapped", [11379]],
      [[11379, 11379], "valid"],
      [[11380, 11380], "valid"],
      [[11381, 11381], "mapped", [11382]],
      [[11382, 11383], "valid"],
      [[11384, 11387], "valid"],
      [[11388, 11388], "mapped", [106]],
      [[11389, 11389], "mapped", [118]],
      [[11390, 11390], "mapped", [575]],
      [[11391, 11391], "mapped", [576]],
      [[11392, 11392], "mapped", [11393]],
      [[11393, 11393], "valid"],
      [[11394, 11394], "mapped", [11395]],
      [[11395, 11395], "valid"],
      [[11396, 11396], "mapped", [11397]],
      [[11397, 11397], "valid"],
      [[11398, 11398], "mapped", [11399]],
      [[11399, 11399], "valid"],
      [[11400, 11400], "mapped", [11401]],
      [[11401, 11401], "valid"],
      [[11402, 11402], "mapped", [11403]],
      [[11403, 11403], "valid"],
      [[11404, 11404], "mapped", [11405]],
      [[11405, 11405], "valid"],
      [[11406, 11406], "mapped", [11407]],
      [[11407, 11407], "valid"],
      [[11408, 11408], "mapped", [11409]],
      [[11409, 11409], "valid"],
      [[11410, 11410], "mapped", [11411]],
      [[11411, 11411], "valid"],
      [[11412, 11412], "mapped", [11413]],
      [[11413, 11413], "valid"],
      [[11414, 11414], "mapped", [11415]],
      [[11415, 11415], "valid"],
      [[11416, 11416], "mapped", [11417]],
      [[11417, 11417], "valid"],
      [[11418, 11418], "mapped", [11419]],
      [[11419, 11419], "valid"],
      [[11420, 11420], "mapped", [11421]],
      [[11421, 11421], "valid"],
      [[11422, 11422], "mapped", [11423]],
      [[11423, 11423], "valid"],
      [[11424, 11424], "mapped", [11425]],
      [[11425, 11425], "valid"],
      [[11426, 11426], "mapped", [11427]],
      [[11427, 11427], "valid"],
      [[11428, 11428], "mapped", [11429]],
      [[11429, 11429], "valid"],
      [[11430, 11430], "mapped", [11431]],
      [[11431, 11431], "valid"],
      [[11432, 11432], "mapped", [11433]],
      [[11433, 11433], "valid"],
      [[11434, 11434], "mapped", [11435]],
      [[11435, 11435], "valid"],
      [[11436, 11436], "mapped", [11437]],
      [[11437, 11437], "valid"],
      [[11438, 11438], "mapped", [11439]],
      [[11439, 11439], "valid"],
      [[11440, 11440], "mapped", [11441]],
      [[11441, 11441], "valid"],
      [[11442, 11442], "mapped", [11443]],
      [[11443, 11443], "valid"],
      [[11444, 11444], "mapped", [11445]],
      [[11445, 11445], "valid"],
      [[11446, 11446], "mapped", [11447]],
      [[11447, 11447], "valid"],
      [[11448, 11448], "mapped", [11449]],
      [[11449, 11449], "valid"],
      [[11450, 11450], "mapped", [11451]],
      [[11451, 11451], "valid"],
      [[11452, 11452], "mapped", [11453]],
      [[11453, 11453], "valid"],
      [[11454, 11454], "mapped", [11455]],
      [[11455, 11455], "valid"],
      [[11456, 11456], "mapped", [11457]],
      [[11457, 11457], "valid"],
      [[11458, 11458], "mapped", [11459]],
      [[11459, 11459], "valid"],
      [[11460, 11460], "mapped", [11461]],
      [[11461, 11461], "valid"],
      [[11462, 11462], "mapped", [11463]],
      [[11463, 11463], "valid"],
      [[11464, 11464], "mapped", [11465]],
      [[11465, 11465], "valid"],
      [[11466, 11466], "mapped", [11467]],
      [[11467, 11467], "valid"],
      [[11468, 11468], "mapped", [11469]],
      [[11469, 11469], "valid"],
      [[11470, 11470], "mapped", [11471]],
      [[11471, 11471], "valid"],
      [[11472, 11472], "mapped", [11473]],
      [[11473, 11473], "valid"],
      [[11474, 11474], "mapped", [11475]],
      [[11475, 11475], "valid"],
      [[11476, 11476], "mapped", [11477]],
      [[11477, 11477], "valid"],
      [[11478, 11478], "mapped", [11479]],
      [[11479, 11479], "valid"],
      [[11480, 11480], "mapped", [11481]],
      [[11481, 11481], "valid"],
      [[11482, 11482], "mapped", [11483]],
      [[11483, 11483], "valid"],
      [[11484, 11484], "mapped", [11485]],
      [[11485, 11485], "valid"],
      [[11486, 11486], "mapped", [11487]],
      [[11487, 11487], "valid"],
      [[11488, 11488], "mapped", [11489]],
      [[11489, 11489], "valid"],
      [[11490, 11490], "mapped", [11491]],
      [[11491, 11492], "valid"],
      [[11493, 11498], "valid", [], "NV8"],
      [[11499, 11499], "mapped", [11500]],
      [[11500, 11500], "valid"],
      [[11501, 11501], "mapped", [11502]],
      [[11502, 11505], "valid"],
      [[11506, 11506], "mapped", [11507]],
      [[11507, 11507], "valid"],
      [[11508, 11512], "disallowed"],
      [[11513, 11519], "valid", [], "NV8"],
      [[11520, 11557], "valid"],
      [[11558, 11558], "disallowed"],
      [[11559, 11559], "valid"],
      [[11560, 11564], "disallowed"],
      [[11565, 11565], "valid"],
      [[11566, 11567], "disallowed"],
      [[11568, 11621], "valid"],
      [[11622, 11623], "valid"],
      [[11624, 11630], "disallowed"],
      [[11631, 11631], "mapped", [11617]],
      [[11632, 11632], "valid", [], "NV8"],
      [[11633, 11646], "disallowed"],
      [[11647, 11647], "valid"],
      [[11648, 11670], "valid"],
      [[11671, 11679], "disallowed"],
      [[11680, 11686], "valid"],
      [[11687, 11687], "disallowed"],
      [[11688, 11694], "valid"],
      [[11695, 11695], "disallowed"],
      [[11696, 11702], "valid"],
      [[11703, 11703], "disallowed"],
      [[11704, 11710], "valid"],
      [[11711, 11711], "disallowed"],
      [[11712, 11718], "valid"],
      [[11719, 11719], "disallowed"],
      [[11720, 11726], "valid"],
      [[11727, 11727], "disallowed"],
      [[11728, 11734], "valid"],
      [[11735, 11735], "disallowed"],
      [[11736, 11742], "valid"],
      [[11743, 11743], "disallowed"],
      [[11744, 11775], "valid"],
      [[11776, 11799], "valid", [], "NV8"],
      [[11800, 11803], "valid", [], "NV8"],
      [[11804, 11805], "valid", [], "NV8"],
      [[11806, 11822], "valid", [], "NV8"],
      [[11823, 11823], "valid"],
      [[11824, 11824], "valid", [], "NV8"],
      [[11825, 11825], "valid", [], "NV8"],
      [[11826, 11835], "valid", [], "NV8"],
      [[11836, 11842], "valid", [], "NV8"],
      [[11843, 11903], "disallowed"],
      [[11904, 11929], "valid", [], "NV8"],
      [[11930, 11930], "disallowed"],
      [[11931, 11934], "valid", [], "NV8"],
      [[11935, 11935], "mapped", [27597]],
      [[11936, 12018], "valid", [], "NV8"],
      [[12019, 12019], "mapped", [40863]],
      [[12020, 12031], "disallowed"],
      [[12032, 12032], "mapped", [19968]],
      [[12033, 12033], "mapped", [20008]],
      [[12034, 12034], "mapped", [20022]],
      [[12035, 12035], "mapped", [20031]],
      [[12036, 12036], "mapped", [20057]],
      [[12037, 12037], "mapped", [20101]],
      [[12038, 12038], "mapped", [20108]],
      [[12039, 12039], "mapped", [20128]],
      [[12040, 12040], "mapped", [20154]],
      [[12041, 12041], "mapped", [20799]],
      [[12042, 12042], "mapped", [20837]],
      [[12043, 12043], "mapped", [20843]],
      [[12044, 12044], "mapped", [20866]],
      [[12045, 12045], "mapped", [20886]],
      [[12046, 12046], "mapped", [20907]],
      [[12047, 12047], "mapped", [20960]],
      [[12048, 12048], "mapped", [20981]],
      [[12049, 12049], "mapped", [20992]],
      [[12050, 12050], "mapped", [21147]],
      [[12051, 12051], "mapped", [21241]],
      [[12052, 12052], "mapped", [21269]],
      [[12053, 12053], "mapped", [21274]],
      [[12054, 12054], "mapped", [21304]],
      [[12055, 12055], "mapped", [21313]],
      [[12056, 12056], "mapped", [21340]],
      [[12057, 12057], "mapped", [21353]],
      [[12058, 12058], "mapped", [21378]],
      [[12059, 12059], "mapped", [21430]],
      [[12060, 12060], "mapped", [21448]],
      [[12061, 12061], "mapped", [21475]],
      [[12062, 12062], "mapped", [22231]],
      [[12063, 12063], "mapped", [22303]],
      [[12064, 12064], "mapped", [22763]],
      [[12065, 12065], "mapped", [22786]],
      [[12066, 12066], "mapped", [22794]],
      [[12067, 12067], "mapped", [22805]],
      [[12068, 12068], "mapped", [22823]],
      [[12069, 12069], "mapped", [22899]],
      [[12070, 12070], "mapped", [23376]],
      [[12071, 12071], "mapped", [23424]],
      [[12072, 12072], "mapped", [23544]],
      [[12073, 12073], "mapped", [23567]],
      [[12074, 12074], "mapped", [23586]],
      [[12075, 12075], "mapped", [23608]],
      [[12076, 12076], "mapped", [23662]],
      [[12077, 12077], "mapped", [23665]],
      [[12078, 12078], "mapped", [24027]],
      [[12079, 12079], "mapped", [24037]],
      [[12080, 12080], "mapped", [24049]],
      [[12081, 12081], "mapped", [24062]],
      [[12082, 12082], "mapped", [24178]],
      [[12083, 12083], "mapped", [24186]],
      [[12084, 12084], "mapped", [24191]],
      [[12085, 12085], "mapped", [24308]],
      [[12086, 12086], "mapped", [24318]],
      [[12087, 12087], "mapped", [24331]],
      [[12088, 12088], "mapped", [24339]],
      [[12089, 12089], "mapped", [24400]],
      [[12090, 12090], "mapped", [24417]],
      [[12091, 12091], "mapped", [24435]],
      [[12092, 12092], "mapped", [24515]],
      [[12093, 12093], "mapped", [25096]],
      [[12094, 12094], "mapped", [25142]],
      [[12095, 12095], "mapped", [25163]],
      [[12096, 12096], "mapped", [25903]],
      [[12097, 12097], "mapped", [25908]],
      [[12098, 12098], "mapped", [25991]],
      [[12099, 12099], "mapped", [26007]],
      [[12100, 12100], "mapped", [26020]],
      [[12101, 12101], "mapped", [26041]],
      [[12102, 12102], "mapped", [26080]],
      [[12103, 12103], "mapped", [26085]],
      [[12104, 12104], "mapped", [26352]],
      [[12105, 12105], "mapped", [26376]],
      [[12106, 12106], "mapped", [26408]],
      [[12107, 12107], "mapped", [27424]],
      [[12108, 12108], "mapped", [27490]],
      [[12109, 12109], "mapped", [27513]],
      [[12110, 12110], "mapped", [27571]],
      [[12111, 12111], "mapped", [27595]],
      [[12112, 12112], "mapped", [27604]],
      [[12113, 12113], "mapped", [27611]],
      [[12114, 12114], "mapped", [27663]],
      [[12115, 12115], "mapped", [27668]],
      [[12116, 12116], "mapped", [27700]],
      [[12117, 12117], "mapped", [28779]],
      [[12118, 12118], "mapped", [29226]],
      [[12119, 12119], "mapped", [29238]],
      [[12120, 12120], "mapped", [29243]],
      [[12121, 12121], "mapped", [29247]],
      [[12122, 12122], "mapped", [29255]],
      [[12123, 12123], "mapped", [29273]],
      [[12124, 12124], "mapped", [29275]],
      [[12125, 12125], "mapped", [29356]],
      [[12126, 12126], "mapped", [29572]],
      [[12127, 12127], "mapped", [29577]],
      [[12128, 12128], "mapped", [29916]],
      [[12129, 12129], "mapped", [29926]],
      [[12130, 12130], "mapped", [29976]],
      [[12131, 12131], "mapped", [29983]],
      [[12132, 12132], "mapped", [29992]],
      [[12133, 12133], "mapped", [3e4]],
      [[12134, 12134], "mapped", [30091]],
      [[12135, 12135], "mapped", [30098]],
      [[12136, 12136], "mapped", [30326]],
      [[12137, 12137], "mapped", [30333]],
      [[12138, 12138], "mapped", [30382]],
      [[12139, 12139], "mapped", [30399]],
      [[12140, 12140], "mapped", [30446]],
      [[12141, 12141], "mapped", [30683]],
      [[12142, 12142], "mapped", [30690]],
      [[12143, 12143], "mapped", [30707]],
      [[12144, 12144], "mapped", [31034]],
      [[12145, 12145], "mapped", [31160]],
      [[12146, 12146], "mapped", [31166]],
      [[12147, 12147], "mapped", [31348]],
      [[12148, 12148], "mapped", [31435]],
      [[12149, 12149], "mapped", [31481]],
      [[12150, 12150], "mapped", [31859]],
      [[12151, 12151], "mapped", [31992]],
      [[12152, 12152], "mapped", [32566]],
      [[12153, 12153], "mapped", [32593]],
      [[12154, 12154], "mapped", [32650]],
      [[12155, 12155], "mapped", [32701]],
      [[12156, 12156], "mapped", [32769]],
      [[12157, 12157], "mapped", [32780]],
      [[12158, 12158], "mapped", [32786]],
      [[12159, 12159], "mapped", [32819]],
      [[12160, 12160], "mapped", [32895]],
      [[12161, 12161], "mapped", [32905]],
      [[12162, 12162], "mapped", [33251]],
      [[12163, 12163], "mapped", [33258]],
      [[12164, 12164], "mapped", [33267]],
      [[12165, 12165], "mapped", [33276]],
      [[12166, 12166], "mapped", [33292]],
      [[12167, 12167], "mapped", [33307]],
      [[12168, 12168], "mapped", [33311]],
      [[12169, 12169], "mapped", [33390]],
      [[12170, 12170], "mapped", [33394]],
      [[12171, 12171], "mapped", [33400]],
      [[12172, 12172], "mapped", [34381]],
      [[12173, 12173], "mapped", [34411]],
      [[12174, 12174], "mapped", [34880]],
      [[12175, 12175], "mapped", [34892]],
      [[12176, 12176], "mapped", [34915]],
      [[12177, 12177], "mapped", [35198]],
      [[12178, 12178], "mapped", [35211]],
      [[12179, 12179], "mapped", [35282]],
      [[12180, 12180], "mapped", [35328]],
      [[12181, 12181], "mapped", [35895]],
      [[12182, 12182], "mapped", [35910]],
      [[12183, 12183], "mapped", [35925]],
      [[12184, 12184], "mapped", [35960]],
      [[12185, 12185], "mapped", [35997]],
      [[12186, 12186], "mapped", [36196]],
      [[12187, 12187], "mapped", [36208]],
      [[12188, 12188], "mapped", [36275]],
      [[12189, 12189], "mapped", [36523]],
      [[12190, 12190], "mapped", [36554]],
      [[12191, 12191], "mapped", [36763]],
      [[12192, 12192], "mapped", [36784]],
      [[12193, 12193], "mapped", [36789]],
      [[12194, 12194], "mapped", [37009]],
      [[12195, 12195], "mapped", [37193]],
      [[12196, 12196], "mapped", [37318]],
      [[12197, 12197], "mapped", [37324]],
      [[12198, 12198], "mapped", [37329]],
      [[12199, 12199], "mapped", [38263]],
      [[12200, 12200], "mapped", [38272]],
      [[12201, 12201], "mapped", [38428]],
      [[12202, 12202], "mapped", [38582]],
      [[12203, 12203], "mapped", [38585]],
      [[12204, 12204], "mapped", [38632]],
      [[12205, 12205], "mapped", [38737]],
      [[12206, 12206], "mapped", [38750]],
      [[12207, 12207], "mapped", [38754]],
      [[12208, 12208], "mapped", [38761]],
      [[12209, 12209], "mapped", [38859]],
      [[12210, 12210], "mapped", [38893]],
      [[12211, 12211], "mapped", [38899]],
      [[12212, 12212], "mapped", [38913]],
      [[12213, 12213], "mapped", [39080]],
      [[12214, 12214], "mapped", [39131]],
      [[12215, 12215], "mapped", [39135]],
      [[12216, 12216], "mapped", [39318]],
      [[12217, 12217], "mapped", [39321]],
      [[12218, 12218], "mapped", [39340]],
      [[12219, 12219], "mapped", [39592]],
      [[12220, 12220], "mapped", [39640]],
      [[12221, 12221], "mapped", [39647]],
      [[12222, 12222], "mapped", [39717]],
      [[12223, 12223], "mapped", [39727]],
      [[12224, 12224], "mapped", [39730]],
      [[12225, 12225], "mapped", [39740]],
      [[12226, 12226], "mapped", [39770]],
      [[12227, 12227], "mapped", [40165]],
      [[12228, 12228], "mapped", [40565]],
      [[12229, 12229], "mapped", [40575]],
      [[12230, 12230], "mapped", [40613]],
      [[12231, 12231], "mapped", [40635]],
      [[12232, 12232], "mapped", [40643]],
      [[12233, 12233], "mapped", [40653]],
      [[12234, 12234], "mapped", [40657]],
      [[12235, 12235], "mapped", [40697]],
      [[12236, 12236], "mapped", [40701]],
      [[12237, 12237], "mapped", [40718]],
      [[12238, 12238], "mapped", [40723]],
      [[12239, 12239], "mapped", [40736]],
      [[12240, 12240], "mapped", [40763]],
      [[12241, 12241], "mapped", [40778]],
      [[12242, 12242], "mapped", [40786]],
      [[12243, 12243], "mapped", [40845]],
      [[12244, 12244], "mapped", [40860]],
      [[12245, 12245], "mapped", [40864]],
      [[12246, 12271], "disallowed"],
      [[12272, 12283], "disallowed"],
      [[12284, 12287], "disallowed"],
      [[12288, 12288], "disallowed_STD3_mapped", [32]],
      [[12289, 12289], "valid", [], "NV8"],
      [[12290, 12290], "mapped", [46]],
      [[12291, 12292], "valid", [], "NV8"],
      [[12293, 12295], "valid"],
      [[12296, 12329], "valid", [], "NV8"],
      [[12330, 12333], "valid"],
      [[12334, 12341], "valid", [], "NV8"],
      [[12342, 12342], "mapped", [12306]],
      [[12343, 12343], "valid", [], "NV8"],
      [[12344, 12344], "mapped", [21313]],
      [[12345, 12345], "mapped", [21316]],
      [[12346, 12346], "mapped", [21317]],
      [[12347, 12347], "valid", [], "NV8"],
      [[12348, 12348], "valid"],
      [[12349, 12349], "valid", [], "NV8"],
      [[12350, 12350], "valid", [], "NV8"],
      [[12351, 12351], "valid", [], "NV8"],
      [[12352, 12352], "disallowed"],
      [[12353, 12436], "valid"],
      [[12437, 12438], "valid"],
      [[12439, 12440], "disallowed"],
      [[12441, 12442], "valid"],
      [[12443, 12443], "disallowed_STD3_mapped", [32, 12441]],
      [[12444, 12444], "disallowed_STD3_mapped", [32, 12442]],
      [[12445, 12446], "valid"],
      [[12447, 12447], "mapped", [12424, 12426]],
      [[12448, 12448], "valid", [], "NV8"],
      [[12449, 12542], "valid"],
      [[12543, 12543], "mapped", [12467, 12488]],
      [[12544, 12548], "disallowed"],
      [[12549, 12588], "valid"],
      [[12589, 12589], "valid"],
      [[12590, 12592], "disallowed"],
      [[12593, 12593], "mapped", [4352]],
      [[12594, 12594], "mapped", [4353]],
      [[12595, 12595], "mapped", [4522]],
      [[12596, 12596], "mapped", [4354]],
      [[12597, 12597], "mapped", [4524]],
      [[12598, 12598], "mapped", [4525]],
      [[12599, 12599], "mapped", [4355]],
      [[12600, 12600], "mapped", [4356]],
      [[12601, 12601], "mapped", [4357]],
      [[12602, 12602], "mapped", [4528]],
      [[12603, 12603], "mapped", [4529]],
      [[12604, 12604], "mapped", [4530]],
      [[12605, 12605], "mapped", [4531]],
      [[12606, 12606], "mapped", [4532]],
      [[12607, 12607], "mapped", [4533]],
      [[12608, 12608], "mapped", [4378]],
      [[12609, 12609], "mapped", [4358]],
      [[12610, 12610], "mapped", [4359]],
      [[12611, 12611], "mapped", [4360]],
      [[12612, 12612], "mapped", [4385]],
      [[12613, 12613], "mapped", [4361]],
      [[12614, 12614], "mapped", [4362]],
      [[12615, 12615], "mapped", [4363]],
      [[12616, 12616], "mapped", [4364]],
      [[12617, 12617], "mapped", [4365]],
      [[12618, 12618], "mapped", [4366]],
      [[12619, 12619], "mapped", [4367]],
      [[12620, 12620], "mapped", [4368]],
      [[12621, 12621], "mapped", [4369]],
      [[12622, 12622], "mapped", [4370]],
      [[12623, 12623], "mapped", [4449]],
      [[12624, 12624], "mapped", [4450]],
      [[12625, 12625], "mapped", [4451]],
      [[12626, 12626], "mapped", [4452]],
      [[12627, 12627], "mapped", [4453]],
      [[12628, 12628], "mapped", [4454]],
      [[12629, 12629], "mapped", [4455]],
      [[12630, 12630], "mapped", [4456]],
      [[12631, 12631], "mapped", [4457]],
      [[12632, 12632], "mapped", [4458]],
      [[12633, 12633], "mapped", [4459]],
      [[12634, 12634], "mapped", [4460]],
      [[12635, 12635], "mapped", [4461]],
      [[12636, 12636], "mapped", [4462]],
      [[12637, 12637], "mapped", [4463]],
      [[12638, 12638], "mapped", [4464]],
      [[12639, 12639], "mapped", [4465]],
      [[12640, 12640], "mapped", [4466]],
      [[12641, 12641], "mapped", [4467]],
      [[12642, 12642], "mapped", [4468]],
      [[12643, 12643], "mapped", [4469]],
      [[12644, 12644], "disallowed"],
      [[12645, 12645], "mapped", [4372]],
      [[12646, 12646], "mapped", [4373]],
      [[12647, 12647], "mapped", [4551]],
      [[12648, 12648], "mapped", [4552]],
      [[12649, 12649], "mapped", [4556]],
      [[12650, 12650], "mapped", [4558]],
      [[12651, 12651], "mapped", [4563]],
      [[12652, 12652], "mapped", [4567]],
      [[12653, 12653], "mapped", [4569]],
      [[12654, 12654], "mapped", [4380]],
      [[12655, 12655], "mapped", [4573]],
      [[12656, 12656], "mapped", [4575]],
      [[12657, 12657], "mapped", [4381]],
      [[12658, 12658], "mapped", [4382]],
      [[12659, 12659], "mapped", [4384]],
      [[12660, 12660], "mapped", [4386]],
      [[12661, 12661], "mapped", [4387]],
      [[12662, 12662], "mapped", [4391]],
      [[12663, 12663], "mapped", [4393]],
      [[12664, 12664], "mapped", [4395]],
      [[12665, 12665], "mapped", [4396]],
      [[12666, 12666], "mapped", [4397]],
      [[12667, 12667], "mapped", [4398]],
      [[12668, 12668], "mapped", [4399]],
      [[12669, 12669], "mapped", [4402]],
      [[12670, 12670], "mapped", [4406]],
      [[12671, 12671], "mapped", [4416]],
      [[12672, 12672], "mapped", [4423]],
      [[12673, 12673], "mapped", [4428]],
      [[12674, 12674], "mapped", [4593]],
      [[12675, 12675], "mapped", [4594]],
      [[12676, 12676], "mapped", [4439]],
      [[12677, 12677], "mapped", [4440]],
      [[12678, 12678], "mapped", [4441]],
      [[12679, 12679], "mapped", [4484]],
      [[12680, 12680], "mapped", [4485]],
      [[12681, 12681], "mapped", [4488]],
      [[12682, 12682], "mapped", [4497]],
      [[12683, 12683], "mapped", [4498]],
      [[12684, 12684], "mapped", [4500]],
      [[12685, 12685], "mapped", [4510]],
      [[12686, 12686], "mapped", [4513]],
      [[12687, 12687], "disallowed"],
      [[12688, 12689], "valid", [], "NV8"],
      [[12690, 12690], "mapped", [19968]],
      [[12691, 12691], "mapped", [20108]],
      [[12692, 12692], "mapped", [19977]],
      [[12693, 12693], "mapped", [22235]],
      [[12694, 12694], "mapped", [19978]],
      [[12695, 12695], "mapped", [20013]],
      [[12696, 12696], "mapped", [19979]],
      [[12697, 12697], "mapped", [30002]],
      [[12698, 12698], "mapped", [20057]],
      [[12699, 12699], "mapped", [19993]],
      [[12700, 12700], "mapped", [19969]],
      [[12701, 12701], "mapped", [22825]],
      [[12702, 12702], "mapped", [22320]],
      [[12703, 12703], "mapped", [20154]],
      [[12704, 12727], "valid"],
      [[12728, 12730], "valid"],
      [[12731, 12735], "disallowed"],
      [[12736, 12751], "valid", [], "NV8"],
      [[12752, 12771], "valid", [], "NV8"],
      [[12772, 12783], "disallowed"],
      [[12784, 12799], "valid"],
      [[12800, 12800], "disallowed_STD3_mapped", [40, 4352, 41]],
      [[12801, 12801], "disallowed_STD3_mapped", [40, 4354, 41]],
      [[12802, 12802], "disallowed_STD3_mapped", [40, 4355, 41]],
      [[12803, 12803], "disallowed_STD3_mapped", [40, 4357, 41]],
      [[12804, 12804], "disallowed_STD3_mapped", [40, 4358, 41]],
      [[12805, 12805], "disallowed_STD3_mapped", [40, 4359, 41]],
      [[12806, 12806], "disallowed_STD3_mapped", [40, 4361, 41]],
      [[12807, 12807], "disallowed_STD3_mapped", [40, 4363, 41]],
      [[12808, 12808], "disallowed_STD3_mapped", [40, 4364, 41]],
      [[12809, 12809], "disallowed_STD3_mapped", [40, 4366, 41]],
      [[12810, 12810], "disallowed_STD3_mapped", [40, 4367, 41]],
      [[12811, 12811], "disallowed_STD3_mapped", [40, 4368, 41]],
      [[12812, 12812], "disallowed_STD3_mapped", [40, 4369, 41]],
      [[12813, 12813], "disallowed_STD3_mapped", [40, 4370, 41]],
      [[12814, 12814], "disallowed_STD3_mapped", [40, 44032, 41]],
      [[12815, 12815], "disallowed_STD3_mapped", [40, 45208, 41]],
      [[12816, 12816], "disallowed_STD3_mapped", [40, 45796, 41]],
      [[12817, 12817], "disallowed_STD3_mapped", [40, 46972, 41]],
      [[12818, 12818], "disallowed_STD3_mapped", [40, 47560, 41]],
      [[12819, 12819], "disallowed_STD3_mapped", [40, 48148, 41]],
      [[12820, 12820], "disallowed_STD3_mapped", [40, 49324, 41]],
      [[12821, 12821], "disallowed_STD3_mapped", [40, 50500, 41]],
      [[12822, 12822], "disallowed_STD3_mapped", [40, 51088, 41]],
      [[12823, 12823], "disallowed_STD3_mapped", [40, 52264, 41]],
      [[12824, 12824], "disallowed_STD3_mapped", [40, 52852, 41]],
      [[12825, 12825], "disallowed_STD3_mapped", [40, 53440, 41]],
      [[12826, 12826], "disallowed_STD3_mapped", [40, 54028, 41]],
      [[12827, 12827], "disallowed_STD3_mapped", [40, 54616, 41]],
      [[12828, 12828], "disallowed_STD3_mapped", [40, 51452, 41]],
      [[12829, 12829], "disallowed_STD3_mapped", [40, 50724, 51204, 41]],
      [[12830, 12830], "disallowed_STD3_mapped", [40, 50724, 54980, 41]],
      [[12831, 12831], "disallowed"],
      [[12832, 12832], "disallowed_STD3_mapped", [40, 19968, 41]],
      [[12833, 12833], "disallowed_STD3_mapped", [40, 20108, 41]],
      [[12834, 12834], "disallowed_STD3_mapped", [40, 19977, 41]],
      [[12835, 12835], "disallowed_STD3_mapped", [40, 22235, 41]],
      [[12836, 12836], "disallowed_STD3_mapped", [40, 20116, 41]],
      [[12837, 12837], "disallowed_STD3_mapped", [40, 20845, 41]],
      [[12838, 12838], "disallowed_STD3_mapped", [40, 19971, 41]],
      [[12839, 12839], "disallowed_STD3_mapped", [40, 20843, 41]],
      [[12840, 12840], "disallowed_STD3_mapped", [40, 20061, 41]],
      [[12841, 12841], "disallowed_STD3_mapped", [40, 21313, 41]],
      [[12842, 12842], "disallowed_STD3_mapped", [40, 26376, 41]],
      [[12843, 12843], "disallowed_STD3_mapped", [40, 28779, 41]],
      [[12844, 12844], "disallowed_STD3_mapped", [40, 27700, 41]],
      [[12845, 12845], "disallowed_STD3_mapped", [40, 26408, 41]],
      [[12846, 12846], "disallowed_STD3_mapped", [40, 37329, 41]],
      [[12847, 12847], "disallowed_STD3_mapped", [40, 22303, 41]],
      [[12848, 12848], "disallowed_STD3_mapped", [40, 26085, 41]],
      [[12849, 12849], "disallowed_STD3_mapped", [40, 26666, 41]],
      [[12850, 12850], "disallowed_STD3_mapped", [40, 26377, 41]],
      [[12851, 12851], "disallowed_STD3_mapped", [40, 31038, 41]],
      [[12852, 12852], "disallowed_STD3_mapped", [40, 21517, 41]],
      [[12853, 12853], "disallowed_STD3_mapped", [40, 29305, 41]],
      [[12854, 12854], "disallowed_STD3_mapped", [40, 36001, 41]],
      [[12855, 12855], "disallowed_STD3_mapped", [40, 31069, 41]],
      [[12856, 12856], "disallowed_STD3_mapped", [40, 21172, 41]],
      [[12857, 12857], "disallowed_STD3_mapped", [40, 20195, 41]],
      [[12858, 12858], "disallowed_STD3_mapped", [40, 21628, 41]],
      [[12859, 12859], "disallowed_STD3_mapped", [40, 23398, 41]],
      [[12860, 12860], "disallowed_STD3_mapped", [40, 30435, 41]],
      [[12861, 12861], "disallowed_STD3_mapped", [40, 20225, 41]],
      [[12862, 12862], "disallowed_STD3_mapped", [40, 36039, 41]],
      [[12863, 12863], "disallowed_STD3_mapped", [40, 21332, 41]],
      [[12864, 12864], "disallowed_STD3_mapped", [40, 31085, 41]],
      [[12865, 12865], "disallowed_STD3_mapped", [40, 20241, 41]],
      [[12866, 12866], "disallowed_STD3_mapped", [40, 33258, 41]],
      [[12867, 12867], "disallowed_STD3_mapped", [40, 33267, 41]],
      [[12868, 12868], "mapped", [21839]],
      [[12869, 12869], "mapped", [24188]],
      [[12870, 12870], "mapped", [25991]],
      [[12871, 12871], "mapped", [31631]],
      [[12872, 12879], "valid", [], "NV8"],
      [[12880, 12880], "mapped", [112, 116, 101]],
      [[12881, 12881], "mapped", [50, 49]],
      [[12882, 12882], "mapped", [50, 50]],
      [[12883, 12883], "mapped", [50, 51]],
      [[12884, 12884], "mapped", [50, 52]],
      [[12885, 12885], "mapped", [50, 53]],
      [[12886, 12886], "mapped", [50, 54]],
      [[12887, 12887], "mapped", [50, 55]],
      [[12888, 12888], "mapped", [50, 56]],
      [[12889, 12889], "mapped", [50, 57]],
      [[12890, 12890], "mapped", [51, 48]],
      [[12891, 12891], "mapped", [51, 49]],
      [[12892, 12892], "mapped", [51, 50]],
      [[12893, 12893], "mapped", [51, 51]],
      [[12894, 12894], "mapped", [51, 52]],
      [[12895, 12895], "mapped", [51, 53]],
      [[12896, 12896], "mapped", [4352]],
      [[12897, 12897], "mapped", [4354]],
      [[12898, 12898], "mapped", [4355]],
      [[12899, 12899], "mapped", [4357]],
      [[12900, 12900], "mapped", [4358]],
      [[12901, 12901], "mapped", [4359]],
      [[12902, 12902], "mapped", [4361]],
      [[12903, 12903], "mapped", [4363]],
      [[12904, 12904], "mapped", [4364]],
      [[12905, 12905], "mapped", [4366]],
      [[12906, 12906], "mapped", [4367]],
      [[12907, 12907], "mapped", [4368]],
      [[12908, 12908], "mapped", [4369]],
      [[12909, 12909], "mapped", [4370]],
      [[12910, 12910], "mapped", [44032]],
      [[12911, 12911], "mapped", [45208]],
      [[12912, 12912], "mapped", [45796]],
      [[12913, 12913], "mapped", [46972]],
      [[12914, 12914], "mapped", [47560]],
      [[12915, 12915], "mapped", [48148]],
      [[12916, 12916], "mapped", [49324]],
      [[12917, 12917], "mapped", [50500]],
      [[12918, 12918], "mapped", [51088]],
      [[12919, 12919], "mapped", [52264]],
      [[12920, 12920], "mapped", [52852]],
      [[12921, 12921], "mapped", [53440]],
      [[12922, 12922], "mapped", [54028]],
      [[12923, 12923], "mapped", [54616]],
      [[12924, 12924], "mapped", [52280, 44256]],
      [[12925, 12925], "mapped", [51452, 51032]],
      [[12926, 12926], "mapped", [50864]],
      [[12927, 12927], "valid", [], "NV8"],
      [[12928, 12928], "mapped", [19968]],
      [[12929, 12929], "mapped", [20108]],
      [[12930, 12930], "mapped", [19977]],
      [[12931, 12931], "mapped", [22235]],
      [[12932, 12932], "mapped", [20116]],
      [[12933, 12933], "mapped", [20845]],
      [[12934, 12934], "mapped", [19971]],
      [[12935, 12935], "mapped", [20843]],
      [[12936, 12936], "mapped", [20061]],
      [[12937, 12937], "mapped", [21313]],
      [[12938, 12938], "mapped", [26376]],
      [[12939, 12939], "mapped", [28779]],
      [[12940, 12940], "mapped", [27700]],
      [[12941, 12941], "mapped", [26408]],
      [[12942, 12942], "mapped", [37329]],
      [[12943, 12943], "mapped", [22303]],
      [[12944, 12944], "mapped", [26085]],
      [[12945, 12945], "mapped", [26666]],
      [[12946, 12946], "mapped", [26377]],
      [[12947, 12947], "mapped", [31038]],
      [[12948, 12948], "mapped", [21517]],
      [[12949, 12949], "mapped", [29305]],
      [[12950, 12950], "mapped", [36001]],
      [[12951, 12951], "mapped", [31069]],
      [[12952, 12952], "mapped", [21172]],
      [[12953, 12953], "mapped", [31192]],
      [[12954, 12954], "mapped", [30007]],
      [[12955, 12955], "mapped", [22899]],
      [[12956, 12956], "mapped", [36969]],
      [[12957, 12957], "mapped", [20778]],
      [[12958, 12958], "mapped", [21360]],
      [[12959, 12959], "mapped", [27880]],
      [[12960, 12960], "mapped", [38917]],
      [[12961, 12961], "mapped", [20241]],
      [[12962, 12962], "mapped", [20889]],
      [[12963, 12963], "mapped", [27491]],
      [[12964, 12964], "mapped", [19978]],
      [[12965, 12965], "mapped", [20013]],
      [[12966, 12966], "mapped", [19979]],
      [[12967, 12967], "mapped", [24038]],
      [[12968, 12968], "mapped", [21491]],
      [[12969, 12969], "mapped", [21307]],
      [[12970, 12970], "mapped", [23447]],
      [[12971, 12971], "mapped", [23398]],
      [[12972, 12972], "mapped", [30435]],
      [[12973, 12973], "mapped", [20225]],
      [[12974, 12974], "mapped", [36039]],
      [[12975, 12975], "mapped", [21332]],
      [[12976, 12976], "mapped", [22812]],
      [[12977, 12977], "mapped", [51, 54]],
      [[12978, 12978], "mapped", [51, 55]],
      [[12979, 12979], "mapped", [51, 56]],
      [[12980, 12980], "mapped", [51, 57]],
      [[12981, 12981], "mapped", [52, 48]],
      [[12982, 12982], "mapped", [52, 49]],
      [[12983, 12983], "mapped", [52, 50]],
      [[12984, 12984], "mapped", [52, 51]],
      [[12985, 12985], "mapped", [52, 52]],
      [[12986, 12986], "mapped", [52, 53]],
      [[12987, 12987], "mapped", [52, 54]],
      [[12988, 12988], "mapped", [52, 55]],
      [[12989, 12989], "mapped", [52, 56]],
      [[12990, 12990], "mapped", [52, 57]],
      [[12991, 12991], "mapped", [53, 48]],
      [[12992, 12992], "mapped", [49, 26376]],
      [[12993, 12993], "mapped", [50, 26376]],
      [[12994, 12994], "mapped", [51, 26376]],
      [[12995, 12995], "mapped", [52, 26376]],
      [[12996, 12996], "mapped", [53, 26376]],
      [[12997, 12997], "mapped", [54, 26376]],
      [[12998, 12998], "mapped", [55, 26376]],
      [[12999, 12999], "mapped", [56, 26376]],
      [[13e3, 13e3], "mapped", [57, 26376]],
      [[13001, 13001], "mapped", [49, 48, 26376]],
      [[13002, 13002], "mapped", [49, 49, 26376]],
      [[13003, 13003], "mapped", [49, 50, 26376]],
      [[13004, 13004], "mapped", [104, 103]],
      [[13005, 13005], "mapped", [101, 114, 103]],
      [[13006, 13006], "mapped", [101, 118]],
      [[13007, 13007], "mapped", [108, 116, 100]],
      [[13008, 13008], "mapped", [12450]],
      [[13009, 13009], "mapped", [12452]],
      [[13010, 13010], "mapped", [12454]],
      [[13011, 13011], "mapped", [12456]],
      [[13012, 13012], "mapped", [12458]],
      [[13013, 13013], "mapped", [12459]],
      [[13014, 13014], "mapped", [12461]],
      [[13015, 13015], "mapped", [12463]],
      [[13016, 13016], "mapped", [12465]],
      [[13017, 13017], "mapped", [12467]],
      [[13018, 13018], "mapped", [12469]],
      [[13019, 13019], "mapped", [12471]],
      [[13020, 13020], "mapped", [12473]],
      [[13021, 13021], "mapped", [12475]],
      [[13022, 13022], "mapped", [12477]],
      [[13023, 13023], "mapped", [12479]],
      [[13024, 13024], "mapped", [12481]],
      [[13025, 13025], "mapped", [12484]],
      [[13026, 13026], "mapped", [12486]],
      [[13027, 13027], "mapped", [12488]],
      [[13028, 13028], "mapped", [12490]],
      [[13029, 13029], "mapped", [12491]],
      [[13030, 13030], "mapped", [12492]],
      [[13031, 13031], "mapped", [12493]],
      [[13032, 13032], "mapped", [12494]],
      [[13033, 13033], "mapped", [12495]],
      [[13034, 13034], "mapped", [12498]],
      [[13035, 13035], "mapped", [12501]],
      [[13036, 13036], "mapped", [12504]],
      [[13037, 13037], "mapped", [12507]],
      [[13038, 13038], "mapped", [12510]],
      [[13039, 13039], "mapped", [12511]],
      [[13040, 13040], "mapped", [12512]],
      [[13041, 13041], "mapped", [12513]],
      [[13042, 13042], "mapped", [12514]],
      [[13043, 13043], "mapped", [12516]],
      [[13044, 13044], "mapped", [12518]],
      [[13045, 13045], "mapped", [12520]],
      [[13046, 13046], "mapped", [12521]],
      [[13047, 13047], "mapped", [12522]],
      [[13048, 13048], "mapped", [12523]],
      [[13049, 13049], "mapped", [12524]],
      [[13050, 13050], "mapped", [12525]],
      [[13051, 13051], "mapped", [12527]],
      [[13052, 13052], "mapped", [12528]],
      [[13053, 13053], "mapped", [12529]],
      [[13054, 13054], "mapped", [12530]],
      [[13055, 13055], "disallowed"],
      [[13056, 13056], "mapped", [12450, 12497, 12540, 12488]],
      [[13057, 13057], "mapped", [12450, 12523, 12501, 12449]],
      [[13058, 13058], "mapped", [12450, 12531, 12506, 12450]],
      [[13059, 13059], "mapped", [12450, 12540, 12523]],
      [[13060, 13060], "mapped", [12452, 12491, 12531, 12464]],
      [[13061, 13061], "mapped", [12452, 12531, 12481]],
      [[13062, 13062], "mapped", [12454, 12457, 12531]],
      [[13063, 13063], "mapped", [12456, 12473, 12463, 12540, 12489]],
      [[13064, 13064], "mapped", [12456, 12540, 12459, 12540]],
      [[13065, 13065], "mapped", [12458, 12531, 12473]],
      [[13066, 13066], "mapped", [12458, 12540, 12512]],
      [[13067, 13067], "mapped", [12459, 12452, 12522]],
      [[13068, 13068], "mapped", [12459, 12521, 12483, 12488]],
      [[13069, 13069], "mapped", [12459, 12525, 12522, 12540]],
      [[13070, 13070], "mapped", [12460, 12525, 12531]],
      [[13071, 13071], "mapped", [12460, 12531, 12510]],
      [[13072, 13072], "mapped", [12462, 12460]],
      [[13073, 13073], "mapped", [12462, 12491, 12540]],
      [[13074, 13074], "mapped", [12461, 12517, 12522, 12540]],
      [[13075, 13075], "mapped", [12462, 12523, 12480, 12540]],
      [[13076, 13076], "mapped", [12461, 12525]],
      [[13077, 13077], "mapped", [12461, 12525, 12464, 12521, 12512]],
      [[13078, 13078], "mapped", [12461, 12525, 12513, 12540, 12488, 12523]],
      [[13079, 13079], "mapped", [12461, 12525, 12527, 12483, 12488]],
      [[13080, 13080], "mapped", [12464, 12521, 12512]],
      [[13081, 13081], "mapped", [12464, 12521, 12512, 12488, 12531]],
      [[13082, 13082], "mapped", [12463, 12523, 12476, 12452, 12525]],
      [[13083, 13083], "mapped", [12463, 12525, 12540, 12493]],
      [[13084, 13084], "mapped", [12465, 12540, 12473]],
      [[13085, 13085], "mapped", [12467, 12523, 12490]],
      [[13086, 13086], "mapped", [12467, 12540, 12509]],
      [[13087, 13087], "mapped", [12469, 12452, 12463, 12523]],
      [[13088, 13088], "mapped", [12469, 12531, 12481, 12540, 12512]],
      [[13089, 13089], "mapped", [12471, 12522, 12531, 12464]],
      [[13090, 13090], "mapped", [12475, 12531, 12481]],
      [[13091, 13091], "mapped", [12475, 12531, 12488]],
      [[13092, 13092], "mapped", [12480, 12540, 12473]],
      [[13093, 13093], "mapped", [12487, 12471]],
      [[13094, 13094], "mapped", [12489, 12523]],
      [[13095, 13095], "mapped", [12488, 12531]],
      [[13096, 13096], "mapped", [12490, 12494]],
      [[13097, 13097], "mapped", [12494, 12483, 12488]],
      [[13098, 13098], "mapped", [12495, 12452, 12484]],
      [[13099, 13099], "mapped", [12497, 12540, 12475, 12531, 12488]],
      [[13100, 13100], "mapped", [12497, 12540, 12484]],
      [[13101, 13101], "mapped", [12496, 12540, 12524, 12523]],
      [[13102, 13102], "mapped", [12500, 12450, 12473, 12488, 12523]],
      [[13103, 13103], "mapped", [12500, 12463, 12523]],
      [[13104, 13104], "mapped", [12500, 12467]],
      [[13105, 13105], "mapped", [12499, 12523]],
      [[13106, 13106], "mapped", [12501, 12449, 12521, 12483, 12489]],
      [[13107, 13107], "mapped", [12501, 12451, 12540, 12488]],
      [[13108, 13108], "mapped", [12502, 12483, 12471, 12455, 12523]],
      [[13109, 13109], "mapped", [12501, 12521, 12531]],
      [[13110, 13110], "mapped", [12504, 12463, 12479, 12540, 12523]],
      [[13111, 13111], "mapped", [12506, 12477]],
      [[13112, 13112], "mapped", [12506, 12491, 12498]],
      [[13113, 13113], "mapped", [12504, 12523, 12484]],
      [[13114, 13114], "mapped", [12506, 12531, 12473]],
      [[13115, 13115], "mapped", [12506, 12540, 12472]],
      [[13116, 13116], "mapped", [12505, 12540, 12479]],
      [[13117, 13117], "mapped", [12509, 12452, 12531, 12488]],
      [[13118, 13118], "mapped", [12508, 12523, 12488]],
      [[13119, 13119], "mapped", [12507, 12531]],
      [[13120, 13120], "mapped", [12509, 12531, 12489]],
      [[13121, 13121], "mapped", [12507, 12540, 12523]],
      [[13122, 13122], "mapped", [12507, 12540, 12531]],
      [[13123, 13123], "mapped", [12510, 12452, 12463, 12525]],
      [[13124, 13124], "mapped", [12510, 12452, 12523]],
      [[13125, 13125], "mapped", [12510, 12483, 12495]],
      [[13126, 13126], "mapped", [12510, 12523, 12463]],
      [[13127, 13127], "mapped", [12510, 12531, 12471, 12519, 12531]],
      [[13128, 13128], "mapped", [12511, 12463, 12525, 12531]],
      [[13129, 13129], "mapped", [12511, 12522]],
      [[13130, 13130], "mapped", [12511, 12522, 12496, 12540, 12523]],
      [[13131, 13131], "mapped", [12513, 12460]],
      [[13132, 13132], "mapped", [12513, 12460, 12488, 12531]],
      [[13133, 13133], "mapped", [12513, 12540, 12488, 12523]],
      [[13134, 13134], "mapped", [12516, 12540, 12489]],
      [[13135, 13135], "mapped", [12516, 12540, 12523]],
      [[13136, 13136], "mapped", [12518, 12450, 12531]],
      [[13137, 13137], "mapped", [12522, 12483, 12488, 12523]],
      [[13138, 13138], "mapped", [12522, 12521]],
      [[13139, 13139], "mapped", [12523, 12500, 12540]],
      [[13140, 13140], "mapped", [12523, 12540, 12502, 12523]],
      [[13141, 13141], "mapped", [12524, 12512]],
      [[13142, 13142], "mapped", [12524, 12531, 12488, 12466, 12531]],
      [[13143, 13143], "mapped", [12527, 12483, 12488]],
      [[13144, 13144], "mapped", [48, 28857]],
      [[13145, 13145], "mapped", [49, 28857]],
      [[13146, 13146], "mapped", [50, 28857]],
      [[13147, 13147], "mapped", [51, 28857]],
      [[13148, 13148], "mapped", [52, 28857]],
      [[13149, 13149], "mapped", [53, 28857]],
      [[13150, 13150], "mapped", [54, 28857]],
      [[13151, 13151], "mapped", [55, 28857]],
      [[13152, 13152], "mapped", [56, 28857]],
      [[13153, 13153], "mapped", [57, 28857]],
      [[13154, 13154], "mapped", [49, 48, 28857]],
      [[13155, 13155], "mapped", [49, 49, 28857]],
      [[13156, 13156], "mapped", [49, 50, 28857]],
      [[13157, 13157], "mapped", [49, 51, 28857]],
      [[13158, 13158], "mapped", [49, 52, 28857]],
      [[13159, 13159], "mapped", [49, 53, 28857]],
      [[13160, 13160], "mapped", [49, 54, 28857]],
      [[13161, 13161], "mapped", [49, 55, 28857]],
      [[13162, 13162], "mapped", [49, 56, 28857]],
      [[13163, 13163], "mapped", [49, 57, 28857]],
      [[13164, 13164], "mapped", [50, 48, 28857]],
      [[13165, 13165], "mapped", [50, 49, 28857]],
      [[13166, 13166], "mapped", [50, 50, 28857]],
      [[13167, 13167], "mapped", [50, 51, 28857]],
      [[13168, 13168], "mapped", [50, 52, 28857]],
      [[13169, 13169], "mapped", [104, 112, 97]],
      [[13170, 13170], "mapped", [100, 97]],
      [[13171, 13171], "mapped", [97, 117]],
      [[13172, 13172], "mapped", [98, 97, 114]],
      [[13173, 13173], "mapped", [111, 118]],
      [[13174, 13174], "mapped", [112, 99]],
      [[13175, 13175], "mapped", [100, 109]],
      [[13176, 13176], "mapped", [100, 109, 50]],
      [[13177, 13177], "mapped", [100, 109, 51]],
      [[13178, 13178], "mapped", [105, 117]],
      [[13179, 13179], "mapped", [24179, 25104]],
      [[13180, 13180], "mapped", [26157, 21644]],
      [[13181, 13181], "mapped", [22823, 27491]],
      [[13182, 13182], "mapped", [26126, 27835]],
      [[13183, 13183], "mapped", [26666, 24335, 20250, 31038]],
      [[13184, 13184], "mapped", [112, 97]],
      [[13185, 13185], "mapped", [110, 97]],
      [[13186, 13186], "mapped", [956, 97]],
      [[13187, 13187], "mapped", [109, 97]],
      [[13188, 13188], "mapped", [107, 97]],
      [[13189, 13189], "mapped", [107, 98]],
      [[13190, 13190], "mapped", [109, 98]],
      [[13191, 13191], "mapped", [103, 98]],
      [[13192, 13192], "mapped", [99, 97, 108]],
      [[13193, 13193], "mapped", [107, 99, 97, 108]],
      [[13194, 13194], "mapped", [112, 102]],
      [[13195, 13195], "mapped", [110, 102]],
      [[13196, 13196], "mapped", [956, 102]],
      [[13197, 13197], "mapped", [956, 103]],
      [[13198, 13198], "mapped", [109, 103]],
      [[13199, 13199], "mapped", [107, 103]],
      [[13200, 13200], "mapped", [104, 122]],
      [[13201, 13201], "mapped", [107, 104, 122]],
      [[13202, 13202], "mapped", [109, 104, 122]],
      [[13203, 13203], "mapped", [103, 104, 122]],
      [[13204, 13204], "mapped", [116, 104, 122]],
      [[13205, 13205], "mapped", [956, 108]],
      [[13206, 13206], "mapped", [109, 108]],
      [[13207, 13207], "mapped", [100, 108]],
      [[13208, 13208], "mapped", [107, 108]],
      [[13209, 13209], "mapped", [102, 109]],
      [[13210, 13210], "mapped", [110, 109]],
      [[13211, 13211], "mapped", [956, 109]],
      [[13212, 13212], "mapped", [109, 109]],
      [[13213, 13213], "mapped", [99, 109]],
      [[13214, 13214], "mapped", [107, 109]],
      [[13215, 13215], "mapped", [109, 109, 50]],
      [[13216, 13216], "mapped", [99, 109, 50]],
      [[13217, 13217], "mapped", [109, 50]],
      [[13218, 13218], "mapped", [107, 109, 50]],
      [[13219, 13219], "mapped", [109, 109, 51]],
      [[13220, 13220], "mapped", [99, 109, 51]],
      [[13221, 13221], "mapped", [109, 51]],
      [[13222, 13222], "mapped", [107, 109, 51]],
      [[13223, 13223], "mapped", [109, 8725, 115]],
      [[13224, 13224], "mapped", [109, 8725, 115, 50]],
      [[13225, 13225], "mapped", [112, 97]],
      [[13226, 13226], "mapped", [107, 112, 97]],
      [[13227, 13227], "mapped", [109, 112, 97]],
      [[13228, 13228], "mapped", [103, 112, 97]],
      [[13229, 13229], "mapped", [114, 97, 100]],
      [[13230, 13230], "mapped", [114, 97, 100, 8725, 115]],
      [[13231, 13231], "mapped", [114, 97, 100, 8725, 115, 50]],
      [[13232, 13232], "mapped", [112, 115]],
      [[13233, 13233], "mapped", [110, 115]],
      [[13234, 13234], "mapped", [956, 115]],
      [[13235, 13235], "mapped", [109, 115]],
      [[13236, 13236], "mapped", [112, 118]],
      [[13237, 13237], "mapped", [110, 118]],
      [[13238, 13238], "mapped", [956, 118]],
      [[13239, 13239], "mapped", [109, 118]],
      [[13240, 13240], "mapped", [107, 118]],
      [[13241, 13241], "mapped", [109, 118]],
      [[13242, 13242], "mapped", [112, 119]],
      [[13243, 13243], "mapped", [110, 119]],
      [[13244, 13244], "mapped", [956, 119]],
      [[13245, 13245], "mapped", [109, 119]],
      [[13246, 13246], "mapped", [107, 119]],
      [[13247, 13247], "mapped", [109, 119]],
      [[13248, 13248], "mapped", [107, 969]],
      [[13249, 13249], "mapped", [109, 969]],
      [[13250, 13250], "disallowed"],
      [[13251, 13251], "mapped", [98, 113]],
      [[13252, 13252], "mapped", [99, 99]],
      [[13253, 13253], "mapped", [99, 100]],
      [[13254, 13254], "mapped", [99, 8725, 107, 103]],
      [[13255, 13255], "disallowed"],
      [[13256, 13256], "mapped", [100, 98]],
      [[13257, 13257], "mapped", [103, 121]],
      [[13258, 13258], "mapped", [104, 97]],
      [[13259, 13259], "mapped", [104, 112]],
      [[13260, 13260], "mapped", [105, 110]],
      [[13261, 13261], "mapped", [107, 107]],
      [[13262, 13262], "mapped", [107, 109]],
      [[13263, 13263], "mapped", [107, 116]],
      [[13264, 13264], "mapped", [108, 109]],
      [[13265, 13265], "mapped", [108, 110]],
      [[13266, 13266], "mapped", [108, 111, 103]],
      [[13267, 13267], "mapped", [108, 120]],
      [[13268, 13268], "mapped", [109, 98]],
      [[13269, 13269], "mapped", [109, 105, 108]],
      [[13270, 13270], "mapped", [109, 111, 108]],
      [[13271, 13271], "mapped", [112, 104]],
      [[13272, 13272], "disallowed"],
      [[13273, 13273], "mapped", [112, 112, 109]],
      [[13274, 13274], "mapped", [112, 114]],
      [[13275, 13275], "mapped", [115, 114]],
      [[13276, 13276], "mapped", [115, 118]],
      [[13277, 13277], "mapped", [119, 98]],
      [[13278, 13278], "mapped", [118, 8725, 109]],
      [[13279, 13279], "mapped", [97, 8725, 109]],
      [[13280, 13280], "mapped", [49, 26085]],
      [[13281, 13281], "mapped", [50, 26085]],
      [[13282, 13282], "mapped", [51, 26085]],
      [[13283, 13283], "mapped", [52, 26085]],
      [[13284, 13284], "mapped", [53, 26085]],
      [[13285, 13285], "mapped", [54, 26085]],
      [[13286, 13286], "mapped", [55, 26085]],
      [[13287, 13287], "mapped", [56, 26085]],
      [[13288, 13288], "mapped", [57, 26085]],
      [[13289, 13289], "mapped", [49, 48, 26085]],
      [[13290, 13290], "mapped", [49, 49, 26085]],
      [[13291, 13291], "mapped", [49, 50, 26085]],
      [[13292, 13292], "mapped", [49, 51, 26085]],
      [[13293, 13293], "mapped", [49, 52, 26085]],
      [[13294, 13294], "mapped", [49, 53, 26085]],
      [[13295, 13295], "mapped", [49, 54, 26085]],
      [[13296, 13296], "mapped", [49, 55, 26085]],
      [[13297, 13297], "mapped", [49, 56, 26085]],
      [[13298, 13298], "mapped", [49, 57, 26085]],
      [[13299, 13299], "mapped", [50, 48, 26085]],
      [[13300, 13300], "mapped", [50, 49, 26085]],
      [[13301, 13301], "mapped", [50, 50, 26085]],
      [[13302, 13302], "mapped", [50, 51, 26085]],
      [[13303, 13303], "mapped", [50, 52, 26085]],
      [[13304, 13304], "mapped", [50, 53, 26085]],
      [[13305, 13305], "mapped", [50, 54, 26085]],
      [[13306, 13306], "mapped", [50, 55, 26085]],
      [[13307, 13307], "mapped", [50, 56, 26085]],
      [[13308, 13308], "mapped", [50, 57, 26085]],
      [[13309, 13309], "mapped", [51, 48, 26085]],
      [[13310, 13310], "mapped", [51, 49, 26085]],
      [[13311, 13311], "mapped", [103, 97, 108]],
      [[13312, 19893], "valid"],
      [[19894, 19903], "disallowed"],
      [[19904, 19967], "valid", [], "NV8"],
      [[19968, 40869], "valid"],
      [[40870, 40891], "valid"],
      [[40892, 40899], "valid"],
      [[40900, 40907], "valid"],
      [[40908, 40908], "valid"],
      [[40909, 40917], "valid"],
      [[40918, 40959], "disallowed"],
      [[40960, 42124], "valid"],
      [[42125, 42127], "disallowed"],
      [[42128, 42145], "valid", [], "NV8"],
      [[42146, 42147], "valid", [], "NV8"],
      [[42148, 42163], "valid", [], "NV8"],
      [[42164, 42164], "valid", [], "NV8"],
      [[42165, 42176], "valid", [], "NV8"],
      [[42177, 42177], "valid", [], "NV8"],
      [[42178, 42180], "valid", [], "NV8"],
      [[42181, 42181], "valid", [], "NV8"],
      [[42182, 42182], "valid", [], "NV8"],
      [[42183, 42191], "disallowed"],
      [[42192, 42237], "valid"],
      [[42238, 42239], "valid", [], "NV8"],
      [[42240, 42508], "valid"],
      [[42509, 42511], "valid", [], "NV8"],
      [[42512, 42539], "valid"],
      [[42540, 42559], "disallowed"],
      [[42560, 42560], "mapped", [42561]],
      [[42561, 42561], "valid"],
      [[42562, 42562], "mapped", [42563]],
      [[42563, 42563], "valid"],
      [[42564, 42564], "mapped", [42565]],
      [[42565, 42565], "valid"],
      [[42566, 42566], "mapped", [42567]],
      [[42567, 42567], "valid"],
      [[42568, 42568], "mapped", [42569]],
      [[42569, 42569], "valid"],
      [[42570, 42570], "mapped", [42571]],
      [[42571, 42571], "valid"],
      [[42572, 42572], "mapped", [42573]],
      [[42573, 42573], "valid"],
      [[42574, 42574], "mapped", [42575]],
      [[42575, 42575], "valid"],
      [[42576, 42576], "mapped", [42577]],
      [[42577, 42577], "valid"],
      [[42578, 42578], "mapped", [42579]],
      [[42579, 42579], "valid"],
      [[42580, 42580], "mapped", [42581]],
      [[42581, 42581], "valid"],
      [[42582, 42582], "mapped", [42583]],
      [[42583, 42583], "valid"],
      [[42584, 42584], "mapped", [42585]],
      [[42585, 42585], "valid"],
      [[42586, 42586], "mapped", [42587]],
      [[42587, 42587], "valid"],
      [[42588, 42588], "mapped", [42589]],
      [[42589, 42589], "valid"],
      [[42590, 42590], "mapped", [42591]],
      [[42591, 42591], "valid"],
      [[42592, 42592], "mapped", [42593]],
      [[42593, 42593], "valid"],
      [[42594, 42594], "mapped", [42595]],
      [[42595, 42595], "valid"],
      [[42596, 42596], "mapped", [42597]],
      [[42597, 42597], "valid"],
      [[42598, 42598], "mapped", [42599]],
      [[42599, 42599], "valid"],
      [[42600, 42600], "mapped", [42601]],
      [[42601, 42601], "valid"],
      [[42602, 42602], "mapped", [42603]],
      [[42603, 42603], "valid"],
      [[42604, 42604], "mapped", [42605]],
      [[42605, 42607], "valid"],
      [[42608, 42611], "valid", [], "NV8"],
      [[42612, 42619], "valid"],
      [[42620, 42621], "valid"],
      [[42622, 42622], "valid", [], "NV8"],
      [[42623, 42623], "valid"],
      [[42624, 42624], "mapped", [42625]],
      [[42625, 42625], "valid"],
      [[42626, 42626], "mapped", [42627]],
      [[42627, 42627], "valid"],
      [[42628, 42628], "mapped", [42629]],
      [[42629, 42629], "valid"],
      [[42630, 42630], "mapped", [42631]],
      [[42631, 42631], "valid"],
      [[42632, 42632], "mapped", [42633]],
      [[42633, 42633], "valid"],
      [[42634, 42634], "mapped", [42635]],
      [[42635, 42635], "valid"],
      [[42636, 42636], "mapped", [42637]],
      [[42637, 42637], "valid"],
      [[42638, 42638], "mapped", [42639]],
      [[42639, 42639], "valid"],
      [[42640, 42640], "mapped", [42641]],
      [[42641, 42641], "valid"],
      [[42642, 42642], "mapped", [42643]],
      [[42643, 42643], "valid"],
      [[42644, 42644], "mapped", [42645]],
      [[42645, 42645], "valid"],
      [[42646, 42646], "mapped", [42647]],
      [[42647, 42647], "valid"],
      [[42648, 42648], "mapped", [42649]],
      [[42649, 42649], "valid"],
      [[42650, 42650], "mapped", [42651]],
      [[42651, 42651], "valid"],
      [[42652, 42652], "mapped", [1098]],
      [[42653, 42653], "mapped", [1100]],
      [[42654, 42654], "valid"],
      [[42655, 42655], "valid"],
      [[42656, 42725], "valid"],
      [[42726, 42735], "valid", [], "NV8"],
      [[42736, 42737], "valid"],
      [[42738, 42743], "valid", [], "NV8"],
      [[42744, 42751], "disallowed"],
      [[42752, 42774], "valid", [], "NV8"],
      [[42775, 42778], "valid"],
      [[42779, 42783], "valid"],
      [[42784, 42785], "valid", [], "NV8"],
      [[42786, 42786], "mapped", [42787]],
      [[42787, 42787], "valid"],
      [[42788, 42788], "mapped", [42789]],
      [[42789, 42789], "valid"],
      [[42790, 42790], "mapped", [42791]],
      [[42791, 42791], "valid"],
      [[42792, 42792], "mapped", [42793]],
      [[42793, 42793], "valid"],
      [[42794, 42794], "mapped", [42795]],
      [[42795, 42795], "valid"],
      [[42796, 42796], "mapped", [42797]],
      [[42797, 42797], "valid"],
      [[42798, 42798], "mapped", [42799]],
      [[42799, 42801], "valid"],
      [[42802, 42802], "mapped", [42803]],
      [[42803, 42803], "valid"],
      [[42804, 42804], "mapped", [42805]],
      [[42805, 42805], "valid"],
      [[42806, 42806], "mapped", [42807]],
      [[42807, 42807], "valid"],
      [[42808, 42808], "mapped", [42809]],
      [[42809, 42809], "valid"],
      [[42810, 42810], "mapped", [42811]],
      [[42811, 42811], "valid"],
      [[42812, 42812], "mapped", [42813]],
      [[42813, 42813], "valid"],
      [[42814, 42814], "mapped", [42815]],
      [[42815, 42815], "valid"],
      [[42816, 42816], "mapped", [42817]],
      [[42817, 42817], "valid"],
      [[42818, 42818], "mapped", [42819]],
      [[42819, 42819], "valid"],
      [[42820, 42820], "mapped", [42821]],
      [[42821, 42821], "valid"],
      [[42822, 42822], "mapped", [42823]],
      [[42823, 42823], "valid"],
      [[42824, 42824], "mapped", [42825]],
      [[42825, 42825], "valid"],
      [[42826, 42826], "mapped", [42827]],
      [[42827, 42827], "valid"],
      [[42828, 42828], "mapped", [42829]],
      [[42829, 42829], "valid"],
      [[42830, 42830], "mapped", [42831]],
      [[42831, 42831], "valid"],
      [[42832, 42832], "mapped", [42833]],
      [[42833, 42833], "valid"],
      [[42834, 42834], "mapped", [42835]],
      [[42835, 42835], "valid"],
      [[42836, 42836], "mapped", [42837]],
      [[42837, 42837], "valid"],
      [[42838, 42838], "mapped", [42839]],
      [[42839, 42839], "valid"],
      [[42840, 42840], "mapped", [42841]],
      [[42841, 42841], "valid"],
      [[42842, 42842], "mapped", [42843]],
      [[42843, 42843], "valid"],
      [[42844, 42844], "mapped", [42845]],
      [[42845, 42845], "valid"],
      [[42846, 42846], "mapped", [42847]],
      [[42847, 42847], "valid"],
      [[42848, 42848], "mapped", [42849]],
      [[42849, 42849], "valid"],
      [[42850, 42850], "mapped", [42851]],
      [[42851, 42851], "valid"],
      [[42852, 42852], "mapped", [42853]],
      [[42853, 42853], "valid"],
      [[42854, 42854], "mapped", [42855]],
      [[42855, 42855], "valid"],
      [[42856, 42856], "mapped", [42857]],
      [[42857, 42857], "valid"],
      [[42858, 42858], "mapped", [42859]],
      [[42859, 42859], "valid"],
      [[42860, 42860], "mapped", [42861]],
      [[42861, 42861], "valid"],
      [[42862, 42862], "mapped", [42863]],
      [[42863, 42863], "valid"],
      [[42864, 42864], "mapped", [42863]],
      [[42865, 42872], "valid"],
      [[42873, 42873], "mapped", [42874]],
      [[42874, 42874], "valid"],
      [[42875, 42875], "mapped", [42876]],
      [[42876, 42876], "valid"],
      [[42877, 42877], "mapped", [7545]],
      [[42878, 42878], "mapped", [42879]],
      [[42879, 42879], "valid"],
      [[42880, 42880], "mapped", [42881]],
      [[42881, 42881], "valid"],
      [[42882, 42882], "mapped", [42883]],
      [[42883, 42883], "valid"],
      [[42884, 42884], "mapped", [42885]],
      [[42885, 42885], "valid"],
      [[42886, 42886], "mapped", [42887]],
      [[42887, 42888], "valid"],
      [[42889, 42890], "valid", [], "NV8"],
      [[42891, 42891], "mapped", [42892]],
      [[42892, 42892], "valid"],
      [[42893, 42893], "mapped", [613]],
      [[42894, 42894], "valid"],
      [[42895, 42895], "valid"],
      [[42896, 42896], "mapped", [42897]],
      [[42897, 42897], "valid"],
      [[42898, 42898], "mapped", [42899]],
      [[42899, 42899], "valid"],
      [[42900, 42901], "valid"],
      [[42902, 42902], "mapped", [42903]],
      [[42903, 42903], "valid"],
      [[42904, 42904], "mapped", [42905]],
      [[42905, 42905], "valid"],
      [[42906, 42906], "mapped", [42907]],
      [[42907, 42907], "valid"],
      [[42908, 42908], "mapped", [42909]],
      [[42909, 42909], "valid"],
      [[42910, 42910], "mapped", [42911]],
      [[42911, 42911], "valid"],
      [[42912, 42912], "mapped", [42913]],
      [[42913, 42913], "valid"],
      [[42914, 42914], "mapped", [42915]],
      [[42915, 42915], "valid"],
      [[42916, 42916], "mapped", [42917]],
      [[42917, 42917], "valid"],
      [[42918, 42918], "mapped", [42919]],
      [[42919, 42919], "valid"],
      [[42920, 42920], "mapped", [42921]],
      [[42921, 42921], "valid"],
      [[42922, 42922], "mapped", [614]],
      [[42923, 42923], "mapped", [604]],
      [[42924, 42924], "mapped", [609]],
      [[42925, 42925], "mapped", [620]],
      [[42926, 42927], "disallowed"],
      [[42928, 42928], "mapped", [670]],
      [[42929, 42929], "mapped", [647]],
      [[42930, 42930], "mapped", [669]],
      [[42931, 42931], "mapped", [43859]],
      [[42932, 42932], "mapped", [42933]],
      [[42933, 42933], "valid"],
      [[42934, 42934], "mapped", [42935]],
      [[42935, 42935], "valid"],
      [[42936, 42998], "disallowed"],
      [[42999, 42999], "valid"],
      [[43e3, 43e3], "mapped", [295]],
      [[43001, 43001], "mapped", [339]],
      [[43002, 43002], "valid"],
      [[43003, 43007], "valid"],
      [[43008, 43047], "valid"],
      [[43048, 43051], "valid", [], "NV8"],
      [[43052, 43055], "disallowed"],
      [[43056, 43065], "valid", [], "NV8"],
      [[43066, 43071], "disallowed"],
      [[43072, 43123], "valid"],
      [[43124, 43127], "valid", [], "NV8"],
      [[43128, 43135], "disallowed"],
      [[43136, 43204], "valid"],
      [[43205, 43213], "disallowed"],
      [[43214, 43215], "valid", [], "NV8"],
      [[43216, 43225], "valid"],
      [[43226, 43231], "disallowed"],
      [[43232, 43255], "valid"],
      [[43256, 43258], "valid", [], "NV8"],
      [[43259, 43259], "valid"],
      [[43260, 43260], "valid", [], "NV8"],
      [[43261, 43261], "valid"],
      [[43262, 43263], "disallowed"],
      [[43264, 43309], "valid"],
      [[43310, 43311], "valid", [], "NV8"],
      [[43312, 43347], "valid"],
      [[43348, 43358], "disallowed"],
      [[43359, 43359], "valid", [], "NV8"],
      [[43360, 43388], "valid", [], "NV8"],
      [[43389, 43391], "disallowed"],
      [[43392, 43456], "valid"],
      [[43457, 43469], "valid", [], "NV8"],
      [[43470, 43470], "disallowed"],
      [[43471, 43481], "valid"],
      [[43482, 43485], "disallowed"],
      [[43486, 43487], "valid", [], "NV8"],
      [[43488, 43518], "valid"],
      [[43519, 43519], "disallowed"],
      [[43520, 43574], "valid"],
      [[43575, 43583], "disallowed"],
      [[43584, 43597], "valid"],
      [[43598, 43599], "disallowed"],
      [[43600, 43609], "valid"],
      [[43610, 43611], "disallowed"],
      [[43612, 43615], "valid", [], "NV8"],
      [[43616, 43638], "valid"],
      [[43639, 43641], "valid", [], "NV8"],
      [[43642, 43643], "valid"],
      [[43644, 43647], "valid"],
      [[43648, 43714], "valid"],
      [[43715, 43738], "disallowed"],
      [[43739, 43741], "valid"],
      [[43742, 43743], "valid", [], "NV8"],
      [[43744, 43759], "valid"],
      [[43760, 43761], "valid", [], "NV8"],
      [[43762, 43766], "valid"],
      [[43767, 43776], "disallowed"],
      [[43777, 43782], "valid"],
      [[43783, 43784], "disallowed"],
      [[43785, 43790], "valid"],
      [[43791, 43792], "disallowed"],
      [[43793, 43798], "valid"],
      [[43799, 43807], "disallowed"],
      [[43808, 43814], "valid"],
      [[43815, 43815], "disallowed"],
      [[43816, 43822], "valid"],
      [[43823, 43823], "disallowed"],
      [[43824, 43866], "valid"],
      [[43867, 43867], "valid", [], "NV8"],
      [[43868, 43868], "mapped", [42791]],
      [[43869, 43869], "mapped", [43831]],
      [[43870, 43870], "mapped", [619]],
      [[43871, 43871], "mapped", [43858]],
      [[43872, 43875], "valid"],
      [[43876, 43877], "valid"],
      [[43878, 43887], "disallowed"],
      [[43888, 43888], "mapped", [5024]],
      [[43889, 43889], "mapped", [5025]],
      [[43890, 43890], "mapped", [5026]],
      [[43891, 43891], "mapped", [5027]],
      [[43892, 43892], "mapped", [5028]],
      [[43893, 43893], "mapped", [5029]],
      [[43894, 43894], "mapped", [5030]],
      [[43895, 43895], "mapped", [5031]],
      [[43896, 43896], "mapped", [5032]],
      [[43897, 43897], "mapped", [5033]],
      [[43898, 43898], "mapped", [5034]],
      [[43899, 43899], "mapped", [5035]],
      [[43900, 43900], "mapped", [5036]],
      [[43901, 43901], "mapped", [5037]],
      [[43902, 43902], "mapped", [5038]],
      [[43903, 43903], "mapped", [5039]],
      [[43904, 43904], "mapped", [5040]],
      [[43905, 43905], "mapped", [5041]],
      [[43906, 43906], "mapped", [5042]],
      [[43907, 43907], "mapped", [5043]],
      [[43908, 43908], "mapped", [5044]],
      [[43909, 43909], "mapped", [5045]],
      [[43910, 43910], "mapped", [5046]],
      [[43911, 43911], "mapped", [5047]],
      [[43912, 43912], "mapped", [5048]],
      [[43913, 43913], "mapped", [5049]],
      [[43914, 43914], "mapped", [5050]],
      [[43915, 43915], "mapped", [5051]],
      [[43916, 43916], "mapped", [5052]],
      [[43917, 43917], "mapped", [5053]],
      [[43918, 43918], "mapped", [5054]],
      [[43919, 43919], "mapped", [5055]],
      [[43920, 43920], "mapped", [5056]],
      [[43921, 43921], "mapped", [5057]],
      [[43922, 43922], "mapped", [5058]],
      [[43923, 43923], "mapped", [5059]],
      [[43924, 43924], "mapped", [5060]],
      [[43925, 43925], "mapped", [5061]],
      [[43926, 43926], "mapped", [5062]],
      [[43927, 43927], "mapped", [5063]],
      [[43928, 43928], "mapped", [5064]],
      [[43929, 43929], "mapped", [5065]],
      [[43930, 43930], "mapped", [5066]],
      [[43931, 43931], "mapped", [5067]],
      [[43932, 43932], "mapped", [5068]],
      [[43933, 43933], "mapped", [5069]],
      [[43934, 43934], "mapped", [5070]],
      [[43935, 43935], "mapped", [5071]],
      [[43936, 43936], "mapped", [5072]],
      [[43937, 43937], "mapped", [5073]],
      [[43938, 43938], "mapped", [5074]],
      [[43939, 43939], "mapped", [5075]],
      [[43940, 43940], "mapped", [5076]],
      [[43941, 43941], "mapped", [5077]],
      [[43942, 43942], "mapped", [5078]],
      [[43943, 43943], "mapped", [5079]],
      [[43944, 43944], "mapped", [5080]],
      [[43945, 43945], "mapped", [5081]],
      [[43946, 43946], "mapped", [5082]],
      [[43947, 43947], "mapped", [5083]],
      [[43948, 43948], "mapped", [5084]],
      [[43949, 43949], "mapped", [5085]],
      [[43950, 43950], "mapped", [5086]],
      [[43951, 43951], "mapped", [5087]],
      [[43952, 43952], "mapped", [5088]],
      [[43953, 43953], "mapped", [5089]],
      [[43954, 43954], "mapped", [5090]],
      [[43955, 43955], "mapped", [5091]],
      [[43956, 43956], "mapped", [5092]],
      [[43957, 43957], "mapped", [5093]],
      [[43958, 43958], "mapped", [5094]],
      [[43959, 43959], "mapped", [5095]],
      [[43960, 43960], "mapped", [5096]],
      [[43961, 43961], "mapped", [5097]],
      [[43962, 43962], "mapped", [5098]],
      [[43963, 43963], "mapped", [5099]],
      [[43964, 43964], "mapped", [5100]],
      [[43965, 43965], "mapped", [5101]],
      [[43966, 43966], "mapped", [5102]],
      [[43967, 43967], "mapped", [5103]],
      [[43968, 44010], "valid"],
      [[44011, 44011], "valid", [], "NV8"],
      [[44012, 44013], "valid"],
      [[44014, 44015], "disallowed"],
      [[44016, 44025], "valid"],
      [[44026, 44031], "disallowed"],
      [[44032, 55203], "valid"],
      [[55204, 55215], "disallowed"],
      [[55216, 55238], "valid", [], "NV8"],
      [[55239, 55242], "disallowed"],
      [[55243, 55291], "valid", [], "NV8"],
      [[55292, 55295], "disallowed"],
      [[55296, 57343], "disallowed"],
      [[57344, 63743], "disallowed"],
      [[63744, 63744], "mapped", [35912]],
      [[63745, 63745], "mapped", [26356]],
      [[63746, 63746], "mapped", [36554]],
      [[63747, 63747], "mapped", [36040]],
      [[63748, 63748], "mapped", [28369]],
      [[63749, 63749], "mapped", [20018]],
      [[63750, 63750], "mapped", [21477]],
      [[63751, 63752], "mapped", [40860]],
      [[63753, 63753], "mapped", [22865]],
      [[63754, 63754], "mapped", [37329]],
      [[63755, 63755], "mapped", [21895]],
      [[63756, 63756], "mapped", [22856]],
      [[63757, 63757], "mapped", [25078]],
      [[63758, 63758], "mapped", [30313]],
      [[63759, 63759], "mapped", [32645]],
      [[63760, 63760], "mapped", [34367]],
      [[63761, 63761], "mapped", [34746]],
      [[63762, 63762], "mapped", [35064]],
      [[63763, 63763], "mapped", [37007]],
      [[63764, 63764], "mapped", [27138]],
      [[63765, 63765], "mapped", [27931]],
      [[63766, 63766], "mapped", [28889]],
      [[63767, 63767], "mapped", [29662]],
      [[63768, 63768], "mapped", [33853]],
      [[63769, 63769], "mapped", [37226]],
      [[63770, 63770], "mapped", [39409]],
      [[63771, 63771], "mapped", [20098]],
      [[63772, 63772], "mapped", [21365]],
      [[63773, 63773], "mapped", [27396]],
      [[63774, 63774], "mapped", [29211]],
      [[63775, 63775], "mapped", [34349]],
      [[63776, 63776], "mapped", [40478]],
      [[63777, 63777], "mapped", [23888]],
      [[63778, 63778], "mapped", [28651]],
      [[63779, 63779], "mapped", [34253]],
      [[63780, 63780], "mapped", [35172]],
      [[63781, 63781], "mapped", [25289]],
      [[63782, 63782], "mapped", [33240]],
      [[63783, 63783], "mapped", [34847]],
      [[63784, 63784], "mapped", [24266]],
      [[63785, 63785], "mapped", [26391]],
      [[63786, 63786], "mapped", [28010]],
      [[63787, 63787], "mapped", [29436]],
      [[63788, 63788], "mapped", [37070]],
      [[63789, 63789], "mapped", [20358]],
      [[63790, 63790], "mapped", [20919]],
      [[63791, 63791], "mapped", [21214]],
      [[63792, 63792], "mapped", [25796]],
      [[63793, 63793], "mapped", [27347]],
      [[63794, 63794], "mapped", [29200]],
      [[63795, 63795], "mapped", [30439]],
      [[63796, 63796], "mapped", [32769]],
      [[63797, 63797], "mapped", [34310]],
      [[63798, 63798], "mapped", [34396]],
      [[63799, 63799], "mapped", [36335]],
      [[63800, 63800], "mapped", [38706]],
      [[63801, 63801], "mapped", [39791]],
      [[63802, 63802], "mapped", [40442]],
      [[63803, 63803], "mapped", [30860]],
      [[63804, 63804], "mapped", [31103]],
      [[63805, 63805], "mapped", [32160]],
      [[63806, 63806], "mapped", [33737]],
      [[63807, 63807], "mapped", [37636]],
      [[63808, 63808], "mapped", [40575]],
      [[63809, 63809], "mapped", [35542]],
      [[63810, 63810], "mapped", [22751]],
      [[63811, 63811], "mapped", [24324]],
      [[63812, 63812], "mapped", [31840]],
      [[63813, 63813], "mapped", [32894]],
      [[63814, 63814], "mapped", [29282]],
      [[63815, 63815], "mapped", [30922]],
      [[63816, 63816], "mapped", [36034]],
      [[63817, 63817], "mapped", [38647]],
      [[63818, 63818], "mapped", [22744]],
      [[63819, 63819], "mapped", [23650]],
      [[63820, 63820], "mapped", [27155]],
      [[63821, 63821], "mapped", [28122]],
      [[63822, 63822], "mapped", [28431]],
      [[63823, 63823], "mapped", [32047]],
      [[63824, 63824], "mapped", [32311]],
      [[63825, 63825], "mapped", [38475]],
      [[63826, 63826], "mapped", [21202]],
      [[63827, 63827], "mapped", [32907]],
      [[63828, 63828], "mapped", [20956]],
      [[63829, 63829], "mapped", [20940]],
      [[63830, 63830], "mapped", [31260]],
      [[63831, 63831], "mapped", [32190]],
      [[63832, 63832], "mapped", [33777]],
      [[63833, 63833], "mapped", [38517]],
      [[63834, 63834], "mapped", [35712]],
      [[63835, 63835], "mapped", [25295]],
      [[63836, 63836], "mapped", [27138]],
      [[63837, 63837], "mapped", [35582]],
      [[63838, 63838], "mapped", [20025]],
      [[63839, 63839], "mapped", [23527]],
      [[63840, 63840], "mapped", [24594]],
      [[63841, 63841], "mapped", [29575]],
      [[63842, 63842], "mapped", [30064]],
      [[63843, 63843], "mapped", [21271]],
      [[63844, 63844], "mapped", [30971]],
      [[63845, 63845], "mapped", [20415]],
      [[63846, 63846], "mapped", [24489]],
      [[63847, 63847], "mapped", [19981]],
      [[63848, 63848], "mapped", [27852]],
      [[63849, 63849], "mapped", [25976]],
      [[63850, 63850], "mapped", [32034]],
      [[63851, 63851], "mapped", [21443]],
      [[63852, 63852], "mapped", [22622]],
      [[63853, 63853], "mapped", [30465]],
      [[63854, 63854], "mapped", [33865]],
      [[63855, 63855], "mapped", [35498]],
      [[63856, 63856], "mapped", [27578]],
      [[63857, 63857], "mapped", [36784]],
      [[63858, 63858], "mapped", [27784]],
      [[63859, 63859], "mapped", [25342]],
      [[63860, 63860], "mapped", [33509]],
      [[63861, 63861], "mapped", [25504]],
      [[63862, 63862], "mapped", [30053]],
      [[63863, 63863], "mapped", [20142]],
      [[63864, 63864], "mapped", [20841]],
      [[63865, 63865], "mapped", [20937]],
      [[63866, 63866], "mapped", [26753]],
      [[63867, 63867], "mapped", [31975]],
      [[63868, 63868], "mapped", [33391]],
      [[63869, 63869], "mapped", [35538]],
      [[63870, 63870], "mapped", [37327]],
      [[63871, 63871], "mapped", [21237]],
      [[63872, 63872], "mapped", [21570]],
      [[63873, 63873], "mapped", [22899]],
      [[63874, 63874], "mapped", [24300]],
      [[63875, 63875], "mapped", [26053]],
      [[63876, 63876], "mapped", [28670]],
      [[63877, 63877], "mapped", [31018]],
      [[63878, 63878], "mapped", [38317]],
      [[63879, 63879], "mapped", [39530]],
      [[63880, 63880], "mapped", [40599]],
      [[63881, 63881], "mapped", [40654]],
      [[63882, 63882], "mapped", [21147]],
      [[63883, 63883], "mapped", [26310]],
      [[63884, 63884], "mapped", [27511]],
      [[63885, 63885], "mapped", [36706]],
      [[63886, 63886], "mapped", [24180]],
      [[63887, 63887], "mapped", [24976]],
      [[63888, 63888], "mapped", [25088]],
      [[63889, 63889], "mapped", [25754]],
      [[63890, 63890], "mapped", [28451]],
      [[63891, 63891], "mapped", [29001]],
      [[63892, 63892], "mapped", [29833]],
      [[63893, 63893], "mapped", [31178]],
      [[63894, 63894], "mapped", [32244]],
      [[63895, 63895], "mapped", [32879]],
      [[63896, 63896], "mapped", [36646]],
      [[63897, 63897], "mapped", [34030]],
      [[63898, 63898], "mapped", [36899]],
      [[63899, 63899], "mapped", [37706]],
      [[63900, 63900], "mapped", [21015]],
      [[63901, 63901], "mapped", [21155]],
      [[63902, 63902], "mapped", [21693]],
      [[63903, 63903], "mapped", [28872]],
      [[63904, 63904], "mapped", [35010]],
      [[63905, 63905], "mapped", [35498]],
      [[63906, 63906], "mapped", [24265]],
      [[63907, 63907], "mapped", [24565]],
      [[63908, 63908], "mapped", [25467]],
      [[63909, 63909], "mapped", [27566]],
      [[63910, 63910], "mapped", [31806]],
      [[63911, 63911], "mapped", [29557]],
      [[63912, 63912], "mapped", [20196]],
      [[63913, 63913], "mapped", [22265]],
      [[63914, 63914], "mapped", [23527]],
      [[63915, 63915], "mapped", [23994]],
      [[63916, 63916], "mapped", [24604]],
      [[63917, 63917], "mapped", [29618]],
      [[63918, 63918], "mapped", [29801]],
      [[63919, 63919], "mapped", [32666]],
      [[63920, 63920], "mapped", [32838]],
      [[63921, 63921], "mapped", [37428]],
      [[63922, 63922], "mapped", [38646]],
      [[63923, 63923], "mapped", [38728]],
      [[63924, 63924], "mapped", [38936]],
      [[63925, 63925], "mapped", [20363]],
      [[63926, 63926], "mapped", [31150]],
      [[63927, 63927], "mapped", [37300]],
      [[63928, 63928], "mapped", [38584]],
      [[63929, 63929], "mapped", [24801]],
      [[63930, 63930], "mapped", [20102]],
      [[63931, 63931], "mapped", [20698]],
      [[63932, 63932], "mapped", [23534]],
      [[63933, 63933], "mapped", [23615]],
      [[63934, 63934], "mapped", [26009]],
      [[63935, 63935], "mapped", [27138]],
      [[63936, 63936], "mapped", [29134]],
      [[63937, 63937], "mapped", [30274]],
      [[63938, 63938], "mapped", [34044]],
      [[63939, 63939], "mapped", [36988]],
      [[63940, 63940], "mapped", [40845]],
      [[63941, 63941], "mapped", [26248]],
      [[63942, 63942], "mapped", [38446]],
      [[63943, 63943], "mapped", [21129]],
      [[63944, 63944], "mapped", [26491]],
      [[63945, 63945], "mapped", [26611]],
      [[63946, 63946], "mapped", [27969]],
      [[63947, 63947], "mapped", [28316]],
      [[63948, 63948], "mapped", [29705]],
      [[63949, 63949], "mapped", [30041]],
      [[63950, 63950], "mapped", [30827]],
      [[63951, 63951], "mapped", [32016]],
      [[63952, 63952], "mapped", [39006]],
      [[63953, 63953], "mapped", [20845]],
      [[63954, 63954], "mapped", [25134]],
      [[63955, 63955], "mapped", [38520]],
      [[63956, 63956], "mapped", [20523]],
      [[63957, 63957], "mapped", [23833]],
      [[63958, 63958], "mapped", [28138]],
      [[63959, 63959], "mapped", [36650]],
      [[63960, 63960], "mapped", [24459]],
      [[63961, 63961], "mapped", [24900]],
      [[63962, 63962], "mapped", [26647]],
      [[63963, 63963], "mapped", [29575]],
      [[63964, 63964], "mapped", [38534]],
      [[63965, 63965], "mapped", [21033]],
      [[63966, 63966], "mapped", [21519]],
      [[63967, 63967], "mapped", [23653]],
      [[63968, 63968], "mapped", [26131]],
      [[63969, 63969], "mapped", [26446]],
      [[63970, 63970], "mapped", [26792]],
      [[63971, 63971], "mapped", [27877]],
      [[63972, 63972], "mapped", [29702]],
      [[63973, 63973], "mapped", [30178]],
      [[63974, 63974], "mapped", [32633]],
      [[63975, 63975], "mapped", [35023]],
      [[63976, 63976], "mapped", [35041]],
      [[63977, 63977], "mapped", [37324]],
      [[63978, 63978], "mapped", [38626]],
      [[63979, 63979], "mapped", [21311]],
      [[63980, 63980], "mapped", [28346]],
      [[63981, 63981], "mapped", [21533]],
      [[63982, 63982], "mapped", [29136]],
      [[63983, 63983], "mapped", [29848]],
      [[63984, 63984], "mapped", [34298]],
      [[63985, 63985], "mapped", [38563]],
      [[63986, 63986], "mapped", [40023]],
      [[63987, 63987], "mapped", [40607]],
      [[63988, 63988], "mapped", [26519]],
      [[63989, 63989], "mapped", [28107]],
      [[63990, 63990], "mapped", [33256]],
      [[63991, 63991], "mapped", [31435]],
      [[63992, 63992], "mapped", [31520]],
      [[63993, 63993], "mapped", [31890]],
      [[63994, 63994], "mapped", [29376]],
      [[63995, 63995], "mapped", [28825]],
      [[63996, 63996], "mapped", [35672]],
      [[63997, 63997], "mapped", [20160]],
      [[63998, 63998], "mapped", [33590]],
      [[63999, 63999], "mapped", [21050]],
      [[64e3, 64e3], "mapped", [20999]],
      [[64001, 64001], "mapped", [24230]],
      [[64002, 64002], "mapped", [25299]],
      [[64003, 64003], "mapped", [31958]],
      [[64004, 64004], "mapped", [23429]],
      [[64005, 64005], "mapped", [27934]],
      [[64006, 64006], "mapped", [26292]],
      [[64007, 64007], "mapped", [36667]],
      [[64008, 64008], "mapped", [34892]],
      [[64009, 64009], "mapped", [38477]],
      [[64010, 64010], "mapped", [35211]],
      [[64011, 64011], "mapped", [24275]],
      [[64012, 64012], "mapped", [20800]],
      [[64013, 64013], "mapped", [21952]],
      [[64014, 64015], "valid"],
      [[64016, 64016], "mapped", [22618]],
      [[64017, 64017], "valid"],
      [[64018, 64018], "mapped", [26228]],
      [[64019, 64020], "valid"],
      [[64021, 64021], "mapped", [20958]],
      [[64022, 64022], "mapped", [29482]],
      [[64023, 64023], "mapped", [30410]],
      [[64024, 64024], "mapped", [31036]],
      [[64025, 64025], "mapped", [31070]],
      [[64026, 64026], "mapped", [31077]],
      [[64027, 64027], "mapped", [31119]],
      [[64028, 64028], "mapped", [38742]],
      [[64029, 64029], "mapped", [31934]],
      [[64030, 64030], "mapped", [32701]],
      [[64031, 64031], "valid"],
      [[64032, 64032], "mapped", [34322]],
      [[64033, 64033], "valid"],
      [[64034, 64034], "mapped", [35576]],
      [[64035, 64036], "valid"],
      [[64037, 64037], "mapped", [36920]],
      [[64038, 64038], "mapped", [37117]],
      [[64039, 64041], "valid"],
      [[64042, 64042], "mapped", [39151]],
      [[64043, 64043], "mapped", [39164]],
      [[64044, 64044], "mapped", [39208]],
      [[64045, 64045], "mapped", [40372]],
      [[64046, 64046], "mapped", [37086]],
      [[64047, 64047], "mapped", [38583]],
      [[64048, 64048], "mapped", [20398]],
      [[64049, 64049], "mapped", [20711]],
      [[64050, 64050], "mapped", [20813]],
      [[64051, 64051], "mapped", [21193]],
      [[64052, 64052], "mapped", [21220]],
      [[64053, 64053], "mapped", [21329]],
      [[64054, 64054], "mapped", [21917]],
      [[64055, 64055], "mapped", [22022]],
      [[64056, 64056], "mapped", [22120]],
      [[64057, 64057], "mapped", [22592]],
      [[64058, 64058], "mapped", [22696]],
      [[64059, 64059], "mapped", [23652]],
      [[64060, 64060], "mapped", [23662]],
      [[64061, 64061], "mapped", [24724]],
      [[64062, 64062], "mapped", [24936]],
      [[64063, 64063], "mapped", [24974]],
      [[64064, 64064], "mapped", [25074]],
      [[64065, 64065], "mapped", [25935]],
      [[64066, 64066], "mapped", [26082]],
      [[64067, 64067], "mapped", [26257]],
      [[64068, 64068], "mapped", [26757]],
      [[64069, 64069], "mapped", [28023]],
      [[64070, 64070], "mapped", [28186]],
      [[64071, 64071], "mapped", [28450]],
      [[64072, 64072], "mapped", [29038]],
      [[64073, 64073], "mapped", [29227]],
      [[64074, 64074], "mapped", [29730]],
      [[64075, 64075], "mapped", [30865]],
      [[64076, 64076], "mapped", [31038]],
      [[64077, 64077], "mapped", [31049]],
      [[64078, 64078], "mapped", [31048]],
      [[64079, 64079], "mapped", [31056]],
      [[64080, 64080], "mapped", [31062]],
      [[64081, 64081], "mapped", [31069]],
      [[64082, 64082], "mapped", [31117]],
      [[64083, 64083], "mapped", [31118]],
      [[64084, 64084], "mapped", [31296]],
      [[64085, 64085], "mapped", [31361]],
      [[64086, 64086], "mapped", [31680]],
      [[64087, 64087], "mapped", [32244]],
      [[64088, 64088], "mapped", [32265]],
      [[64089, 64089], "mapped", [32321]],
      [[64090, 64090], "mapped", [32626]],
      [[64091, 64091], "mapped", [32773]],
      [[64092, 64092], "mapped", [33261]],
      [[64093, 64094], "mapped", [33401]],
      [[64095, 64095], "mapped", [33879]],
      [[64096, 64096], "mapped", [35088]],
      [[64097, 64097], "mapped", [35222]],
      [[64098, 64098], "mapped", [35585]],
      [[64099, 64099], "mapped", [35641]],
      [[64100, 64100], "mapped", [36051]],
      [[64101, 64101], "mapped", [36104]],
      [[64102, 64102], "mapped", [36790]],
      [[64103, 64103], "mapped", [36920]],
      [[64104, 64104], "mapped", [38627]],
      [[64105, 64105], "mapped", [38911]],
      [[64106, 64106], "mapped", [38971]],
      [[64107, 64107], "mapped", [24693]],
      [[64108, 64108], "mapped", [148206]],
      [[64109, 64109], "mapped", [33304]],
      [[64110, 64111], "disallowed"],
      [[64112, 64112], "mapped", [20006]],
      [[64113, 64113], "mapped", [20917]],
      [[64114, 64114], "mapped", [20840]],
      [[64115, 64115], "mapped", [20352]],
      [[64116, 64116], "mapped", [20805]],
      [[64117, 64117], "mapped", [20864]],
      [[64118, 64118], "mapped", [21191]],
      [[64119, 64119], "mapped", [21242]],
      [[64120, 64120], "mapped", [21917]],
      [[64121, 64121], "mapped", [21845]],
      [[64122, 64122], "mapped", [21913]],
      [[64123, 64123], "mapped", [21986]],
      [[64124, 64124], "mapped", [22618]],
      [[64125, 64125], "mapped", [22707]],
      [[64126, 64126], "mapped", [22852]],
      [[64127, 64127], "mapped", [22868]],
      [[64128, 64128], "mapped", [23138]],
      [[64129, 64129], "mapped", [23336]],
      [[64130, 64130], "mapped", [24274]],
      [[64131, 64131], "mapped", [24281]],
      [[64132, 64132], "mapped", [24425]],
      [[64133, 64133], "mapped", [24493]],
      [[64134, 64134], "mapped", [24792]],
      [[64135, 64135], "mapped", [24910]],
      [[64136, 64136], "mapped", [24840]],
      [[64137, 64137], "mapped", [24974]],
      [[64138, 64138], "mapped", [24928]],
      [[64139, 64139], "mapped", [25074]],
      [[64140, 64140], "mapped", [25140]],
      [[64141, 64141], "mapped", [25540]],
      [[64142, 64142], "mapped", [25628]],
      [[64143, 64143], "mapped", [25682]],
      [[64144, 64144], "mapped", [25942]],
      [[64145, 64145], "mapped", [26228]],
      [[64146, 64146], "mapped", [26391]],
      [[64147, 64147], "mapped", [26395]],
      [[64148, 64148], "mapped", [26454]],
      [[64149, 64149], "mapped", [27513]],
      [[64150, 64150], "mapped", [27578]],
      [[64151, 64151], "mapped", [27969]],
      [[64152, 64152], "mapped", [28379]],
      [[64153, 64153], "mapped", [28363]],
      [[64154, 64154], "mapped", [28450]],
      [[64155, 64155], "mapped", [28702]],
      [[64156, 64156], "mapped", [29038]],
      [[64157, 64157], "mapped", [30631]],
      [[64158, 64158], "mapped", [29237]],
      [[64159, 64159], "mapped", [29359]],
      [[64160, 64160], "mapped", [29482]],
      [[64161, 64161], "mapped", [29809]],
      [[64162, 64162], "mapped", [29958]],
      [[64163, 64163], "mapped", [30011]],
      [[64164, 64164], "mapped", [30237]],
      [[64165, 64165], "mapped", [30239]],
      [[64166, 64166], "mapped", [30410]],
      [[64167, 64167], "mapped", [30427]],
      [[64168, 64168], "mapped", [30452]],
      [[64169, 64169], "mapped", [30538]],
      [[64170, 64170], "mapped", [30528]],
      [[64171, 64171], "mapped", [30924]],
      [[64172, 64172], "mapped", [31409]],
      [[64173, 64173], "mapped", [31680]],
      [[64174, 64174], "mapped", [31867]],
      [[64175, 64175], "mapped", [32091]],
      [[64176, 64176], "mapped", [32244]],
      [[64177, 64177], "mapped", [32574]],
      [[64178, 64178], "mapped", [32773]],
      [[64179, 64179], "mapped", [33618]],
      [[64180, 64180], "mapped", [33775]],
      [[64181, 64181], "mapped", [34681]],
      [[64182, 64182], "mapped", [35137]],
      [[64183, 64183], "mapped", [35206]],
      [[64184, 64184], "mapped", [35222]],
      [[64185, 64185], "mapped", [35519]],
      [[64186, 64186], "mapped", [35576]],
      [[64187, 64187], "mapped", [35531]],
      [[64188, 64188], "mapped", [35585]],
      [[64189, 64189], "mapped", [35582]],
      [[64190, 64190], "mapped", [35565]],
      [[64191, 64191], "mapped", [35641]],
      [[64192, 64192], "mapped", [35722]],
      [[64193, 64193], "mapped", [36104]],
      [[64194, 64194], "mapped", [36664]],
      [[64195, 64195], "mapped", [36978]],
      [[64196, 64196], "mapped", [37273]],
      [[64197, 64197], "mapped", [37494]],
      [[64198, 64198], "mapped", [38524]],
      [[64199, 64199], "mapped", [38627]],
      [[64200, 64200], "mapped", [38742]],
      [[64201, 64201], "mapped", [38875]],
      [[64202, 64202], "mapped", [38911]],
      [[64203, 64203], "mapped", [38923]],
      [[64204, 64204], "mapped", [38971]],
      [[64205, 64205], "mapped", [39698]],
      [[64206, 64206], "mapped", [40860]],
      [[64207, 64207], "mapped", [141386]],
      [[64208, 64208], "mapped", [141380]],
      [[64209, 64209], "mapped", [144341]],
      [[64210, 64210], "mapped", [15261]],
      [[64211, 64211], "mapped", [16408]],
      [[64212, 64212], "mapped", [16441]],
      [[64213, 64213], "mapped", [152137]],
      [[64214, 64214], "mapped", [154832]],
      [[64215, 64215], "mapped", [163539]],
      [[64216, 64216], "mapped", [40771]],
      [[64217, 64217], "mapped", [40846]],
      [[64218, 64255], "disallowed"],
      [[64256, 64256], "mapped", [102, 102]],
      [[64257, 64257], "mapped", [102, 105]],
      [[64258, 64258], "mapped", [102, 108]],
      [[64259, 64259], "mapped", [102, 102, 105]],
      [[64260, 64260], "mapped", [102, 102, 108]],
      [[64261, 64262], "mapped", [115, 116]],
      [[64263, 64274], "disallowed"],
      [[64275, 64275], "mapped", [1396, 1398]],
      [[64276, 64276], "mapped", [1396, 1381]],
      [[64277, 64277], "mapped", [1396, 1387]],
      [[64278, 64278], "mapped", [1406, 1398]],
      [[64279, 64279], "mapped", [1396, 1389]],
      [[64280, 64284], "disallowed"],
      [[64285, 64285], "mapped", [1497, 1460]],
      [[64286, 64286], "valid"],
      [[64287, 64287], "mapped", [1522, 1463]],
      [[64288, 64288], "mapped", [1506]],
      [[64289, 64289], "mapped", [1488]],
      [[64290, 64290], "mapped", [1491]],
      [[64291, 64291], "mapped", [1492]],
      [[64292, 64292], "mapped", [1499]],
      [[64293, 64293], "mapped", [1500]],
      [[64294, 64294], "mapped", [1501]],
      [[64295, 64295], "mapped", [1512]],
      [[64296, 64296], "mapped", [1514]],
      [[64297, 64297], "disallowed_STD3_mapped", [43]],
      [[64298, 64298], "mapped", [1513, 1473]],
      [[64299, 64299], "mapped", [1513, 1474]],
      [[64300, 64300], "mapped", [1513, 1468, 1473]],
      [[64301, 64301], "mapped", [1513, 1468, 1474]],
      [[64302, 64302], "mapped", [1488, 1463]],
      [[64303, 64303], "mapped", [1488, 1464]],
      [[64304, 64304], "mapped", [1488, 1468]],
      [[64305, 64305], "mapped", [1489, 1468]],
      [[64306, 64306], "mapped", [1490, 1468]],
      [[64307, 64307], "mapped", [1491, 1468]],
      [[64308, 64308], "mapped", [1492, 1468]],
      [[64309, 64309], "mapped", [1493, 1468]],
      [[64310, 64310], "mapped", [1494, 1468]],
      [[64311, 64311], "disallowed"],
      [[64312, 64312], "mapped", [1496, 1468]],
      [[64313, 64313], "mapped", [1497, 1468]],
      [[64314, 64314], "mapped", [1498, 1468]],
      [[64315, 64315], "mapped", [1499, 1468]],
      [[64316, 64316], "mapped", [1500, 1468]],
      [[64317, 64317], "disallowed"],
      [[64318, 64318], "mapped", [1502, 1468]],
      [[64319, 64319], "disallowed"],
      [[64320, 64320], "mapped", [1504, 1468]],
      [[64321, 64321], "mapped", [1505, 1468]],
      [[64322, 64322], "disallowed"],
      [[64323, 64323], "mapped", [1507, 1468]],
      [[64324, 64324], "mapped", [1508, 1468]],
      [[64325, 64325], "disallowed"],
      [[64326, 64326], "mapped", [1510, 1468]],
      [[64327, 64327], "mapped", [1511, 1468]],
      [[64328, 64328], "mapped", [1512, 1468]],
      [[64329, 64329], "mapped", [1513, 1468]],
      [[64330, 64330], "mapped", [1514, 1468]],
      [[64331, 64331], "mapped", [1493, 1465]],
      [[64332, 64332], "mapped", [1489, 1471]],
      [[64333, 64333], "mapped", [1499, 1471]],
      [[64334, 64334], "mapped", [1508, 1471]],
      [[64335, 64335], "mapped", [1488, 1500]],
      [[64336, 64337], "mapped", [1649]],
      [[64338, 64341], "mapped", [1659]],
      [[64342, 64345], "mapped", [1662]],
      [[64346, 64349], "mapped", [1664]],
      [[64350, 64353], "mapped", [1658]],
      [[64354, 64357], "mapped", [1663]],
      [[64358, 64361], "mapped", [1657]],
      [[64362, 64365], "mapped", [1700]],
      [[64366, 64369], "mapped", [1702]],
      [[64370, 64373], "mapped", [1668]],
      [[64374, 64377], "mapped", [1667]],
      [[64378, 64381], "mapped", [1670]],
      [[64382, 64385], "mapped", [1671]],
      [[64386, 64387], "mapped", [1677]],
      [[64388, 64389], "mapped", [1676]],
      [[64390, 64391], "mapped", [1678]],
      [[64392, 64393], "mapped", [1672]],
      [[64394, 64395], "mapped", [1688]],
      [[64396, 64397], "mapped", [1681]],
      [[64398, 64401], "mapped", [1705]],
      [[64402, 64405], "mapped", [1711]],
      [[64406, 64409], "mapped", [1715]],
      [[64410, 64413], "mapped", [1713]],
      [[64414, 64415], "mapped", [1722]],
      [[64416, 64419], "mapped", [1723]],
      [[64420, 64421], "mapped", [1728]],
      [[64422, 64425], "mapped", [1729]],
      [[64426, 64429], "mapped", [1726]],
      [[64430, 64431], "mapped", [1746]],
      [[64432, 64433], "mapped", [1747]],
      [[64434, 64449], "valid", [], "NV8"],
      [[64450, 64466], "disallowed"],
      [[64467, 64470], "mapped", [1709]],
      [[64471, 64472], "mapped", [1735]],
      [[64473, 64474], "mapped", [1734]],
      [[64475, 64476], "mapped", [1736]],
      [[64477, 64477], "mapped", [1735, 1652]],
      [[64478, 64479], "mapped", [1739]],
      [[64480, 64481], "mapped", [1733]],
      [[64482, 64483], "mapped", [1737]],
      [[64484, 64487], "mapped", [1744]],
      [[64488, 64489], "mapped", [1609]],
      [[64490, 64491], "mapped", [1574, 1575]],
      [[64492, 64493], "mapped", [1574, 1749]],
      [[64494, 64495], "mapped", [1574, 1608]],
      [[64496, 64497], "mapped", [1574, 1735]],
      [[64498, 64499], "mapped", [1574, 1734]],
      [[64500, 64501], "mapped", [1574, 1736]],
      [[64502, 64504], "mapped", [1574, 1744]],
      [[64505, 64507], "mapped", [1574, 1609]],
      [[64508, 64511], "mapped", [1740]],
      [[64512, 64512], "mapped", [1574, 1580]],
      [[64513, 64513], "mapped", [1574, 1581]],
      [[64514, 64514], "mapped", [1574, 1605]],
      [[64515, 64515], "mapped", [1574, 1609]],
      [[64516, 64516], "mapped", [1574, 1610]],
      [[64517, 64517], "mapped", [1576, 1580]],
      [[64518, 64518], "mapped", [1576, 1581]],
      [[64519, 64519], "mapped", [1576, 1582]],
      [[64520, 64520], "mapped", [1576, 1605]],
      [[64521, 64521], "mapped", [1576, 1609]],
      [[64522, 64522], "mapped", [1576, 1610]],
      [[64523, 64523], "mapped", [1578, 1580]],
      [[64524, 64524], "mapped", [1578, 1581]],
      [[64525, 64525], "mapped", [1578, 1582]],
      [[64526, 64526], "mapped", [1578, 1605]],
      [[64527, 64527], "mapped", [1578, 1609]],
      [[64528, 64528], "mapped", [1578, 1610]],
      [[64529, 64529], "mapped", [1579, 1580]],
      [[64530, 64530], "mapped", [1579, 1605]],
      [[64531, 64531], "mapped", [1579, 1609]],
      [[64532, 64532], "mapped", [1579, 1610]],
      [[64533, 64533], "mapped", [1580, 1581]],
      [[64534, 64534], "mapped", [1580, 1605]],
      [[64535, 64535], "mapped", [1581, 1580]],
      [[64536, 64536], "mapped", [1581, 1605]],
      [[64537, 64537], "mapped", [1582, 1580]],
      [[64538, 64538], "mapped", [1582, 1581]],
      [[64539, 64539], "mapped", [1582, 1605]],
      [[64540, 64540], "mapped", [1587, 1580]],
      [[64541, 64541], "mapped", [1587, 1581]],
      [[64542, 64542], "mapped", [1587, 1582]],
      [[64543, 64543], "mapped", [1587, 1605]],
      [[64544, 64544], "mapped", [1589, 1581]],
      [[64545, 64545], "mapped", [1589, 1605]],
      [[64546, 64546], "mapped", [1590, 1580]],
      [[64547, 64547], "mapped", [1590, 1581]],
      [[64548, 64548], "mapped", [1590, 1582]],
      [[64549, 64549], "mapped", [1590, 1605]],
      [[64550, 64550], "mapped", [1591, 1581]],
      [[64551, 64551], "mapped", [1591, 1605]],
      [[64552, 64552], "mapped", [1592, 1605]],
      [[64553, 64553], "mapped", [1593, 1580]],
      [[64554, 64554], "mapped", [1593, 1605]],
      [[64555, 64555], "mapped", [1594, 1580]],
      [[64556, 64556], "mapped", [1594, 1605]],
      [[64557, 64557], "mapped", [1601, 1580]],
      [[64558, 64558], "mapped", [1601, 1581]],
      [[64559, 64559], "mapped", [1601, 1582]],
      [[64560, 64560], "mapped", [1601, 1605]],
      [[64561, 64561], "mapped", [1601, 1609]],
      [[64562, 64562], "mapped", [1601, 1610]],
      [[64563, 64563], "mapped", [1602, 1581]],
      [[64564, 64564], "mapped", [1602, 1605]],
      [[64565, 64565], "mapped", [1602, 1609]],
      [[64566, 64566], "mapped", [1602, 1610]],
      [[64567, 64567], "mapped", [1603, 1575]],
      [[64568, 64568], "mapped", [1603, 1580]],
      [[64569, 64569], "mapped", [1603, 1581]],
      [[64570, 64570], "mapped", [1603, 1582]],
      [[64571, 64571], "mapped", [1603, 1604]],
      [[64572, 64572], "mapped", [1603, 1605]],
      [[64573, 64573], "mapped", [1603, 1609]],
      [[64574, 64574], "mapped", [1603, 1610]],
      [[64575, 64575], "mapped", [1604, 1580]],
      [[64576, 64576], "mapped", [1604, 1581]],
      [[64577, 64577], "mapped", [1604, 1582]],
      [[64578, 64578], "mapped", [1604, 1605]],
      [[64579, 64579], "mapped", [1604, 1609]],
      [[64580, 64580], "mapped", [1604, 1610]],
      [[64581, 64581], "mapped", [1605, 1580]],
      [[64582, 64582], "mapped", [1605, 1581]],
      [[64583, 64583], "mapped", [1605, 1582]],
      [[64584, 64584], "mapped", [1605, 1605]],
      [[64585, 64585], "mapped", [1605, 1609]],
      [[64586, 64586], "mapped", [1605, 1610]],
      [[64587, 64587], "mapped", [1606, 1580]],
      [[64588, 64588], "mapped", [1606, 1581]],
      [[64589, 64589], "mapped", [1606, 1582]],
      [[64590, 64590], "mapped", [1606, 1605]],
      [[64591, 64591], "mapped", [1606, 1609]],
      [[64592, 64592], "mapped", [1606, 1610]],
      [[64593, 64593], "mapped", [1607, 1580]],
      [[64594, 64594], "mapped", [1607, 1605]],
      [[64595, 64595], "mapped", [1607, 1609]],
      [[64596, 64596], "mapped", [1607, 1610]],
      [[64597, 64597], "mapped", [1610, 1580]],
      [[64598, 64598], "mapped", [1610, 1581]],
      [[64599, 64599], "mapped", [1610, 1582]],
      [[64600, 64600], "mapped", [1610, 1605]],
      [[64601, 64601], "mapped", [1610, 1609]],
      [[64602, 64602], "mapped", [1610, 1610]],
      [[64603, 64603], "mapped", [1584, 1648]],
      [[64604, 64604], "mapped", [1585, 1648]],
      [[64605, 64605], "mapped", [1609, 1648]],
      [[64606, 64606], "disallowed_STD3_mapped", [32, 1612, 1617]],
      [[64607, 64607], "disallowed_STD3_mapped", [32, 1613, 1617]],
      [[64608, 64608], "disallowed_STD3_mapped", [32, 1614, 1617]],
      [[64609, 64609], "disallowed_STD3_mapped", [32, 1615, 1617]],
      [[64610, 64610], "disallowed_STD3_mapped", [32, 1616, 1617]],
      [[64611, 64611], "disallowed_STD3_mapped", [32, 1617, 1648]],
      [[64612, 64612], "mapped", [1574, 1585]],
      [[64613, 64613], "mapped", [1574, 1586]],
      [[64614, 64614], "mapped", [1574, 1605]],
      [[64615, 64615], "mapped", [1574, 1606]],
      [[64616, 64616], "mapped", [1574, 1609]],
      [[64617, 64617], "mapped", [1574, 1610]],
      [[64618, 64618], "mapped", [1576, 1585]],
      [[64619, 64619], "mapped", [1576, 1586]],
      [[64620, 64620], "mapped", [1576, 1605]],
      [[64621, 64621], "mapped", [1576, 1606]],
      [[64622, 64622], "mapped", [1576, 1609]],
      [[64623, 64623], "mapped", [1576, 1610]],
      [[64624, 64624], "mapped", [1578, 1585]],
      [[64625, 64625], "mapped", [1578, 1586]],
      [[64626, 64626], "mapped", [1578, 1605]],
      [[64627, 64627], "mapped", [1578, 1606]],
      [[64628, 64628], "mapped", [1578, 1609]],
      [[64629, 64629], "mapped", [1578, 1610]],
      [[64630, 64630], "mapped", [1579, 1585]],
      [[64631, 64631], "mapped", [1579, 1586]],
      [[64632, 64632], "mapped", [1579, 1605]],
      [[64633, 64633], "mapped", [1579, 1606]],
      [[64634, 64634], "mapped", [1579, 1609]],
      [[64635, 64635], "mapped", [1579, 1610]],
      [[64636, 64636], "mapped", [1601, 1609]],
      [[64637, 64637], "mapped", [1601, 1610]],
      [[64638, 64638], "mapped", [1602, 1609]],
      [[64639, 64639], "mapped", [1602, 1610]],
      [[64640, 64640], "mapped", [1603, 1575]],
      [[64641, 64641], "mapped", [1603, 1604]],
      [[64642, 64642], "mapped", [1603, 1605]],
      [[64643, 64643], "mapped", [1603, 1609]],
      [[64644, 64644], "mapped", [1603, 1610]],
      [[64645, 64645], "mapped", [1604, 1605]],
      [[64646, 64646], "mapped", [1604, 1609]],
      [[64647, 64647], "mapped", [1604, 1610]],
      [[64648, 64648], "mapped", [1605, 1575]],
      [[64649, 64649], "mapped", [1605, 1605]],
      [[64650, 64650], "mapped", [1606, 1585]],
      [[64651, 64651], "mapped", [1606, 1586]],
      [[64652, 64652], "mapped", [1606, 1605]],
      [[64653, 64653], "mapped", [1606, 1606]],
      [[64654, 64654], "mapped", [1606, 1609]],
      [[64655, 64655], "mapped", [1606, 1610]],
      [[64656, 64656], "mapped", [1609, 1648]],
      [[64657, 64657], "mapped", [1610, 1585]],
      [[64658, 64658], "mapped", [1610, 1586]],
      [[64659, 64659], "mapped", [1610, 1605]],
      [[64660, 64660], "mapped", [1610, 1606]],
      [[64661, 64661], "mapped", [1610, 1609]],
      [[64662, 64662], "mapped", [1610, 1610]],
      [[64663, 64663], "mapped", [1574, 1580]],
      [[64664, 64664], "mapped", [1574, 1581]],
      [[64665, 64665], "mapped", [1574, 1582]],
      [[64666, 64666], "mapped", [1574, 1605]],
      [[64667, 64667], "mapped", [1574, 1607]],
      [[64668, 64668], "mapped", [1576, 1580]],
      [[64669, 64669], "mapped", [1576, 1581]],
      [[64670, 64670], "mapped", [1576, 1582]],
      [[64671, 64671], "mapped", [1576, 1605]],
      [[64672, 64672], "mapped", [1576, 1607]],
      [[64673, 64673], "mapped", [1578, 1580]],
      [[64674, 64674], "mapped", [1578, 1581]],
      [[64675, 64675], "mapped", [1578, 1582]],
      [[64676, 64676], "mapped", [1578, 1605]],
      [[64677, 64677], "mapped", [1578, 1607]],
      [[64678, 64678], "mapped", [1579, 1605]],
      [[64679, 64679], "mapped", [1580, 1581]],
      [[64680, 64680], "mapped", [1580, 1605]],
      [[64681, 64681], "mapped", [1581, 1580]],
      [[64682, 64682], "mapped", [1581, 1605]],
      [[64683, 64683], "mapped", [1582, 1580]],
      [[64684, 64684], "mapped", [1582, 1605]],
      [[64685, 64685], "mapped", [1587, 1580]],
      [[64686, 64686], "mapped", [1587, 1581]],
      [[64687, 64687], "mapped", [1587, 1582]],
      [[64688, 64688], "mapped", [1587, 1605]],
      [[64689, 64689], "mapped", [1589, 1581]],
      [[64690, 64690], "mapped", [1589, 1582]],
      [[64691, 64691], "mapped", [1589, 1605]],
      [[64692, 64692], "mapped", [1590, 1580]],
      [[64693, 64693], "mapped", [1590, 1581]],
      [[64694, 64694], "mapped", [1590, 1582]],
      [[64695, 64695], "mapped", [1590, 1605]],
      [[64696, 64696], "mapped", [1591, 1581]],
      [[64697, 64697], "mapped", [1592, 1605]],
      [[64698, 64698], "mapped", [1593, 1580]],
      [[64699, 64699], "mapped", [1593, 1605]],
      [[64700, 64700], "mapped", [1594, 1580]],
      [[64701, 64701], "mapped", [1594, 1605]],
      [[64702, 64702], "mapped", [1601, 1580]],
      [[64703, 64703], "mapped", [1601, 1581]],
      [[64704, 64704], "mapped", [1601, 1582]],
      [[64705, 64705], "mapped", [1601, 1605]],
      [[64706, 64706], "mapped", [1602, 1581]],
      [[64707, 64707], "mapped", [1602, 1605]],
      [[64708, 64708], "mapped", [1603, 1580]],
      [[64709, 64709], "mapped", [1603, 1581]],
      [[64710, 64710], "mapped", [1603, 1582]],
      [[64711, 64711], "mapped", [1603, 1604]],
      [[64712, 64712], "mapped", [1603, 1605]],
      [[64713, 64713], "mapped", [1604, 1580]],
      [[64714, 64714], "mapped", [1604, 1581]],
      [[64715, 64715], "mapped", [1604, 1582]],
      [[64716, 64716], "mapped", [1604, 1605]],
      [[64717, 64717], "mapped", [1604, 1607]],
      [[64718, 64718], "mapped", [1605, 1580]],
      [[64719, 64719], "mapped", [1605, 1581]],
      [[64720, 64720], "mapped", [1605, 1582]],
      [[64721, 64721], "mapped", [1605, 1605]],
      [[64722, 64722], "mapped", [1606, 1580]],
      [[64723, 64723], "mapped", [1606, 1581]],
      [[64724, 64724], "mapped", [1606, 1582]],
      [[64725, 64725], "mapped", [1606, 1605]],
      [[64726, 64726], "mapped", [1606, 1607]],
      [[64727, 64727], "mapped", [1607, 1580]],
      [[64728, 64728], "mapped", [1607, 1605]],
      [[64729, 64729], "mapped", [1607, 1648]],
      [[64730, 64730], "mapped", [1610, 1580]],
      [[64731, 64731], "mapped", [1610, 1581]],
      [[64732, 64732], "mapped", [1610, 1582]],
      [[64733, 64733], "mapped", [1610, 1605]],
      [[64734, 64734], "mapped", [1610, 1607]],
      [[64735, 64735], "mapped", [1574, 1605]],
      [[64736, 64736], "mapped", [1574, 1607]],
      [[64737, 64737], "mapped", [1576, 1605]],
      [[64738, 64738], "mapped", [1576, 1607]],
      [[64739, 64739], "mapped", [1578, 1605]],
      [[64740, 64740], "mapped", [1578, 1607]],
      [[64741, 64741], "mapped", [1579, 1605]],
      [[64742, 64742], "mapped", [1579, 1607]],
      [[64743, 64743], "mapped", [1587, 1605]],
      [[64744, 64744], "mapped", [1587, 1607]],
      [[64745, 64745], "mapped", [1588, 1605]],
      [[64746, 64746], "mapped", [1588, 1607]],
      [[64747, 64747], "mapped", [1603, 1604]],
      [[64748, 64748], "mapped", [1603, 1605]],
      [[64749, 64749], "mapped", [1604, 1605]],
      [[64750, 64750], "mapped", [1606, 1605]],
      [[64751, 64751], "mapped", [1606, 1607]],
      [[64752, 64752], "mapped", [1610, 1605]],
      [[64753, 64753], "mapped", [1610, 1607]],
      [[64754, 64754], "mapped", [1600, 1614, 1617]],
      [[64755, 64755], "mapped", [1600, 1615, 1617]],
      [[64756, 64756], "mapped", [1600, 1616, 1617]],
      [[64757, 64757], "mapped", [1591, 1609]],
      [[64758, 64758], "mapped", [1591, 1610]],
      [[64759, 64759], "mapped", [1593, 1609]],
      [[64760, 64760], "mapped", [1593, 1610]],
      [[64761, 64761], "mapped", [1594, 1609]],
      [[64762, 64762], "mapped", [1594, 1610]],
      [[64763, 64763], "mapped", [1587, 1609]],
      [[64764, 64764], "mapped", [1587, 1610]],
      [[64765, 64765], "mapped", [1588, 1609]],
      [[64766, 64766], "mapped", [1588, 1610]],
      [[64767, 64767], "mapped", [1581, 1609]],
      [[64768, 64768], "mapped", [1581, 1610]],
      [[64769, 64769], "mapped", [1580, 1609]],
      [[64770, 64770], "mapped", [1580, 1610]],
      [[64771, 64771], "mapped", [1582, 1609]],
      [[64772, 64772], "mapped", [1582, 1610]],
      [[64773, 64773], "mapped", [1589, 1609]],
      [[64774, 64774], "mapped", [1589, 1610]],
      [[64775, 64775], "mapped", [1590, 1609]],
      [[64776, 64776], "mapped", [1590, 1610]],
      [[64777, 64777], "mapped", [1588, 1580]],
      [[64778, 64778], "mapped", [1588, 1581]],
      [[64779, 64779], "mapped", [1588, 1582]],
      [[64780, 64780], "mapped", [1588, 1605]],
      [[64781, 64781], "mapped", [1588, 1585]],
      [[64782, 64782], "mapped", [1587, 1585]],
      [[64783, 64783], "mapped", [1589, 1585]],
      [[64784, 64784], "mapped", [1590, 1585]],
      [[64785, 64785], "mapped", [1591, 1609]],
      [[64786, 64786], "mapped", [1591, 1610]],
      [[64787, 64787], "mapped", [1593, 1609]],
      [[64788, 64788], "mapped", [1593, 1610]],
      [[64789, 64789], "mapped", [1594, 1609]],
      [[64790, 64790], "mapped", [1594, 1610]],
      [[64791, 64791], "mapped", [1587, 1609]],
      [[64792, 64792], "mapped", [1587, 1610]],
      [[64793, 64793], "mapped", [1588, 1609]],
      [[64794, 64794], "mapped", [1588, 1610]],
      [[64795, 64795], "mapped", [1581, 1609]],
      [[64796, 64796], "mapped", [1581, 1610]],
      [[64797, 64797], "mapped", [1580, 1609]],
      [[64798, 64798], "mapped", [1580, 1610]],
      [[64799, 64799], "mapped", [1582, 1609]],
      [[64800, 64800], "mapped", [1582, 1610]],
      [[64801, 64801], "mapped", [1589, 1609]],
      [[64802, 64802], "mapped", [1589, 1610]],
      [[64803, 64803], "mapped", [1590, 1609]],
      [[64804, 64804], "mapped", [1590, 1610]],
      [[64805, 64805], "mapped", [1588, 1580]],
      [[64806, 64806], "mapped", [1588, 1581]],
      [[64807, 64807], "mapped", [1588, 1582]],
      [[64808, 64808], "mapped", [1588, 1605]],
      [[64809, 64809], "mapped", [1588, 1585]],
      [[64810, 64810], "mapped", [1587, 1585]],
      [[64811, 64811], "mapped", [1589, 1585]],
      [[64812, 64812], "mapped", [1590, 1585]],
      [[64813, 64813], "mapped", [1588, 1580]],
      [[64814, 64814], "mapped", [1588, 1581]],
      [[64815, 64815], "mapped", [1588, 1582]],
      [[64816, 64816], "mapped", [1588, 1605]],
      [[64817, 64817], "mapped", [1587, 1607]],
      [[64818, 64818], "mapped", [1588, 1607]],
      [[64819, 64819], "mapped", [1591, 1605]],
      [[64820, 64820], "mapped", [1587, 1580]],
      [[64821, 64821], "mapped", [1587, 1581]],
      [[64822, 64822], "mapped", [1587, 1582]],
      [[64823, 64823], "mapped", [1588, 1580]],
      [[64824, 64824], "mapped", [1588, 1581]],
      [[64825, 64825], "mapped", [1588, 1582]],
      [[64826, 64826], "mapped", [1591, 1605]],
      [[64827, 64827], "mapped", [1592, 1605]],
      [[64828, 64829], "mapped", [1575, 1611]],
      [[64830, 64831], "valid", [], "NV8"],
      [[64832, 64847], "disallowed"],
      [[64848, 64848], "mapped", [1578, 1580, 1605]],
      [[64849, 64850], "mapped", [1578, 1581, 1580]],
      [[64851, 64851], "mapped", [1578, 1581, 1605]],
      [[64852, 64852], "mapped", [1578, 1582, 1605]],
      [[64853, 64853], "mapped", [1578, 1605, 1580]],
      [[64854, 64854], "mapped", [1578, 1605, 1581]],
      [[64855, 64855], "mapped", [1578, 1605, 1582]],
      [[64856, 64857], "mapped", [1580, 1605, 1581]],
      [[64858, 64858], "mapped", [1581, 1605, 1610]],
      [[64859, 64859], "mapped", [1581, 1605, 1609]],
      [[64860, 64860], "mapped", [1587, 1581, 1580]],
      [[64861, 64861], "mapped", [1587, 1580, 1581]],
      [[64862, 64862], "mapped", [1587, 1580, 1609]],
      [[64863, 64864], "mapped", [1587, 1605, 1581]],
      [[64865, 64865], "mapped", [1587, 1605, 1580]],
      [[64866, 64867], "mapped", [1587, 1605, 1605]],
      [[64868, 64869], "mapped", [1589, 1581, 1581]],
      [[64870, 64870], "mapped", [1589, 1605, 1605]],
      [[64871, 64872], "mapped", [1588, 1581, 1605]],
      [[64873, 64873], "mapped", [1588, 1580, 1610]],
      [[64874, 64875], "mapped", [1588, 1605, 1582]],
      [[64876, 64877], "mapped", [1588, 1605, 1605]],
      [[64878, 64878], "mapped", [1590, 1581, 1609]],
      [[64879, 64880], "mapped", [1590, 1582, 1605]],
      [[64881, 64882], "mapped", [1591, 1605, 1581]],
      [[64883, 64883], "mapped", [1591, 1605, 1605]],
      [[64884, 64884], "mapped", [1591, 1605, 1610]],
      [[64885, 64885], "mapped", [1593, 1580, 1605]],
      [[64886, 64887], "mapped", [1593, 1605, 1605]],
      [[64888, 64888], "mapped", [1593, 1605, 1609]],
      [[64889, 64889], "mapped", [1594, 1605, 1605]],
      [[64890, 64890], "mapped", [1594, 1605, 1610]],
      [[64891, 64891], "mapped", [1594, 1605, 1609]],
      [[64892, 64893], "mapped", [1601, 1582, 1605]],
      [[64894, 64894], "mapped", [1602, 1605, 1581]],
      [[64895, 64895], "mapped", [1602, 1605, 1605]],
      [[64896, 64896], "mapped", [1604, 1581, 1605]],
      [[64897, 64897], "mapped", [1604, 1581, 1610]],
      [[64898, 64898], "mapped", [1604, 1581, 1609]],
      [[64899, 64900], "mapped", [1604, 1580, 1580]],
      [[64901, 64902], "mapped", [1604, 1582, 1605]],
      [[64903, 64904], "mapped", [1604, 1605, 1581]],
      [[64905, 64905], "mapped", [1605, 1581, 1580]],
      [[64906, 64906], "mapped", [1605, 1581, 1605]],
      [[64907, 64907], "mapped", [1605, 1581, 1610]],
      [[64908, 64908], "mapped", [1605, 1580, 1581]],
      [[64909, 64909], "mapped", [1605, 1580, 1605]],
      [[64910, 64910], "mapped", [1605, 1582, 1580]],
      [[64911, 64911], "mapped", [1605, 1582, 1605]],
      [[64912, 64913], "disallowed"],
      [[64914, 64914], "mapped", [1605, 1580, 1582]],
      [[64915, 64915], "mapped", [1607, 1605, 1580]],
      [[64916, 64916], "mapped", [1607, 1605, 1605]],
      [[64917, 64917], "mapped", [1606, 1581, 1605]],
      [[64918, 64918], "mapped", [1606, 1581, 1609]],
      [[64919, 64920], "mapped", [1606, 1580, 1605]],
      [[64921, 64921], "mapped", [1606, 1580, 1609]],
      [[64922, 64922], "mapped", [1606, 1605, 1610]],
      [[64923, 64923], "mapped", [1606, 1605, 1609]],
      [[64924, 64925], "mapped", [1610, 1605, 1605]],
      [[64926, 64926], "mapped", [1576, 1582, 1610]],
      [[64927, 64927], "mapped", [1578, 1580, 1610]],
      [[64928, 64928], "mapped", [1578, 1580, 1609]],
      [[64929, 64929], "mapped", [1578, 1582, 1610]],
      [[64930, 64930], "mapped", [1578, 1582, 1609]],
      [[64931, 64931], "mapped", [1578, 1605, 1610]],
      [[64932, 64932], "mapped", [1578, 1605, 1609]],
      [[64933, 64933], "mapped", [1580, 1605, 1610]],
      [[64934, 64934], "mapped", [1580, 1581, 1609]],
      [[64935, 64935], "mapped", [1580, 1605, 1609]],
      [[64936, 64936], "mapped", [1587, 1582, 1609]],
      [[64937, 64937], "mapped", [1589, 1581, 1610]],
      [[64938, 64938], "mapped", [1588, 1581, 1610]],
      [[64939, 64939], "mapped", [1590, 1581, 1610]],
      [[64940, 64940], "mapped", [1604, 1580, 1610]],
      [[64941, 64941], "mapped", [1604, 1605, 1610]],
      [[64942, 64942], "mapped", [1610, 1581, 1610]],
      [[64943, 64943], "mapped", [1610, 1580, 1610]],
      [[64944, 64944], "mapped", [1610, 1605, 1610]],
      [[64945, 64945], "mapped", [1605, 1605, 1610]],
      [[64946, 64946], "mapped", [1602, 1605, 1610]],
      [[64947, 64947], "mapped", [1606, 1581, 1610]],
      [[64948, 64948], "mapped", [1602, 1605, 1581]],
      [[64949, 64949], "mapped", [1604, 1581, 1605]],
      [[64950, 64950], "mapped", [1593, 1605, 1610]],
      [[64951, 64951], "mapped", [1603, 1605, 1610]],
      [[64952, 64952], "mapped", [1606, 1580, 1581]],
      [[64953, 64953], "mapped", [1605, 1582, 1610]],
      [[64954, 64954], "mapped", [1604, 1580, 1605]],
      [[64955, 64955], "mapped", [1603, 1605, 1605]],
      [[64956, 64956], "mapped", [1604, 1580, 1605]],
      [[64957, 64957], "mapped", [1606, 1580, 1581]],
      [[64958, 64958], "mapped", [1580, 1581, 1610]],
      [[64959, 64959], "mapped", [1581, 1580, 1610]],
      [[64960, 64960], "mapped", [1605, 1580, 1610]],
      [[64961, 64961], "mapped", [1601, 1605, 1610]],
      [[64962, 64962], "mapped", [1576, 1581, 1610]],
      [[64963, 64963], "mapped", [1603, 1605, 1605]],
      [[64964, 64964], "mapped", [1593, 1580, 1605]],
      [[64965, 64965], "mapped", [1589, 1605, 1605]],
      [[64966, 64966], "mapped", [1587, 1582, 1610]],
      [[64967, 64967], "mapped", [1606, 1580, 1610]],
      [[64968, 64975], "disallowed"],
      [[64976, 65007], "disallowed"],
      [[65008, 65008], "mapped", [1589, 1604, 1746]],
      [[65009, 65009], "mapped", [1602, 1604, 1746]],
      [[65010, 65010], "mapped", [1575, 1604, 1604, 1607]],
      [[65011, 65011], "mapped", [1575, 1603, 1576, 1585]],
      [[65012, 65012], "mapped", [1605, 1581, 1605, 1583]],
      [[65013, 65013], "mapped", [1589, 1604, 1593, 1605]],
      [[65014, 65014], "mapped", [1585, 1587, 1608, 1604]],
      [[65015, 65015], "mapped", [1593, 1604, 1610, 1607]],
      [[65016, 65016], "mapped", [1608, 1587, 1604, 1605]],
      [[65017, 65017], "mapped", [1589, 1604, 1609]],
      [
        [65018, 65018],
        "disallowed_STD3_mapped",
        [
          1589, 1604, 1609, 32, 1575, 1604, 1604, 1607, 32, 1593, 1604, 1610,
          1607, 32, 1608, 1587, 1604, 1605,
        ],
      ],
      [
        [65019, 65019],
        "disallowed_STD3_mapped",
        [1580, 1604, 32, 1580, 1604, 1575, 1604, 1607],
      ],
      [[65020, 65020], "mapped", [1585, 1740, 1575, 1604]],
      [[65021, 65021], "valid", [], "NV8"],
      [[65022, 65023], "disallowed"],
      [[65024, 65039], "ignored"],
      [[65040, 65040], "disallowed_STD3_mapped", [44]],
      [[65041, 65041], "mapped", [12289]],
      [[65042, 65042], "disallowed"],
      [[65043, 65043], "disallowed_STD3_mapped", [58]],
      [[65044, 65044], "disallowed_STD3_mapped", [59]],
      [[65045, 65045], "disallowed_STD3_mapped", [33]],
      [[65046, 65046], "disallowed_STD3_mapped", [63]],
      [[65047, 65047], "mapped", [12310]],
      [[65048, 65048], "mapped", [12311]],
      [[65049, 65049], "disallowed"],
      [[65050, 65055], "disallowed"],
      [[65056, 65059], "valid"],
      [[65060, 65062], "valid"],
      [[65063, 65069], "valid"],
      [[65070, 65071], "valid"],
      [[65072, 65072], "disallowed"],
      [[65073, 65073], "mapped", [8212]],
      [[65074, 65074], "mapped", [8211]],
      [[65075, 65076], "disallowed_STD3_mapped", [95]],
      [[65077, 65077], "disallowed_STD3_mapped", [40]],
      [[65078, 65078], "disallowed_STD3_mapped", [41]],
      [[65079, 65079], "disallowed_STD3_mapped", [123]],
      [[65080, 65080], "disallowed_STD3_mapped", [125]],
      [[65081, 65081], "mapped", [12308]],
      [[65082, 65082], "mapped", [12309]],
      [[65083, 65083], "mapped", [12304]],
      [[65084, 65084], "mapped", [12305]],
      [[65085, 65085], "mapped", [12298]],
      [[65086, 65086], "mapped", [12299]],
      [[65087, 65087], "mapped", [12296]],
      [[65088, 65088], "mapped", [12297]],
      [[65089, 65089], "mapped", [12300]],
      [[65090, 65090], "mapped", [12301]],
      [[65091, 65091], "mapped", [12302]],
      [[65092, 65092], "mapped", [12303]],
      [[65093, 65094], "valid", [], "NV8"],
      [[65095, 65095], "disallowed_STD3_mapped", [91]],
      [[65096, 65096], "disallowed_STD3_mapped", [93]],
      [[65097, 65100], "disallowed_STD3_mapped", [32, 773]],
      [[65101, 65103], "disallowed_STD3_mapped", [95]],
      [[65104, 65104], "disallowed_STD3_mapped", [44]],
      [[65105, 65105], "mapped", [12289]],
      [[65106, 65106], "disallowed"],
      [[65107, 65107], "disallowed"],
      [[65108, 65108], "disallowed_STD3_mapped", [59]],
      [[65109, 65109], "disallowed_STD3_mapped", [58]],
      [[65110, 65110], "disallowed_STD3_mapped", [63]],
      [[65111, 65111], "disallowed_STD3_mapped", [33]],
      [[65112, 65112], "mapped", [8212]],
      [[65113, 65113], "disallowed_STD3_mapped", [40]],
      [[65114, 65114], "disallowed_STD3_mapped", [41]],
      [[65115, 65115], "disallowed_STD3_mapped", [123]],
      [[65116, 65116], "disallowed_STD3_mapped", [125]],
      [[65117, 65117], "mapped", [12308]],
      [[65118, 65118], "mapped", [12309]],
      [[65119, 65119], "disallowed_STD3_mapped", [35]],
      [[65120, 65120], "disallowed_STD3_mapped", [38]],
      [[65121, 65121], "disallowed_STD3_mapped", [42]],
      [[65122, 65122], "disallowed_STD3_mapped", [43]],
      [[65123, 65123], "mapped", [45]],
      [[65124, 65124], "disallowed_STD3_mapped", [60]],
      [[65125, 65125], "disallowed_STD3_mapped", [62]],
      [[65126, 65126], "disallowed_STD3_mapped", [61]],
      [[65127, 65127], "disallowed"],
      [[65128, 65128], "disallowed_STD3_mapped", [92]],
      [[65129, 65129], "disallowed_STD3_mapped", [36]],
      [[65130, 65130], "disallowed_STD3_mapped", [37]],
      [[65131, 65131], "disallowed_STD3_mapped", [64]],
      [[65132, 65135], "disallowed"],
      [[65136, 65136], "disallowed_STD3_mapped", [32, 1611]],
      [[65137, 65137], "mapped", [1600, 1611]],
      [[65138, 65138], "disallowed_STD3_mapped", [32, 1612]],
      [[65139, 65139], "valid"],
      [[65140, 65140], "disallowed_STD3_mapped", [32, 1613]],
      [[65141, 65141], "disallowed"],
      [[65142, 65142], "disallowed_STD3_mapped", [32, 1614]],
      [[65143, 65143], "mapped", [1600, 1614]],
      [[65144, 65144], "disallowed_STD3_mapped", [32, 1615]],
      [[65145, 65145], "mapped", [1600, 1615]],
      [[65146, 65146], "disallowed_STD3_mapped", [32, 1616]],
      [[65147, 65147], "mapped", [1600, 1616]],
      [[65148, 65148], "disallowed_STD3_mapped", [32, 1617]],
      [[65149, 65149], "mapped", [1600, 1617]],
      [[65150, 65150], "disallowed_STD3_mapped", [32, 1618]],
      [[65151, 65151], "mapped", [1600, 1618]],
      [[65152, 65152], "mapped", [1569]],
      [[65153, 65154], "mapped", [1570]],
      [[65155, 65156], "mapped", [1571]],
      [[65157, 65158], "mapped", [1572]],
      [[65159, 65160], "mapped", [1573]],
      [[65161, 65164], "mapped", [1574]],
      [[65165, 65166], "mapped", [1575]],
      [[65167, 65170], "mapped", [1576]],
      [[65171, 65172], "mapped", [1577]],
      [[65173, 65176], "mapped", [1578]],
      [[65177, 65180], "mapped", [1579]],
      [[65181, 65184], "mapped", [1580]],
      [[65185, 65188], "mapped", [1581]],
      [[65189, 65192], "mapped", [1582]],
      [[65193, 65194], "mapped", [1583]],
      [[65195, 65196], "mapped", [1584]],
      [[65197, 65198], "mapped", [1585]],
      [[65199, 65200], "mapped", [1586]],
      [[65201, 65204], "mapped", [1587]],
      [[65205, 65208], "mapped", [1588]],
      [[65209, 65212], "mapped", [1589]],
      [[65213, 65216], "mapped", [1590]],
      [[65217, 65220], "mapped", [1591]],
      [[65221, 65224], "mapped", [1592]],
      [[65225, 65228], "mapped", [1593]],
      [[65229, 65232], "mapped", [1594]],
      [[65233, 65236], "mapped", [1601]],
      [[65237, 65240], "mapped", [1602]],
      [[65241, 65244], "mapped", [1603]],
      [[65245, 65248], "mapped", [1604]],
      [[65249, 65252], "mapped", [1605]],
      [[65253, 65256], "mapped", [1606]],
      [[65257, 65260], "mapped", [1607]],
      [[65261, 65262], "mapped", [1608]],
      [[65263, 65264], "mapped", [1609]],
      [[65265, 65268], "mapped", [1610]],
      [[65269, 65270], "mapped", [1604, 1570]],
      [[65271, 65272], "mapped", [1604, 1571]],
      [[65273, 65274], "mapped", [1604, 1573]],
      [[65275, 65276], "mapped", [1604, 1575]],
      [[65277, 65278], "disallowed"],
      [[65279, 65279], "ignored"],
      [[65280, 65280], "disallowed"],
      [[65281, 65281], "disallowed_STD3_mapped", [33]],
      [[65282, 65282], "disallowed_STD3_mapped", [34]],
      [[65283, 65283], "disallowed_STD3_mapped", [35]],
      [[65284, 65284], "disallowed_STD3_mapped", [36]],
      [[65285, 65285], "disallowed_STD3_mapped", [37]],
      [[65286, 65286], "disallowed_STD3_mapped", [38]],
      [[65287, 65287], "disallowed_STD3_mapped", [39]],
      [[65288, 65288], "disallowed_STD3_mapped", [40]],
      [[65289, 65289], "disallowed_STD3_mapped", [41]],
      [[65290, 65290], "disallowed_STD3_mapped", [42]],
      [[65291, 65291], "disallowed_STD3_mapped", [43]],
      [[65292, 65292], "disallowed_STD3_mapped", [44]],
      [[65293, 65293], "mapped", [45]],
      [[65294, 65294], "mapped", [46]],
      [[65295, 65295], "disallowed_STD3_mapped", [47]],
      [[65296, 65296], "mapped", [48]],
      [[65297, 65297], "mapped", [49]],
      [[65298, 65298], "mapped", [50]],
      [[65299, 65299], "mapped", [51]],
      [[65300, 65300], "mapped", [52]],
      [[65301, 65301], "mapped", [53]],
      [[65302, 65302], "mapped", [54]],
      [[65303, 65303], "mapped", [55]],
      [[65304, 65304], "mapped", [56]],
      [[65305, 65305], "mapped", [57]],
      [[65306, 65306], "disallowed_STD3_mapped", [58]],
      [[65307, 65307], "disallowed_STD3_mapped", [59]],
      [[65308, 65308], "disallowed_STD3_mapped", [60]],
      [[65309, 65309], "disallowed_STD3_mapped", [61]],
      [[65310, 65310], "disallowed_STD3_mapped", [62]],
      [[65311, 65311], "disallowed_STD3_mapped", [63]],
      [[65312, 65312], "disallowed_STD3_mapped", [64]],
      [[65313, 65313], "mapped", [97]],
      [[65314, 65314], "mapped", [98]],
      [[65315, 65315], "mapped", [99]],
      [[65316, 65316], "mapped", [100]],
      [[65317, 65317], "mapped", [101]],
      [[65318, 65318], "mapped", [102]],
      [[65319, 65319], "mapped", [103]],
      [[65320, 65320], "mapped", [104]],
      [[65321, 65321], "mapped", [105]],
      [[65322, 65322], "mapped", [106]],
      [[65323, 65323], "mapped", [107]],
      [[65324, 65324], "mapped", [108]],
      [[65325, 65325], "mapped", [109]],
      [[65326, 65326], "mapped", [110]],
      [[65327, 65327], "mapped", [111]],
      [[65328, 65328], "mapped", [112]],
      [[65329, 65329], "mapped", [113]],
      [[65330, 65330], "mapped", [114]],
      [[65331, 65331], "mapped", [115]],
      [[65332, 65332], "mapped", [116]],
      [[65333, 65333], "mapped", [117]],
      [[65334, 65334], "mapped", [118]],
      [[65335, 65335], "mapped", [119]],
      [[65336, 65336], "mapped", [120]],
      [[65337, 65337], "mapped", [121]],
      [[65338, 65338], "mapped", [122]],
      [[65339, 65339], "disallowed_STD3_mapped", [91]],
      [[65340, 65340], "disallowed_STD3_mapped", [92]],
      [[65341, 65341], "disallowed_STD3_mapped", [93]],
      [[65342, 65342], "disallowed_STD3_mapped", [94]],
      [[65343, 65343], "disallowed_STD3_mapped", [95]],
      [[65344, 65344], "disallowed_STD3_mapped", [96]],
      [[65345, 65345], "mapped", [97]],
      [[65346, 65346], "mapped", [98]],
      [[65347, 65347], "mapped", [99]],
      [[65348, 65348], "mapped", [100]],
      [[65349, 65349], "mapped", [101]],
      [[65350, 65350], "mapped", [102]],
      [[65351, 65351], "mapped", [103]],
      [[65352, 65352], "mapped", [104]],
      [[65353, 65353], "mapped", [105]],
      [[65354, 65354], "mapped", [106]],
      [[65355, 65355], "mapped", [107]],
      [[65356, 65356], "mapped", [108]],
      [[65357, 65357], "mapped", [109]],
      [[65358, 65358], "mapped", [110]],
      [[65359, 65359], "mapped", [111]],
      [[65360, 65360], "mapped", [112]],
      [[65361, 65361], "mapped", [113]],
      [[65362, 65362], "mapped", [114]],
      [[65363, 65363], "mapped", [115]],
      [[65364, 65364], "mapped", [116]],
      [[65365, 65365], "mapped", [117]],
      [[65366, 65366], "mapped", [118]],
      [[65367, 65367], "mapped", [119]],
      [[65368, 65368], "mapped", [120]],
      [[65369, 65369], "mapped", [121]],
      [[65370, 65370], "mapped", [122]],
      [[65371, 65371], "disallowed_STD3_mapped", [123]],
      [[65372, 65372], "disallowed_STD3_mapped", [124]],
      [[65373, 65373], "disallowed_STD3_mapped", [125]],
      [[65374, 65374], "disallowed_STD3_mapped", [126]],
      [[65375, 65375], "mapped", [10629]],
      [[65376, 65376], "mapped", [10630]],
      [[65377, 65377], "mapped", [46]],
      [[65378, 65378], "mapped", [12300]],
      [[65379, 65379], "mapped", [12301]],
      [[65380, 65380], "mapped", [12289]],
      [[65381, 65381], "mapped", [12539]],
      [[65382, 65382], "mapped", [12530]],
      [[65383, 65383], "mapped", [12449]],
      [[65384, 65384], "mapped", [12451]],
      [[65385, 65385], "mapped", [12453]],
      [[65386, 65386], "mapped", [12455]],
      [[65387, 65387], "mapped", [12457]],
      [[65388, 65388], "mapped", [12515]],
      [[65389, 65389], "mapped", [12517]],
      [[65390, 65390], "mapped", [12519]],
      [[65391, 65391], "mapped", [12483]],
      [[65392, 65392], "mapped", [12540]],
      [[65393, 65393], "mapped", [12450]],
      [[65394, 65394], "mapped", [12452]],
      [[65395, 65395], "mapped", [12454]],
      [[65396, 65396], "mapped", [12456]],
      [[65397, 65397], "mapped", [12458]],
      [[65398, 65398], "mapped", [12459]],
      [[65399, 65399], "mapped", [12461]],
      [[65400, 65400], "mapped", [12463]],
      [[65401, 65401], "mapped", [12465]],
      [[65402, 65402], "mapped", [12467]],
      [[65403, 65403], "mapped", [12469]],
      [[65404, 65404], "mapped", [12471]],
      [[65405, 65405], "mapped", [12473]],
      [[65406, 65406], "mapped", [12475]],
      [[65407, 65407], "mapped", [12477]],
      [[65408, 65408], "mapped", [12479]],
      [[65409, 65409], "mapped", [12481]],
      [[65410, 65410], "mapped", [12484]],
      [[65411, 65411], "mapped", [12486]],
      [[65412, 65412], "mapped", [12488]],
      [[65413, 65413], "mapped", [12490]],
      [[65414, 65414], "mapped", [12491]],
      [[65415, 65415], "mapped", [12492]],
      [[65416, 65416], "mapped", [12493]],
      [[65417, 65417], "mapped", [12494]],
      [[65418, 65418], "mapped", [12495]],
      [[65419, 65419], "mapped", [12498]],
      [[65420, 65420], "mapped", [12501]],
      [[65421, 65421], "mapped", [12504]],
      [[65422, 65422], "mapped", [12507]],
      [[65423, 65423], "mapped", [12510]],
      [[65424, 65424], "mapped", [12511]],
      [[65425, 65425], "mapped", [12512]],
      [[65426, 65426], "mapped", [12513]],
      [[65427, 65427], "mapped", [12514]],
      [[65428, 65428], "mapped", [12516]],
      [[65429, 65429], "mapped", [12518]],
      [[65430, 65430], "mapped", [12520]],
      [[65431, 65431], "mapped", [12521]],
      [[65432, 65432], "mapped", [12522]],
      [[65433, 65433], "mapped", [12523]],
      [[65434, 65434], "mapped", [12524]],
      [[65435, 65435], "mapped", [12525]],
      [[65436, 65436], "mapped", [12527]],
      [[65437, 65437], "mapped", [12531]],
      [[65438, 65438], "mapped", [12441]],
      [[65439, 65439], "mapped", [12442]],
      [[65440, 65440], "disallowed"],
      [[65441, 65441], "mapped", [4352]],
      [[65442, 65442], "mapped", [4353]],
      [[65443, 65443], "mapped", [4522]],
      [[65444, 65444], "mapped", [4354]],
      [[65445, 65445], "mapped", [4524]],
      [[65446, 65446], "mapped", [4525]],
      [[65447, 65447], "mapped", [4355]],
      [[65448, 65448], "mapped", [4356]],
      [[65449, 65449], "mapped", [4357]],
      [[65450, 65450], "mapped", [4528]],
      [[65451, 65451], "mapped", [4529]],
      [[65452, 65452], "mapped", [4530]],
      [[65453, 65453], "mapped", [4531]],
      [[65454, 65454], "mapped", [4532]],
      [[65455, 65455], "mapped", [4533]],
      [[65456, 65456], "mapped", [4378]],
      [[65457, 65457], "mapped", [4358]],
      [[65458, 65458], "mapped", [4359]],
      [[65459, 65459], "mapped", [4360]],
      [[65460, 65460], "mapped", [4385]],
      [[65461, 65461], "mapped", [4361]],
      [[65462, 65462], "mapped", [4362]],
      [[65463, 65463], "mapped", [4363]],
      [[65464, 65464], "mapped", [4364]],
      [[65465, 65465], "mapped", [4365]],
      [[65466, 65466], "mapped", [4366]],
      [[65467, 65467], "mapped", [4367]],
      [[65468, 65468], "mapped", [4368]],
      [[65469, 65469], "mapped", [4369]],
      [[65470, 65470], "mapped", [4370]],
      [[65471, 65473], "disallowed"],
      [[65474, 65474], "mapped", [4449]],
      [[65475, 65475], "mapped", [4450]],
      [[65476, 65476], "mapped", [4451]],
      [[65477, 65477], "mapped", [4452]],
      [[65478, 65478], "mapped", [4453]],
      [[65479, 65479], "mapped", [4454]],
      [[65480, 65481], "disallowed"],
      [[65482, 65482], "mapped", [4455]],
      [[65483, 65483], "mapped", [4456]],
      [[65484, 65484], "mapped", [4457]],
      [[65485, 65485], "mapped", [4458]],
      [[65486, 65486], "mapped", [4459]],
      [[65487, 65487], "mapped", [4460]],
      [[65488, 65489], "disallowed"],
      [[65490, 65490], "mapped", [4461]],
      [[65491, 65491], "mapped", [4462]],
      [[65492, 65492], "mapped", [4463]],
      [[65493, 65493], "mapped", [4464]],
      [[65494, 65494], "mapped", [4465]],
      [[65495, 65495], "mapped", [4466]],
      [[65496, 65497], "disallowed"],
      [[65498, 65498], "mapped", [4467]],
      [[65499, 65499], "mapped", [4468]],
      [[65500, 65500], "mapped", [4469]],
      [[65501, 65503], "disallowed"],
      [[65504, 65504], "mapped", [162]],
      [[65505, 65505], "mapped", [163]],
      [[65506, 65506], "mapped", [172]],
      [[65507, 65507], "disallowed_STD3_mapped", [32, 772]],
      [[65508, 65508], "mapped", [166]],
      [[65509, 65509], "mapped", [165]],
      [[65510, 65510], "mapped", [8361]],
      [[65511, 65511], "disallowed"],
      [[65512, 65512], "mapped", [9474]],
      [[65513, 65513], "mapped", [8592]],
      [[65514, 65514], "mapped", [8593]],
      [[65515, 65515], "mapped", [8594]],
      [[65516, 65516], "mapped", [8595]],
      [[65517, 65517], "mapped", [9632]],
      [[65518, 65518], "mapped", [9675]],
      [[65519, 65528], "disallowed"],
      [[65529, 65531], "disallowed"],
      [[65532, 65532], "disallowed"],
      [[65533, 65533], "disallowed"],
      [[65534, 65535], "disallowed"],
      [[65536, 65547], "valid"],
      [[65548, 65548], "disallowed"],
      [[65549, 65574], "valid"],
      [[65575, 65575], "disallowed"],
      [[65576, 65594], "valid"],
      [[65595, 65595], "disallowed"],
      [[65596, 65597], "valid"],
      [[65598, 65598], "disallowed"],
      [[65599, 65613], "valid"],
      [[65614, 65615], "disallowed"],
      [[65616, 65629], "valid"],
      [[65630, 65663], "disallowed"],
      [[65664, 65786], "valid"],
      [[65787, 65791], "disallowed"],
      [[65792, 65794], "valid", [], "NV8"],
      [[65795, 65798], "disallowed"],
      [[65799, 65843], "valid", [], "NV8"],
      [[65844, 65846], "disallowed"],
      [[65847, 65855], "valid", [], "NV8"],
      [[65856, 65930], "valid", [], "NV8"],
      [[65931, 65932], "valid", [], "NV8"],
      [[65933, 65935], "disallowed"],
      [[65936, 65947], "valid", [], "NV8"],
      [[65948, 65951], "disallowed"],
      [[65952, 65952], "valid", [], "NV8"],
      [[65953, 65999], "disallowed"],
      [[66e3, 66044], "valid", [], "NV8"],
      [[66045, 66045], "valid"],
      [[66046, 66175], "disallowed"],
      [[66176, 66204], "valid"],
      [[66205, 66207], "disallowed"],
      [[66208, 66256], "valid"],
      [[66257, 66271], "disallowed"],
      [[66272, 66272], "valid"],
      [[66273, 66299], "valid", [], "NV8"],
      [[66300, 66303], "disallowed"],
      [[66304, 66334], "valid"],
      [[66335, 66335], "valid"],
      [[66336, 66339], "valid", [], "NV8"],
      [[66340, 66351], "disallowed"],
      [[66352, 66368], "valid"],
      [[66369, 66369], "valid", [], "NV8"],
      [[66370, 66377], "valid"],
      [[66378, 66378], "valid", [], "NV8"],
      [[66379, 66383], "disallowed"],
      [[66384, 66426], "valid"],
      [[66427, 66431], "disallowed"],
      [[66432, 66461], "valid"],
      [[66462, 66462], "disallowed"],
      [[66463, 66463], "valid", [], "NV8"],
      [[66464, 66499], "valid"],
      [[66500, 66503], "disallowed"],
      [[66504, 66511], "valid"],
      [[66512, 66517], "valid", [], "NV8"],
      [[66518, 66559], "disallowed"],
      [[66560, 66560], "mapped", [66600]],
      [[66561, 66561], "mapped", [66601]],
      [[66562, 66562], "mapped", [66602]],
      [[66563, 66563], "mapped", [66603]],
      [[66564, 66564], "mapped", [66604]],
      [[66565, 66565], "mapped", [66605]],
      [[66566, 66566], "mapped", [66606]],
      [[66567, 66567], "mapped", [66607]],
      [[66568, 66568], "mapped", [66608]],
      [[66569, 66569], "mapped", [66609]],
      [[66570, 66570], "mapped", [66610]],
      [[66571, 66571], "mapped", [66611]],
      [[66572, 66572], "mapped", [66612]],
      [[66573, 66573], "mapped", [66613]],
      [[66574, 66574], "mapped", [66614]],
      [[66575, 66575], "mapped", [66615]],
      [[66576, 66576], "mapped", [66616]],
      [[66577, 66577], "mapped", [66617]],
      [[66578, 66578], "mapped", [66618]],
      [[66579, 66579], "mapped", [66619]],
      [[66580, 66580], "mapped", [66620]],
      [[66581, 66581], "mapped", [66621]],
      [[66582, 66582], "mapped", [66622]],
      [[66583, 66583], "mapped", [66623]],
      [[66584, 66584], "mapped", [66624]],
      [[66585, 66585], "mapped", [66625]],
      [[66586, 66586], "mapped", [66626]],
      [[66587, 66587], "mapped", [66627]],
      [[66588, 66588], "mapped", [66628]],
      [[66589, 66589], "mapped", [66629]],
      [[66590, 66590], "mapped", [66630]],
      [[66591, 66591], "mapped", [66631]],
      [[66592, 66592], "mapped", [66632]],
      [[66593, 66593], "mapped", [66633]],
      [[66594, 66594], "mapped", [66634]],
      [[66595, 66595], "mapped", [66635]],
      [[66596, 66596], "mapped", [66636]],
      [[66597, 66597], "mapped", [66637]],
      [[66598, 66598], "mapped", [66638]],
      [[66599, 66599], "mapped", [66639]],
      [[66600, 66637], "valid"],
      [[66638, 66717], "valid"],
      [[66718, 66719], "disallowed"],
      [[66720, 66729], "valid"],
      [[66730, 66815], "disallowed"],
      [[66816, 66855], "valid"],
      [[66856, 66863], "disallowed"],
      [[66864, 66915], "valid"],
      [[66916, 66926], "disallowed"],
      [[66927, 66927], "valid", [], "NV8"],
      [[66928, 67071], "disallowed"],
      [[67072, 67382], "valid"],
      [[67383, 67391], "disallowed"],
      [[67392, 67413], "valid"],
      [[67414, 67423], "disallowed"],
      [[67424, 67431], "valid"],
      [[67432, 67583], "disallowed"],
      [[67584, 67589], "valid"],
      [[67590, 67591], "disallowed"],
      [[67592, 67592], "valid"],
      [[67593, 67593], "disallowed"],
      [[67594, 67637], "valid"],
      [[67638, 67638], "disallowed"],
      [[67639, 67640], "valid"],
      [[67641, 67643], "disallowed"],
      [[67644, 67644], "valid"],
      [[67645, 67646], "disallowed"],
      [[67647, 67647], "valid"],
      [[67648, 67669], "valid"],
      [[67670, 67670], "disallowed"],
      [[67671, 67679], "valid", [], "NV8"],
      [[67680, 67702], "valid"],
      [[67703, 67711], "valid", [], "NV8"],
      [[67712, 67742], "valid"],
      [[67743, 67750], "disallowed"],
      [[67751, 67759], "valid", [], "NV8"],
      [[67760, 67807], "disallowed"],
      [[67808, 67826], "valid"],
      [[67827, 67827], "disallowed"],
      [[67828, 67829], "valid"],
      [[67830, 67834], "disallowed"],
      [[67835, 67839], "valid", [], "NV8"],
      [[67840, 67861], "valid"],
      [[67862, 67865], "valid", [], "NV8"],
      [[67866, 67867], "valid", [], "NV8"],
      [[67868, 67870], "disallowed"],
      [[67871, 67871], "valid", [], "NV8"],
      [[67872, 67897], "valid"],
      [[67898, 67902], "disallowed"],
      [[67903, 67903], "valid", [], "NV8"],
      [[67904, 67967], "disallowed"],
      [[67968, 68023], "valid"],
      [[68024, 68027], "disallowed"],
      [[68028, 68029], "valid", [], "NV8"],
      [[68030, 68031], "valid"],
      [[68032, 68047], "valid", [], "NV8"],
      [[68048, 68049], "disallowed"],
      [[68050, 68095], "valid", [], "NV8"],
      [[68096, 68099], "valid"],
      [[68100, 68100], "disallowed"],
      [[68101, 68102], "valid"],
      [[68103, 68107], "disallowed"],
      [[68108, 68115], "valid"],
      [[68116, 68116], "disallowed"],
      [[68117, 68119], "valid"],
      [[68120, 68120], "disallowed"],
      [[68121, 68147], "valid"],
      [[68148, 68151], "disallowed"],
      [[68152, 68154], "valid"],
      [[68155, 68158], "disallowed"],
      [[68159, 68159], "valid"],
      [[68160, 68167], "valid", [], "NV8"],
      [[68168, 68175], "disallowed"],
      [[68176, 68184], "valid", [], "NV8"],
      [[68185, 68191], "disallowed"],
      [[68192, 68220], "valid"],
      [[68221, 68223], "valid", [], "NV8"],
      [[68224, 68252], "valid"],
      [[68253, 68255], "valid", [], "NV8"],
      [[68256, 68287], "disallowed"],
      [[68288, 68295], "valid"],
      [[68296, 68296], "valid", [], "NV8"],
      [[68297, 68326], "valid"],
      [[68327, 68330], "disallowed"],
      [[68331, 68342], "valid", [], "NV8"],
      [[68343, 68351], "disallowed"],
      [[68352, 68405], "valid"],
      [[68406, 68408], "disallowed"],
      [[68409, 68415], "valid", [], "NV8"],
      [[68416, 68437], "valid"],
      [[68438, 68439], "disallowed"],
      [[68440, 68447], "valid", [], "NV8"],
      [[68448, 68466], "valid"],
      [[68467, 68471], "disallowed"],
      [[68472, 68479], "valid", [], "NV8"],
      [[68480, 68497], "valid"],
      [[68498, 68504], "disallowed"],
      [[68505, 68508], "valid", [], "NV8"],
      [[68509, 68520], "disallowed"],
      [[68521, 68527], "valid", [], "NV8"],
      [[68528, 68607], "disallowed"],
      [[68608, 68680], "valid"],
      [[68681, 68735], "disallowed"],
      [[68736, 68736], "mapped", [68800]],
      [[68737, 68737], "mapped", [68801]],
      [[68738, 68738], "mapped", [68802]],
      [[68739, 68739], "mapped", [68803]],
      [[68740, 68740], "mapped", [68804]],
      [[68741, 68741], "mapped", [68805]],
      [[68742, 68742], "mapped", [68806]],
      [[68743, 68743], "mapped", [68807]],
      [[68744, 68744], "mapped", [68808]],
      [[68745, 68745], "mapped", [68809]],
      [[68746, 68746], "mapped", [68810]],
      [[68747, 68747], "mapped", [68811]],
      [[68748, 68748], "mapped", [68812]],
      [[68749, 68749], "mapped", [68813]],
      [[68750, 68750], "mapped", [68814]],
      [[68751, 68751], "mapped", [68815]],
      [[68752, 68752], "mapped", [68816]],
      [[68753, 68753], "mapped", [68817]],
      [[68754, 68754], "mapped", [68818]],
      [[68755, 68755], "mapped", [68819]],
      [[68756, 68756], "mapped", [68820]],
      [[68757, 68757], "mapped", [68821]],
      [[68758, 68758], "mapped", [68822]],
      [[68759, 68759], "mapped", [68823]],
      [[68760, 68760], "mapped", [68824]],
      [[68761, 68761], "mapped", [68825]],
      [[68762, 68762], "mapped", [68826]],
      [[68763, 68763], "mapped", [68827]],
      [[68764, 68764], "mapped", [68828]],
      [[68765, 68765], "mapped", [68829]],
      [[68766, 68766], "mapped", [68830]],
      [[68767, 68767], "mapped", [68831]],
      [[68768, 68768], "mapped", [68832]],
      [[68769, 68769], "mapped", [68833]],
      [[68770, 68770], "mapped", [68834]],
      [[68771, 68771], "mapped", [68835]],
      [[68772, 68772], "mapped", [68836]],
      [[68773, 68773], "mapped", [68837]],
      [[68774, 68774], "mapped", [68838]],
      [[68775, 68775], "mapped", [68839]],
      [[68776, 68776], "mapped", [68840]],
      [[68777, 68777], "mapped", [68841]],
      [[68778, 68778], "mapped", [68842]],
      [[68779, 68779], "mapped", [68843]],
      [[68780, 68780], "mapped", [68844]],
      [[68781, 68781], "mapped", [68845]],
      [[68782, 68782], "mapped", [68846]],
      [[68783, 68783], "mapped", [68847]],
      [[68784, 68784], "mapped", [68848]],
      [[68785, 68785], "mapped", [68849]],
      [[68786, 68786], "mapped", [68850]],
      [[68787, 68799], "disallowed"],
      [[68800, 68850], "valid"],
      [[68851, 68857], "disallowed"],
      [[68858, 68863], "valid", [], "NV8"],
      [[68864, 69215], "disallowed"],
      [[69216, 69246], "valid", [], "NV8"],
      [[69247, 69631], "disallowed"],
      [[69632, 69702], "valid"],
      [[69703, 69709], "valid", [], "NV8"],
      [[69710, 69713], "disallowed"],
      [[69714, 69733], "valid", [], "NV8"],
      [[69734, 69743], "valid"],
      [[69744, 69758], "disallowed"],
      [[69759, 69759], "valid"],
      [[69760, 69818], "valid"],
      [[69819, 69820], "valid", [], "NV8"],
      [[69821, 69821], "disallowed"],
      [[69822, 69825], "valid", [], "NV8"],
      [[69826, 69839], "disallowed"],
      [[69840, 69864], "valid"],
      [[69865, 69871], "disallowed"],
      [[69872, 69881], "valid"],
      [[69882, 69887], "disallowed"],
      [[69888, 69940], "valid"],
      [[69941, 69941], "disallowed"],
      [[69942, 69951], "valid"],
      [[69952, 69955], "valid", [], "NV8"],
      [[69956, 69967], "disallowed"],
      [[69968, 70003], "valid"],
      [[70004, 70005], "valid", [], "NV8"],
      [[70006, 70006], "valid"],
      [[70007, 70015], "disallowed"],
      [[70016, 70084], "valid"],
      [[70085, 70088], "valid", [], "NV8"],
      [[70089, 70089], "valid", [], "NV8"],
      [[70090, 70092], "valid"],
      [[70093, 70093], "valid", [], "NV8"],
      [[70094, 70095], "disallowed"],
      [[70096, 70105], "valid"],
      [[70106, 70106], "valid"],
      [[70107, 70107], "valid", [], "NV8"],
      [[70108, 70108], "valid"],
      [[70109, 70111], "valid", [], "NV8"],
      [[70112, 70112], "disallowed"],
      [[70113, 70132], "valid", [], "NV8"],
      [[70133, 70143], "disallowed"],
      [[70144, 70161], "valid"],
      [[70162, 70162], "disallowed"],
      [[70163, 70199], "valid"],
      [[70200, 70205], "valid", [], "NV8"],
      [[70206, 70271], "disallowed"],
      [[70272, 70278], "valid"],
      [[70279, 70279], "disallowed"],
      [[70280, 70280], "valid"],
      [[70281, 70281], "disallowed"],
      [[70282, 70285], "valid"],
      [[70286, 70286], "disallowed"],
      [[70287, 70301], "valid"],
      [[70302, 70302], "disallowed"],
      [[70303, 70312], "valid"],
      [[70313, 70313], "valid", [], "NV8"],
      [[70314, 70319], "disallowed"],
      [[70320, 70378], "valid"],
      [[70379, 70383], "disallowed"],
      [[70384, 70393], "valid"],
      [[70394, 70399], "disallowed"],
      [[70400, 70400], "valid"],
      [[70401, 70403], "valid"],
      [[70404, 70404], "disallowed"],
      [[70405, 70412], "valid"],
      [[70413, 70414], "disallowed"],
      [[70415, 70416], "valid"],
      [[70417, 70418], "disallowed"],
      [[70419, 70440], "valid"],
      [[70441, 70441], "disallowed"],
      [[70442, 70448], "valid"],
      [[70449, 70449], "disallowed"],
      [[70450, 70451], "valid"],
      [[70452, 70452], "disallowed"],
      [[70453, 70457], "valid"],
      [[70458, 70459], "disallowed"],
      [[70460, 70468], "valid"],
      [[70469, 70470], "disallowed"],
      [[70471, 70472], "valid"],
      [[70473, 70474], "disallowed"],
      [[70475, 70477], "valid"],
      [[70478, 70479], "disallowed"],
      [[70480, 70480], "valid"],
      [[70481, 70486], "disallowed"],
      [[70487, 70487], "valid"],
      [[70488, 70492], "disallowed"],
      [[70493, 70499], "valid"],
      [[70500, 70501], "disallowed"],
      [[70502, 70508], "valid"],
      [[70509, 70511], "disallowed"],
      [[70512, 70516], "valid"],
      [[70517, 70783], "disallowed"],
      [[70784, 70853], "valid"],
      [[70854, 70854], "valid", [], "NV8"],
      [[70855, 70855], "valid"],
      [[70856, 70863], "disallowed"],
      [[70864, 70873], "valid"],
      [[70874, 71039], "disallowed"],
      [[71040, 71093], "valid"],
      [[71094, 71095], "disallowed"],
      [[71096, 71104], "valid"],
      [[71105, 71113], "valid", [], "NV8"],
      [[71114, 71127], "valid", [], "NV8"],
      [[71128, 71133], "valid"],
      [[71134, 71167], "disallowed"],
      [[71168, 71232], "valid"],
      [[71233, 71235], "valid", [], "NV8"],
      [[71236, 71236], "valid"],
      [[71237, 71247], "disallowed"],
      [[71248, 71257], "valid"],
      [[71258, 71295], "disallowed"],
      [[71296, 71351], "valid"],
      [[71352, 71359], "disallowed"],
      [[71360, 71369], "valid"],
      [[71370, 71423], "disallowed"],
      [[71424, 71449], "valid"],
      [[71450, 71452], "disallowed"],
      [[71453, 71467], "valid"],
      [[71468, 71471], "disallowed"],
      [[71472, 71481], "valid"],
      [[71482, 71487], "valid", [], "NV8"],
      [[71488, 71839], "disallowed"],
      [[71840, 71840], "mapped", [71872]],
      [[71841, 71841], "mapped", [71873]],
      [[71842, 71842], "mapped", [71874]],
      [[71843, 71843], "mapped", [71875]],
      [[71844, 71844], "mapped", [71876]],
      [[71845, 71845], "mapped", [71877]],
      [[71846, 71846], "mapped", [71878]],
      [[71847, 71847], "mapped", [71879]],
      [[71848, 71848], "mapped", [71880]],
      [[71849, 71849], "mapped", [71881]],
      [[71850, 71850], "mapped", [71882]],
      [[71851, 71851], "mapped", [71883]],
      [[71852, 71852], "mapped", [71884]],
      [[71853, 71853], "mapped", [71885]],
      [[71854, 71854], "mapped", [71886]],
      [[71855, 71855], "mapped", [71887]],
      [[71856, 71856], "mapped", [71888]],
      [[71857, 71857], "mapped", [71889]],
      [[71858, 71858], "mapped", [71890]],
      [[71859, 71859], "mapped", [71891]],
      [[71860, 71860], "mapped", [71892]],
      [[71861, 71861], "mapped", [71893]],
      [[71862, 71862], "mapped", [71894]],
      [[71863, 71863], "mapped", [71895]],
      [[71864, 71864], "mapped", [71896]],
      [[71865, 71865], "mapped", [71897]],
      [[71866, 71866], "mapped", [71898]],
      [[71867, 71867], "mapped", [71899]],
      [[71868, 71868], "mapped", [71900]],
      [[71869, 71869], "mapped", [71901]],
      [[71870, 71870], "mapped", [71902]],
      [[71871, 71871], "mapped", [71903]],
      [[71872, 71913], "valid"],
      [[71914, 71922], "valid", [], "NV8"],
      [[71923, 71934], "disallowed"],
      [[71935, 71935], "valid"],
      [[71936, 72383], "disallowed"],
      [[72384, 72440], "valid"],
      [[72441, 73727], "disallowed"],
      [[73728, 74606], "valid"],
      [[74607, 74648], "valid"],
      [[74649, 74649], "valid"],
      [[74650, 74751], "disallowed"],
      [[74752, 74850], "valid", [], "NV8"],
      [[74851, 74862], "valid", [], "NV8"],
      [[74863, 74863], "disallowed"],
      [[74864, 74867], "valid", [], "NV8"],
      [[74868, 74868], "valid", [], "NV8"],
      [[74869, 74879], "disallowed"],
      [[74880, 75075], "valid"],
      [[75076, 77823], "disallowed"],
      [[77824, 78894], "valid"],
      [[78895, 82943], "disallowed"],
      [[82944, 83526], "valid"],
      [[83527, 92159], "disallowed"],
      [[92160, 92728], "valid"],
      [[92729, 92735], "disallowed"],
      [[92736, 92766], "valid"],
      [[92767, 92767], "disallowed"],
      [[92768, 92777], "valid"],
      [[92778, 92781], "disallowed"],
      [[92782, 92783], "valid", [], "NV8"],
      [[92784, 92879], "disallowed"],
      [[92880, 92909], "valid"],
      [[92910, 92911], "disallowed"],
      [[92912, 92916], "valid"],
      [[92917, 92917], "valid", [], "NV8"],
      [[92918, 92927], "disallowed"],
      [[92928, 92982], "valid"],
      [[92983, 92991], "valid", [], "NV8"],
      [[92992, 92995], "valid"],
      [[92996, 92997], "valid", [], "NV8"],
      [[92998, 93007], "disallowed"],
      [[93008, 93017], "valid"],
      [[93018, 93018], "disallowed"],
      [[93019, 93025], "valid", [], "NV8"],
      [[93026, 93026], "disallowed"],
      [[93027, 93047], "valid"],
      [[93048, 93052], "disallowed"],
      [[93053, 93071], "valid"],
      [[93072, 93951], "disallowed"],
      [[93952, 94020], "valid"],
      [[94021, 94031], "disallowed"],
      [[94032, 94078], "valid"],
      [[94079, 94094], "disallowed"],
      [[94095, 94111], "valid"],
      [[94112, 110591], "disallowed"],
      [[110592, 110593], "valid"],
      [[110594, 113663], "disallowed"],
      [[113664, 113770], "valid"],
      [[113771, 113775], "disallowed"],
      [[113776, 113788], "valid"],
      [[113789, 113791], "disallowed"],
      [[113792, 113800], "valid"],
      [[113801, 113807], "disallowed"],
      [[113808, 113817], "valid"],
      [[113818, 113819], "disallowed"],
      [[113820, 113820], "valid", [], "NV8"],
      [[113821, 113822], "valid"],
      [[113823, 113823], "valid", [], "NV8"],
      [[113824, 113827], "ignored"],
      [[113828, 118783], "disallowed"],
      [[118784, 119029], "valid", [], "NV8"],
      [[119030, 119039], "disallowed"],
      [[119040, 119078], "valid", [], "NV8"],
      [[119079, 119080], "disallowed"],
      [[119081, 119081], "valid", [], "NV8"],
      [[119082, 119133], "valid", [], "NV8"],
      [[119134, 119134], "mapped", [119127, 119141]],
      [[119135, 119135], "mapped", [119128, 119141]],
      [[119136, 119136], "mapped", [119128, 119141, 119150]],
      [[119137, 119137], "mapped", [119128, 119141, 119151]],
      [[119138, 119138], "mapped", [119128, 119141, 119152]],
      [[119139, 119139], "mapped", [119128, 119141, 119153]],
      [[119140, 119140], "mapped", [119128, 119141, 119154]],
      [[119141, 119154], "valid", [], "NV8"],
      [[119155, 119162], "disallowed"],
      [[119163, 119226], "valid", [], "NV8"],
      [[119227, 119227], "mapped", [119225, 119141]],
      [[119228, 119228], "mapped", [119226, 119141]],
      [[119229, 119229], "mapped", [119225, 119141, 119150]],
      [[119230, 119230], "mapped", [119226, 119141, 119150]],
      [[119231, 119231], "mapped", [119225, 119141, 119151]],
      [[119232, 119232], "mapped", [119226, 119141, 119151]],
      [[119233, 119261], "valid", [], "NV8"],
      [[119262, 119272], "valid", [], "NV8"],
      [[119273, 119295], "disallowed"],
      [[119296, 119365], "valid", [], "NV8"],
      [[119366, 119551], "disallowed"],
      [[119552, 119638], "valid", [], "NV8"],
      [[119639, 119647], "disallowed"],
      [[119648, 119665], "valid", [], "NV8"],
      [[119666, 119807], "disallowed"],
      [[119808, 119808], "mapped", [97]],
      [[119809, 119809], "mapped", [98]],
      [[119810, 119810], "mapped", [99]],
      [[119811, 119811], "mapped", [100]],
      [[119812, 119812], "mapped", [101]],
      [[119813, 119813], "mapped", [102]],
      [[119814, 119814], "mapped", [103]],
      [[119815, 119815], "mapped", [104]],
      [[119816, 119816], "mapped", [105]],
      [[119817, 119817], "mapped", [106]],
      [[119818, 119818], "mapped", [107]],
      [[119819, 119819], "mapped", [108]],
      [[119820, 119820], "mapped", [109]],
      [[119821, 119821], "mapped", [110]],
      [[119822, 119822], "mapped", [111]],
      [[119823, 119823], "mapped", [112]],
      [[119824, 119824], "mapped", [113]],
      [[119825, 119825], "mapped", [114]],
      [[119826, 119826], "mapped", [115]],
      [[119827, 119827], "mapped", [116]],
      [[119828, 119828], "mapped", [117]],
      [[119829, 119829], "mapped", [118]],
      [[119830, 119830], "mapped", [119]],
      [[119831, 119831], "mapped", [120]],
      [[119832, 119832], "mapped", [121]],
      [[119833, 119833], "mapped", [122]],
      [[119834, 119834], "mapped", [97]],
      [[119835, 119835], "mapped", [98]],
      [[119836, 119836], "mapped", [99]],
      [[119837, 119837], "mapped", [100]],
      [[119838, 119838], "mapped", [101]],
      [[119839, 119839], "mapped", [102]],
      [[119840, 119840], "mapped", [103]],
      [[119841, 119841], "mapped", [104]],
      [[119842, 119842], "mapped", [105]],
      [[119843, 119843], "mapped", [106]],
      [[119844, 119844], "mapped", [107]],
      [[119845, 119845], "mapped", [108]],
      [[119846, 119846], "mapped", [109]],
      [[119847, 119847], "mapped", [110]],
      [[119848, 119848], "mapped", [111]],
      [[119849, 119849], "mapped", [112]],
      [[119850, 119850], "mapped", [113]],
      [[119851, 119851], "mapped", [114]],
      [[119852, 119852], "mapped", [115]],
      [[119853, 119853], "mapped", [116]],
      [[119854, 119854], "mapped", [117]],
      [[119855, 119855], "mapped", [118]],
      [[119856, 119856], "mapped", [119]],
      [[119857, 119857], "mapped", [120]],
      [[119858, 119858], "mapped", [121]],
      [[119859, 119859], "mapped", [122]],
      [[119860, 119860], "mapped", [97]],
      [[119861, 119861], "mapped", [98]],
      [[119862, 119862], "mapped", [99]],
      [[119863, 119863], "mapped", [100]],
      [[119864, 119864], "mapped", [101]],
      [[119865, 119865], "mapped", [102]],
      [[119866, 119866], "mapped", [103]],
      [[119867, 119867], "mapped", [104]],
      [[119868, 119868], "mapped", [105]],
      [[119869, 119869], "mapped", [106]],
      [[119870, 119870], "mapped", [107]],
      [[119871, 119871], "mapped", [108]],
      [[119872, 119872], "mapped", [109]],
      [[119873, 119873], "mapped", [110]],
      [[119874, 119874], "mapped", [111]],
      [[119875, 119875], "mapped", [112]],
      [[119876, 119876], "mapped", [113]],
      [[119877, 119877], "mapped", [114]],
      [[119878, 119878], "mapped", [115]],
      [[119879, 119879], "mapped", [116]],
      [[119880, 119880], "mapped", [117]],
      [[119881, 119881], "mapped", [118]],
      [[119882, 119882], "mapped", [119]],
      [[119883, 119883], "mapped", [120]],
      [[119884, 119884], "mapped", [121]],
      [[119885, 119885], "mapped", [122]],
      [[119886, 119886], "mapped", [97]],
      [[119887, 119887], "mapped", [98]],
      [[119888, 119888], "mapped", [99]],
      [[119889, 119889], "mapped", [100]],
      [[119890, 119890], "mapped", [101]],
      [[119891, 119891], "mapped", [102]],
      [[119892, 119892], "mapped", [103]],
      [[119893, 119893], "disallowed"],
      [[119894, 119894], "mapped", [105]],
      [[119895, 119895], "mapped", [106]],
      [[119896, 119896], "mapped", [107]],
      [[119897, 119897], "mapped", [108]],
      [[119898, 119898], "mapped", [109]],
      [[119899, 119899], "mapped", [110]],
      [[119900, 119900], "mapped", [111]],
      [[119901, 119901], "mapped", [112]],
      [[119902, 119902], "mapped", [113]],
      [[119903, 119903], "mapped", [114]],
      [[119904, 119904], "mapped", [115]],
      [[119905, 119905], "mapped", [116]],
      [[119906, 119906], "mapped", [117]],
      [[119907, 119907], "mapped", [118]],
      [[119908, 119908], "mapped", [119]],
      [[119909, 119909], "mapped", [120]],
      [[119910, 119910], "mapped", [121]],
      [[119911, 119911], "mapped", [122]],
      [[119912, 119912], "mapped", [97]],
      [[119913, 119913], "mapped", [98]],
      [[119914, 119914], "mapped", [99]],
      [[119915, 119915], "mapped", [100]],
      [[119916, 119916], "mapped", [101]],
      [[119917, 119917], "mapped", [102]],
      [[119918, 119918], "mapped", [103]],
      [[119919, 119919], "mapped", [104]],
      [[119920, 119920], "mapped", [105]],
      [[119921, 119921], "mapped", [106]],
      [[119922, 119922], "mapped", [107]],
      [[119923, 119923], "mapped", [108]],
      [[119924, 119924], "mapped", [109]],
      [[119925, 119925], "mapped", [110]],
      [[119926, 119926], "mapped", [111]],
      [[119927, 119927], "mapped", [112]],
      [[119928, 119928], "mapped", [113]],
      [[119929, 119929], "mapped", [114]],
      [[119930, 119930], "mapped", [115]],
      [[119931, 119931], "mapped", [116]],
      [[119932, 119932], "mapped", [117]],
      [[119933, 119933], "mapped", [118]],
      [[119934, 119934], "mapped", [119]],
      [[119935, 119935], "mapped", [120]],
      [[119936, 119936], "mapped", [121]],
      [[119937, 119937], "mapped", [122]],
      [[119938, 119938], "mapped", [97]],
      [[119939, 119939], "mapped", [98]],
      [[119940, 119940], "mapped", [99]],
      [[119941, 119941], "mapped", [100]],
      [[119942, 119942], "mapped", [101]],
      [[119943, 119943], "mapped", [102]],
      [[119944, 119944], "mapped", [103]],
      [[119945, 119945], "mapped", [104]],
      [[119946, 119946], "mapped", [105]],
      [[119947, 119947], "mapped", [106]],
      [[119948, 119948], "mapped", [107]],
      [[119949, 119949], "mapped", [108]],
      [[119950, 119950], "mapped", [109]],
      [[119951, 119951], "mapped", [110]],
      [[119952, 119952], "mapped", [111]],
      [[119953, 119953], "mapped", [112]],
      [[119954, 119954], "mapped", [113]],
      [[119955, 119955], "mapped", [114]],
      [[119956, 119956], "mapped", [115]],
      [[119957, 119957], "mapped", [116]],
      [[119958, 119958], "mapped", [117]],
      [[119959, 119959], "mapped", [118]],
      [[119960, 119960], "mapped", [119]],
      [[119961, 119961], "mapped", [120]],
      [[119962, 119962], "mapped", [121]],
      [[119963, 119963], "mapped", [122]],
      [[119964, 119964], "mapped", [97]],
      [[119965, 119965], "disallowed"],
      [[119966, 119966], "mapped", [99]],
      [[119967, 119967], "mapped", [100]],
      [[119968, 119969], "disallowed"],
      [[119970, 119970], "mapped", [103]],
      [[119971, 119972], "disallowed"],
      [[119973, 119973], "mapped", [106]],
      [[119974, 119974], "mapped", [107]],
      [[119975, 119976], "disallowed"],
      [[119977, 119977], "mapped", [110]],
      [[119978, 119978], "mapped", [111]],
      [[119979, 119979], "mapped", [112]],
      [[119980, 119980], "mapped", [113]],
      [[119981, 119981], "disallowed"],
      [[119982, 119982], "mapped", [115]],
      [[119983, 119983], "mapped", [116]],
      [[119984, 119984], "mapped", [117]],
      [[119985, 119985], "mapped", [118]],
      [[119986, 119986], "mapped", [119]],
      [[119987, 119987], "mapped", [120]],
      [[119988, 119988], "mapped", [121]],
      [[119989, 119989], "mapped", [122]],
      [[119990, 119990], "mapped", [97]],
      [[119991, 119991], "mapped", [98]],
      [[119992, 119992], "mapped", [99]],
      [[119993, 119993], "mapped", [100]],
      [[119994, 119994], "disallowed"],
      [[119995, 119995], "mapped", [102]],
      [[119996, 119996], "disallowed"],
      [[119997, 119997], "mapped", [104]],
      [[119998, 119998], "mapped", [105]],
      [[119999, 119999], "mapped", [106]],
      [[12e4, 12e4], "mapped", [107]],
      [[120001, 120001], "mapped", [108]],
      [[120002, 120002], "mapped", [109]],
      [[120003, 120003], "mapped", [110]],
      [[120004, 120004], "disallowed"],
      [[120005, 120005], "mapped", [112]],
      [[120006, 120006], "mapped", [113]],
      [[120007, 120007], "mapped", [114]],
      [[120008, 120008], "mapped", [115]],
      [[120009, 120009], "mapped", [116]],
      [[120010, 120010], "mapped", [117]],
      [[120011, 120011], "mapped", [118]],
      [[120012, 120012], "mapped", [119]],
      [[120013, 120013], "mapped", [120]],
      [[120014, 120014], "mapped", [121]],
      [[120015, 120015], "mapped", [122]],
      [[120016, 120016], "mapped", [97]],
      [[120017, 120017], "mapped", [98]],
      [[120018, 120018], "mapped", [99]],
      [[120019, 120019], "mapped", [100]],
      [[120020, 120020], "mapped", [101]],
      [[120021, 120021], "mapped", [102]],
      [[120022, 120022], "mapped", [103]],
      [[120023, 120023], "mapped", [104]],
      [[120024, 120024], "mapped", [105]],
      [[120025, 120025], "mapped", [106]],
      [[120026, 120026], "mapped", [107]],
      [[120027, 120027], "mapped", [108]],
      [[120028, 120028], "mapped", [109]],
      [[120029, 120029], "mapped", [110]],
      [[120030, 120030], "mapped", [111]],
      [[120031, 120031], "mapped", [112]],
      [[120032, 120032], "mapped", [113]],
      [[120033, 120033], "mapped", [114]],
      [[120034, 120034], "mapped", [115]],
      [[120035, 120035], "mapped", [116]],
      [[120036, 120036], "mapped", [117]],
      [[120037, 120037], "mapped", [118]],
      [[120038, 120038], "mapped", [119]],
      [[120039, 120039], "mapped", [120]],
      [[120040, 120040], "mapped", [121]],
      [[120041, 120041], "mapped", [122]],
      [[120042, 120042], "mapped", [97]],
      [[120043, 120043], "mapped", [98]],
      [[120044, 120044], "mapped", [99]],
      [[120045, 120045], "mapped", [100]],
      [[120046, 120046], "mapped", [101]],
      [[120047, 120047], "mapped", [102]],
      [[120048, 120048], "mapped", [103]],
      [[120049, 120049], "mapped", [104]],
      [[120050, 120050], "mapped", [105]],
      [[120051, 120051], "mapped", [106]],
      [[120052, 120052], "mapped", [107]],
      [[120053, 120053], "mapped", [108]],
      [[120054, 120054], "mapped", [109]],
      [[120055, 120055], "mapped", [110]],
      [[120056, 120056], "mapped", [111]],
      [[120057, 120057], "mapped", [112]],
      [[120058, 120058], "mapped", [113]],
      [[120059, 120059], "mapped", [114]],
      [[120060, 120060], "mapped", [115]],
      [[120061, 120061], "mapped", [116]],
      [[120062, 120062], "mapped", [117]],
      [[120063, 120063], "mapped", [118]],
      [[120064, 120064], "mapped", [119]],
      [[120065, 120065], "mapped", [120]],
      [[120066, 120066], "mapped", [121]],
      [[120067, 120067], "mapped", [122]],
      [[120068, 120068], "mapped", [97]],
      [[120069, 120069], "mapped", [98]],
      [[120070, 120070], "disallowed"],
      [[120071, 120071], "mapped", [100]],
      [[120072, 120072], "mapped", [101]],
      [[120073, 120073], "mapped", [102]],
      [[120074, 120074], "mapped", [103]],
      [[120075, 120076], "disallowed"],
      [[120077, 120077], "mapped", [106]],
      [[120078, 120078], "mapped", [107]],
      [[120079, 120079], "mapped", [108]],
      [[120080, 120080], "mapped", [109]],
      [[120081, 120081], "mapped", [110]],
      [[120082, 120082], "mapped", [111]],
      [[120083, 120083], "mapped", [112]],
      [[120084, 120084], "mapped", [113]],
      [[120085, 120085], "disallowed"],
      [[120086, 120086], "mapped", [115]],
      [[120087, 120087], "mapped", [116]],
      [[120088, 120088], "mapped", [117]],
      [[120089, 120089], "mapped", [118]],
      [[120090, 120090], "mapped", [119]],
      [[120091, 120091], "mapped", [120]],
      [[120092, 120092], "mapped", [121]],
      [[120093, 120093], "disallowed"],
      [[120094, 120094], "mapped", [97]],
      [[120095, 120095], "mapped", [98]],
      [[120096, 120096], "mapped", [99]],
      [[120097, 120097], "mapped", [100]],
      [[120098, 120098], "mapped", [101]],
      [[120099, 120099], "mapped", [102]],
      [[120100, 120100], "mapped", [103]],
      [[120101, 120101], "mapped", [104]],
      [[120102, 120102], "mapped", [105]],
      [[120103, 120103], "mapped", [106]],
      [[120104, 120104], "mapped", [107]],
      [[120105, 120105], "mapped", [108]],
      [[120106, 120106], "mapped", [109]],
      [[120107, 120107], "mapped", [110]],
      [[120108, 120108], "mapped", [111]],
      [[120109, 120109], "mapped", [112]],
      [[120110, 120110], "mapped", [113]],
      [[120111, 120111], "mapped", [114]],
      [[120112, 120112], "mapped", [115]],
      [[120113, 120113], "mapped", [116]],
      [[120114, 120114], "mapped", [117]],
      [[120115, 120115], "mapped", [118]],
      [[120116, 120116], "mapped", [119]],
      [[120117, 120117], "mapped", [120]],
      [[120118, 120118], "mapped", [121]],
      [[120119, 120119], "mapped", [122]],
      [[120120, 120120], "mapped", [97]],
      [[120121, 120121], "mapped", [98]],
      [[120122, 120122], "disallowed"],
      [[120123, 120123], "mapped", [100]],
      [[120124, 120124], "mapped", [101]],
      [[120125, 120125], "mapped", [102]],
      [[120126, 120126], "mapped", [103]],
      [[120127, 120127], "disallowed"],
      [[120128, 120128], "mapped", [105]],
      [[120129, 120129], "mapped", [106]],
      [[120130, 120130], "mapped", [107]],
      [[120131, 120131], "mapped", [108]],
      [[120132, 120132], "mapped", [109]],
      [[120133, 120133], "disallowed"],
      [[120134, 120134], "mapped", [111]],
      [[120135, 120137], "disallowed"],
      [[120138, 120138], "mapped", [115]],
      [[120139, 120139], "mapped", [116]],
      [[120140, 120140], "mapped", [117]],
      [[120141, 120141], "mapped", [118]],
      [[120142, 120142], "mapped", [119]],
      [[120143, 120143], "mapped", [120]],
      [[120144, 120144], "mapped", [121]],
      [[120145, 120145], "disallowed"],
      [[120146, 120146], "mapped", [97]],
      [[120147, 120147], "mapped", [98]],
      [[120148, 120148], "mapped", [99]],
      [[120149, 120149], "mapped", [100]],
      [[120150, 120150], "mapped", [101]],
      [[120151, 120151], "mapped", [102]],
      [[120152, 120152], "mapped", [103]],
      [[120153, 120153], "mapped", [104]],
      [[120154, 120154], "mapped", [105]],
      [[120155, 120155], "mapped", [106]],
      [[120156, 120156], "mapped", [107]],
      [[120157, 120157], "mapped", [108]],
      [[120158, 120158], "mapped", [109]],
      [[120159, 120159], "mapped", [110]],
      [[120160, 120160], "mapped", [111]],
      [[120161, 120161], "mapped", [112]],
      [[120162, 120162], "mapped", [113]],
      [[120163, 120163], "mapped", [114]],
      [[120164, 120164], "mapped", [115]],
      [[120165, 120165], "mapped", [116]],
      [[120166, 120166], "mapped", [117]],
      [[120167, 120167], "mapped", [118]],
      [[120168, 120168], "mapped", [119]],
      [[120169, 120169], "mapped", [120]],
      [[120170, 120170], "mapped", [121]],
      [[120171, 120171], "mapped", [122]],
      [[120172, 120172], "mapped", [97]],
      [[120173, 120173], "mapped", [98]],
      [[120174, 120174], "mapped", [99]],
      [[120175, 120175], "mapped", [100]],
      [[120176, 120176], "mapped", [101]],
      [[120177, 120177], "mapped", [102]],
      [[120178, 120178], "mapped", [103]],
      [[120179, 120179], "mapped", [104]],
      [[120180, 120180], "mapped", [105]],
      [[120181, 120181], "mapped", [106]],
      [[120182, 120182], "mapped", [107]],
      [[120183, 120183], "mapped", [108]],
      [[120184, 120184], "mapped", [109]],
      [[120185, 120185], "mapped", [110]],
      [[120186, 120186], "mapped", [111]],
      [[120187, 120187], "mapped", [112]],
      [[120188, 120188], "mapped", [113]],
      [[120189, 120189], "mapped", [114]],
      [[120190, 120190], "mapped", [115]],
      [[120191, 120191], "mapped", [116]],
      [[120192, 120192], "mapped", [117]],
      [[120193, 120193], "mapped", [118]],
      [[120194, 120194], "mapped", [119]],
      [[120195, 120195], "mapped", [120]],
      [[120196, 120196], "mapped", [121]],
      [[120197, 120197], "mapped", [122]],
      [[120198, 120198], "mapped", [97]],
      [[120199, 120199], "mapped", [98]],
      [[120200, 120200], "mapped", [99]],
      [[120201, 120201], "mapped", [100]],
      [[120202, 120202], "mapped", [101]],
      [[120203, 120203], "mapped", [102]],
      [[120204, 120204], "mapped", [103]],
      [[120205, 120205], "mapped", [104]],
      [[120206, 120206], "mapped", [105]],
      [[120207, 120207], "mapped", [106]],
      [[120208, 120208], "mapped", [107]],
      [[120209, 120209], "mapped", [108]],
      [[120210, 120210], "mapped", [109]],
      [[120211, 120211], "mapped", [110]],
      [[120212, 120212], "mapped", [111]],
      [[120213, 120213], "mapped", [112]],
      [[120214, 120214], "mapped", [113]],
      [[120215, 120215], "mapped", [114]],
      [[120216, 120216], "mapped", [115]],
      [[120217, 120217], "mapped", [116]],
      [[120218, 120218], "mapped", [117]],
      [[120219, 120219], "mapped", [118]],
      [[120220, 120220], "mapped", [119]],
      [[120221, 120221], "mapped", [120]],
      [[120222, 120222], "mapped", [121]],
      [[120223, 120223], "mapped", [122]],
      [[120224, 120224], "mapped", [97]],
      [[120225, 120225], "mapped", [98]],
      [[120226, 120226], "mapped", [99]],
      [[120227, 120227], "mapped", [100]],
      [[120228, 120228], "mapped", [101]],
      [[120229, 120229], "mapped", [102]],
      [[120230, 120230], "mapped", [103]],
      [[120231, 120231], "mapped", [104]],
      [[120232, 120232], "mapped", [105]],
      [[120233, 120233], "mapped", [106]],
      [[120234, 120234], "mapped", [107]],
      [[120235, 120235], "mapped", [108]],
      [[120236, 120236], "mapped", [109]],
      [[120237, 120237], "mapped", [110]],
      [[120238, 120238], "mapped", [111]],
      [[120239, 120239], "mapped", [112]],
      [[120240, 120240], "mapped", [113]],
      [[120241, 120241], "mapped", [114]],
      [[120242, 120242], "mapped", [115]],
      [[120243, 120243], "mapped", [116]],
      [[120244, 120244], "mapped", [117]],
      [[120245, 120245], "mapped", [118]],
      [[120246, 120246], "mapped", [119]],
      [[120247, 120247], "mapped", [120]],
      [[120248, 120248], "mapped", [121]],
      [[120249, 120249], "mapped", [122]],
      [[120250, 120250], "mapped", [97]],
      [[120251, 120251], "mapped", [98]],
      [[120252, 120252], "mapped", [99]],
      [[120253, 120253], "mapped", [100]],
      [[120254, 120254], "mapped", [101]],
      [[120255, 120255], "mapped", [102]],
      [[120256, 120256], "mapped", [103]],
      [[120257, 120257], "mapped", [104]],
      [[120258, 120258], "mapped", [105]],
      [[120259, 120259], "mapped", [106]],
      [[120260, 120260], "mapped", [107]],
      [[120261, 120261], "mapped", [108]],
      [[120262, 120262], "mapped", [109]],
      [[120263, 120263], "mapped", [110]],
      [[120264, 120264], "mapped", [111]],
      [[120265, 120265], "mapped", [112]],
      [[120266, 120266], "mapped", [113]],
      [[120267, 120267], "mapped", [114]],
      [[120268, 120268], "mapped", [115]],
      [[120269, 120269], "mapped", [116]],
      [[120270, 120270], "mapped", [117]],
      [[120271, 120271], "mapped", [118]],
      [[120272, 120272], "mapped", [119]],
      [[120273, 120273], "mapped", [120]],
      [[120274, 120274], "mapped", [121]],
      [[120275, 120275], "mapped", [122]],
      [[120276, 120276], "mapped", [97]],
      [[120277, 120277], "mapped", [98]],
      [[120278, 120278], "mapped", [99]],
      [[120279, 120279], "mapped", [100]],
      [[120280, 120280], "mapped", [101]],
      [[120281, 120281], "mapped", [102]],
      [[120282, 120282], "mapped", [103]],
      [[120283, 120283], "mapped", [104]],
      [[120284, 120284], "mapped", [105]],
      [[120285, 120285], "mapped", [106]],
      [[120286, 120286], "mapped", [107]],
      [[120287, 120287], "mapped", [108]],
      [[120288, 120288], "mapped", [109]],
      [[120289, 120289], "mapped", [110]],
      [[120290, 120290], "mapped", [111]],
      [[120291, 120291], "mapped", [112]],
      [[120292, 120292], "mapped", [113]],
      [[120293, 120293], "mapped", [114]],
      [[120294, 120294], "mapped", [115]],
      [[120295, 120295], "mapped", [116]],
      [[120296, 120296], "mapped", [117]],
      [[120297, 120297], "mapped", [118]],
      [[120298, 120298], "mapped", [119]],
      [[120299, 120299], "mapped", [120]],
      [[120300, 120300], "mapped", [121]],
      [[120301, 120301], "mapped", [122]],
      [[120302, 120302], "mapped", [97]],
      [[120303, 120303], "mapped", [98]],
      [[120304, 120304], "mapped", [99]],
      [[120305, 120305], "mapped", [100]],
      [[120306, 120306], "mapped", [101]],
      [[120307, 120307], "mapped", [102]],
      [[120308, 120308], "mapped", [103]],
      [[120309, 120309], "mapped", [104]],
      [[120310, 120310], "mapped", [105]],
      [[120311, 120311], "mapped", [106]],
      [[120312, 120312], "mapped", [107]],
      [[120313, 120313], "mapped", [108]],
      [[120314, 120314], "mapped", [109]],
      [[120315, 120315], "mapped", [110]],
      [[120316, 120316], "mapped", [111]],
      [[120317, 120317], "mapped", [112]],
      [[120318, 120318], "mapped", [113]],
      [[120319, 120319], "mapped", [114]],
      [[120320, 120320], "mapped", [115]],
      [[120321, 120321], "mapped", [116]],
      [[120322, 120322], "mapped", [117]],
      [[120323, 120323], "mapped", [118]],
      [[120324, 120324], "mapped", [119]],
      [[120325, 120325], "mapped", [120]],
      [[120326, 120326], "mapped", [121]],
      [[120327, 120327], "mapped", [122]],
      [[120328, 120328], "mapped", [97]],
      [[120329, 120329], "mapped", [98]],
      [[120330, 120330], "mapped", [99]],
      [[120331, 120331], "mapped", [100]],
      [[120332, 120332], "mapped", [101]],
      [[120333, 120333], "mapped", [102]],
      [[120334, 120334], "mapped", [103]],
      [[120335, 120335], "mapped", [104]],
      [[120336, 120336], "mapped", [105]],
      [[120337, 120337], "mapped", [106]],
      [[120338, 120338], "mapped", [107]],
      [[120339, 120339], "mapped", [108]],
      [[120340, 120340], "mapped", [109]],
      [[120341, 120341], "mapped", [110]],
      [[120342, 120342], "mapped", [111]],
      [[120343, 120343], "mapped", [112]],
      [[120344, 120344], "mapped", [113]],
      [[120345, 120345], "mapped", [114]],
      [[120346, 120346], "mapped", [115]],
      [[120347, 120347], "mapped", [116]],
      [[120348, 120348], "mapped", [117]],
      [[120349, 120349], "mapped", [118]],
      [[120350, 120350], "mapped", [119]],
      [[120351, 120351], "mapped", [120]],
      [[120352, 120352], "mapped", [121]],
      [[120353, 120353], "mapped", [122]],
      [[120354, 120354], "mapped", [97]],
      [[120355, 120355], "mapped", [98]],
      [[120356, 120356], "mapped", [99]],
      [[120357, 120357], "mapped", [100]],
      [[120358, 120358], "mapped", [101]],
      [[120359, 120359], "mapped", [102]],
      [[120360, 120360], "mapped", [103]],
      [[120361, 120361], "mapped", [104]],
      [[120362, 120362], "mapped", [105]],
      [[120363, 120363], "mapped", [106]],
      [[120364, 120364], "mapped", [107]],
      [[120365, 120365], "mapped", [108]],
      [[120366, 120366], "mapped", [109]],
      [[120367, 120367], "mapped", [110]],
      [[120368, 120368], "mapped", [111]],
      [[120369, 120369], "mapped", [112]],
      [[120370, 120370], "mapped", [113]],
      [[120371, 120371], "mapped", [114]],
      [[120372, 120372], "mapped", [115]],
      [[120373, 120373], "mapped", [116]],
      [[120374, 120374], "mapped", [117]],
      [[120375, 120375], "mapped", [118]],
      [[120376, 120376], "mapped", [119]],
      [[120377, 120377], "mapped", [120]],
      [[120378, 120378], "mapped", [121]],
      [[120379, 120379], "mapped", [122]],
      [[120380, 120380], "mapped", [97]],
      [[120381, 120381], "mapped", [98]],
      [[120382, 120382], "mapped", [99]],
      [[120383, 120383], "mapped", [100]],
      [[120384, 120384], "mapped", [101]],
      [[120385, 120385], "mapped", [102]],
      [[120386, 120386], "mapped", [103]],
      [[120387, 120387], "mapped", [104]],
      [[120388, 120388], "mapped", [105]],
      [[120389, 120389], "mapped", [106]],
      [[120390, 120390], "mapped", [107]],
      [[120391, 120391], "mapped", [108]],
      [[120392, 120392], "mapped", [109]],
      [[120393, 120393], "mapped", [110]],
      [[120394, 120394], "mapped", [111]],
      [[120395, 120395], "mapped", [112]],
      [[120396, 120396], "mapped", [113]],
      [[120397, 120397], "mapped", [114]],
      [[120398, 120398], "mapped", [115]],
      [[120399, 120399], "mapped", [116]],
      [[120400, 120400], "mapped", [117]],
      [[120401, 120401], "mapped", [118]],
      [[120402, 120402], "mapped", [119]],
      [[120403, 120403], "mapped", [120]],
      [[120404, 120404], "mapped", [121]],
      [[120405, 120405], "mapped", [122]],
      [[120406, 120406], "mapped", [97]],
      [[120407, 120407], "mapped", [98]],
      [[120408, 120408], "mapped", [99]],
      [[120409, 120409], "mapped", [100]],
      [[120410, 120410], "mapped", [101]],
      [[120411, 120411], "mapped", [102]],
      [[120412, 120412], "mapped", [103]],
      [[120413, 120413], "mapped", [104]],
      [[120414, 120414], "mapped", [105]],
      [[120415, 120415], "mapped", [106]],
      [[120416, 120416], "mapped", [107]],
      [[120417, 120417], "mapped", [108]],
      [[120418, 120418], "mapped", [109]],
      [[120419, 120419], "mapped", [110]],
      [[120420, 120420], "mapped", [111]],
      [[120421, 120421], "mapped", [112]],
      [[120422, 120422], "mapped", [113]],
      [[120423, 120423], "mapped", [114]],
      [[120424, 120424], "mapped", [115]],
      [[120425, 120425], "mapped", [116]],
      [[120426, 120426], "mapped", [117]],
      [[120427, 120427], "mapped", [118]],
      [[120428, 120428], "mapped", [119]],
      [[120429, 120429], "mapped", [120]],
      [[120430, 120430], "mapped", [121]],
      [[120431, 120431], "mapped", [122]],
      [[120432, 120432], "mapped", [97]],
      [[120433, 120433], "mapped", [98]],
      [[120434, 120434], "mapped", [99]],
      [[120435, 120435], "mapped", [100]],
      [[120436, 120436], "mapped", [101]],
      [[120437, 120437], "mapped", [102]],
      [[120438, 120438], "mapped", [103]],
      [[120439, 120439], "mapped", [104]],
      [[120440, 120440], "mapped", [105]],
      [[120441, 120441], "mapped", [106]],
      [[120442, 120442], "mapped", [107]],
      [[120443, 120443], "mapped", [108]],
      [[120444, 120444], "mapped", [109]],
      [[120445, 120445], "mapped", [110]],
      [[120446, 120446], "mapped", [111]],
      [[120447, 120447], "mapped", [112]],
      [[120448, 120448], "mapped", [113]],
      [[120449, 120449], "mapped", [114]],
      [[120450, 120450], "mapped", [115]],
      [[120451, 120451], "mapped", [116]],
      [[120452, 120452], "mapped", [117]],
      [[120453, 120453], "mapped", [118]],
      [[120454, 120454], "mapped", [119]],
      [[120455, 120455], "mapped", [120]],
      [[120456, 120456], "mapped", [121]],
      [[120457, 120457], "mapped", [122]],
      [[120458, 120458], "mapped", [97]],
      [[120459, 120459], "mapped", [98]],
      [[120460, 120460], "mapped", [99]],
      [[120461, 120461], "mapped", [100]],
      [[120462, 120462], "mapped", [101]],
      [[120463, 120463], "mapped", [102]],
      [[120464, 120464], "mapped", [103]],
      [[120465, 120465], "mapped", [104]],
      [[120466, 120466], "mapped", [105]],
      [[120467, 120467], "mapped", [106]],
      [[120468, 120468], "mapped", [107]],
      [[120469, 120469], "mapped", [108]],
      [[120470, 120470], "mapped", [109]],
      [[120471, 120471], "mapped", [110]],
      [[120472, 120472], "mapped", [111]],
      [[120473, 120473], "mapped", [112]],
      [[120474, 120474], "mapped", [113]],
      [[120475, 120475], "mapped", [114]],
      [[120476, 120476], "mapped", [115]],
      [[120477, 120477], "mapped", [116]],
      [[120478, 120478], "mapped", [117]],
      [[120479, 120479], "mapped", [118]],
      [[120480, 120480], "mapped", [119]],
      [[120481, 120481], "mapped", [120]],
      [[120482, 120482], "mapped", [121]],
      [[120483, 120483], "mapped", [122]],
      [[120484, 120484], "mapped", [305]],
      [[120485, 120485], "mapped", [567]],
      [[120486, 120487], "disallowed"],
      [[120488, 120488], "mapped", [945]],
      [[120489, 120489], "mapped", [946]],
      [[120490, 120490], "mapped", [947]],
      [[120491, 120491], "mapped", [948]],
      [[120492, 120492], "mapped", [949]],
      [[120493, 120493], "mapped", [950]],
      [[120494, 120494], "mapped", [951]],
      [[120495, 120495], "mapped", [952]],
      [[120496, 120496], "mapped", [953]],
      [[120497, 120497], "mapped", [954]],
      [[120498, 120498], "mapped", [955]],
      [[120499, 120499], "mapped", [956]],
      [[120500, 120500], "mapped", [957]],
      [[120501, 120501], "mapped", [958]],
      [[120502, 120502], "mapped", [959]],
      [[120503, 120503], "mapped", [960]],
      [[120504, 120504], "mapped", [961]],
      [[120505, 120505], "mapped", [952]],
      [[120506, 120506], "mapped", [963]],
      [[120507, 120507], "mapped", [964]],
      [[120508, 120508], "mapped", [965]],
      [[120509, 120509], "mapped", [966]],
      [[120510, 120510], "mapped", [967]],
      [[120511, 120511], "mapped", [968]],
      [[120512, 120512], "mapped", [969]],
      [[120513, 120513], "mapped", [8711]],
      [[120514, 120514], "mapped", [945]],
      [[120515, 120515], "mapped", [946]],
      [[120516, 120516], "mapped", [947]],
      [[120517, 120517], "mapped", [948]],
      [[120518, 120518], "mapped", [949]],
      [[120519, 120519], "mapped", [950]],
      [[120520, 120520], "mapped", [951]],
      [[120521, 120521], "mapped", [952]],
      [[120522, 120522], "mapped", [953]],
      [[120523, 120523], "mapped", [954]],
      [[120524, 120524], "mapped", [955]],
      [[120525, 120525], "mapped", [956]],
      [[120526, 120526], "mapped", [957]],
      [[120527, 120527], "mapped", [958]],
      [[120528, 120528], "mapped", [959]],
      [[120529, 120529], "mapped", [960]],
      [[120530, 120530], "mapped", [961]],
      [[120531, 120532], "mapped", [963]],
      [[120533, 120533], "mapped", [964]],
      [[120534, 120534], "mapped", [965]],
      [[120535, 120535], "mapped", [966]],
      [[120536, 120536], "mapped", [967]],
      [[120537, 120537], "mapped", [968]],
      [[120538, 120538], "mapped", [969]],
      [[120539, 120539], "mapped", [8706]],
      [[120540, 120540], "mapped", [949]],
      [[120541, 120541], "mapped", [952]],
      [[120542, 120542], "mapped", [954]],
      [[120543, 120543], "mapped", [966]],
      [[120544, 120544], "mapped", [961]],
      [[120545, 120545], "mapped", [960]],
      [[120546, 120546], "mapped", [945]],
      [[120547, 120547], "mapped", [946]],
      [[120548, 120548], "mapped", [947]],
      [[120549, 120549], "mapped", [948]],
      [[120550, 120550], "mapped", [949]],
      [[120551, 120551], "mapped", [950]],
      [[120552, 120552], "mapped", [951]],
      [[120553, 120553], "mapped", [952]],
      [[120554, 120554], "mapped", [953]],
      [[120555, 120555], "mapped", [954]],
      [[120556, 120556], "mapped", [955]],
      [[120557, 120557], "mapped", [956]],
      [[120558, 120558], "mapped", [957]],
      [[120559, 120559], "mapped", [958]],
      [[120560, 120560], "mapped", [959]],
      [[120561, 120561], "mapped", [960]],
      [[120562, 120562], "mapped", [961]],
      [[120563, 120563], "mapped", [952]],
      [[120564, 120564], "mapped", [963]],
      [[120565, 120565], "mapped", [964]],
      [[120566, 120566], "mapped", [965]],
      [[120567, 120567], "mapped", [966]],
      [[120568, 120568], "mapped", [967]],
      [[120569, 120569], "mapped", [968]],
      [[120570, 120570], "mapped", [969]],
      [[120571, 120571], "mapped", [8711]],
      [[120572, 120572], "mapped", [945]],
      [[120573, 120573], "mapped", [946]],
      [[120574, 120574], "mapped", [947]],
      [[120575, 120575], "mapped", [948]],
      [[120576, 120576], "mapped", [949]],
      [[120577, 120577], "mapped", [950]],
      [[120578, 120578], "mapped", [951]],
      [[120579, 120579], "mapped", [952]],
      [[120580, 120580], "mapped", [953]],
      [[120581, 120581], "mapped", [954]],
      [[120582, 120582], "mapped", [955]],
      [[120583, 120583], "mapped", [956]],
      [[120584, 120584], "mapped", [957]],
      [[120585, 120585], "mapped", [958]],
      [[120586, 120586], "mapped", [959]],
      [[120587, 120587], "mapped", [960]],
      [[120588, 120588], "mapped", [961]],
      [[120589, 120590], "mapped", [963]],
      [[120591, 120591], "mapped", [964]],
      [[120592, 120592], "mapped", [965]],
      [[120593, 120593], "mapped", [966]],
      [[120594, 120594], "mapped", [967]],
      [[120595, 120595], "mapped", [968]],
      [[120596, 120596], "mapped", [969]],
      [[120597, 120597], "mapped", [8706]],
      [[120598, 120598], "mapped", [949]],
      [[120599, 120599], "mapped", [952]],
      [[120600, 120600], "mapped", [954]],
      [[120601, 120601], "mapped", [966]],
      [[120602, 120602], "mapped", [961]],
      [[120603, 120603], "mapped", [960]],
      [[120604, 120604], "mapped", [945]],
      [[120605, 120605], "mapped", [946]],
      [[120606, 120606], "mapped", [947]],
      [[120607, 120607], "mapped", [948]],
      [[120608, 120608], "mapped", [949]],
      [[120609, 120609], "mapped", [950]],
      [[120610, 120610], "mapped", [951]],
      [[120611, 120611], "mapped", [952]],
      [[120612, 120612], "mapped", [953]],
      [[120613, 120613], "mapped", [954]],
      [[120614, 120614], "mapped", [955]],
      [[120615, 120615], "mapped", [956]],
      [[120616, 120616], "mapped", [957]],
      [[120617, 120617], "mapped", [958]],
      [[120618, 120618], "mapped", [959]],
      [[120619, 120619], "mapped", [960]],
      [[120620, 120620], "mapped", [961]],
      [[120621, 120621], "mapped", [952]],
      [[120622, 120622], "mapped", [963]],
      [[120623, 120623], "mapped", [964]],
      [[120624, 120624], "mapped", [965]],
      [[120625, 120625], "mapped", [966]],
      [[120626, 120626], "mapped", [967]],
      [[120627, 120627], "mapped", [968]],
      [[120628, 120628], "mapped", [969]],
      [[120629, 120629], "mapped", [8711]],
      [[120630, 120630], "mapped", [945]],
      [[120631, 120631], "mapped", [946]],
      [[120632, 120632], "mapped", [947]],
      [[120633, 120633], "mapped", [948]],
      [[120634, 120634], "mapped", [949]],
      [[120635, 120635], "mapped", [950]],
      [[120636, 120636], "mapped", [951]],
      [[120637, 120637], "mapped", [952]],
      [[120638, 120638], "mapped", [953]],
      [[120639, 120639], "mapped", [954]],
      [[120640, 120640], "mapped", [955]],
      [[120641, 120641], "mapped", [956]],
      [[120642, 120642], "mapped", [957]],
      [[120643, 120643], "mapped", [958]],
      [[120644, 120644], "mapped", [959]],
      [[120645, 120645], "mapped", [960]],
      [[120646, 120646], "mapped", [961]],
      [[120647, 120648], "mapped", [963]],
      [[120649, 120649], "mapped", [964]],
      [[120650, 120650], "mapped", [965]],
      [[120651, 120651], "mapped", [966]],
      [[120652, 120652], "mapped", [967]],
      [[120653, 120653], "mapped", [968]],
      [[120654, 120654], "mapped", [969]],
      [[120655, 120655], "mapped", [8706]],
      [[120656, 120656], "mapped", [949]],
      [[120657, 120657], "mapped", [952]],
      [[120658, 120658], "mapped", [954]],
      [[120659, 120659], "mapped", [966]],
      [[120660, 120660], "mapped", [961]],
      [[120661, 120661], "mapped", [960]],
      [[120662, 120662], "mapped", [945]],
      [[120663, 120663], "mapped", [946]],
      [[120664, 120664], "mapped", [947]],
      [[120665, 120665], "mapped", [948]],
      [[120666, 120666], "mapped", [949]],
      [[120667, 120667], "mapped", [950]],
      [[120668, 120668], "mapped", [951]],
      [[120669, 120669], "mapped", [952]],
      [[120670, 120670], "mapped", [953]],
      [[120671, 120671], "mapped", [954]],
      [[120672, 120672], "mapped", [955]],
      [[120673, 120673], "mapped", [956]],
      [[120674, 120674], "mapped", [957]],
      [[120675, 120675], "mapped", [958]],
      [[120676, 120676], "mapped", [959]],
      [[120677, 120677], "mapped", [960]],
      [[120678, 120678], "mapped", [961]],
      [[120679, 120679], "mapped", [952]],
      [[120680, 120680], "mapped", [963]],
      [[120681, 120681], "mapped", [964]],
      [[120682, 120682], "mapped", [965]],
      [[120683, 120683], "mapped", [966]],
      [[120684, 120684], "mapped", [967]],
      [[120685, 120685], "mapped", [968]],
      [[120686, 120686], "mapped", [969]],
      [[120687, 120687], "mapped", [8711]],
      [[120688, 120688], "mapped", [945]],
      [[120689, 120689], "mapped", [946]],
      [[120690, 120690], "mapped", [947]],
      [[120691, 120691], "mapped", [948]],
      [[120692, 120692], "mapped", [949]],
      [[120693, 120693], "mapped", [950]],
      [[120694, 120694], "mapped", [951]],
      [[120695, 120695], "mapped", [952]],
      [[120696, 120696], "mapped", [953]],
      [[120697, 120697], "mapped", [954]],
      [[120698, 120698], "mapped", [955]],
      [[120699, 120699], "mapped", [956]],
      [[120700, 120700], "mapped", [957]],
      [[120701, 120701], "mapped", [958]],
      [[120702, 120702], "mapped", [959]],
      [[120703, 120703], "mapped", [960]],
      [[120704, 120704], "mapped", [961]],
      [[120705, 120706], "mapped", [963]],
      [[120707, 120707], "mapped", [964]],
      [[120708, 120708], "mapped", [965]],
      [[120709, 120709], "mapped", [966]],
      [[120710, 120710], "mapped", [967]],
      [[120711, 120711], "mapped", [968]],
      [[120712, 120712], "mapped", [969]],
      [[120713, 120713], "mapped", [8706]],
      [[120714, 120714], "mapped", [949]],
      [[120715, 120715], "mapped", [952]],
      [[120716, 120716], "mapped", [954]],
      [[120717, 120717], "mapped", [966]],
      [[120718, 120718], "mapped", [961]],
      [[120719, 120719], "mapped", [960]],
      [[120720, 120720], "mapped", [945]],
      [[120721, 120721], "mapped", [946]],
      [[120722, 120722], "mapped", [947]],
      [[120723, 120723], "mapped", [948]],
      [[120724, 120724], "mapped", [949]],
      [[120725, 120725], "mapped", [950]],
      [[120726, 120726], "mapped", [951]],
      [[120727, 120727], "mapped", [952]],
      [[120728, 120728], "mapped", [953]],
      [[120729, 120729], "mapped", [954]],
      [[120730, 120730], "mapped", [955]],
      [[120731, 120731], "mapped", [956]],
      [[120732, 120732], "mapped", [957]],
      [[120733, 120733], "mapped", [958]],
      [[120734, 120734], "mapped", [959]],
      [[120735, 120735], "mapped", [960]],
      [[120736, 120736], "mapped", [961]],
      [[120737, 120737], "mapped", [952]],
      [[120738, 120738], "mapped", [963]],
      [[120739, 120739], "mapped", [964]],
      [[120740, 120740], "mapped", [965]],
      [[120741, 120741], "mapped", [966]],
      [[120742, 120742], "mapped", [967]],
      [[120743, 120743], "mapped", [968]],
      [[120744, 120744], "mapped", [969]],
      [[120745, 120745], "mapped", [8711]],
      [[120746, 120746], "mapped", [945]],
      [[120747, 120747], "mapped", [946]],
      [[120748, 120748], "mapped", [947]],
      [[120749, 120749], "mapped", [948]],
      [[120750, 120750], "mapped", [949]],
      [[120751, 120751], "mapped", [950]],
      [[120752, 120752], "mapped", [951]],
      [[120753, 120753], "mapped", [952]],
      [[120754, 120754], "mapped", [953]],
      [[120755, 120755], "mapped", [954]],
      [[120756, 120756], "mapped", [955]],
      [[120757, 120757], "mapped", [956]],
      [[120758, 120758], "mapped", [957]],
      [[120759, 120759], "mapped", [958]],
      [[120760, 120760], "mapped", [959]],
      [[120761, 120761], "mapped", [960]],
      [[120762, 120762], "mapped", [961]],
      [[120763, 120764], "mapped", [963]],
      [[120765, 120765], "mapped", [964]],
      [[120766, 120766], "mapped", [965]],
      [[120767, 120767], "mapped", [966]],
      [[120768, 120768], "mapped", [967]],
      [[120769, 120769], "mapped", [968]],
      [[120770, 120770], "mapped", [969]],
      [[120771, 120771], "mapped", [8706]],
      [[120772, 120772], "mapped", [949]],
      [[120773, 120773], "mapped", [952]],
      [[120774, 120774], "mapped", [954]],
      [[120775, 120775], "mapped", [966]],
      [[120776, 120776], "mapped", [961]],
      [[120777, 120777], "mapped", [960]],
      [[120778, 120779], "mapped", [989]],
      [[120780, 120781], "disallowed"],
      [[120782, 120782], "mapped", [48]],
      [[120783, 120783], "mapped", [49]],
      [[120784, 120784], "mapped", [50]],
      [[120785, 120785], "mapped", [51]],
      [[120786, 120786], "mapped", [52]],
      [[120787, 120787], "mapped", [53]],
      [[120788, 120788], "mapped", [54]],
      [[120789, 120789], "mapped", [55]],
      [[120790, 120790], "mapped", [56]],
      [[120791, 120791], "mapped", [57]],
      [[120792, 120792], "mapped", [48]],
      [[120793, 120793], "mapped", [49]],
      [[120794, 120794], "mapped", [50]],
      [[120795, 120795], "mapped", [51]],
      [[120796, 120796], "mapped", [52]],
      [[120797, 120797], "mapped", [53]],
      [[120798, 120798], "mapped", [54]],
      [[120799, 120799], "mapped", [55]],
      [[120800, 120800], "mapped", [56]],
      [[120801, 120801], "mapped", [57]],
      [[120802, 120802], "mapped", [48]],
      [[120803, 120803], "mapped", [49]],
      [[120804, 120804], "mapped", [50]],
      [[120805, 120805], "mapped", [51]],
      [[120806, 120806], "mapped", [52]],
      [[120807, 120807], "mapped", [53]],
      [[120808, 120808], "mapped", [54]],
      [[120809, 120809], "mapped", [55]],
      [[120810, 120810], "mapped", [56]],
      [[120811, 120811], "mapped", [57]],
      [[120812, 120812], "mapped", [48]],
      [[120813, 120813], "mapped", [49]],
      [[120814, 120814], "mapped", [50]],
      [[120815, 120815], "mapped", [51]],
      [[120816, 120816], "mapped", [52]],
      [[120817, 120817], "mapped", [53]],
      [[120818, 120818], "mapped", [54]],
      [[120819, 120819], "mapped", [55]],
      [[120820, 120820], "mapped", [56]],
      [[120821, 120821], "mapped", [57]],
      [[120822, 120822], "mapped", [48]],
      [[120823, 120823], "mapped", [49]],
      [[120824, 120824], "mapped", [50]],
      [[120825, 120825], "mapped", [51]],
      [[120826, 120826], "mapped", [52]],
      [[120827, 120827], "mapped", [53]],
      [[120828, 120828], "mapped", [54]],
      [[120829, 120829], "mapped", [55]],
      [[120830, 120830], "mapped", [56]],
      [[120831, 120831], "mapped", [57]],
      [[120832, 121343], "valid", [], "NV8"],
      [[121344, 121398], "valid"],
      [[121399, 121402], "valid", [], "NV8"],
      [[121403, 121452], "valid"],
      [[121453, 121460], "valid", [], "NV8"],
      [[121461, 121461], "valid"],
      [[121462, 121475], "valid", [], "NV8"],
      [[121476, 121476], "valid"],
      [[121477, 121483], "valid", [], "NV8"],
      [[121484, 121498], "disallowed"],
      [[121499, 121503], "valid"],
      [[121504, 121504], "disallowed"],
      [[121505, 121519], "valid"],
      [[121520, 124927], "disallowed"],
      [[124928, 125124], "valid"],
      [[125125, 125126], "disallowed"],
      [[125127, 125135], "valid", [], "NV8"],
      [[125136, 125142], "valid"],
      [[125143, 126463], "disallowed"],
      [[126464, 126464], "mapped", [1575]],
      [[126465, 126465], "mapped", [1576]],
      [[126466, 126466], "mapped", [1580]],
      [[126467, 126467], "mapped", [1583]],
      [[126468, 126468], "disallowed"],
      [[126469, 126469], "mapped", [1608]],
      [[126470, 126470], "mapped", [1586]],
      [[126471, 126471], "mapped", [1581]],
      [[126472, 126472], "mapped", [1591]],
      [[126473, 126473], "mapped", [1610]],
      [[126474, 126474], "mapped", [1603]],
      [[126475, 126475], "mapped", [1604]],
      [[126476, 126476], "mapped", [1605]],
      [[126477, 126477], "mapped", [1606]],
      [[126478, 126478], "mapped", [1587]],
      [[126479, 126479], "mapped", [1593]],
      [[126480, 126480], "mapped", [1601]],
      [[126481, 126481], "mapped", [1589]],
      [[126482, 126482], "mapped", [1602]],
      [[126483, 126483], "mapped", [1585]],
      [[126484, 126484], "mapped", [1588]],
      [[126485, 126485], "mapped", [1578]],
      [[126486, 126486], "mapped", [1579]],
      [[126487, 126487], "mapped", [1582]],
      [[126488, 126488], "mapped", [1584]],
      [[126489, 126489], "mapped", [1590]],
      [[126490, 126490], "mapped", [1592]],
      [[126491, 126491], "mapped", [1594]],
      [[126492, 126492], "mapped", [1646]],
      [[126493, 126493], "mapped", [1722]],
      [[126494, 126494], "mapped", [1697]],
      [[126495, 126495], "mapped", [1647]],
      [[126496, 126496], "disallowed"],
      [[126497, 126497], "mapped", [1576]],
      [[126498, 126498], "mapped", [1580]],
      [[126499, 126499], "disallowed"],
      [[126500, 126500], "mapped", [1607]],
      [[126501, 126502], "disallowed"],
      [[126503, 126503], "mapped", [1581]],
      [[126504, 126504], "disallowed"],
      [[126505, 126505], "mapped", [1610]],
      [[126506, 126506], "mapped", [1603]],
      [[126507, 126507], "mapped", [1604]],
      [[126508, 126508], "mapped", [1605]],
      [[126509, 126509], "mapped", [1606]],
      [[126510, 126510], "mapped", [1587]],
      [[126511, 126511], "mapped", [1593]],
      [[126512, 126512], "mapped", [1601]],
      [[126513, 126513], "mapped", [1589]],
      [[126514, 126514], "mapped", [1602]],
      [[126515, 126515], "disallowed"],
      [[126516, 126516], "mapped", [1588]],
      [[126517, 126517], "mapped", [1578]],
      [[126518, 126518], "mapped", [1579]],
      [[126519, 126519], "mapped", [1582]],
      [[126520, 126520], "disallowed"],
      [[126521, 126521], "mapped", [1590]],
      [[126522, 126522], "disallowed"],
      [[126523, 126523], "mapped", [1594]],
      [[126524, 126529], "disallowed"],
      [[126530, 126530], "mapped", [1580]],
      [[126531, 126534], "disallowed"],
      [[126535, 126535], "mapped", [1581]],
      [[126536, 126536], "disallowed"],
      [[126537, 126537], "mapped", [1610]],
      [[126538, 126538], "disallowed"],
      [[126539, 126539], "mapped", [1604]],
      [[126540, 126540], "disallowed"],
      [[126541, 126541], "mapped", [1606]],
      [[126542, 126542], "mapped", [1587]],
      [[126543, 126543], "mapped", [1593]],
      [[126544, 126544], "disallowed"],
      [[126545, 126545], "mapped", [1589]],
      [[126546, 126546], "mapped", [1602]],
      [[126547, 126547], "disallowed"],
      [[126548, 126548], "mapped", [1588]],
      [[126549, 126550], "disallowed"],
      [[126551, 126551], "mapped", [1582]],
      [[126552, 126552], "disallowed"],
      [[126553, 126553], "mapped", [1590]],
      [[126554, 126554], "disallowed"],
      [[126555, 126555], "mapped", [1594]],
      [[126556, 126556], "disallowed"],
      [[126557, 126557], "mapped", [1722]],
      [[126558, 126558], "disallowed"],
      [[126559, 126559], "mapped", [1647]],
      [[126560, 126560], "disallowed"],
      [[126561, 126561], "mapped", [1576]],
      [[126562, 126562], "mapped", [1580]],
      [[126563, 126563], "disallowed"],
      [[126564, 126564], "mapped", [1607]],
      [[126565, 126566], "disallowed"],
      [[126567, 126567], "mapped", [1581]],
      [[126568, 126568], "mapped", [1591]],
      [[126569, 126569], "mapped", [1610]],
      [[126570, 126570], "mapped", [1603]],
      [[126571, 126571], "disallowed"],
      [[126572, 126572], "mapped", [1605]],
      [[126573, 126573], "mapped", [1606]],
      [[126574, 126574], "mapped", [1587]],
      [[126575, 126575], "mapped", [1593]],
      [[126576, 126576], "mapped", [1601]],
      [[126577, 126577], "mapped", [1589]],
      [[126578, 126578], "mapped", [1602]],
      [[126579, 126579], "disallowed"],
      [[126580, 126580], "mapped", [1588]],
      [[126581, 126581], "mapped", [1578]],
      [[126582, 126582], "mapped", [1579]],
      [[126583, 126583], "mapped", [1582]],
      [[126584, 126584], "disallowed"],
      [[126585, 126585], "mapped", [1590]],
      [[126586, 126586], "mapped", [1592]],
      [[126587, 126587], "mapped", [1594]],
      [[126588, 126588], "mapped", [1646]],
      [[126589, 126589], "disallowed"],
      [[126590, 126590], "mapped", [1697]],
      [[126591, 126591], "disallowed"],
      [[126592, 126592], "mapped", [1575]],
      [[126593, 126593], "mapped", [1576]],
      [[126594, 126594], "mapped", [1580]],
      [[126595, 126595], "mapped", [1583]],
      [[126596, 126596], "mapped", [1607]],
      [[126597, 126597], "mapped", [1608]],
      [[126598, 126598], "mapped", [1586]],
      [[126599, 126599], "mapped", [1581]],
      [[126600, 126600], "mapped", [1591]],
      [[126601, 126601], "mapped", [1610]],
      [[126602, 126602], "disallowed"],
      [[126603, 126603], "mapped", [1604]],
      [[126604, 126604], "mapped", [1605]],
      [[126605, 126605], "mapped", [1606]],
      [[126606, 126606], "mapped", [1587]],
      [[126607, 126607], "mapped", [1593]],
      [[126608, 126608], "mapped", [1601]],
      [[126609, 126609], "mapped", [1589]],
      [[126610, 126610], "mapped", [1602]],
      [[126611, 126611], "mapped", [1585]],
      [[126612, 126612], "mapped", [1588]],
      [[126613, 126613], "mapped", [1578]],
      [[126614, 126614], "mapped", [1579]],
      [[126615, 126615], "mapped", [1582]],
      [[126616, 126616], "mapped", [1584]],
      [[126617, 126617], "mapped", [1590]],
      [[126618, 126618], "mapped", [1592]],
      [[126619, 126619], "mapped", [1594]],
      [[126620, 126624], "disallowed"],
      [[126625, 126625], "mapped", [1576]],
      [[126626, 126626], "mapped", [1580]],
      [[126627, 126627], "mapped", [1583]],
      [[126628, 126628], "disallowed"],
      [[126629, 126629], "mapped", [1608]],
      [[126630, 126630], "mapped", [1586]],
      [[126631, 126631], "mapped", [1581]],
      [[126632, 126632], "mapped", [1591]],
      [[126633, 126633], "mapped", [1610]],
      [[126634, 126634], "disallowed"],
      [[126635, 126635], "mapped", [1604]],
      [[126636, 126636], "mapped", [1605]],
      [[126637, 126637], "mapped", [1606]],
      [[126638, 126638], "mapped", [1587]],
      [[126639, 126639], "mapped", [1593]],
      [[126640, 126640], "mapped", [1601]],
      [[126641, 126641], "mapped", [1589]],
      [[126642, 126642], "mapped", [1602]],
      [[126643, 126643], "mapped", [1585]],
      [[126644, 126644], "mapped", [1588]],
      [[126645, 126645], "mapped", [1578]],
      [[126646, 126646], "mapped", [1579]],
      [[126647, 126647], "mapped", [1582]],
      [[126648, 126648], "mapped", [1584]],
      [[126649, 126649], "mapped", [1590]],
      [[126650, 126650], "mapped", [1592]],
      [[126651, 126651], "mapped", [1594]],
      [[126652, 126703], "disallowed"],
      [[126704, 126705], "valid", [], "NV8"],
      [[126706, 126975], "disallowed"],
      [[126976, 127019], "valid", [], "NV8"],
      [[127020, 127023], "disallowed"],
      [[127024, 127123], "valid", [], "NV8"],
      [[127124, 127135], "disallowed"],
      [[127136, 127150], "valid", [], "NV8"],
      [[127151, 127152], "disallowed"],
      [[127153, 127166], "valid", [], "NV8"],
      [[127167, 127167], "valid", [], "NV8"],
      [[127168, 127168], "disallowed"],
      [[127169, 127183], "valid", [], "NV8"],
      [[127184, 127184], "disallowed"],
      [[127185, 127199], "valid", [], "NV8"],
      [[127200, 127221], "valid", [], "NV8"],
      [[127222, 127231], "disallowed"],
      [[127232, 127232], "disallowed"],
      [[127233, 127233], "disallowed_STD3_mapped", [48, 44]],
      [[127234, 127234], "disallowed_STD3_mapped", [49, 44]],
      [[127235, 127235], "disallowed_STD3_mapped", [50, 44]],
      [[127236, 127236], "disallowed_STD3_mapped", [51, 44]],
      [[127237, 127237], "disallowed_STD3_mapped", [52, 44]],
      [[127238, 127238], "disallowed_STD3_mapped", [53, 44]],
      [[127239, 127239], "disallowed_STD3_mapped", [54, 44]],
      [[127240, 127240], "disallowed_STD3_mapped", [55, 44]],
      [[127241, 127241], "disallowed_STD3_mapped", [56, 44]],
      [[127242, 127242], "disallowed_STD3_mapped", [57, 44]],
      [[127243, 127244], "valid", [], "NV8"],
      [[127245, 127247], "disallowed"],
      [[127248, 127248], "disallowed_STD3_mapped", [40, 97, 41]],
      [[127249, 127249], "disallowed_STD3_mapped", [40, 98, 41]],
      [[127250, 127250], "disallowed_STD3_mapped", [40, 99, 41]],
      [[127251, 127251], "disallowed_STD3_mapped", [40, 100, 41]],
      [[127252, 127252], "disallowed_STD3_mapped", [40, 101, 41]],
      [[127253, 127253], "disallowed_STD3_mapped", [40, 102, 41]],
      [[127254, 127254], "disallowed_STD3_mapped", [40, 103, 41]],
      [[127255, 127255], "disallowed_STD3_mapped", [40, 104, 41]],
      [[127256, 127256], "disallowed_STD3_mapped", [40, 105, 41]],
      [[127257, 127257], "disallowed_STD3_mapped", [40, 106, 41]],
      [[127258, 127258], "disallowed_STD3_mapped", [40, 107, 41]],
      [[127259, 127259], "disallowed_STD3_mapped", [40, 108, 41]],
      [[127260, 127260], "disallowed_STD3_mapped", [40, 109, 41]],
      [[127261, 127261], "disallowed_STD3_mapped", [40, 110, 41]],
      [[127262, 127262], "disallowed_STD3_mapped", [40, 111, 41]],
      [[127263, 127263], "disallowed_STD3_mapped", [40, 112, 41]],
      [[127264, 127264], "disallowed_STD3_mapped", [40, 113, 41]],
      [[127265, 127265], "disallowed_STD3_mapped", [40, 114, 41]],
      [[127266, 127266], "disallowed_STD3_mapped", [40, 115, 41]],
      [[127267, 127267], "disallowed_STD3_mapped", [40, 116, 41]],
      [[127268, 127268], "disallowed_STD3_mapped", [40, 117, 41]],
      [[127269, 127269], "disallowed_STD3_mapped", [40, 118, 41]],
      [[127270, 127270], "disallowed_STD3_mapped", [40, 119, 41]],
      [[127271, 127271], "disallowed_STD3_mapped", [40, 120, 41]],
      [[127272, 127272], "disallowed_STD3_mapped", [40, 121, 41]],
      [[127273, 127273], "disallowed_STD3_mapped", [40, 122, 41]],
      [[127274, 127274], "mapped", [12308, 115, 12309]],
      [[127275, 127275], "mapped", [99]],
      [[127276, 127276], "mapped", [114]],
      [[127277, 127277], "mapped", [99, 100]],
      [[127278, 127278], "mapped", [119, 122]],
      [[127279, 127279], "disallowed"],
      [[127280, 127280], "mapped", [97]],
      [[127281, 127281], "mapped", [98]],
      [[127282, 127282], "mapped", [99]],
      [[127283, 127283], "mapped", [100]],
      [[127284, 127284], "mapped", [101]],
      [[127285, 127285], "mapped", [102]],
      [[127286, 127286], "mapped", [103]],
      [[127287, 127287], "mapped", [104]],
      [[127288, 127288], "mapped", [105]],
      [[127289, 127289], "mapped", [106]],
      [[127290, 127290], "mapped", [107]],
      [[127291, 127291], "mapped", [108]],
      [[127292, 127292], "mapped", [109]],
      [[127293, 127293], "mapped", [110]],
      [[127294, 127294], "mapped", [111]],
      [[127295, 127295], "mapped", [112]],
      [[127296, 127296], "mapped", [113]],
      [[127297, 127297], "mapped", [114]],
      [[127298, 127298], "mapped", [115]],
      [[127299, 127299], "mapped", [116]],
      [[127300, 127300], "mapped", [117]],
      [[127301, 127301], "mapped", [118]],
      [[127302, 127302], "mapped", [119]],
      [[127303, 127303], "mapped", [120]],
      [[127304, 127304], "mapped", [121]],
      [[127305, 127305], "mapped", [122]],
      [[127306, 127306], "mapped", [104, 118]],
      [[127307, 127307], "mapped", [109, 118]],
      [[127308, 127308], "mapped", [115, 100]],
      [[127309, 127309], "mapped", [115, 115]],
      [[127310, 127310], "mapped", [112, 112, 118]],
      [[127311, 127311], "mapped", [119, 99]],
      [[127312, 127318], "valid", [], "NV8"],
      [[127319, 127319], "valid", [], "NV8"],
      [[127320, 127326], "valid", [], "NV8"],
      [[127327, 127327], "valid", [], "NV8"],
      [[127328, 127337], "valid", [], "NV8"],
      [[127338, 127338], "mapped", [109, 99]],
      [[127339, 127339], "mapped", [109, 100]],
      [[127340, 127343], "disallowed"],
      [[127344, 127352], "valid", [], "NV8"],
      [[127353, 127353], "valid", [], "NV8"],
      [[127354, 127354], "valid", [], "NV8"],
      [[127355, 127356], "valid", [], "NV8"],
      [[127357, 127358], "valid", [], "NV8"],
      [[127359, 127359], "valid", [], "NV8"],
      [[127360, 127369], "valid", [], "NV8"],
      [[127370, 127373], "valid", [], "NV8"],
      [[127374, 127375], "valid", [], "NV8"],
      [[127376, 127376], "mapped", [100, 106]],
      [[127377, 127386], "valid", [], "NV8"],
      [[127387, 127461], "disallowed"],
      [[127462, 127487], "valid", [], "NV8"],
      [[127488, 127488], "mapped", [12411, 12363]],
      [[127489, 127489], "mapped", [12467, 12467]],
      [[127490, 127490], "mapped", [12469]],
      [[127491, 127503], "disallowed"],
      [[127504, 127504], "mapped", [25163]],
      [[127505, 127505], "mapped", [23383]],
      [[127506, 127506], "mapped", [21452]],
      [[127507, 127507], "mapped", [12487]],
      [[127508, 127508], "mapped", [20108]],
      [[127509, 127509], "mapped", [22810]],
      [[127510, 127510], "mapped", [35299]],
      [[127511, 127511], "mapped", [22825]],
      [[127512, 127512], "mapped", [20132]],
      [[127513, 127513], "mapped", [26144]],
      [[127514, 127514], "mapped", [28961]],
      [[127515, 127515], "mapped", [26009]],
      [[127516, 127516], "mapped", [21069]],
      [[127517, 127517], "mapped", [24460]],
      [[127518, 127518], "mapped", [20877]],
      [[127519, 127519], "mapped", [26032]],
      [[127520, 127520], "mapped", [21021]],
      [[127521, 127521], "mapped", [32066]],
      [[127522, 127522], "mapped", [29983]],
      [[127523, 127523], "mapped", [36009]],
      [[127524, 127524], "mapped", [22768]],
      [[127525, 127525], "mapped", [21561]],
      [[127526, 127526], "mapped", [28436]],
      [[127527, 127527], "mapped", [25237]],
      [[127528, 127528], "mapped", [25429]],
      [[127529, 127529], "mapped", [19968]],
      [[127530, 127530], "mapped", [19977]],
      [[127531, 127531], "mapped", [36938]],
      [[127532, 127532], "mapped", [24038]],
      [[127533, 127533], "mapped", [20013]],
      [[127534, 127534], "mapped", [21491]],
      [[127535, 127535], "mapped", [25351]],
      [[127536, 127536], "mapped", [36208]],
      [[127537, 127537], "mapped", [25171]],
      [[127538, 127538], "mapped", [31105]],
      [[127539, 127539], "mapped", [31354]],
      [[127540, 127540], "mapped", [21512]],
      [[127541, 127541], "mapped", [28288]],
      [[127542, 127542], "mapped", [26377]],
      [[127543, 127543], "mapped", [26376]],
      [[127544, 127544], "mapped", [30003]],
      [[127545, 127545], "mapped", [21106]],
      [[127546, 127546], "mapped", [21942]],
      [[127547, 127551], "disallowed"],
      [[127552, 127552], "mapped", [12308, 26412, 12309]],
      [[127553, 127553], "mapped", [12308, 19977, 12309]],
      [[127554, 127554], "mapped", [12308, 20108, 12309]],
      [[127555, 127555], "mapped", [12308, 23433, 12309]],
      [[127556, 127556], "mapped", [12308, 28857, 12309]],
      [[127557, 127557], "mapped", [12308, 25171, 12309]],
      [[127558, 127558], "mapped", [12308, 30423, 12309]],
      [[127559, 127559], "mapped", [12308, 21213, 12309]],
      [[127560, 127560], "mapped", [12308, 25943, 12309]],
      [[127561, 127567], "disallowed"],
      [[127568, 127568], "mapped", [24471]],
      [[127569, 127569], "mapped", [21487]],
      [[127570, 127743], "disallowed"],
      [[127744, 127776], "valid", [], "NV8"],
      [[127777, 127788], "valid", [], "NV8"],
      [[127789, 127791], "valid", [], "NV8"],
      [[127792, 127797], "valid", [], "NV8"],
      [[127798, 127798], "valid", [], "NV8"],
      [[127799, 127868], "valid", [], "NV8"],
      [[127869, 127869], "valid", [], "NV8"],
      [[127870, 127871], "valid", [], "NV8"],
      [[127872, 127891], "valid", [], "NV8"],
      [[127892, 127903], "valid", [], "NV8"],
      [[127904, 127940], "valid", [], "NV8"],
      [[127941, 127941], "valid", [], "NV8"],
      [[127942, 127946], "valid", [], "NV8"],
      [[127947, 127950], "valid", [], "NV8"],
      [[127951, 127955], "valid", [], "NV8"],
      [[127956, 127967], "valid", [], "NV8"],
      [[127968, 127984], "valid", [], "NV8"],
      [[127985, 127991], "valid", [], "NV8"],
      [[127992, 127999], "valid", [], "NV8"],
      [[128e3, 128062], "valid", [], "NV8"],
      [[128063, 128063], "valid", [], "NV8"],
      [[128064, 128064], "valid", [], "NV8"],
      [[128065, 128065], "valid", [], "NV8"],
      [[128066, 128247], "valid", [], "NV8"],
      [[128248, 128248], "valid", [], "NV8"],
      [[128249, 128252], "valid", [], "NV8"],
      [[128253, 128254], "valid", [], "NV8"],
      [[128255, 128255], "valid", [], "NV8"],
      [[128256, 128317], "valid", [], "NV8"],
      [[128318, 128319], "valid", [], "NV8"],
      [[128320, 128323], "valid", [], "NV8"],
      [[128324, 128330], "valid", [], "NV8"],
      [[128331, 128335], "valid", [], "NV8"],
      [[128336, 128359], "valid", [], "NV8"],
      [[128360, 128377], "valid", [], "NV8"],
      [[128378, 128378], "disallowed"],
      [[128379, 128419], "valid", [], "NV8"],
      [[128420, 128420], "disallowed"],
      [[128421, 128506], "valid", [], "NV8"],
      [[128507, 128511], "valid", [], "NV8"],
      [[128512, 128512], "valid", [], "NV8"],
      [[128513, 128528], "valid", [], "NV8"],
      [[128529, 128529], "valid", [], "NV8"],
      [[128530, 128532], "valid", [], "NV8"],
      [[128533, 128533], "valid", [], "NV8"],
      [[128534, 128534], "valid", [], "NV8"],
      [[128535, 128535], "valid", [], "NV8"],
      [[128536, 128536], "valid", [], "NV8"],
      [[128537, 128537], "valid", [], "NV8"],
      [[128538, 128538], "valid", [], "NV8"],
      [[128539, 128539], "valid", [], "NV8"],
      [[128540, 128542], "valid", [], "NV8"],
      [[128543, 128543], "valid", [], "NV8"],
      [[128544, 128549], "valid", [], "NV8"],
      [[128550, 128551], "valid", [], "NV8"],
      [[128552, 128555], "valid", [], "NV8"],
      [[128556, 128556], "valid", [], "NV8"],
      [[128557, 128557], "valid", [], "NV8"],
      [[128558, 128559], "valid", [], "NV8"],
      [[128560, 128563], "valid", [], "NV8"],
      [[128564, 128564], "valid", [], "NV8"],
      [[128565, 128576], "valid", [], "NV8"],
      [[128577, 128578], "valid", [], "NV8"],
      [[128579, 128580], "valid", [], "NV8"],
      [[128581, 128591], "valid", [], "NV8"],
      [[128592, 128639], "valid", [], "NV8"],
      [[128640, 128709], "valid", [], "NV8"],
      [[128710, 128719], "valid", [], "NV8"],
      [[128720, 128720], "valid", [], "NV8"],
      [[128721, 128735], "disallowed"],
      [[128736, 128748], "valid", [], "NV8"],
      [[128749, 128751], "disallowed"],
      [[128752, 128755], "valid", [], "NV8"],
      [[128756, 128767], "disallowed"],
      [[128768, 128883], "valid", [], "NV8"],
      [[128884, 128895], "disallowed"],
      [[128896, 128980], "valid", [], "NV8"],
      [[128981, 129023], "disallowed"],
      [[129024, 129035], "valid", [], "NV8"],
      [[129036, 129039], "disallowed"],
      [[129040, 129095], "valid", [], "NV8"],
      [[129096, 129103], "disallowed"],
      [[129104, 129113], "valid", [], "NV8"],
      [[129114, 129119], "disallowed"],
      [[129120, 129159], "valid", [], "NV8"],
      [[129160, 129167], "disallowed"],
      [[129168, 129197], "valid", [], "NV8"],
      [[129198, 129295], "disallowed"],
      [[129296, 129304], "valid", [], "NV8"],
      [[129305, 129407], "disallowed"],
      [[129408, 129412], "valid", [], "NV8"],
      [[129413, 129471], "disallowed"],
      [[129472, 129472], "valid", [], "NV8"],
      [[129473, 131069], "disallowed"],
      [[131070, 131071], "disallowed"],
      [[131072, 173782], "valid"],
      [[173783, 173823], "disallowed"],
      [[173824, 177972], "valid"],
      [[177973, 177983], "disallowed"],
      [[177984, 178205], "valid"],
      [[178206, 178207], "disallowed"],
      [[178208, 183969], "valid"],
      [[183970, 194559], "disallowed"],
      [[194560, 194560], "mapped", [20029]],
      [[194561, 194561], "mapped", [20024]],
      [[194562, 194562], "mapped", [20033]],
      [[194563, 194563], "mapped", [131362]],
      [[194564, 194564], "mapped", [20320]],
      [[194565, 194565], "mapped", [20398]],
      [[194566, 194566], "mapped", [20411]],
      [[194567, 194567], "mapped", [20482]],
      [[194568, 194568], "mapped", [20602]],
      [[194569, 194569], "mapped", [20633]],
      [[194570, 194570], "mapped", [20711]],
      [[194571, 194571], "mapped", [20687]],
      [[194572, 194572], "mapped", [13470]],
      [[194573, 194573], "mapped", [132666]],
      [[194574, 194574], "mapped", [20813]],
      [[194575, 194575], "mapped", [20820]],
      [[194576, 194576], "mapped", [20836]],
      [[194577, 194577], "mapped", [20855]],
      [[194578, 194578], "mapped", [132380]],
      [[194579, 194579], "mapped", [13497]],
      [[194580, 194580], "mapped", [20839]],
      [[194581, 194581], "mapped", [20877]],
      [[194582, 194582], "mapped", [132427]],
      [[194583, 194583], "mapped", [20887]],
      [[194584, 194584], "mapped", [20900]],
      [[194585, 194585], "mapped", [20172]],
      [[194586, 194586], "mapped", [20908]],
      [[194587, 194587], "mapped", [20917]],
      [[194588, 194588], "mapped", [168415]],
      [[194589, 194589], "mapped", [20981]],
      [[194590, 194590], "mapped", [20995]],
      [[194591, 194591], "mapped", [13535]],
      [[194592, 194592], "mapped", [21051]],
      [[194593, 194593], "mapped", [21062]],
      [[194594, 194594], "mapped", [21106]],
      [[194595, 194595], "mapped", [21111]],
      [[194596, 194596], "mapped", [13589]],
      [[194597, 194597], "mapped", [21191]],
      [[194598, 194598], "mapped", [21193]],
      [[194599, 194599], "mapped", [21220]],
      [[194600, 194600], "mapped", [21242]],
      [[194601, 194601], "mapped", [21253]],
      [[194602, 194602], "mapped", [21254]],
      [[194603, 194603], "mapped", [21271]],
      [[194604, 194604], "mapped", [21321]],
      [[194605, 194605], "mapped", [21329]],
      [[194606, 194606], "mapped", [21338]],
      [[194607, 194607], "mapped", [21363]],
      [[194608, 194608], "mapped", [21373]],
      [[194609, 194611], "mapped", [21375]],
      [[194612, 194612], "mapped", [133676]],
      [[194613, 194613], "mapped", [28784]],
      [[194614, 194614], "mapped", [21450]],
      [[194615, 194615], "mapped", [21471]],
      [[194616, 194616], "mapped", [133987]],
      [[194617, 194617], "mapped", [21483]],
      [[194618, 194618], "mapped", [21489]],
      [[194619, 194619], "mapped", [21510]],
      [[194620, 194620], "mapped", [21662]],
      [[194621, 194621], "mapped", [21560]],
      [[194622, 194622], "mapped", [21576]],
      [[194623, 194623], "mapped", [21608]],
      [[194624, 194624], "mapped", [21666]],
      [[194625, 194625], "mapped", [21750]],
      [[194626, 194626], "mapped", [21776]],
      [[194627, 194627], "mapped", [21843]],
      [[194628, 194628], "mapped", [21859]],
      [[194629, 194630], "mapped", [21892]],
      [[194631, 194631], "mapped", [21913]],
      [[194632, 194632], "mapped", [21931]],
      [[194633, 194633], "mapped", [21939]],
      [[194634, 194634], "mapped", [21954]],
      [[194635, 194635], "mapped", [22294]],
      [[194636, 194636], "mapped", [22022]],
      [[194637, 194637], "mapped", [22295]],
      [[194638, 194638], "mapped", [22097]],
      [[194639, 194639], "mapped", [22132]],
      [[194640, 194640], "mapped", [20999]],
      [[194641, 194641], "mapped", [22766]],
      [[194642, 194642], "mapped", [22478]],
      [[194643, 194643], "mapped", [22516]],
      [[194644, 194644], "mapped", [22541]],
      [[194645, 194645], "mapped", [22411]],
      [[194646, 194646], "mapped", [22578]],
      [[194647, 194647], "mapped", [22577]],
      [[194648, 194648], "mapped", [22700]],
      [[194649, 194649], "mapped", [136420]],
      [[194650, 194650], "mapped", [22770]],
      [[194651, 194651], "mapped", [22775]],
      [[194652, 194652], "mapped", [22790]],
      [[194653, 194653], "mapped", [22810]],
      [[194654, 194654], "mapped", [22818]],
      [[194655, 194655], "mapped", [22882]],
      [[194656, 194656], "mapped", [136872]],
      [[194657, 194657], "mapped", [136938]],
      [[194658, 194658], "mapped", [23020]],
      [[194659, 194659], "mapped", [23067]],
      [[194660, 194660], "mapped", [23079]],
      [[194661, 194661], "mapped", [23e3]],
      [[194662, 194662], "mapped", [23142]],
      [[194663, 194663], "mapped", [14062]],
      [[194664, 194664], "disallowed"],
      [[194665, 194665], "mapped", [23304]],
      [[194666, 194667], "mapped", [23358]],
      [[194668, 194668], "mapped", [137672]],
      [[194669, 194669], "mapped", [23491]],
      [[194670, 194670], "mapped", [23512]],
      [[194671, 194671], "mapped", [23527]],
      [[194672, 194672], "mapped", [23539]],
      [[194673, 194673], "mapped", [138008]],
      [[194674, 194674], "mapped", [23551]],
      [[194675, 194675], "mapped", [23558]],
      [[194676, 194676], "disallowed"],
      [[194677, 194677], "mapped", [23586]],
      [[194678, 194678], "mapped", [14209]],
      [[194679, 194679], "mapped", [23648]],
      [[194680, 194680], "mapped", [23662]],
      [[194681, 194681], "mapped", [23744]],
      [[194682, 194682], "mapped", [23693]],
      [[194683, 194683], "mapped", [138724]],
      [[194684, 194684], "mapped", [23875]],
      [[194685, 194685], "mapped", [138726]],
      [[194686, 194686], "mapped", [23918]],
      [[194687, 194687], "mapped", [23915]],
      [[194688, 194688], "mapped", [23932]],
      [[194689, 194689], "mapped", [24033]],
      [[194690, 194690], "mapped", [24034]],
      [[194691, 194691], "mapped", [14383]],
      [[194692, 194692], "mapped", [24061]],
      [[194693, 194693], "mapped", [24104]],
      [[194694, 194694], "mapped", [24125]],
      [[194695, 194695], "mapped", [24169]],
      [[194696, 194696], "mapped", [14434]],
      [[194697, 194697], "mapped", [139651]],
      [[194698, 194698], "mapped", [14460]],
      [[194699, 194699], "mapped", [24240]],
      [[194700, 194700], "mapped", [24243]],
      [[194701, 194701], "mapped", [24246]],
      [[194702, 194702], "mapped", [24266]],
      [[194703, 194703], "mapped", [172946]],
      [[194704, 194704], "mapped", [24318]],
      [[194705, 194706], "mapped", [140081]],
      [[194707, 194707], "mapped", [33281]],
      [[194708, 194709], "mapped", [24354]],
      [[194710, 194710], "mapped", [14535]],
      [[194711, 194711], "mapped", [144056]],
      [[194712, 194712], "mapped", [156122]],
      [[194713, 194713], "mapped", [24418]],
      [[194714, 194714], "mapped", [24427]],
      [[194715, 194715], "mapped", [14563]],
      [[194716, 194716], "mapped", [24474]],
      [[194717, 194717], "mapped", [24525]],
      [[194718, 194718], "mapped", [24535]],
      [[194719, 194719], "mapped", [24569]],
      [[194720, 194720], "mapped", [24705]],
      [[194721, 194721], "mapped", [14650]],
      [[194722, 194722], "mapped", [14620]],
      [[194723, 194723], "mapped", [24724]],
      [[194724, 194724], "mapped", [141012]],
      [[194725, 194725], "mapped", [24775]],
      [[194726, 194726], "mapped", [24904]],
      [[194727, 194727], "mapped", [24908]],
      [[194728, 194728], "mapped", [24910]],
      [[194729, 194729], "mapped", [24908]],
      [[194730, 194730], "mapped", [24954]],
      [[194731, 194731], "mapped", [24974]],
      [[194732, 194732], "mapped", [25010]],
      [[194733, 194733], "mapped", [24996]],
      [[194734, 194734], "mapped", [25007]],
      [[194735, 194735], "mapped", [25054]],
      [[194736, 194736], "mapped", [25074]],
      [[194737, 194737], "mapped", [25078]],
      [[194738, 194738], "mapped", [25104]],
      [[194739, 194739], "mapped", [25115]],
      [[194740, 194740], "mapped", [25181]],
      [[194741, 194741], "mapped", [25265]],
      [[194742, 194742], "mapped", [25300]],
      [[194743, 194743], "mapped", [25424]],
      [[194744, 194744], "mapped", [142092]],
      [[194745, 194745], "mapped", [25405]],
      [[194746, 194746], "mapped", [25340]],
      [[194747, 194747], "mapped", [25448]],
      [[194748, 194748], "mapped", [25475]],
      [[194749, 194749], "mapped", [25572]],
      [[194750, 194750], "mapped", [142321]],
      [[194751, 194751], "mapped", [25634]],
      [[194752, 194752], "mapped", [25541]],
      [[194753, 194753], "mapped", [25513]],
      [[194754, 194754], "mapped", [14894]],
      [[194755, 194755], "mapped", [25705]],
      [[194756, 194756], "mapped", [25726]],
      [[194757, 194757], "mapped", [25757]],
      [[194758, 194758], "mapped", [25719]],
      [[194759, 194759], "mapped", [14956]],
      [[194760, 194760], "mapped", [25935]],
      [[194761, 194761], "mapped", [25964]],
      [[194762, 194762], "mapped", [143370]],
      [[194763, 194763], "mapped", [26083]],
      [[194764, 194764], "mapped", [26360]],
      [[194765, 194765], "mapped", [26185]],
      [[194766, 194766], "mapped", [15129]],
      [[194767, 194767], "mapped", [26257]],
      [[194768, 194768], "mapped", [15112]],
      [[194769, 194769], "mapped", [15076]],
      [[194770, 194770], "mapped", [20882]],
      [[194771, 194771], "mapped", [20885]],
      [[194772, 194772], "mapped", [26368]],
      [[194773, 194773], "mapped", [26268]],
      [[194774, 194774], "mapped", [32941]],
      [[194775, 194775], "mapped", [17369]],
      [[194776, 194776], "mapped", [26391]],
      [[194777, 194777], "mapped", [26395]],
      [[194778, 194778], "mapped", [26401]],
      [[194779, 194779], "mapped", [26462]],
      [[194780, 194780], "mapped", [26451]],
      [[194781, 194781], "mapped", [144323]],
      [[194782, 194782], "mapped", [15177]],
      [[194783, 194783], "mapped", [26618]],
      [[194784, 194784], "mapped", [26501]],
      [[194785, 194785], "mapped", [26706]],
      [[194786, 194786], "mapped", [26757]],
      [[194787, 194787], "mapped", [144493]],
      [[194788, 194788], "mapped", [26766]],
      [[194789, 194789], "mapped", [26655]],
      [[194790, 194790], "mapped", [26900]],
      [[194791, 194791], "mapped", [15261]],
      [[194792, 194792], "mapped", [26946]],
      [[194793, 194793], "mapped", [27043]],
      [[194794, 194794], "mapped", [27114]],
      [[194795, 194795], "mapped", [27304]],
      [[194796, 194796], "mapped", [145059]],
      [[194797, 194797], "mapped", [27355]],
      [[194798, 194798], "mapped", [15384]],
      [[194799, 194799], "mapped", [27425]],
      [[194800, 194800], "mapped", [145575]],
      [[194801, 194801], "mapped", [27476]],
      [[194802, 194802], "mapped", [15438]],
      [[194803, 194803], "mapped", [27506]],
      [[194804, 194804], "mapped", [27551]],
      [[194805, 194805], "mapped", [27578]],
      [[194806, 194806], "mapped", [27579]],
      [[194807, 194807], "mapped", [146061]],
      [[194808, 194808], "mapped", [138507]],
      [[194809, 194809], "mapped", [146170]],
      [[194810, 194810], "mapped", [27726]],
      [[194811, 194811], "mapped", [146620]],
      [[194812, 194812], "mapped", [27839]],
      [[194813, 194813], "mapped", [27853]],
      [[194814, 194814], "mapped", [27751]],
      [[194815, 194815], "mapped", [27926]],
      [[194816, 194816], "mapped", [27966]],
      [[194817, 194817], "mapped", [28023]],
      [[194818, 194818], "mapped", [27969]],
      [[194819, 194819], "mapped", [28009]],
      [[194820, 194820], "mapped", [28024]],
      [[194821, 194821], "mapped", [28037]],
      [[194822, 194822], "mapped", [146718]],
      [[194823, 194823], "mapped", [27956]],
      [[194824, 194824], "mapped", [28207]],
      [[194825, 194825], "mapped", [28270]],
      [[194826, 194826], "mapped", [15667]],
      [[194827, 194827], "mapped", [28363]],
      [[194828, 194828], "mapped", [28359]],
      [[194829, 194829], "mapped", [147153]],
      [[194830, 194830], "mapped", [28153]],
      [[194831, 194831], "mapped", [28526]],
      [[194832, 194832], "mapped", [147294]],
      [[194833, 194833], "mapped", [147342]],
      [[194834, 194834], "mapped", [28614]],
      [[194835, 194835], "mapped", [28729]],
      [[194836, 194836], "mapped", [28702]],
      [[194837, 194837], "mapped", [28699]],
      [[194838, 194838], "mapped", [15766]],
      [[194839, 194839], "mapped", [28746]],
      [[194840, 194840], "mapped", [28797]],
      [[194841, 194841], "mapped", [28791]],
      [[194842, 194842], "mapped", [28845]],
      [[194843, 194843], "mapped", [132389]],
      [[194844, 194844], "mapped", [28997]],
      [[194845, 194845], "mapped", [148067]],
      [[194846, 194846], "mapped", [29084]],
      [[194847, 194847], "disallowed"],
      [[194848, 194848], "mapped", [29224]],
      [[194849, 194849], "mapped", [29237]],
      [[194850, 194850], "mapped", [29264]],
      [[194851, 194851], "mapped", [149e3]],
      [[194852, 194852], "mapped", [29312]],
      [[194853, 194853], "mapped", [29333]],
      [[194854, 194854], "mapped", [149301]],
      [[194855, 194855], "mapped", [149524]],
      [[194856, 194856], "mapped", [29562]],
      [[194857, 194857], "mapped", [29579]],
      [[194858, 194858], "mapped", [16044]],
      [[194859, 194859], "mapped", [29605]],
      [[194860, 194861], "mapped", [16056]],
      [[194862, 194862], "mapped", [29767]],
      [[194863, 194863], "mapped", [29788]],
      [[194864, 194864], "mapped", [29809]],
      [[194865, 194865], "mapped", [29829]],
      [[194866, 194866], "mapped", [29898]],
      [[194867, 194867], "mapped", [16155]],
      [[194868, 194868], "mapped", [29988]],
      [[194869, 194869], "mapped", [150582]],
      [[194870, 194870], "mapped", [30014]],
      [[194871, 194871], "mapped", [150674]],
      [[194872, 194872], "mapped", [30064]],
      [[194873, 194873], "mapped", [139679]],
      [[194874, 194874], "mapped", [30224]],
      [[194875, 194875], "mapped", [151457]],
      [[194876, 194876], "mapped", [151480]],
      [[194877, 194877], "mapped", [151620]],
      [[194878, 194878], "mapped", [16380]],
      [[194879, 194879], "mapped", [16392]],
      [[194880, 194880], "mapped", [30452]],
      [[194881, 194881], "mapped", [151795]],
      [[194882, 194882], "mapped", [151794]],
      [[194883, 194883], "mapped", [151833]],
      [[194884, 194884], "mapped", [151859]],
      [[194885, 194885], "mapped", [30494]],
      [[194886, 194887], "mapped", [30495]],
      [[194888, 194888], "mapped", [30538]],
      [[194889, 194889], "mapped", [16441]],
      [[194890, 194890], "mapped", [30603]],
      [[194891, 194891], "mapped", [16454]],
      [[194892, 194892], "mapped", [16534]],
      [[194893, 194893], "mapped", [152605]],
      [[194894, 194894], "mapped", [30798]],
      [[194895, 194895], "mapped", [30860]],
      [[194896, 194896], "mapped", [30924]],
      [[194897, 194897], "mapped", [16611]],
      [[194898, 194898], "mapped", [153126]],
      [[194899, 194899], "mapped", [31062]],
      [[194900, 194900], "mapped", [153242]],
      [[194901, 194901], "mapped", [153285]],
      [[194902, 194902], "mapped", [31119]],
      [[194903, 194903], "mapped", [31211]],
      [[194904, 194904], "mapped", [16687]],
      [[194905, 194905], "mapped", [31296]],
      [[194906, 194906], "mapped", [31306]],
      [[194907, 194907], "mapped", [31311]],
      [[194908, 194908], "mapped", [153980]],
      [[194909, 194910], "mapped", [154279]],
      [[194911, 194911], "disallowed"],
      [[194912, 194912], "mapped", [16898]],
      [[194913, 194913], "mapped", [154539]],
      [[194914, 194914], "mapped", [31686]],
      [[194915, 194915], "mapped", [31689]],
      [[194916, 194916], "mapped", [16935]],
      [[194917, 194917], "mapped", [154752]],
      [[194918, 194918], "mapped", [31954]],
      [[194919, 194919], "mapped", [17056]],
      [[194920, 194920], "mapped", [31976]],
      [[194921, 194921], "mapped", [31971]],
      [[194922, 194922], "mapped", [32e3]],
      [[194923, 194923], "mapped", [155526]],
      [[194924, 194924], "mapped", [32099]],
      [[194925, 194925], "mapped", [17153]],
      [[194926, 194926], "mapped", [32199]],
      [[194927, 194927], "mapped", [32258]],
      [[194928, 194928], "mapped", [32325]],
      [[194929, 194929], "mapped", [17204]],
      [[194930, 194930], "mapped", [156200]],
      [[194931, 194931], "mapped", [156231]],
      [[194932, 194932], "mapped", [17241]],
      [[194933, 194933], "mapped", [156377]],
      [[194934, 194934], "mapped", [32634]],
      [[194935, 194935], "mapped", [156478]],
      [[194936, 194936], "mapped", [32661]],
      [[194937, 194937], "mapped", [32762]],
      [[194938, 194938], "mapped", [32773]],
      [[194939, 194939], "mapped", [156890]],
      [[194940, 194940], "mapped", [156963]],
      [[194941, 194941], "mapped", [32864]],
      [[194942, 194942], "mapped", [157096]],
      [[194943, 194943], "mapped", [32880]],
      [[194944, 194944], "mapped", [144223]],
      [[194945, 194945], "mapped", [17365]],
      [[194946, 194946], "mapped", [32946]],
      [[194947, 194947], "mapped", [33027]],
      [[194948, 194948], "mapped", [17419]],
      [[194949, 194949], "mapped", [33086]],
      [[194950, 194950], "mapped", [23221]],
      [[194951, 194951], "mapped", [157607]],
      [[194952, 194952], "mapped", [157621]],
      [[194953, 194953], "mapped", [144275]],
      [[194954, 194954], "mapped", [144284]],
      [[194955, 194955], "mapped", [33281]],
      [[194956, 194956], "mapped", [33284]],
      [[194957, 194957], "mapped", [36766]],
      [[194958, 194958], "mapped", [17515]],
      [[194959, 194959], "mapped", [33425]],
      [[194960, 194960], "mapped", [33419]],
      [[194961, 194961], "mapped", [33437]],
      [[194962, 194962], "mapped", [21171]],
      [[194963, 194963], "mapped", [33457]],
      [[194964, 194964], "mapped", [33459]],
      [[194965, 194965], "mapped", [33469]],
      [[194966, 194966], "mapped", [33510]],
      [[194967, 194967], "mapped", [158524]],
      [[194968, 194968], "mapped", [33509]],
      [[194969, 194969], "mapped", [33565]],
      [[194970, 194970], "mapped", [33635]],
      [[194971, 194971], "mapped", [33709]],
      [[194972, 194972], "mapped", [33571]],
      [[194973, 194973], "mapped", [33725]],
      [[194974, 194974], "mapped", [33767]],
      [[194975, 194975], "mapped", [33879]],
      [[194976, 194976], "mapped", [33619]],
      [[194977, 194977], "mapped", [33738]],
      [[194978, 194978], "mapped", [33740]],
      [[194979, 194979], "mapped", [33756]],
      [[194980, 194980], "mapped", [158774]],
      [[194981, 194981], "mapped", [159083]],
      [[194982, 194982], "mapped", [158933]],
      [[194983, 194983], "mapped", [17707]],
      [[194984, 194984], "mapped", [34033]],
      [[194985, 194985], "mapped", [34035]],
      [[194986, 194986], "mapped", [34070]],
      [[194987, 194987], "mapped", [160714]],
      [[194988, 194988], "mapped", [34148]],
      [[194989, 194989], "mapped", [159532]],
      [[194990, 194990], "mapped", [17757]],
      [[194991, 194991], "mapped", [17761]],
      [[194992, 194992], "mapped", [159665]],
      [[194993, 194993], "mapped", [159954]],
      [[194994, 194994], "mapped", [17771]],
      [[194995, 194995], "mapped", [34384]],
      [[194996, 194996], "mapped", [34396]],
      [[194997, 194997], "mapped", [34407]],
      [[194998, 194998], "mapped", [34409]],
      [[194999, 194999], "mapped", [34473]],
      [[195e3, 195e3], "mapped", [34440]],
      [[195001, 195001], "mapped", [34574]],
      [[195002, 195002], "mapped", [34530]],
      [[195003, 195003], "mapped", [34681]],
      [[195004, 195004], "mapped", [34600]],
      [[195005, 195005], "mapped", [34667]],
      [[195006, 195006], "mapped", [34694]],
      [[195007, 195007], "disallowed"],
      [[195008, 195008], "mapped", [34785]],
      [[195009, 195009], "mapped", [34817]],
      [[195010, 195010], "mapped", [17913]],
      [[195011, 195011], "mapped", [34912]],
      [[195012, 195012], "mapped", [34915]],
      [[195013, 195013], "mapped", [161383]],
      [[195014, 195014], "mapped", [35031]],
      [[195015, 195015], "mapped", [35038]],
      [[195016, 195016], "mapped", [17973]],
      [[195017, 195017], "mapped", [35066]],
      [[195018, 195018], "mapped", [13499]],
      [[195019, 195019], "mapped", [161966]],
      [[195020, 195020], "mapped", [162150]],
      [[195021, 195021], "mapped", [18110]],
      [[195022, 195022], "mapped", [18119]],
      [[195023, 195023], "mapped", [35488]],
      [[195024, 195024], "mapped", [35565]],
      [[195025, 195025], "mapped", [35722]],
      [[195026, 195026], "mapped", [35925]],
      [[195027, 195027], "mapped", [162984]],
      [[195028, 195028], "mapped", [36011]],
      [[195029, 195029], "mapped", [36033]],
      [[195030, 195030], "mapped", [36123]],
      [[195031, 195031], "mapped", [36215]],
      [[195032, 195032], "mapped", [163631]],
      [[195033, 195033], "mapped", [133124]],
      [[195034, 195034], "mapped", [36299]],
      [[195035, 195035], "mapped", [36284]],
      [[195036, 195036], "mapped", [36336]],
      [[195037, 195037], "mapped", [133342]],
      [[195038, 195038], "mapped", [36564]],
      [[195039, 195039], "mapped", [36664]],
      [[195040, 195040], "mapped", [165330]],
      [[195041, 195041], "mapped", [165357]],
      [[195042, 195042], "mapped", [37012]],
      [[195043, 195043], "mapped", [37105]],
      [[195044, 195044], "mapped", [37137]],
      [[195045, 195045], "mapped", [165678]],
      [[195046, 195046], "mapped", [37147]],
      [[195047, 195047], "mapped", [37432]],
      [[195048, 195048], "mapped", [37591]],
      [[195049, 195049], "mapped", [37592]],
      [[195050, 195050], "mapped", [37500]],
      [[195051, 195051], "mapped", [37881]],
      [[195052, 195052], "mapped", [37909]],
      [[195053, 195053], "mapped", [166906]],
      [[195054, 195054], "mapped", [38283]],
      [[195055, 195055], "mapped", [18837]],
      [[195056, 195056], "mapped", [38327]],
      [[195057, 195057], "mapped", [167287]],
      [[195058, 195058], "mapped", [18918]],
      [[195059, 195059], "mapped", [38595]],
      [[195060, 195060], "mapped", [23986]],
      [[195061, 195061], "mapped", [38691]],
      [[195062, 195062], "mapped", [168261]],
      [[195063, 195063], "mapped", [168474]],
      [[195064, 195064], "mapped", [19054]],
      [[195065, 195065], "mapped", [19062]],
      [[195066, 195066], "mapped", [38880]],
      [[195067, 195067], "mapped", [168970]],
      [[195068, 195068], "mapped", [19122]],
      [[195069, 195069], "mapped", [169110]],
      [[195070, 195071], "mapped", [38923]],
      [[195072, 195072], "mapped", [38953]],
      [[195073, 195073], "mapped", [169398]],
      [[195074, 195074], "mapped", [39138]],
      [[195075, 195075], "mapped", [19251]],
      [[195076, 195076], "mapped", [39209]],
      [[195077, 195077], "mapped", [39335]],
      [[195078, 195078], "mapped", [39362]],
      [[195079, 195079], "mapped", [39422]],
      [[195080, 195080], "mapped", [19406]],
      [[195081, 195081], "mapped", [170800]],
      [[195082, 195082], "mapped", [39698]],
      [[195083, 195083], "mapped", [4e4]],
      [[195084, 195084], "mapped", [40189]],
      [[195085, 195085], "mapped", [19662]],
      [[195086, 195086], "mapped", [19693]],
      [[195087, 195087], "mapped", [40295]],
      [[195088, 195088], "mapped", [172238]],
      [[195089, 195089], "mapped", [19704]],
      [[195090, 195090], "mapped", [172293]],
      [[195091, 195091], "mapped", [172558]],
      [[195092, 195092], "mapped", [172689]],
      [[195093, 195093], "mapped", [40635]],
      [[195094, 195094], "mapped", [19798]],
      [[195095, 195095], "mapped", [40697]],
      [[195096, 195096], "mapped", [40702]],
      [[195097, 195097], "mapped", [40709]],
      [[195098, 195098], "mapped", [40719]],
      [[195099, 195099], "mapped", [40726]],
      [[195100, 195100], "mapped", [40763]],
      [[195101, 195101], "mapped", [173568]],
      [[195102, 196605], "disallowed"],
      [[196606, 196607], "disallowed"],
      [[196608, 262141], "disallowed"],
      [[262142, 262143], "disallowed"],
      [[262144, 327677], "disallowed"],
      [[327678, 327679], "disallowed"],
      [[327680, 393213], "disallowed"],
      [[393214, 393215], "disallowed"],
      [[393216, 458749], "disallowed"],
      [[458750, 458751], "disallowed"],
      [[458752, 524285], "disallowed"],
      [[524286, 524287], "disallowed"],
      [[524288, 589821], "disallowed"],
      [[589822, 589823], "disallowed"],
      [[589824, 655357], "disallowed"],
      [[655358, 655359], "disallowed"],
      [[655360, 720893], "disallowed"],
      [[720894, 720895], "disallowed"],
      [[720896, 786429], "disallowed"],
      [[786430, 786431], "disallowed"],
      [[786432, 851965], "disallowed"],
      [[851966, 851967], "disallowed"],
      [[851968, 917501], "disallowed"],
      [[917502, 917503], "disallowed"],
      [[917504, 917504], "disallowed"],
      [[917505, 917505], "disallowed"],
      [[917506, 917535], "disallowed"],
      [[917536, 917631], "disallowed"],
      [[917632, 917759], "disallowed"],
      [[917760, 917999], "ignored"],
      [[918e3, 983037], "disallowed"],
      [[983038, 983039], "disallowed"],
      [[983040, 1048573], "disallowed"],
      [[1048574, 1048575], "disallowed"],
      [[1048576, 1114109], "disallowed"],
      [[1114110, 1114111], "disallowed"],
    ];
  },
});

// node_modules/tr46/index.js
var require_tr46 = __commonJS({
  "node_modules/tr46/index.js"(exports2, module2) {
    "use strict";
    var punycode = require("punycode");
    var mappingTable = require_mappingTable();
    var PROCESSING_OPTIONS = {
      TRANSITIONAL: 0,
      NONTRANSITIONAL: 1,
    };
    function normalize(str) {
      return str
        .split("\0")
        .map(function (s) {
          return s.normalize("NFC");
        })
        .join("\0");
    }
    function findStatus(val) {
      var start = 0;
      var end = mappingTable.length - 1;
      while (start <= end) {
        var mid = Math.floor((start + end) / 2);
        var target = mappingTable[mid];
        if (target[0][0] <= val && target[0][1] >= val) {
          return target;
        } else if (target[0][0] > val) {
          end = mid - 1;
        } else {
          start = mid + 1;
        }
      }
      return null;
    }
    var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    function countSymbols(string) {
      return string.replace(regexAstralSymbols, "_").length;
    }
    function mapChars(domain_name, useSTD3, processing_option) {
      var hasError = false;
      var processed = "";
      var len = countSymbols(domain_name);
      for (var i = 0; i < len; ++i) {
        var codePoint = domain_name.codePointAt(i);
        var status = findStatus(codePoint);
        switch (status[1]) {
          case "disallowed":
            hasError = true;
            processed += String.fromCodePoint(codePoint);
            break;
          case "ignored":
            break;
          case "mapped":
            processed += String.fromCodePoint.apply(String, status[2]);
            break;
          case "deviation":
            if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) {
              processed += String.fromCodePoint.apply(String, status[2]);
            } else {
              processed += String.fromCodePoint(codePoint);
            }
            break;
          case "valid":
            processed += String.fromCodePoint(codePoint);
            break;
          case "disallowed_STD3_mapped":
            if (useSTD3) {
              hasError = true;
              processed += String.fromCodePoint(codePoint);
            } else {
              processed += String.fromCodePoint.apply(String, status[2]);
            }
            break;
          case "disallowed_STD3_valid":
            if (useSTD3) {
              hasError = true;
            }
            processed += String.fromCodePoint(codePoint);
            break;
        }
      }
      return {
        string: processed,
        error: hasError,
      };
    }
    var combiningMarksRegex =
      /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;
    function validateLabel(label, processing_option) {
      if (label.substr(0, 4) === "xn--") {
        label = punycode.toUnicode(label);
        processing_option = PROCESSING_OPTIONS.NONTRANSITIONAL;
      }
      var error = false;
      if (
        normalize(label) !== label ||
        (label[3] === "-" && label[4] === "-") ||
        label[0] === "-" ||
        label[label.length - 1] === "-" ||
        label.indexOf(".") !== -1 ||
        label.search(combiningMarksRegex) === 0
      ) {
        error = true;
      }
      var len = countSymbols(label);
      for (var i = 0; i < len; ++i) {
        var status = findStatus(label.codePointAt(i));
        if (
          (processing === PROCESSING_OPTIONS.TRANSITIONAL &&
            status[1] !== "valid") ||
          (processing === PROCESSING_OPTIONS.NONTRANSITIONAL &&
            status[1] !== "valid" &&
            status[1] !== "deviation")
        ) {
          error = true;
          break;
        }
      }
      return {
        label,
        error,
      };
    }
    function processing(domain_name, useSTD3, processing_option) {
      var result = mapChars(domain_name, useSTD3, processing_option);
      result.string = normalize(result.string);
      var labels = result.string.split(".");
      for (var i = 0; i < labels.length; ++i) {
        try {
          var validation = validateLabel(labels[i]);
          labels[i] = validation.label;
          result.error = result.error || validation.error;
        } catch (e) {
          result.error = true;
        }
      }
      return {
        string: labels.join("."),
        error: result.error,
      };
    }
    module2.exports.toASCII = function (
      domain_name,
      useSTD3,
      processing_option,
      verifyDnsLength
    ) {
      var result = processing(domain_name, useSTD3, processing_option);
      var labels = result.string.split(".");
      labels = labels.map(function (l) {
        try {
          return punycode.toASCII(l);
        } catch (e) {
          result.error = true;
          return l;
        }
      });
      if (verifyDnsLength) {
        var total = labels.slice(0, labels.length - 1).join(".").length;
        if (total.length > 253 || total.length === 0) {
          result.error = true;
        }
        for (var i = 0; i < labels.length; ++i) {
          if (labels.length > 63 || labels.length === 0) {
            result.error = true;
            break;
          }
        }
      }
      if (result.error) return null;
      return labels.join(".");
    };
    module2.exports.toUnicode = function (domain_name, useSTD3) {
      var result = processing(
        domain_name,
        useSTD3,
        PROCESSING_OPTIONS.NONTRANSITIONAL
      );
      return {
        domain: result.string,
        error: result.error,
      };
    };
    module2.exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;
  },
});

// node_modules/whatwg-url/lib/url-state-machine.js
var require_url_state_machine = __commonJS({
  "node_modules/whatwg-url/lib/url-state-machine.js"(exports2, module2) {
    "use strict";
    var punycode = require("punycode");
    var tr46 = require_tr46();
    var specialSchemes = {
      ftp: 21,
      file: null,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443,
    };
    var failure = Symbol("failure");
    function countSymbols(str) {
      return punycode.ucs2.decode(str).length;
    }
    function at(input, idx) {
      const c = input[idx];
      return isNaN(c) ? void 0 : String.fromCodePoint(c);
    }
    function isASCIIDigit(c) {
      return c >= 48 && c <= 57;
    }
    function isASCIIAlpha(c) {
      return (c >= 65 && c <= 90) || (c >= 97 && c <= 122);
    }
    function isASCIIAlphanumeric(c) {
      return isASCIIAlpha(c) || isASCIIDigit(c);
    }
    function isASCIIHex(c) {
      return isASCIIDigit(c) || (c >= 65 && c <= 70) || (c >= 97 && c <= 102);
    }
    function isSingleDot(buffer) {
      return buffer === "." || buffer.toLowerCase() === "%2e";
    }
    function isDoubleDot(buffer) {
      buffer = buffer.toLowerCase();
      return (
        buffer === ".." ||
        buffer === "%2e." ||
        buffer === ".%2e" ||
        buffer === "%2e%2e"
      );
    }
    function isWindowsDriveLetterCodePoints(cp1, cp2) {
      return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);
    }
    function isWindowsDriveLetterString(string) {
      return (
        string.length === 2 &&
        isASCIIAlpha(string.codePointAt(0)) &&
        (string[1] === ":" || string[1] === "|")
      );
    }
    function isNormalizedWindowsDriveLetterString(string) {
      return (
        string.length === 2 &&
        isASCIIAlpha(string.codePointAt(0)) &&
        string[1] === ":"
      );
    }
    function containsForbiddenHostCodePoint(string) {
      return (
        string.search(
          /\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/
        ) !== -1
      );
    }
    function containsForbiddenHostCodePointExcludingPercent(string) {
      return (
        string.search(
          /\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/
        ) !== -1
      );
    }
    function isSpecialScheme(scheme) {
      return specialSchemes[scheme] !== void 0;
    }
    function isSpecial(url) {
      return isSpecialScheme(url.scheme);
    }
    function defaultPort(scheme) {
      return specialSchemes[scheme];
    }
    function percentEncode(c) {
      let hex = c.toString(16).toUpperCase();
      if (hex.length === 1) {
        hex = "0" + hex;
      }
      return "%" + hex;
    }
    function utf8PercentEncode(c) {
      const buf = new Buffer(c);
      let str = "";
      for (let i = 0; i < buf.length; ++i) {
        str += percentEncode(buf[i]);
      }
      return str;
    }
    function utf8PercentDecode(str) {
      const input = new Buffer(str);
      const output = [];
      for (let i = 0; i < input.length; ++i) {
        if (input[i] !== 37) {
          output.push(input[i]);
        } else if (
          input[i] === 37 &&
          isASCIIHex(input[i + 1]) &&
          isASCIIHex(input[i + 2])
        ) {
          output.push(parseInt(input.slice(i + 1, i + 3).toString(), 16));
          i += 2;
        } else {
          output.push(input[i]);
        }
      }
      return new Buffer(output).toString();
    }
    function isC0ControlPercentEncode(c) {
      return c <= 31 || c > 126;
    }
    var extraPathPercentEncodeSet = /* @__PURE__ */ new Set([
      32, 34, 35, 60, 62, 63, 96, 123, 125,
    ]);
    function isPathPercentEncode(c) {
      return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);
    }
    var extraUserinfoPercentEncodeSet = /* @__PURE__ */ new Set([
      47, 58, 59, 61, 64, 91, 92, 93, 94, 124,
    ]);
    function isUserinfoPercentEncode(c) {
      return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
    }
    function percentEncodeChar(c, encodeSetPredicate) {
      const cStr = String.fromCodePoint(c);
      if (encodeSetPredicate(c)) {
        return utf8PercentEncode(cStr);
      }
      return cStr;
    }
    function parseIPv4Number(input) {
      let R = 10;
      if (
        input.length >= 2 &&
        input.charAt(0) === "0" &&
        input.charAt(1).toLowerCase() === "x"
      ) {
        input = input.substring(2);
        R = 16;
      } else if (input.length >= 2 && input.charAt(0) === "0") {
        input = input.substring(1);
        R = 8;
      }
      if (input === "") {
        return 0;
      }
      const regex = R === 10 ? /[^0-9]/ : R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/;
      if (regex.test(input)) {
        return failure;
      }
      return parseInt(input, R);
    }
    function parseIPv4(input) {
      const parts = input.split(".");
      if (parts[parts.length - 1] === "") {
        if (parts.length > 1) {
          parts.pop();
        }
      }
      if (parts.length > 4) {
        return input;
      }
      const numbers = [];
      for (const part of parts) {
        if (part === "") {
          return input;
        }
        const n = parseIPv4Number(part);
        if (n === failure) {
          return input;
        }
        numbers.push(n);
      }
      for (let i = 0; i < numbers.length - 1; ++i) {
        if (numbers[i] > 255) {
          return failure;
        }
      }
      if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
        return failure;
      }
      let ipv4 = numbers.pop();
      let counter = 0;
      for (const n of numbers) {
        ipv4 += n * Math.pow(256, 3 - counter);
        ++counter;
      }
      return ipv4;
    }
    function serializeIPv4(address) {
      let output = "";
      let n = address;
      for (let i = 1; i <= 4; ++i) {
        output = String(n % 256) + output;
        if (i !== 4) {
          output = "." + output;
        }
        n = Math.floor(n / 256);
      }
      return output;
    }
    function parseIPv6(input) {
      const address = [0, 0, 0, 0, 0, 0, 0, 0];
      let pieceIndex = 0;
      let compress = null;
      let pointer = 0;
      input = punycode.ucs2.decode(input);
      if (input[pointer] === 58) {
        if (input[pointer + 1] !== 58) {
          return failure;
        }
        pointer += 2;
        ++pieceIndex;
        compress = pieceIndex;
      }
      while (pointer < input.length) {
        if (pieceIndex === 8) {
          return failure;
        }
        if (input[pointer] === 58) {
          if (compress !== null) {
            return failure;
          }
          ++pointer;
          ++pieceIndex;
          compress = pieceIndex;
          continue;
        }
        let value = 0;
        let length = 0;
        while (length < 4 && isASCIIHex(input[pointer])) {
          value = value * 16 + parseInt(at(input, pointer), 16);
          ++pointer;
          ++length;
        }
        if (input[pointer] === 46) {
          if (length === 0) {
            return failure;
          }
          pointer -= length;
          if (pieceIndex > 6) {
            return failure;
          }
          let numbersSeen = 0;
          while (input[pointer] !== void 0) {
            let ipv4Piece = null;
            if (numbersSeen > 0) {
              if (input[pointer] === 46 && numbersSeen < 4) {
                ++pointer;
              } else {
                return failure;
              }
            }
            if (!isASCIIDigit(input[pointer])) {
              return failure;
            }
            while (isASCIIDigit(input[pointer])) {
              const number = parseInt(at(input, pointer));
              if (ipv4Piece === null) {
                ipv4Piece = number;
              } else if (ipv4Piece === 0) {
                return failure;
              } else {
                ipv4Piece = ipv4Piece * 10 + number;
              }
              if (ipv4Piece > 255) {
                return failure;
              }
              ++pointer;
            }
            address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
            ++numbersSeen;
            if (numbersSeen === 2 || numbersSeen === 4) {
              ++pieceIndex;
            }
          }
          if (numbersSeen !== 4) {
            return failure;
          }
          break;
        } else if (input[pointer] === 58) {
          ++pointer;
          if (input[pointer] === void 0) {
            return failure;
          }
        } else if (input[pointer] !== void 0) {
          return failure;
        }
        address[pieceIndex] = value;
        ++pieceIndex;
      }
      if (compress !== null) {
        let swaps = pieceIndex - compress;
        pieceIndex = 7;
        while (pieceIndex !== 0 && swaps > 0) {
          const temp = address[compress + swaps - 1];
          address[compress + swaps - 1] = address[pieceIndex];
          address[pieceIndex] = temp;
          --pieceIndex;
          --swaps;
        }
      } else if (compress === null && pieceIndex !== 8) {
        return failure;
      }
      return address;
    }
    function serializeIPv6(address) {
      let output = "";
      const seqResult = findLongestZeroSequence(address);
      const compress = seqResult.idx;
      let ignore0 = false;
      for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {
        if (ignore0 && address[pieceIndex] === 0) {
          continue;
        } else if (ignore0) {
          ignore0 = false;
        }
        if (compress === pieceIndex) {
          const separator = pieceIndex === 0 ? "::" : ":";
          output += separator;
          ignore0 = true;
          continue;
        }
        output += address[pieceIndex].toString(16);
        if (pieceIndex !== 7) {
          output += ":";
        }
      }
      return output;
    }
    function parseHost(input, isSpecialArg) {
      if (input[0] === "[") {
        if (input[input.length - 1] !== "]") {
          return failure;
        }
        return parseIPv6(input.substring(1, input.length - 1));
      }
      if (!isSpecialArg) {
        return parseOpaqueHost(input);
      }
      const domain = utf8PercentDecode(input);
      const asciiDomain = tr46.toASCII(
        domain,
        false,
        tr46.PROCESSING_OPTIONS.NONTRANSITIONAL,
        false
      );
      if (asciiDomain === null) {
        return failure;
      }
      if (containsForbiddenHostCodePoint(asciiDomain)) {
        return failure;
      }
      const ipv4Host = parseIPv4(asciiDomain);
      if (typeof ipv4Host === "number" || ipv4Host === failure) {
        return ipv4Host;
      }
      return asciiDomain;
    }
    function parseOpaqueHost(input) {
      if (containsForbiddenHostCodePointExcludingPercent(input)) {
        return failure;
      }
      let output = "";
      const decoded = punycode.ucs2.decode(input);
      for (let i = 0; i < decoded.length; ++i) {
        output += percentEncodeChar(decoded[i], isC0ControlPercentEncode);
      }
      return output;
    }
    function findLongestZeroSequence(arr) {
      let maxIdx = null;
      let maxLen = 1;
      let currStart = null;
      let currLen = 0;
      for (let i = 0; i < arr.length; ++i) {
        if (arr[i] !== 0) {
          if (currLen > maxLen) {
            maxIdx = currStart;
            maxLen = currLen;
          }
          currStart = null;
          currLen = 0;
        } else {
          if (currStart === null) {
            currStart = i;
          }
          ++currLen;
        }
      }
      if (currLen > maxLen) {
        maxIdx = currStart;
        maxLen = currLen;
      }
      return {
        idx: maxIdx,
        len: maxLen,
      };
    }
    function serializeHost(host) {
      if (typeof host === "number") {
        return serializeIPv4(host);
      }
      if (host instanceof Array) {
        return "[" + serializeIPv6(host) + "]";
      }
      return host;
    }
    function trimControlChars(url) {
      return url.replace(
        /^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g,
        ""
      );
    }
    function trimTabAndNewline(url) {
      return url.replace(/\u0009|\u000A|\u000D/g, "");
    }
    function shortenPath(url) {
      const path = url.path;
      if (path.length === 0) {
        return;
      }
      if (
        url.scheme === "file" &&
        path.length === 1 &&
        isNormalizedWindowsDriveLetter(path[0])
      ) {
        return;
      }
      path.pop();
    }
    function includesCredentials(url) {
      return url.username !== "" || url.password !== "";
    }
    function cannotHaveAUsernamePasswordPort(url) {
      return (
        url.host === null ||
        url.host === "" ||
        url.cannotBeABaseURL ||
        url.scheme === "file"
      );
    }
    function isNormalizedWindowsDriveLetter(string) {
      return /^[A-Za-z]:$/.test(string);
    }
    function URLStateMachine(
      input,
      base,
      encodingOverride,
      url,
      stateOverride
    ) {
      this.pointer = 0;
      this.input = input;
      this.base = base || null;
      this.encodingOverride = encodingOverride || "utf-8";
      this.stateOverride = stateOverride;
      this.url = url;
      this.failure = false;
      this.parseError = false;
      if (!this.url) {
        this.url = {
          scheme: "",
          username: "",
          password: "",
          host: null,
          port: null,
          path: [],
          query: null,
          fragment: null,
          cannotBeABaseURL: false,
        };
        const res2 = trimControlChars(this.input);
        if (res2 !== this.input) {
          this.parseError = true;
        }
        this.input = res2;
      }
      const res = trimTabAndNewline(this.input);
      if (res !== this.input) {
        this.parseError = true;
      }
      this.input = res;
      this.state = stateOverride || "scheme start";
      this.buffer = "";
      this.atFlag = false;
      this.arrFlag = false;
      this.passwordTokenSeenFlag = false;
      this.input = punycode.ucs2.decode(this.input);
      for (; this.pointer <= this.input.length; ++this.pointer) {
        const c = this.input[this.pointer];
        const cStr = isNaN(c) ? void 0 : String.fromCodePoint(c);
        const ret = this["parse " + this.state](c, cStr);
        if (!ret) {
          break;
        } else if (ret === failure) {
          this.failure = true;
          break;
        }
      }
    }
    URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(
      c,
      cStr
    ) {
      if (isASCIIAlpha(c)) {
        this.buffer += cStr.toLowerCase();
        this.state = "scheme";
      } else if (!this.stateOverride) {
        this.state = "no scheme";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse scheme"] = function parseScheme(c, cStr) {
      if (isASCIIAlphanumeric(c) || c === 43 || c === 45 || c === 46) {
        this.buffer += cStr.toLowerCase();
      } else if (c === 58) {
        if (this.stateOverride) {
          if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
            return false;
          }
          if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
            return false;
          }
          if (
            (includesCredentials(this.url) || this.url.port !== null) &&
            this.buffer === "file"
          ) {
            return false;
          }
          if (
            this.url.scheme === "file" &&
            (this.url.host === "" || this.url.host === null)
          ) {
            return false;
          }
        }
        this.url.scheme = this.buffer;
        this.buffer = "";
        if (this.stateOverride) {
          return false;
        }
        if (this.url.scheme === "file") {
          if (
            this.input[this.pointer + 1] !== 47 ||
            this.input[this.pointer + 2] !== 47
          ) {
            this.parseError = true;
          }
          this.state = "file";
        } else if (
          isSpecial(this.url) &&
          this.base !== null &&
          this.base.scheme === this.url.scheme
        ) {
          this.state = "special relative or authority";
        } else if (isSpecial(this.url)) {
          this.state = "special authority slashes";
        } else if (this.input[this.pointer + 1] === 47) {
          this.state = "path or authority";
          ++this.pointer;
        } else {
          this.url.cannotBeABaseURL = true;
          this.url.path.push("");
          this.state = "cannot-be-a-base-URL path";
        }
      } else if (!this.stateOverride) {
        this.buffer = "";
        this.state = "no scheme";
        this.pointer = -1;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c) {
      if (this.base === null || (this.base.cannotBeABaseURL && c !== 35)) {
        return failure;
      } else if (this.base.cannotBeABaseURL && c === 35) {
        this.url.scheme = this.base.scheme;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.url.cannotBeABaseURL = true;
        this.state = "fragment";
      } else if (this.base.scheme === "file") {
        this.state = "file";
        --this.pointer;
      } else {
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special relative or authority"] =
      function parseSpecialRelativeOrAuthority(c) {
        if (c === 47 && this.input[this.pointer + 1] === 47) {
          this.state = "special authority ignore slashes";
          ++this.pointer;
        } else {
          this.parseError = true;
          this.state = "relative";
          --this.pointer;
        }
        return true;
      };
    URLStateMachine.prototype["parse path or authority"] =
      function parsePathOrAuthority(c) {
        if (c === 47) {
          this.state = "authority";
        } else {
          this.state = "path";
          --this.pointer;
        }
        return true;
      };
    URLStateMachine.prototype["parse relative"] = function parseRelative(c) {
      this.url.scheme = this.base.scheme;
      if (isNaN(c)) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
      } else if (c === 47) {
        this.state = "relative slash";
      } else if (c === 63) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = "";
        this.state = "query";
      } else if (c === 35) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.state = "fragment";
      } else if (isSpecial(this.url) && c === 92) {
        this.parseError = true;
        this.state = "relative slash";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice(0, this.base.path.length - 1);
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative slash"] =
      function parseRelativeSlash(c) {
        if (isSpecial(this.url) && (c === 47 || c === 92)) {
          if (c === 92) {
            this.parseError = true;
          }
          this.state = "special authority ignore slashes";
        } else if (c === 47) {
          this.state = "authority";
        } else {
          this.url.username = this.base.username;
          this.url.password = this.base.password;
          this.url.host = this.base.host;
          this.url.port = this.base.port;
          this.state = "path";
          --this.pointer;
        }
        return true;
      };
    URLStateMachine.prototype["parse special authority slashes"] =
      function parseSpecialAuthoritySlashes(c) {
        if (c === 47 && this.input[this.pointer + 1] === 47) {
          this.state = "special authority ignore slashes";
          ++this.pointer;
        } else {
          this.parseError = true;
          this.state = "special authority ignore slashes";
          --this.pointer;
        }
        return true;
      };
    URLStateMachine.prototype["parse special authority ignore slashes"] =
      function parseSpecialAuthorityIgnoreSlashes(c) {
        if (c !== 47 && c !== 92) {
          this.state = "authority";
          --this.pointer;
        } else {
          this.parseError = true;
        }
        return true;
      };
    URLStateMachine.prototype["parse authority"] = function parseAuthority(
      c,
      cStr
    ) {
      if (c === 64) {
        this.parseError = true;
        if (this.atFlag) {
          this.buffer = "%40" + this.buffer;
        }
        this.atFlag = true;
        const len = countSymbols(this.buffer);
        for (let pointer = 0; pointer < len; ++pointer) {
          const codePoint = this.buffer.codePointAt(pointer);
          if (codePoint === 58 && !this.passwordTokenSeenFlag) {
            this.passwordTokenSeenFlag = true;
            continue;
          }
          const encodedCodePoints = percentEncodeChar(
            codePoint,
            isUserinfoPercentEncode
          );
          if (this.passwordTokenSeenFlag) {
            this.url.password += encodedCodePoints;
          } else {
            this.url.username += encodedCodePoints;
          }
        }
        this.buffer = "";
      } else if (
        isNaN(c) ||
        c === 47 ||
        c === 63 ||
        c === 35 ||
        (isSpecial(this.url) && c === 92)
      ) {
        if (this.atFlag && this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        this.pointer -= countSymbols(this.buffer) + 1;
        this.buffer = "";
        this.state = "host";
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype[
      "parse host"
    ] = function parseHostName(c, cStr) {
      if (this.stateOverride && this.url.scheme === "file") {
        --this.pointer;
        this.state = "file host";
      } else if (c === 58 && !this.arrFlag) {
        if (this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "port";
        if (this.stateOverride === "hostname") {
          return false;
        }
      } else if (
        isNaN(c) ||
        c === 47 ||
        c === 63 ||
        c === 35 ||
        (isSpecial(this.url) && c === 92)
      ) {
        --this.pointer;
        if (isSpecial(this.url) && this.buffer === "") {
          this.parseError = true;
          return failure;
        } else if (
          this.stateOverride &&
          this.buffer === "" &&
          (includesCredentials(this.url) || this.url.port !== null)
        ) {
          this.parseError = true;
          return false;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "path start";
        if (this.stateOverride) {
          return false;
        }
      } else {
        if (c === 91) {
          this.arrFlag = true;
        } else if (c === 93) {
          this.arrFlag = false;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse port"] = function parsePort(c, cStr) {
      if (isASCIIDigit(c)) {
        this.buffer += cStr;
      } else if (
        isNaN(c) ||
        c === 47 ||
        c === 63 ||
        c === 35 ||
        (isSpecial(this.url) && c === 92) ||
        this.stateOverride
      ) {
        if (this.buffer !== "") {
          const port = parseInt(this.buffer);
          if (port > Math.pow(2, 16) - 1) {
            this.parseError = true;
            return failure;
          }
          this.url.port = port === defaultPort(this.url.scheme) ? null : port;
          this.buffer = "";
        }
        if (this.stateOverride) {
          return false;
        }
        this.state = "path start";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    var fileOtherwiseCodePoints = /* @__PURE__ */ new Set([47, 92, 63, 35]);
    URLStateMachine.prototype["parse file"] = function parseFile(c) {
      this.url.scheme = "file";
      if (c === 47 || c === 92) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "file slash";
      } else if (this.base !== null && this.base.scheme === "file") {
        if (isNaN(c)) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
        } else if (c === 63) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = "";
          this.state = "query";
        } else if (c === 35) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
          this.url.fragment = "";
          this.state = "fragment";
        } else {
          if (
            this.input.length - this.pointer - 1 === 0 || // remaining consists of 0 code points
            !isWindowsDriveLetterCodePoints(c, this.input[this.pointer + 1]) ||
            (this.input.length - this.pointer - 1 >= 2 && // remaining has at least 2 code points
              !fileOtherwiseCodePoints.has(this.input[this.pointer + 2]))
          ) {
            this.url.host = this.base.host;
            this.url.path = this.base.path.slice();
            shortenPath(this.url);
          } else {
            this.parseError = true;
          }
          this.state = "path";
          --this.pointer;
        }
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c) {
      if (c === 47 || c === 92) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "file host";
      } else {
        if (this.base !== null && this.base.scheme === "file") {
          if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {
            this.url.path.push(this.base.path[0]);
          } else {
            this.url.host = this.base.host;
          }
        }
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file host"] = function parseFileHost(
      c,
      cStr
    ) {
      if (isNaN(c) || c === 47 || c === 92 || c === 63 || c === 35) {
        --this.pointer;
        if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
          this.parseError = true;
          this.state = "path";
        } else if (this.buffer === "") {
          this.url.host = "";
          if (this.stateOverride) {
            return false;
          }
          this.state = "path start";
        } else {
          let host = parseHost(this.buffer, isSpecial(this.url));
          if (host === failure) {
            return failure;
          }
          if (host === "localhost") {
            host = "";
          }
          this.url.host = host;
          if (this.stateOverride) {
            return false;
          }
          this.buffer = "";
          this.state = "path start";
        }
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse path start"] = function parsePathStart(c) {
      if (isSpecial(this.url)) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "path";
        if (c !== 47 && c !== 92) {
          --this.pointer;
        }
      } else if (!this.stateOverride && c === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (!this.stateOverride && c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else if (c !== void 0) {
        this.state = "path";
        if (c !== 47) {
          --this.pointer;
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse path"] = function parsePath(c) {
      if (
        isNaN(c) ||
        c === 47 ||
        (isSpecial(this.url) && c === 92) ||
        (!this.stateOverride && (c === 63 || c === 35))
      ) {
        if (isSpecial(this.url) && c === 92) {
          this.parseError = true;
        }
        if (isDoubleDot(this.buffer)) {
          shortenPath(this.url);
          if (c !== 47 && !(isSpecial(this.url) && c === 92)) {
            this.url.path.push("");
          }
        } else if (
          isSingleDot(this.buffer) &&
          c !== 47 &&
          !(isSpecial(this.url) && c === 92)
        ) {
          this.url.path.push("");
        } else if (!isSingleDot(this.buffer)) {
          if (
            this.url.scheme === "file" &&
            this.url.path.length === 0 &&
            isWindowsDriveLetterString(this.buffer)
          ) {
            if (this.url.host !== "" && this.url.host !== null) {
              this.parseError = true;
              this.url.host = "";
            }
            this.buffer = this.buffer[0] + ":";
          }
          this.url.path.push(this.buffer);
        }
        this.buffer = "";
        if (
          this.url.scheme === "file" &&
          (c === void 0 || c === 63 || c === 35)
        ) {
          while (this.url.path.length > 1 && this.url.path[0] === "") {
            this.parseError = true;
            this.url.path.shift();
          }
        }
        if (c === 63) {
          this.url.query = "";
          this.state = "query";
        }
        if (c === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (
          c === 37 &&
          (!isASCIIHex(this.input[this.pointer + 1]) ||
            !isASCIIHex(this.input[this.pointer + 2]))
        ) {
          this.parseError = true;
        }
        this.buffer += percentEncodeChar(c, isPathPercentEncode);
      }
      return true;
    };
    URLStateMachine.prototype["parse cannot-be-a-base-URL path"] =
      function parseCannotBeABaseURLPath(c) {
        if (c === 63) {
          this.url.query = "";
          this.state = "query";
        } else if (c === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        } else {
          if (!isNaN(c) && c !== 37) {
            this.parseError = true;
          }
          if (
            c === 37 &&
            (!isASCIIHex(this.input[this.pointer + 1]) ||
              !isASCIIHex(this.input[this.pointer + 2]))
          ) {
            this.parseError = true;
          }
          if (!isNaN(c)) {
            this.url.path[0] =
              this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);
          }
        }
        return true;
      };
    URLStateMachine.prototype["parse query"] = function parseQuery(c, cStr) {
      if (isNaN(c) || (!this.stateOverride && c === 35)) {
        if (
          !isSpecial(this.url) ||
          this.url.scheme === "ws" ||
          this.url.scheme === "wss"
        ) {
          this.encodingOverride = "utf-8";
        }
        const buffer = new Buffer(this.buffer);
        for (let i = 0; i < buffer.length; ++i) {
          if (
            buffer[i] < 33 ||
            buffer[i] > 126 ||
            buffer[i] === 34 ||
            buffer[i] === 35 ||
            buffer[i] === 60 ||
            buffer[i] === 62
          ) {
            this.url.query += percentEncode(buffer[i]);
          } else {
            this.url.query += String.fromCodePoint(buffer[i]);
          }
        }
        this.buffer = "";
        if (c === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (
          c === 37 &&
          (!isASCIIHex(this.input[this.pointer + 1]) ||
            !isASCIIHex(this.input[this.pointer + 2]))
        ) {
          this.parseError = true;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse fragment"] = function parseFragment(c) {
      if (isNaN(c)) {
      } else if (c === 0) {
        this.parseError = true;
      } else {
        if (
          c === 37 &&
          (!isASCIIHex(this.input[this.pointer + 1]) ||
            !isASCIIHex(this.input[this.pointer + 2]))
        ) {
          this.parseError = true;
        }
        this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode);
      }
      return true;
    };
    function serializeURL(url, excludeFragment) {
      let output = url.scheme + ":";
      if (url.host !== null) {
        output += "//";
        if (url.username !== "" || url.password !== "") {
          output += url.username;
          if (url.password !== "") {
            output += ":" + url.password;
          }
          output += "@";
        }
        output += serializeHost(url.host);
        if (url.port !== null) {
          output += ":" + url.port;
        }
      } else if (url.host === null && url.scheme === "file") {
        output += "//";
      }
      if (url.cannotBeABaseURL) {
        output += url.path[0];
      } else {
        for (const string of url.path) {
          output += "/" + string;
        }
      }
      if (url.query !== null) {
        output += "?" + url.query;
      }
      if (!excludeFragment && url.fragment !== null) {
        output += "#" + url.fragment;
      }
      return output;
    }
    function serializeOrigin(tuple) {
      let result = tuple.scheme + "://";
      result += serializeHost(tuple.host);
      if (tuple.port !== null) {
        result += ":" + tuple.port;
      }
      return result;
    }
    module2.exports.serializeURL = serializeURL;
    module2.exports.serializeURLOrigin = function (url) {
      switch (url.scheme) {
        case "blob":
          try {
            return module2.exports.serializeURLOrigin(
              module2.exports.parseURL(url.path[0])
            );
          } catch (e) {
            return "null";
          }
        case "ftp":
        case "gopher":
        case "http":
        case "https":
        case "ws":
        case "wss":
          return serializeOrigin({
            scheme: url.scheme,
            host: url.host,
            port: url.port,
          });
        case "file":
          return "file://";
        default:
          return "null";
      }
    };
    module2.exports.basicURLParse = function (input, options) {
      if (options === void 0) {
        options = {};
      }
      const usm = new URLStateMachine(
        input,
        options.baseURL,
        options.encodingOverride,
        options.url,
        options.stateOverride
      );
      if (usm.failure) {
        return "failure";
      }
      return usm.url;
    };
    module2.exports.setTheUsername = function (url, username) {
      url.username = "";
      const decoded = punycode.ucs2.decode(username);
      for (let i = 0; i < decoded.length; ++i) {
        url.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
      }
    };
    module2.exports.setThePassword = function (url, password) {
      url.password = "";
      const decoded = punycode.ucs2.decode(password);
      for (let i = 0; i < decoded.length; ++i) {
        url.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
      }
    };
    module2.exports.serializeHost = serializeHost;
    module2.exports.cannotHaveAUsernamePasswordPort =
      cannotHaveAUsernamePasswordPort;
    module2.exports.serializeInteger = function (integer) {
      return String(integer);
    };
    module2.exports.parseURL = function (input, options) {
      if (options === void 0) {
        options = {};
      }
      return module2.exports.basicURLParse(input, {
        baseURL: options.baseURL,
        encodingOverride: options.encodingOverride,
      });
    };
  },
});

// node_modules/whatwg-url/lib/URL-impl.js
var require_URL_impl = __commonJS({
  "node_modules/whatwg-url/lib/URL-impl.js"(exports2) {
    "use strict";
    var usm = require_url_state_machine();
    exports2.implementation = class URLImpl {
      constructor(constructorArgs) {
        const url = constructorArgs[0];
        const base = constructorArgs[1];
        let parsedBase = null;
        if (base !== void 0) {
          parsedBase = usm.basicURLParse(base);
          if (parsedBase === "failure") {
            throw new TypeError("Invalid base URL");
          }
        }
        const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
      }
      get href() {
        return usm.serializeURL(this._url);
      }
      set href(v) {
        const parsedURL = usm.basicURLParse(v);
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
      }
      get origin() {
        return usm.serializeURLOrigin(this._url);
      }
      get protocol() {
        return this._url.scheme + ":";
      }
      set protocol(v) {
        usm.basicURLParse(v + ":", {
          url: this._url,
          stateOverride: "scheme start",
        });
      }
      get username() {
        return this._url.username;
      }
      set username(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setTheUsername(this._url, v);
      }
      get password() {
        return this._url.password;
      }
      set password(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setThePassword(this._url, v);
      }
      get host() {
        const url = this._url;
        if (url.host === null) {
          return "";
        }
        if (url.port === null) {
          return usm.serializeHost(url.host);
        }
        return (
          usm.serializeHost(url.host) + ":" + usm.serializeInteger(url.port)
        );
      }
      set host(v) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v, { url: this._url, stateOverride: "host" });
      }
      get hostname() {
        if (this._url.host === null) {
          return "";
        }
        return usm.serializeHost(this._url.host);
      }
      set hostname(v) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v, { url: this._url, stateOverride: "hostname" });
      }
      get port() {
        if (this._url.port === null) {
          return "";
        }
        return usm.serializeInteger(this._url.port);
      }
      set port(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        if (v === "") {
          this._url.port = null;
        } else {
          usm.basicURLParse(v, { url: this._url, stateOverride: "port" });
        }
      }
      get pathname() {
        if (this._url.cannotBeABaseURL) {
          return this._url.path[0];
        }
        if (this._url.path.length === 0) {
          return "";
        }
        return "/" + this._url.path.join("/");
      }
      set pathname(v) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        this._url.path = [];
        usm.basicURLParse(v, { url: this._url, stateOverride: "path start" });
      }
      get search() {
        if (this._url.query === null || this._url.query === "") {
          return "";
        }
        return "?" + this._url.query;
      }
      set search(v) {
        const url = this._url;
        if (v === "") {
          url.query = null;
          return;
        }
        const input = v[0] === "?" ? v.substring(1) : v;
        url.query = "";
        usm.basicURLParse(input, { url, stateOverride: "query" });
      }
      get hash() {
        if (this._url.fragment === null || this._url.fragment === "") {
          return "";
        }
        return "#" + this._url.fragment;
      }
      set hash(v) {
        if (v === "") {
          this._url.fragment = null;
          return;
        }
        const input = v[0] === "#" ? v.substring(1) : v;
        this._url.fragment = "";
        usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
      }
      toJSON() {
        return this.href;
      }
    };
  },
});

// node_modules/whatwg-url/lib/URL.js
var require_URL = __commonJS({
  "node_modules/whatwg-url/lib/URL.js"(exports2, module2) {
    "use strict";
    var conversions = require_lib3();
    var utils = require_utils11();
    var Impl = require_URL_impl();
    var impl = utils.implSymbol;
    function URL(url) {
      if (!this || this[impl] || !(this instanceof URL)) {
        throw new TypeError(
          "Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function."
        );
      }
      if (arguments.length < 1) {
        throw new TypeError(
          "Failed to construct 'URL': 1 argument required, but only " +
            arguments.length +
            " present."
        );
      }
      const args = [];
      for (let i = 0; i < arguments.length && i < 2; ++i) {
        args[i] = arguments[i];
      }
      args[0] = conversions["USVString"](args[0]);
      if (args[1] !== void 0) {
        args[1] = conversions["USVString"](args[1]);
      }
      module2.exports.setup(this, args);
    }
    URL.prototype.toJSON = function toJSON() {
      if (!this || !module2.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }
      const args = [];
      for (let i = 0; i < arguments.length && i < 0; ++i) {
        args[i] = arguments[i];
      }
      return this[impl].toJSON.apply(this[impl], args);
    };
    Object.defineProperty(URL.prototype, "href", {
      get() {
        return this[impl].href;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].href = V;
      },
      enumerable: true,
      configurable: true,
    });
    URL.prototype.toString = function () {
      if (!this || !module2.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }
      return this.href;
    };
    Object.defineProperty(URL.prototype, "origin", {
      get() {
        return this[impl].origin;
      },
      enumerable: true,
      configurable: true,
    });
    Object.defineProperty(URL.prototype, "protocol", {
      get() {
        return this[impl].protocol;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].protocol = V;
      },
      enumerable: true,
      configurable: true,
    });
    Object.defineProperty(URL.prototype, "username", {
      get() {
        return this[impl].username;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].username = V;
      },
      enumerable: true,
      configurable: true,
    });
    Object.defineProperty(URL.prototype, "password", {
      get() {
        return this[impl].password;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].password = V;
      },
      enumerable: true,
      configurable: true,
    });
    Object.defineProperty(URL.prototype, "host", {
      get() {
        return this[impl].host;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].host = V;
      },
      enumerable: true,
      configurable: true,
    });
    Object.defineProperty(URL.prototype, "hostname", {
      get() {
        return this[impl].hostname;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].hostname = V;
      },
      enumerable: true,
      configurable: true,
    });
    Object.defineProperty(URL.prototype, "port", {
      get() {
        return this[impl].port;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].port = V;
      },
      enumerable: true,
      configurable: true,
    });
    Object.defineProperty(URL.prototype, "pathname", {
      get() {
        return this[impl].pathname;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].pathname = V;
      },
      enumerable: true,
      configurable: true,
    });
    Object.defineProperty(URL.prototype, "search", {
      get() {
        return this[impl].search;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].search = V;
      },
      enumerable: true,
      configurable: true,
    });
    Object.defineProperty(URL.prototype, "hash", {
      get() {
        return this[impl].hash;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].hash = V;
      },
      enumerable: true,
      configurable: true,
    });
    module2.exports = {
      is(obj) {
        return !!obj && obj[impl] instanceof Impl.implementation;
      },
      create(constructorArgs, privateData) {
        let obj = Object.create(URL.prototype);
        this.setup(obj, constructorArgs, privateData);
        return obj;
      },
      setup(obj, constructorArgs, privateData) {
        if (!privateData) privateData = {};
        privateData.wrapper = obj;
        obj[impl] = new Impl.implementation(constructorArgs, privateData);
        obj[impl][utils.wrapperSymbol] = obj;
      },
      interface: URL,
      expose: {
        Window: { URL },
        Worker: { URL },
      },
    };
  },
});

// node_modules/whatwg-url/lib/public-api.js
var require_public_api = __commonJS({
  "node_modules/whatwg-url/lib/public-api.js"(exports2) {
    "use strict";
    exports2.URL = require_URL().interface;
    exports2.serializeURL = require_url_state_machine().serializeURL;
    exports2.serializeURLOrigin =
      require_url_state_machine().serializeURLOrigin;
    exports2.basicURLParse = require_url_state_machine().basicURLParse;
    exports2.setTheUsername = require_url_state_machine().setTheUsername;
    exports2.setThePassword = require_url_state_machine().setThePassword;
    exports2.serializeHost = require_url_state_machine().serializeHost;
    exports2.serializeInteger = require_url_state_machine().serializeInteger;
    exports2.parseURL = require_url_state_machine().parseURL;
  },
});

// node_modules/node-fetch/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/node-fetch/lib/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex
        ? ex["default"]
        : ex;
    }
    var Stream = _interopDefault(require("stream"));
    var http = _interopDefault(require("http"));
    var Url = _interopDefault(require("url"));
    var whatwgUrl = _interopDefault(require_public_api());
    var https = _interopDefault(require("https"));
    var zlib = _interopDefault(require("zlib"));
    var Readable = Stream.Readable;
    var BUFFER = Symbol("buffer");
    var TYPE = Symbol("type");
    var Blob2 = class _Blob {
      constructor() {
        this[TYPE] = "";
        const blobParts = arguments[0];
        const options = arguments[1];
        const buffers = [];
        let size = 0;
        if (blobParts) {
          const a = blobParts;
          const length = Number(a.length);
          for (let i = 0; i < length; i++) {
            const element = a[i];
            let buffer;
            if (element instanceof Buffer) {
              buffer = element;
            } else if (ArrayBuffer.isView(element)) {
              buffer = Buffer.from(
                element.buffer,
                element.byteOffset,
                element.byteLength
              );
            } else if (element instanceof ArrayBuffer) {
              buffer = Buffer.from(element);
            } else if (element instanceof _Blob) {
              buffer = element[BUFFER];
            } else {
              buffer = Buffer.from(
                typeof element === "string" ? element : String(element)
              );
            }
            size += buffer.length;
            buffers.push(buffer);
          }
        }
        this[BUFFER] = Buffer.concat(buffers);
        let type =
          options &&
          options.type !== void 0 &&
          String(options.type).toLowerCase();
        if (type && !/[^\u0020-\u007E]/.test(type)) {
          this[TYPE] = type;
        }
      }
      get size() {
        return this[BUFFER].length;
      }
      get type() {
        return this[TYPE];
      }
      text() {
        return Promise.resolve(this[BUFFER].toString());
      }
      arrayBuffer() {
        const buf = this[BUFFER];
        const ab = buf.buffer.slice(
          buf.byteOffset,
          buf.byteOffset + buf.byteLength
        );
        return Promise.resolve(ab);
      }
      stream() {
        const readable = new Readable();
        readable._read = function () {};
        readable.push(this[BUFFER]);
        readable.push(null);
        return readable;
      }
      toString() {
        return "[object Blob]";
      }
      slice() {
        const size = this.size;
        const start = arguments[0];
        const end = arguments[1];
        let relativeStart, relativeEnd;
        if (start === void 0) {
          relativeStart = 0;
        } else if (start < 0) {
          relativeStart = Math.max(size + start, 0);
        } else {
          relativeStart = Math.min(start, size);
        }
        if (end === void 0) {
          relativeEnd = size;
        } else if (end < 0) {
          relativeEnd = Math.max(size + end, 0);
        } else {
          relativeEnd = Math.min(end, size);
        }
        const span = Math.max(relativeEnd - relativeStart, 0);
        const buffer = this[BUFFER];
        const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
        const blob = new _Blob([], { type: arguments[2] });
        blob[BUFFER] = slicedBuffer;
        return blob;
      }
    };
    Object.defineProperties(Blob2.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true },
    });
    Object.defineProperty(Blob2.prototype, Symbol.toStringTag, {
      value: "Blob",
      writable: false,
      enumerable: false,
      configurable: true,
    });
    function FetchError(message, type, systemError) {
      Error.call(this, message);
      this.message = message;
      this.type = type;
      if (systemError) {
        this.code = this.errno = systemError.code;
      }
      Error.captureStackTrace(this, this.constructor);
    }
    FetchError.prototype = Object.create(Error.prototype);
    FetchError.prototype.constructor = FetchError;
    FetchError.prototype.name = "FetchError";
    var convert;
    try {
      convert = require("encoding").convert;
    } catch (e) {}
    var INTERNALS = Symbol("Body internals");
    var PassThrough = Stream.PassThrough;
    function Body(body) {
      var _this = this;
      var _ref =
          arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
        _ref$size = _ref.size;
      let size = _ref$size === void 0 ? 0 : _ref$size;
      var _ref$timeout = _ref.timeout;
      let timeout = _ref$timeout === void 0 ? 0 : _ref$timeout;
      if (body == null) {
        body = null;
      } else if (isURLSearchParams(body)) {
        body = Buffer.from(body.toString());
      } else if (isBlob(body));
      else if (Buffer.isBuffer(body));
      else if (
        Object.prototype.toString.call(body) === "[object ArrayBuffer]"
      ) {
        body = Buffer.from(body);
      } else if (ArrayBuffer.isView(body)) {
        body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
      } else if (body instanceof Stream);
      else {
        body = Buffer.from(String(body));
      }
      this[INTERNALS] = {
        body,
        disturbed: false,
        error: null,
      };
      this.size = size;
      this.timeout = timeout;
      if (body instanceof Stream) {
        body.on("error", function (err) {
          const error =
            err.name === "AbortError"
              ? err
              : new FetchError(
                  `Invalid response body while trying to fetch ${_this.url}: ${err.message}`,
                  "system",
                  err
                );
          _this[INTERNALS].error = error;
        });
      }
    }
    Body.prototype = {
      get body() {
        return this[INTERNALS].body;
      },
      get bodyUsed() {
        return this[INTERNALS].disturbed;
      },
      /**
       * Decode response as ArrayBuffer
       *
       * @return  Promise
       */
      arrayBuffer() {
        return consumeBody.call(this).then(function (buf) {
          return buf.buffer.slice(
            buf.byteOffset,
            buf.byteOffset + buf.byteLength
          );
        });
      },
      /**
       * Return raw response as Blob
       *
       * @return Promise
       */
      blob() {
        let ct = (this.headers && this.headers.get("content-type")) || "";
        return consumeBody.call(this).then(function (buf) {
          return Object.assign(
            // Prevent copying
            new Blob2([], {
              type: ct.toLowerCase(),
            }),
            {
              [BUFFER]: buf,
            }
          );
        });
      },
      /**
       * Decode response as json
       *
       * @return  Promise
       */
      json() {
        var _this2 = this;
        return consumeBody.call(this).then(function (buffer) {
          try {
            return JSON.parse(buffer.toString());
          } catch (err) {
            return Body.Promise.reject(
              new FetchError(
                `invalid json response body at ${_this2.url} reason: ${err.message}`,
                "invalid-json"
              )
            );
          }
        });
      },
      /**
       * Decode response as text
       *
       * @return  Promise
       */
      text() {
        return consumeBody.call(this).then(function (buffer) {
          return buffer.toString();
        });
      },
      /**
       * Decode response as buffer (non-spec api)
       *
       * @return  Promise
       */
      buffer() {
        return consumeBody.call(this);
      },
      /**
       * Decode response as text, while automatically detecting the encoding and
       * trying to decode to UTF-8 (non-spec api)
       *
       * @return  Promise
       */
      textConverted() {
        var _this3 = this;
        return consumeBody.call(this).then(function (buffer) {
          return convertBody(buffer, _this3.headers);
        });
      },
    };
    Object.defineProperties(Body.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true },
    });
    Body.mixIn = function (proto) {
      for (const name of Object.getOwnPropertyNames(Body.prototype)) {
        if (!(name in proto)) {
          const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
          Object.defineProperty(proto, name, desc);
        }
      }
    };
    function consumeBody() {
      var _this4 = this;
      if (this[INTERNALS].disturbed) {
        return Body.Promise.reject(
          new TypeError(`body used already for: ${this.url}`)
        );
      }
      this[INTERNALS].disturbed = true;
      if (this[INTERNALS].error) {
        return Body.Promise.reject(this[INTERNALS].error);
      }
      let body = this.body;
      if (body === null) {
        return Body.Promise.resolve(Buffer.alloc(0));
      }
      if (isBlob(body)) {
        body = body.stream();
      }
      if (Buffer.isBuffer(body)) {
        return Body.Promise.resolve(body);
      }
      if (!(body instanceof Stream)) {
        return Body.Promise.resolve(Buffer.alloc(0));
      }
      let accum = [];
      let accumBytes = 0;
      let abort = false;
      return new Body.Promise(function (resolve, reject) {
        let resTimeout;
        if (_this4.timeout) {
          resTimeout = setTimeout(function () {
            abort = true;
            reject(
              new FetchError(
                `Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`,
                "body-timeout"
              )
            );
          }, _this4.timeout);
        }
        body.on("error", function (err) {
          if (err.name === "AbortError") {
            abort = true;
            reject(err);
          } else {
            reject(
              new FetchError(
                `Invalid response body while trying to fetch ${_this4.url}: ${err.message}`,
                "system",
                err
              )
            );
          }
        });
        body.on("data", function (chunk) {
          if (abort || chunk === null) {
            return;
          }
          if (_this4.size && accumBytes + chunk.length > _this4.size) {
            abort = true;
            reject(
              new FetchError(
                `content size at ${_this4.url} over limit: ${_this4.size}`,
                "max-size"
              )
            );
            return;
          }
          accumBytes += chunk.length;
          accum.push(chunk);
        });
        body.on("end", function () {
          if (abort) {
            return;
          }
          clearTimeout(resTimeout);
          try {
            resolve(Buffer.concat(accum, accumBytes));
          } catch (err) {
            reject(
              new FetchError(
                `Could not create Buffer from response body for ${_this4.url}: ${err.message}`,
                "system",
                err
              )
            );
          }
        });
      });
    }
    function convertBody(buffer, headers) {
      if (typeof convert !== "function") {
        throw new Error(
          "The package `encoding` must be installed to use the textConverted() function"
        );
      }
      const ct = headers.get("content-type");
      let charset = "utf-8";
      let res, str;
      if (ct) {
        res = /charset=([^;]*)/i.exec(ct);
      }
      str = buffer.slice(0, 1024).toString();
      if (!res && str) {
        res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
      }
      if (!res && str) {
        res =
          /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(
            str
          );
        if (!res) {
          res =
            /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(
              str
            );
          if (res) {
            res.pop();
          }
        }
        if (res) {
          res = /charset=(.*)/i.exec(res.pop());
        }
      }
      if (!res && str) {
        res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
      }
      if (res) {
        charset = res.pop();
        if (charset === "gb2312" || charset === "gbk") {
          charset = "gb18030";
        }
      }
      return convert(buffer, "UTF-8", charset).toString();
    }
    function isURLSearchParams(obj) {
      if (
        typeof obj !== "object" ||
        typeof obj.append !== "function" ||
        typeof obj.delete !== "function" ||
        typeof obj.get !== "function" ||
        typeof obj.getAll !== "function" ||
        typeof obj.has !== "function" ||
        typeof obj.set !== "function"
      ) {
        return false;
      }
      return (
        obj.constructor.name === "URLSearchParams" ||
        Object.prototype.toString.call(obj) === "[object URLSearchParams]" ||
        typeof obj.sort === "function"
      );
    }
    function isBlob(obj) {
      return (
        typeof obj === "object" &&
        typeof obj.arrayBuffer === "function" &&
        typeof obj.type === "string" &&
        typeof obj.stream === "function" &&
        typeof obj.constructor === "function" &&
        typeof obj.constructor.name === "string" &&
        /^(Blob|File)$/.test(obj.constructor.name) &&
        /^(Blob|File)$/.test(obj[Symbol.toStringTag])
      );
    }
    function clone(instance) {
      let p1, p2;
      let body = instance.body;
      if (instance.bodyUsed) {
        throw new Error("cannot clone body after it is used");
      }
      if (body instanceof Stream && typeof body.getBoundary !== "function") {
        p1 = new PassThrough();
        p2 = new PassThrough();
        body.pipe(p1);
        body.pipe(p2);
        instance[INTERNALS].body = p1;
        body = p2;
      }
      return body;
    }
    function extractContentType(body) {
      if (body === null) {
        return null;
      } else if (typeof body === "string") {
        return "text/plain;charset=UTF-8";
      } else if (isURLSearchParams(body)) {
        return "application/x-www-form-urlencoded;charset=UTF-8";
      } else if (isBlob(body)) {
        return body.type || null;
      } else if (Buffer.isBuffer(body)) {
        return null;
      } else if (
        Object.prototype.toString.call(body) === "[object ArrayBuffer]"
      ) {
        return null;
      } else if (ArrayBuffer.isView(body)) {
        return null;
      } else if (typeof body.getBoundary === "function") {
        return `multipart/form-data;boundary=${body.getBoundary()}`;
      } else if (body instanceof Stream) {
        return null;
      } else {
        return "text/plain;charset=UTF-8";
      }
    }
    function getTotalBytes(instance) {
      const body = instance.body;
      if (body === null) {
        return 0;
      } else if (isBlob(body)) {
        return body.size;
      } else if (Buffer.isBuffer(body)) {
        return body.length;
      } else if (body && typeof body.getLengthSync === "function") {
        if (
          (body._lengthRetrievers && body._lengthRetrievers.length == 0) || // 1.x
          (body.hasKnownLength && body.hasKnownLength())
        ) {
          return body.getLengthSync();
        }
        return null;
      } else {
        return null;
      }
    }
    function writeToStream(dest, instance) {
      const body = instance.body;
      if (body === null) {
        dest.end();
      } else if (isBlob(body)) {
        body.stream().pipe(dest);
      } else if (Buffer.isBuffer(body)) {
        dest.write(body);
        dest.end();
      } else {
        body.pipe(dest);
      }
    }
    Body.Promise = global.Promise;
    var invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
    var invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
    function validateName(name) {
      name = `${name}`;
      if (invalidTokenRegex.test(name) || name === "") {
        throw new TypeError(`${name} is not a legal HTTP header name`);
      }
    }
    function validateValue(value) {
      value = `${value}`;
      if (invalidHeaderCharRegex.test(value)) {
        throw new TypeError(`${value} is not a legal HTTP header value`);
      }
    }
    function find(map, name) {
      name = name.toLowerCase();
      for (const key in map) {
        if (key.toLowerCase() === name) {
          return key;
        }
      }
      return void 0;
    }
    var MAP = Symbol("map");
    var Headers = class _Headers {
      /**
       * Headers class
       *
       * @param   Object  headers  Response headers
       * @return  Void
       */
      constructor() {
        let init =
          arguments.length > 0 && arguments[0] !== void 0
            ? arguments[0]
            : void 0;
        this[MAP] = /* @__PURE__ */ Object.create(null);
        if (init instanceof _Headers) {
          const rawHeaders = init.raw();
          const headerNames = Object.keys(rawHeaders);
          for (const headerName of headerNames) {
            for (const value of rawHeaders[headerName]) {
              this.append(headerName, value);
            }
          }
          return;
        }
        if (init == null);
        else if (typeof init === "object") {
          const method = init[Symbol.iterator];
          if (method != null) {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            const pairs = [];
            for (const pair of init) {
              if (
                typeof pair !== "object" ||
                typeof pair[Symbol.iterator] !== "function"
              ) {
                throw new TypeError("Each header pair must be iterable");
              }
              pairs.push(Array.from(pair));
            }
            for (const pair of pairs) {
              if (pair.length !== 2) {
                throw new TypeError(
                  "Each header pair must be a name/value tuple"
                );
              }
              this.append(pair[0], pair[1]);
            }
          } else {
            for (const key of Object.keys(init)) {
              const value = init[key];
              this.append(key, value);
            }
          }
        } else {
          throw new TypeError("Provided initializer must be an object");
        }
      }
      /**
       * Return combined header value given name
       *
       * @param   String  name  Header name
       * @return  Mixed
       */
      get(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key === void 0) {
          return null;
        }
        return this[MAP][key].join(", ");
      }
      /**
       * Iterate over all headers
       *
       * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
       * @param   Boolean   thisArg   `this` context for callback function
       * @return  Void
       */
      forEach(callback) {
        let thisArg =
          arguments.length > 1 && arguments[1] !== void 0
            ? arguments[1]
            : void 0;
        let pairs = getHeaders(this);
        let i = 0;
        while (i < pairs.length) {
          var _pairs$i = pairs[i];
          const name = _pairs$i[0],
            value = _pairs$i[1];
          callback.call(thisArg, value, name, this);
          pairs = getHeaders(this);
          i++;
        }
      }
      /**
       * Overwrite header values given name
       *
       * @param   String  name   Header name
       * @param   String  value  Header value
       * @return  Void
       */
      set(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        this[MAP][key !== void 0 ? key : name] = [value];
      }
      /**
       * Append a value onto existing header
       *
       * @param   String  name   Header name
       * @param   String  value  Header value
       * @return  Void
       */
      append(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        if (key !== void 0) {
          this[MAP][key].push(value);
        } else {
          this[MAP][name] = [value];
        }
      }
      /**
       * Check for header name existence
       *
       * @param   String   name  Header name
       * @return  Boolean
       */
      has(name) {
        name = `${name}`;
        validateName(name);
        return find(this[MAP], name) !== void 0;
      }
      /**
       * Delete all header values given name
       *
       * @param   String  name  Header name
       * @return  Void
       */
      delete(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key !== void 0) {
          delete this[MAP][key];
        }
      }
      /**
       * Return raw headers (non-spec api)
       *
       * @return  Object
       */
      raw() {
        return this[MAP];
      }
      /**
       * Get an iterator on keys.
       *
       * @return  Iterator
       */
      keys() {
        return createHeadersIterator(this, "key");
      }
      /**
       * Get an iterator on values.
       *
       * @return  Iterator
       */
      values() {
        return createHeadersIterator(this, "value");
      }
      /**
       * Get an iterator on entries.
       *
       * This is the default iterator of the Headers object.
       *
       * @return  Iterator
       */
      [Symbol.iterator]() {
        return createHeadersIterator(this, "key+value");
      }
    };
    Headers.prototype.entries = Headers.prototype[Symbol.iterator];
    Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
      value: "Headers",
      writable: false,
      enumerable: false,
      configurable: true,
    });
    Object.defineProperties(Headers.prototype, {
      get: { enumerable: true },
      forEach: { enumerable: true },
      set: { enumerable: true },
      append: { enumerable: true },
      has: { enumerable: true },
      delete: { enumerable: true },
      keys: { enumerable: true },
      values: { enumerable: true },
      entries: { enumerable: true },
    });
    function getHeaders(headers) {
      let kind =
        arguments.length > 1 && arguments[1] !== void 0
          ? arguments[1]
          : "key+value";
      const keys = Object.keys(headers[MAP]).sort();
      return keys.map(
        kind === "key"
          ? function (k) {
              return k.toLowerCase();
            }
          : kind === "value"
          ? function (k) {
              return headers[MAP][k].join(", ");
            }
          : function (k) {
              return [k.toLowerCase(), headers[MAP][k].join(", ")];
            }
      );
    }
    var INTERNAL = Symbol("internal");
    function createHeadersIterator(target, kind) {
      const iterator = Object.create(HeadersIteratorPrototype);
      iterator[INTERNAL] = {
        target,
        kind,
        index: 0,
      };
      return iterator;
    }
    var HeadersIteratorPrototype = Object.setPrototypeOf(
      {
        next() {
          if (
            !this ||
            Object.getPrototypeOf(this) !== HeadersIteratorPrototype
          ) {
            throw new TypeError("Value of `this` is not a HeadersIterator");
          }
          var _INTERNAL = this[INTERNAL];
          const target = _INTERNAL.target,
            kind = _INTERNAL.kind,
            index = _INTERNAL.index;
          const values = getHeaders(target, kind);
          const len = values.length;
          if (index >= len) {
            return {
              value: void 0,
              done: true,
            };
          }
          this[INTERNAL].index = index + 1;
          return {
            value: values[index],
            done: false,
          };
        },
      },
      Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()))
    );
    Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
      value: "HeadersIterator",
      writable: false,
      enumerable: false,
      configurable: true,
    });
    function exportNodeCompatibleHeaders(headers) {
      const obj = Object.assign({ __proto__: null }, headers[MAP]);
      const hostHeaderKey = find(headers[MAP], "Host");
      if (hostHeaderKey !== void 0) {
        obj[hostHeaderKey] = obj[hostHeaderKey][0];
      }
      return obj;
    }
    function createHeadersLenient(obj) {
      const headers = new Headers();
      for (const name of Object.keys(obj)) {
        if (invalidTokenRegex.test(name)) {
          continue;
        }
        if (Array.isArray(obj[name])) {
          for (const val of obj[name]) {
            if (invalidHeaderCharRegex.test(val)) {
              continue;
            }
            if (headers[MAP][name] === void 0) {
              headers[MAP][name] = [val];
            } else {
              headers[MAP][name].push(val);
            }
          }
        } else if (!invalidHeaderCharRegex.test(obj[name])) {
          headers[MAP][name] = [obj[name]];
        }
      }
      return headers;
    }
    var INTERNALS$1 = Symbol("Response internals");
    var STATUS_CODES = http.STATUS_CODES;
    var Response = class _Response {
      constructor() {
        let body =
          arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        let opts =
          arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        Body.call(this, body, opts);
        const status = opts.status || 200;
        const headers = new Headers(opts.headers);
        if (body != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(body);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS$1] = {
          url: opts.url,
          status,
          statusText: opts.statusText || STATUS_CODES[status],
          headers,
          counter: opts.counter,
        };
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      /**
       * Convenience property representing if the request ended normally
       */
      get ok() {
        return (
          this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300
        );
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      get headers() {
        return this[INTERNALS$1].headers;
      }
      /**
       * Clone this response
       *
       * @return  Response
       */
      clone() {
        return new _Response(clone(this), {
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected,
        });
      }
    };
    Body.mixIn(Response.prototype);
    Object.defineProperties(Response.prototype, {
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      redirected: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true },
    });
    Object.defineProperty(Response.prototype, Symbol.toStringTag, {
      value: "Response",
      writable: false,
      enumerable: false,
      configurable: true,
    });
    var INTERNALS$2 = Symbol("Request internals");
    var URL = Url.URL || whatwgUrl.URL;
    var parse_url = Url.parse;
    var format_url = Url.format;
    function parseURL(urlStr) {
      if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {
        urlStr = new URL(urlStr).toString();
      }
      return parse_url(urlStr);
    }
    var streamDestructionSupported = "destroy" in Stream.Readable.prototype;
    function isRequest(input) {
      return (
        typeof input === "object" && typeof input[INTERNALS$2] === "object"
      );
    }
    function isAbortSignal(signal) {
      const proto =
        signal && typeof signal === "object" && Object.getPrototypeOf(signal);
      return !!(proto && proto.constructor.name === "AbortSignal");
    }
    var Request = class _Request {
      constructor(input) {
        let init =
          arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        let parsedURL;
        if (!isRequest(input)) {
          if (input && input.href) {
            parsedURL = parseURL(input.href);
          } else {
            parsedURL = parseURL(`${input}`);
          }
          input = {};
        } else {
          parsedURL = parseURL(input.url);
        }
        let method = init.method || input.method || "GET";
        method = method.toUpperCase();
        if (
          (init.body != null || (isRequest(input) && input.body !== null)) &&
          (method === "GET" || method === "HEAD")
        ) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        let inputBody =
          init.body != null
            ? init.body
            : isRequest(input) && input.body !== null
            ? clone(input)
            : null;
        Body.call(this, inputBody, {
          timeout: init.timeout || input.timeout || 0,
          size: init.size || input.size || 0,
        });
        const headers = new Headers(init.headers || input.headers || {});
        if (inputBody != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(inputBody);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ("signal" in init) signal = init.signal;
        if (signal != null && !isAbortSignal(signal)) {
          throw new TypeError(
            "Expected signal to be an instanceof AbortSignal"
          );
        }
        this[INTERNALS$2] = {
          method,
          redirect: init.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal,
        };
        this.follow =
          init.follow !== void 0
            ? init.follow
            : input.follow !== void 0
            ? input.follow
            : 20;
        this.compress =
          init.compress !== void 0
            ? init.compress
            : input.compress !== void 0
            ? input.compress
            : true;
        this.counter = init.counter || input.counter || 0;
        this.agent = init.agent || input.agent;
      }
      get method() {
        return this[INTERNALS$2].method;
      }
      get url() {
        return format_url(this[INTERNALS$2].parsedURL);
      }
      get headers() {
        return this[INTERNALS$2].headers;
      }
      get redirect() {
        return this[INTERNALS$2].redirect;
      }
      get signal() {
        return this[INTERNALS$2].signal;
      }
      /**
       * Clone this request
       *
       * @return  Request
       */
      clone() {
        return new _Request(this);
      }
    };
    Body.mixIn(Request.prototype);
    Object.defineProperty(Request.prototype, Symbol.toStringTag, {
      value: "Request",
      writable: false,
      enumerable: false,
      configurable: true,
    });
    Object.defineProperties(Request.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true },
    });
    function getNodeRequestOptions(request) {
      const parsedURL = request[INTERNALS$2].parsedURL;
      const headers = new Headers(request[INTERNALS$2].headers);
      if (!headers.has("Accept")) {
        headers.set("Accept", "*/*");
      }
      if (!parsedURL.protocol || !parsedURL.hostname) {
        throw new TypeError("Only absolute URLs are supported");
      }
      if (!/^https?:$/.test(parsedURL.protocol)) {
        throw new TypeError("Only HTTP(S) protocols are supported");
      }
      if (
        request.signal &&
        request.body instanceof Stream.Readable &&
        !streamDestructionSupported
      ) {
        throw new Error(
          "Cancellation of streamed requests with AbortSignal is not supported in node < 8"
        );
      }
      let contentLengthValue = null;
      if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
        contentLengthValue = "0";
      }
      if (request.body != null) {
        const totalBytes = getTotalBytes(request);
        if (typeof totalBytes === "number") {
          contentLengthValue = String(totalBytes);
        }
      }
      if (contentLengthValue) {
        headers.set("Content-Length", contentLengthValue);
      }
      if (!headers.has("User-Agent")) {
        headers.set(
          "User-Agent",
          "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)"
        );
      }
      if (request.compress && !headers.has("Accept-Encoding")) {
        headers.set("Accept-Encoding", "gzip,deflate");
      }
      let agent = request.agent;
      if (typeof agent === "function") {
        agent = agent(parsedURL);
      }
      return Object.assign({}, parsedURL, {
        method: request.method,
        headers: exportNodeCompatibleHeaders(headers),
        agent,
      });
    }
    function AbortError(message) {
      Error.call(this, message);
      this.type = "aborted";
      this.message = message;
      Error.captureStackTrace(this, this.constructor);
    }
    AbortError.prototype = Object.create(Error.prototype);
    AbortError.prototype.constructor = AbortError;
    AbortError.prototype.name = "AbortError";
    var URL$1 = Url.URL || whatwgUrl.URL;
    var PassThrough$1 = Stream.PassThrough;
    var isDomainOrSubdomain = function isDomainOrSubdomain2(
      destination,
      original
    ) {
      const orig = new URL$1(original).hostname;
      const dest = new URL$1(destination).hostname;
      return (
        orig === dest ||
        (orig[orig.length - dest.length - 1] === "." && orig.endsWith(dest))
      );
    };
    var isSameProtocol = function isSameProtocol2(destination, original) {
      const orig = new URL$1(original).protocol;
      const dest = new URL$1(destination).protocol;
      return orig === dest;
    };
    function fetch(url, opts) {
      if (!fetch.Promise) {
        throw new Error(
          "native promise missing, set fetch.Promise to your favorite alternative"
        );
      }
      Body.Promise = fetch.Promise;
      return new fetch.Promise(function (resolve, reject) {
        const request = new Request(url, opts);
        const options = getNodeRequestOptions(request);
        const send = (options.protocol === "https:" ? https : http).request;
        const signal = request.signal;
        let response = null;
        const abort = function abort2() {
          let error = new AbortError("The user aborted a request.");
          reject(error);
          if (request.body && request.body instanceof Stream.Readable) {
            destroyStream(request.body, error);
          }
          if (!response || !response.body) return;
          response.body.emit("error", error);
        };
        if (signal && signal.aborted) {
          abort();
          return;
        }
        const abortAndFinalize = function abortAndFinalize2() {
          abort();
          finalize();
        };
        const req = send(options);
        let reqTimeout;
        if (signal) {
          signal.addEventListener("abort", abortAndFinalize);
        }
        function finalize() {
          req.abort();
          if (signal) signal.removeEventListener("abort", abortAndFinalize);
          clearTimeout(reqTimeout);
        }
        if (request.timeout) {
          req.once("socket", function (socket) {
            reqTimeout = setTimeout(function () {
              reject(
                new FetchError(
                  `network timeout at: ${request.url}`,
                  "request-timeout"
                )
              );
              finalize();
            }, request.timeout);
          });
        }
        req.on("error", function (err) {
          reject(
            new FetchError(
              `request to ${request.url} failed, reason: ${err.message}`,
              "system",
              err
            )
          );
          if (response && response.body) {
            destroyStream(response.body, err);
          }
          finalize();
        });
        fixResponseChunkedTransferBadEnding(req, function (err) {
          if (signal && signal.aborted) {
            return;
          }
          if (response && response.body) {
            destroyStream(response.body, err);
          }
        });
        if (parseInt(process.version.substring(1)) < 14) {
          req.on("socket", function (s) {
            s.addListener("close", function (hadError) {
              const hasDataListener = s.listenerCount("data") > 0;
              if (
                response &&
                hasDataListener &&
                !hadError &&
                !(signal && signal.aborted)
              ) {
                const err = new Error("Premature close");
                err.code = "ERR_STREAM_PREMATURE_CLOSE";
                response.body.emit("error", err);
              }
            });
          });
        }
        req.on("response", function (res) {
          clearTimeout(reqTimeout);
          const headers = createHeadersLenient(res.headers);
          if (fetch.isRedirect(res.statusCode)) {
            const location = headers.get("Location");
            let locationURL = null;
            try {
              locationURL =
                location === null
                  ? null
                  : new URL$1(location, request.url).toString();
            } catch (err) {
              if (request.redirect !== "manual") {
                reject(
                  new FetchError(
                    `uri requested responds with an invalid redirect URL: ${location}`,
                    "invalid-redirect"
                  )
                );
                finalize();
                return;
              }
            }
            switch (request.redirect) {
              case "error":
                reject(
                  new FetchError(
                    `uri requested responds with a redirect, redirect mode is set to error: ${request.url}`,
                    "no-redirect"
                  )
                );
                finalize();
                return;
              case "manual":
                if (locationURL !== null) {
                  try {
                    headers.set("Location", locationURL);
                  } catch (err) {
                    reject(err);
                  }
                }
                break;
              case "follow":
                if (locationURL === null) {
                  break;
                }
                if (request.counter >= request.follow) {
                  reject(
                    new FetchError(
                      `maximum redirect reached at: ${request.url}`,
                      "max-redirect"
                    )
                  );
                  finalize();
                  return;
                }
                const requestOpts = {
                  headers: new Headers(request.headers),
                  follow: request.follow,
                  counter: request.counter + 1,
                  agent: request.agent,
                  compress: request.compress,
                  method: request.method,
                  body: request.body,
                  signal: request.signal,
                  timeout: request.timeout,
                  size: request.size,
                };
                if (
                  !isDomainOrSubdomain(request.url, locationURL) ||
                  !isSameProtocol(request.url, locationURL)
                ) {
                  for (const name of [
                    "authorization",
                    "www-authenticate",
                    "cookie",
                    "cookie2",
                  ]) {
                    requestOpts.headers.delete(name);
                  }
                }
                if (
                  res.statusCode !== 303 &&
                  request.body &&
                  getTotalBytes(request) === null
                ) {
                  reject(
                    new FetchError(
                      "Cannot follow redirect with body being a readable stream",
                      "unsupported-redirect"
                    )
                  );
                  finalize();
                  return;
                }
                if (
                  res.statusCode === 303 ||
                  ((res.statusCode === 301 || res.statusCode === 302) &&
                    request.method === "POST")
                ) {
                  requestOpts.method = "GET";
                  requestOpts.body = void 0;
                  requestOpts.headers.delete("content-length");
                }
                resolve(fetch(new Request(locationURL, requestOpts)));
                finalize();
                return;
            }
          }
          res.once("end", function () {
            if (signal) signal.removeEventListener("abort", abortAndFinalize);
          });
          let body = res.pipe(new PassThrough$1());
          const response_options = {
            url: request.url,
            status: res.statusCode,
            statusText: res.statusMessage,
            headers,
            size: request.size,
            timeout: request.timeout,
            counter: request.counter,
          };
          const codings = headers.get("Content-Encoding");
          if (
            !request.compress ||
            request.method === "HEAD" ||
            codings === null ||
            res.statusCode === 204 ||
            res.statusCode === 304
          ) {
            response = new Response(body, response_options);
            resolve(response);
            return;
          }
          const zlibOptions = {
            flush: zlib.Z_SYNC_FLUSH,
            finishFlush: zlib.Z_SYNC_FLUSH,
          };
          if (codings == "gzip" || codings == "x-gzip") {
            body = body.pipe(zlib.createGunzip(zlibOptions));
            response = new Response(body, response_options);
            resolve(response);
            return;
          }
          if (codings == "deflate" || codings == "x-deflate") {
            const raw = res.pipe(new PassThrough$1());
            raw.once("data", function (chunk) {
              if ((chunk[0] & 15) === 8) {
                body = body.pipe(zlib.createInflate());
              } else {
                body = body.pipe(zlib.createInflateRaw());
              }
              response = new Response(body, response_options);
              resolve(response);
            });
            raw.on("end", function () {
              if (!response) {
                response = new Response(body, response_options);
                resolve(response);
              }
            });
            return;
          }
          if (
            codings == "br" &&
            typeof zlib.createBrotliDecompress === "function"
          ) {
            body = body.pipe(zlib.createBrotliDecompress());
            response = new Response(body, response_options);
            resolve(response);
            return;
          }
          response = new Response(body, response_options);
          resolve(response);
        });
        writeToStream(req, request);
      });
    }
    function fixResponseChunkedTransferBadEnding(request, errorCallback) {
      let socket;
      request.on("socket", function (s) {
        socket = s;
      });
      request.on("response", function (response) {
        const headers = response.headers;
        if (
          headers["transfer-encoding"] === "chunked" &&
          !headers["content-length"]
        ) {
          response.once("close", function (hadError) {
            const hasDataListener = socket && socket.listenerCount("data") > 0;
            if (hasDataListener && !hadError) {
              const err = new Error("Premature close");
              err.code = "ERR_STREAM_PREMATURE_CLOSE";
              errorCallback(err);
            }
          });
        }
      });
    }
    function destroyStream(stream, err) {
      if (stream.destroy) {
        stream.destroy(err);
      } else {
        stream.emit("error", err);
        stream.end();
      }
    }
    fetch.isRedirect = function (code) {
      return (
        code === 301 ||
        code === 302 ||
        code === 303 ||
        code === 307 ||
        code === 308
      );
    };
    fetch.Promise = global.Promise;
    module2.exports = exports2 = fetch;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = exports2;
    exports2.Headers = Headers;
    exports2.Request = Request;
    exports2.Response = Response;
    exports2.FetchError = FetchError;
    exports2.AbortError = AbortError;
  },
});

// node_modules/cross-fetch/dist/node-ponyfill.js
var require_node_ponyfill = __commonJS({
  "node_modules/cross-fetch/dist/node-ponyfill.js"(exports2, module2) {
    var nodeFetch = require_lib4();
    var realFetch = nodeFetch.default || nodeFetch;
    var fetch = function (url, options) {
      if (/^\/\//.test(url)) {
        url = "https:" + url;
      }
      return realFetch.call(this, url, options);
    };
    fetch.ponyfill = true;
    module2.exports = exports2 = fetch;
    exports2.fetch = fetch;
    exports2.Headers = nodeFetch.Headers;
    exports2.Request = nodeFetch.Request;
    exports2.Response = nodeFetch.Response;
    exports2.default = fetch;
  },
});

// node_modules/xrpl/dist/npm/Wallet/defaultFaucets.js
var require_defaultFaucets = __commonJS({
  "node_modules/xrpl/dist/npm/Wallet/defaultFaucets.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getDefaultFaucetPath =
      exports2.getFaucetHost =
      exports2.FaucetNetworkPaths =
      exports2.FaucetNetwork =
        void 0;
    var errors_1 = require_errors();
    var FaucetNetwork;
    (function (FaucetNetwork2) {
      FaucetNetwork2["Testnet"] = "faucet.altnet.rippletest.net";
      FaucetNetwork2["Devnet"] = "faucet.devnet.rippletest.net";
      FaucetNetwork2["HooksV3Testnet"] = "hooks-testnet-v3.xrpl-labs.com";
    })(FaucetNetwork || (exports2.FaucetNetwork = FaucetNetwork = {}));
    exports2.FaucetNetworkPaths = {
      [FaucetNetwork.Testnet]: "/accounts",
      [FaucetNetwork.Devnet]: "/accounts",
      [FaucetNetwork.HooksV3Testnet]: "/accounts",
    };
    function getFaucetHost(client) {
      const connectionUrl = client.url;
      if (connectionUrl.includes("hooks-testnet-v3")) {
        return FaucetNetwork.HooksV3Testnet;
      }
      if (
        connectionUrl.includes("altnet") ||
        connectionUrl.includes("testnet")
      ) {
        return FaucetNetwork.Testnet;
      }
      if (connectionUrl.includes("sidechain-net2")) {
        throw new errors_1.XRPLFaucetError(
          "Cannot fund an account on an issuing chain. Accounts must be created via the bridge."
        );
      }
      if (connectionUrl.includes("devnet")) {
        return FaucetNetwork.Devnet;
      }
      throw new errors_1.XRPLFaucetError(
        "Faucet URL is not defined or inferrable."
      );
    }
    exports2.getFaucetHost = getFaucetHost;
    function getDefaultFaucetPath(hostname) {
      if (hostname === void 0) {
        return "/accounts";
      }
      return exports2.FaucetNetworkPaths[hostname] || "/accounts";
    }
    exports2.getDefaultFaucetPath = getDefaultFaucetPath;
  },
});

// node_modules/xrpl/dist/npm/Wallet/fundWallet.js
var require_fundWallet = __commonJS({
  "node_modules/xrpl/dist/npm/Wallet/fundWallet.js"(exports2) {
    "use strict";
    var __awaiter =
      (exports2 && exports2.__awaiter) ||
      function (thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P
            ? value
            : new P(function (resolve) {
                resolve(value);
              });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done
              ? resolve(result.value)
              : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
    var __importDefault =
      (exports2 && exports2.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.requestFunding =
      exports2.getStartingBalance =
      exports2.generateWalletToFund =
        void 0;
    var cross_fetch_1 = __importDefault(require_node_ponyfill());
    var ripple_address_codec_1 = require_dist();
    var errors_1 = require_errors();
    var defaultFaucets_1 = require_defaultFaucets();
    var _1 = require_Wallet();
    var INTERVAL_SECONDS = 1;
    var MAX_ATTEMPTS = 20;
    function generateWalletToFund(wallet) {
      if (
        wallet &&
        (0, ripple_address_codec_1.isValidClassicAddress)(wallet.classicAddress)
      ) {
        return wallet;
      }
      return _1.Wallet.generate();
    }
    exports2.generateWalletToFund = generateWalletToFund;
    function getStartingBalance(client, classicAddress) {
      return __awaiter(this, void 0, void 0, function* () {
        let startingBalance = 0;
        try {
          startingBalance = Number(yield client.getXrpBalance(classicAddress));
        } catch (_a) {}
        return startingBalance;
      });
    }
    exports2.getStartingBalance = getStartingBalance;
    function requestFunding(
      options,
      client,
      startingBalance,
      walletToFund,
      postBody
    ) {
      var _a, _b, _c;
      return __awaiter(this, void 0, void 0, function* () {
        const hostname =
          (_a = options.faucetHost) !== null && _a !== void 0
            ? _a
            : (0, defaultFaucets_1.getFaucetHost)(client);
        if (!hostname) {
          throw new errors_1.XRPLFaucetError(
            "No faucet hostname could be derived"
          );
        }
        const pathname =
          (_b = options.faucetPath) !== null && _b !== void 0
            ? _b
            : (0, defaultFaucets_1.getDefaultFaucetPath)(hostname);
        const response = yield (0, cross_fetch_1.default)(
          `https://${hostname}${pathname}`,
          {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify(postBody),
          }
        );
        const body = yield response.json();
        if (
          response.ok &&
          ((_c = response.headers.get("Content-Type")) === null || _c === void 0
            ? void 0
            : _c.startsWith("application/json"))
        ) {
          const classicAddress = body.account.classicAddress;
          return processSuccessfulResponse(
            client,
            classicAddress,
            walletToFund,
            startingBalance
          );
        }
        return processError(response, body);
      });
    }
    exports2.requestFunding = requestFunding;
    function processSuccessfulResponse(
      client,
      classicAddress,
      walletToFund,
      startingBalance
    ) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!classicAddress) {
          return Promise.reject(
            new errors_1.XRPLFaucetError(`The faucet account is undefined`)
          );
        }
        try {
          const updatedBalance = yield getUpdatedBalance(
            client,
            classicAddress,
            startingBalance
          );
          if (updatedBalance > startingBalance) {
            return {
              wallet: walletToFund,
              balance: updatedBalance,
            };
          }
          throw new errors_1.XRPLFaucetError(
            `Unable to fund address with faucet after waiting ${
              INTERVAL_SECONDS * MAX_ATTEMPTS
            } seconds`
          );
        } catch (err) {
          if (err instanceof Error) {
            throw new errors_1.XRPLFaucetError(err.message);
          }
          throw err;
        }
      });
    }
    function processError(response, body) {
      return __awaiter(this, void 0, void 0, function* () {
        return Promise.reject(
          new errors_1.XRPLFaucetError(
            `Request failed: ${JSON.stringify({
              body: body || {},
              contentType: response.headers.get("Content-Type"),
              statusCode: response.status,
            })}`
          )
        );
      });
    }
    function getUpdatedBalance(client, address, originalBalance) {
      return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
          let attempts = MAX_ATTEMPTS;
          const interval = setInterval(
            () =>
              __awaiter(this, void 0, void 0, function* () {
                if (attempts < 0) {
                  clearInterval(interval);
                  resolve(originalBalance);
                } else {
                  attempts -= 1;
                }
                try {
                  let newBalance;
                  try {
                    newBalance = Number(yield client.getXrpBalance(address));
                  } catch (_a) {}
                  if (newBalance > originalBalance) {
                    clearInterval(interval);
                    resolve(newBalance);
                  }
                } catch (err) {
                  clearInterval(interval);
                  if (err instanceof Error) {
                    reject(
                      new errors_1.XRPLFaucetError(
                        `Unable to check if the address ${address} balance has increased. Error: ${err.message}`
                      )
                    );
                  }
                  reject(err);
                }
              }),
            INTERVAL_SECONDS * 1e3
          );
        });
      });
    }
  },
});

// node_modules/ws/lib/constants.js
var require_constants2 = __commonJS({
  "node_modules/ws/lib/constants.js"(exports2, module2) {
    "use strict";
    var BINARY_TYPES = ["nodebuffer", "arraybuffer", "fragments"];
    var hasBlob = typeof Blob !== "undefined";
    if (hasBlob) BINARY_TYPES.push("blob");
    module2.exports = {
      BINARY_TYPES,
      EMPTY_BUFFER: Buffer.alloc(0),
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      hasBlob,
      kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
      kListener: Symbol("kListener"),
      kStatusCode: Symbol("status-code"),
      kWebSocket: Symbol("websocket"),
      NOOP: () => {},
    };
  },
});

// node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS({
  "node_modules/ws/lib/buffer-util.js"(exports2, module2) {
    "use strict";
    var { EMPTY_BUFFER } = require_constants2();
    var FastBuffer = Buffer[Symbol.species];
    function concat(list, totalLength) {
      if (list.length === 0) return EMPTY_BUFFER;
      if (list.length === 1) return list[0];
      const target = Buffer.allocUnsafe(totalLength);
      let offset = 0;
      for (let i = 0; i < list.length; i++) {
        const buf = list[i];
        target.set(buf, offset);
        offset += buf.length;
      }
      if (offset < totalLength) {
        return new FastBuffer(target.buffer, target.byteOffset, offset);
      }
      return target;
    }
    function _mask(source, mask, output, offset, length) {
      for (let i = 0; i < length; i++) {
        output[offset + i] = source[i] ^ mask[i & 3];
      }
    }
    function _unmask(buffer, mask) {
      for (let i = 0; i < buffer.length; i++) {
        buffer[i] ^= mask[i & 3];
      }
    }
    function toArrayBuffer(buf) {
      if (buf.length === buf.buffer.byteLength) {
        return buf.buffer;
      }
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
    }
    function toBuffer(data) {
      toBuffer.readOnly = true;
      if (Buffer.isBuffer(data)) return data;
      let buf;
      if (data instanceof ArrayBuffer) {
        buf = new FastBuffer(data);
      } else if (ArrayBuffer.isView(data)) {
        buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
      } else {
        buf = Buffer.from(data);
        toBuffer.readOnly = false;
      }
      return buf;
    }
    module2.exports = {
      concat,
      mask: _mask,
      toArrayBuffer,
      toBuffer,
      unmask: _unmask,
    };
    if (!process.env.WS_NO_BUFFER_UTIL) {
      try {
        const bufferUtil = require("bufferutil");
        module2.exports.mask = function (source, mask, output, offset, length) {
          if (length < 48) _mask(source, mask, output, offset, length);
          else bufferUtil.mask(source, mask, output, offset, length);
        };
        module2.exports.unmask = function (buffer, mask) {
          if (buffer.length < 32) _unmask(buffer, mask);
          else bufferUtil.unmask(buffer, mask);
        };
      } catch (e) {}
    }
  },
});

// node_modules/ws/lib/limiter.js
var require_limiter = __commonJS({
  "node_modules/ws/lib/limiter.js"(exports2, module2) {
    "use strict";
    var kDone = Symbol("kDone");
    var kRun = Symbol("kRun");
    var Limiter = class {
      /**
       * Creates a new `Limiter`.
       *
       * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
       *     to run concurrently
       */
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }
      /**
       * Adds a job to the queue.
       *
       * @param {Function} job The job to run
       * @public
       */
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }
      /**
       * Removes a job from the queue and runs it if possible.
       *
       * @private
       */
      [kRun]() {
        if (this.pending === this.concurrency) return;
        if (this.jobs.length) {
          const job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    };
    module2.exports = Limiter;
  },
});

// node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS({
  "node_modules/ws/lib/permessage-deflate.js"(exports2, module2) {
    "use strict";
    var zlib = require("zlib");
    var bufferUtil = require_buffer_util();
    var Limiter = require_limiter();
    var { kStatusCode } = require_constants2();
    var FastBuffer = Buffer[Symbol.species];
    var TRAILER = Buffer.from([0, 0, 255, 255]);
    var kPerMessageDeflate = Symbol("permessage-deflate");
    var kTotalLength = Symbol("total-length");
    var kCallback = Symbol("callback");
    var kBuffers = Symbol("buffers");
    var kError = Symbol("error");
    var zlibLimiter;
    var PerMessageDeflate = class {
      /**
       * Creates a PerMessageDeflate instance.
       *
       * @param {Object} [options] Configuration options
       * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
       *     for, or request, a custom client window size
       * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
       *     acknowledge disabling of client context takeover
       * @param {Number} [options.concurrencyLimit=10] The number of concurrent
       *     calls to zlib
       * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
       *     use of a custom server window size
       * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
       *     disabling of server context takeover
       * @param {Number} [options.threshold=1024] Size (in bytes) below which
       *     messages should not be compressed if context takeover is disabled
       * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
       *     deflate
       * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
       *     inflate
       * @param {Boolean} [isServer=false] Create the instance in either server or
       *     client mode
       * @param {Number} [maxPayload=0] The maximum allowed message length
       */
      constructor(options, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options || {};
        this._threshold =
          this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency =
            this._options.concurrencyLimit !== void 0
              ? this._options.concurrencyLimit
              : 10;
          zlibLimiter = new Limiter(concurrency);
        }
      }
      /**
       * @type {String}
       */
      static get extensionName() {
        return "permessage-deflate";
      }
      /**
       * Create an extension negotiation offer.
       *
       * @return {Object} Extension parameters
       * @public
       */
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      /**
       * Accept an extension negotiation offer/response.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Object} Accepted configuration
       * @public
       */
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer
          ? this.acceptAsServer(configurations)
          : this.acceptAsClient(configurations);
        return this.params;
      }
      /**
       * Releases all resources used by the extension.
       *
       * @public
       */
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          const callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(
              new Error(
                "The deflate stream was closed while data was being processed"
              )
            );
          }
        }
      }
      /**
       *  Accept an extension negotiation offer.
       *
       * @param {Array} offers The extension negotiation offers
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (
            (opts.serverNoContextTakeover === false &&
              params.server_no_context_takeover) ||
            (params.server_max_window_bits &&
              (opts.serverMaxWindowBits === false ||
                (typeof opts.serverMaxWindowBits === "number" &&
                  opts.serverMaxWindowBits > params.server_max_window_bits))) ||
            (typeof opts.clientMaxWindowBits === "number" &&
              !params.client_max_window_bits)
          ) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (
          accepted.client_max_window_bits === true ||
          opts.clientMaxWindowBits === false
        ) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      /**
       * Accept the extension negotiation response.
       *
       * @param {Array} response The extension negotiation response
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsClient(response) {
        const params = response[0];
        if (
          this._options.clientNoContextTakeover === false &&
          params.client_no_context_takeover
        ) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (
          this._options.clientMaxWindowBits === false ||
          (typeof this._options.clientMaxWindowBits === "number" &&
            params.client_max_window_bits > this._options.clientMaxWindowBits)
        ) {
          throw new Error(
            'Unexpected or invalid parameter "client_max_window_bits"'
          );
        }
        return params;
      }
      /**
       * Normalize parameters.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Array} The offers/response with normalized parameters
       * @private
       */
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key) => {
            let value = params[key];
            if (value.length > 1) {
              throw new Error(
                `Parameter "${key}" must have only a single value`
              );
            }
            value = value[0];
            if (key === "client_max_window_bits") {
              if (value !== true) {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(
                    `Invalid value for parameter "${key}": ${value}`
                  );
                }
                value = num;
              } else if (!this._isServer) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else if (key === "server_max_window_bits") {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
              value = num;
            } else if (
              key === "client_no_context_takeover" ||
              key === "server_no_context_takeover"
            ) {
              if (value !== true) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }
            params[key] = value;
          });
        });
        return configurations;
      }
      /**
       * Decompress data. Concurrency limited.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      decompress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._decompress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Compress data. Concurrency limited.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      compress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._compress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Decompress data.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _decompress(data, fin, callback) {
        const endpoint = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits =
            typeof this.params[key] !== "number"
              ? zlib.Z_DEFAULT_WINDOWBITS
              : this.params[key];
          this._inflate = zlib.createInflateRaw({
            ...this._options.zlibInflateOptions,
            windowBits,
          });
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data);
        if (fin) this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data2 = bufferUtil.concat(
            this._inflate[kBuffers],
            this._inflate[kTotalLength]
          );
          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }
          callback(null, data2);
        });
      }
      /**
       * Compress data.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _compress(data, fin, callback) {
        const endpoint = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits =
            typeof this.params[key] !== "number"
              ? zlib.Z_DEFAULT_WINDOWBITS
              : this.params[key];
          this._deflate = zlib.createDeflateRaw({
            ...this._options.zlibDeflateOptions,
            windowBits,
          });
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data);
        this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          let data2 = bufferUtil.concat(
            this._deflate[kBuffers],
            this._deflate[kTotalLength]
          );
          if (fin) {
            data2 = new FastBuffer(
              data2.buffer,
              data2.byteOffset,
              data2.length - 4
            );
          }
          this._deflate[kCallback] = null;
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._deflate.reset();
          }
          callback(null, data2);
        });
      }
    };
    module2.exports = PerMessageDeflate;
    function deflateOnData(chunk) {
      this[kBuffers].push(chunk);
      this[kTotalLength] += chunk.length;
    }
    function inflateOnData(chunk) {
      this[kTotalLength] += chunk.length;
      if (
        this[kPerMessageDeflate]._maxPayload < 1 ||
        this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload
      ) {
        this[kBuffers].push(chunk);
        return;
      }
      this[kError] = new RangeError("Max payload size exceeded");
      this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
      this[kError][kStatusCode] = 1009;
      this.removeListener("data", inflateOnData);
      this.reset();
    }
    function inflateOnError(err) {
      this[kPerMessageDeflate]._inflate = null;
      if (this[kError]) {
        this[kCallback](this[kError]);
        return;
      }
      err[kStatusCode] = 1007;
      this[kCallback](err);
    }
  },
});

// node_modules/ws/lib/validation.js
var require_validation = __commonJS({
  "node_modules/ws/lib/validation.js"(exports2, module2) {
    "use strict";
    var { isUtf8 } = require("buffer");
    var { hasBlob } = require_constants2();
    var tokenChars = [
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      // 0 - 15
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      // 16 - 31
      0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0,
      // 32 - 47
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
      // 48 - 63
      0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
      // 64 - 79
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1,
      // 80 - 95
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
      // 96 - 111
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0,
      // 112 - 127
    ];
    function isValidStatusCode(code) {
      return (
        (code >= 1e3 &&
          code <= 1014 &&
          code !== 1004 &&
          code !== 1005 &&
          code !== 1006) ||
        (code >= 3e3 && code <= 4999)
      );
    }
    function _isValidUTF8(buf) {
      const len = buf.length;
      let i = 0;
      while (i < len) {
        if ((buf[i] & 128) === 0) {
          i++;
        } else if ((buf[i] & 224) === 192) {
          if (
            i + 1 === len ||
            (buf[i + 1] & 192) !== 128 ||
            (buf[i] & 254) === 192
          ) {
            return false;
          }
          i += 2;
        } else if ((buf[i] & 240) === 224) {
          if (
            i + 2 >= len ||
            (buf[i + 1] & 192) !== 128 ||
            (buf[i + 2] & 192) !== 128 ||
            (buf[i] === 224 && (buf[i + 1] & 224) === 128) || // Overlong
            (buf[i] === 237 && (buf[i + 1] & 224) === 160)
          ) {
            return false;
          }
          i += 3;
        } else if ((buf[i] & 248) === 240) {
          if (
            i + 3 >= len ||
            (buf[i + 1] & 192) !== 128 ||
            (buf[i + 2] & 192) !== 128 ||
            (buf[i + 3] & 192) !== 128 ||
            (buf[i] === 240 && (buf[i + 1] & 240) === 128) || // Overlong
            (buf[i] === 244 && buf[i + 1] > 143) ||
            buf[i] > 244
          ) {
            return false;
          }
          i += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    function isBlob(value) {
      return (
        hasBlob &&
        typeof value === "object" &&
        typeof value.arrayBuffer === "function" &&
        typeof value.type === "string" &&
        typeof value.stream === "function" &&
        (value[Symbol.toStringTag] === "Blob" ||
          value[Symbol.toStringTag] === "File")
      );
    }
    module2.exports = {
      isBlob,
      isValidStatusCode,
      isValidUTF8: _isValidUTF8,
      tokenChars,
    };
    if (isUtf8) {
      module2.exports.isValidUTF8 = function (buf) {
        return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
      };
    } else if (!process.env.WS_NO_UTF_8_VALIDATE) {
      try {
        const isValidUTF8 = require("utf-8-validate");
        module2.exports.isValidUTF8 = function (buf) {
          return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
        };
      } catch (e) {}
    }
  },
});

// node_modules/ws/lib/receiver.js
var require_receiver = __commonJS({
  "node_modules/ws/lib/receiver.js"(exports2, module2) {
    "use strict";
    var { Writable } = require("stream");
    var PerMessageDeflate = require_permessage_deflate();
    var { BINARY_TYPES, EMPTY_BUFFER, kStatusCode, kWebSocket } =
      require_constants2();
    var { concat, toArrayBuffer, unmask } = require_buffer_util();
    var { isValidStatusCode, isValidUTF8 } = require_validation();
    var FastBuffer = Buffer[Symbol.species];
    var GET_INFO = 0;
    var GET_PAYLOAD_LENGTH_16 = 1;
    var GET_PAYLOAD_LENGTH_64 = 2;
    var GET_MASK = 3;
    var GET_DATA = 4;
    var INFLATING = 5;
    var DEFER_EVENT = 6;
    var Receiver = class extends Writable {
      /**
       * Creates a Receiver instance.
       *
       * @param {Object} [options] Options object
       * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {String} [options.binaryType=nodebuffer] The type for binary data
       * @param {Object} [options.extensions] An object containing the negotiated
       *     extensions
       * @param {Boolean} [options.isServer=false] Specifies whether to operate in
       *     client or server mode
       * @param {Number} [options.maxPayload=0] The maximum allowed message length
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       */
      constructor(options = {}) {
        super();
        this._allowSynchronousEvents =
          options.allowSynchronousEvents !== void 0
            ? options.allowSynchronousEvents
            : true;
        this._binaryType = options.binaryType || BINARY_TYPES[0];
        this._extensions = options.extensions || {};
        this._isServer = !!options.isServer;
        this._maxPayload = options.maxPayload | 0;
        this._skipUTF8Validation = !!options.skipUTF8Validation;
        this[kWebSocket] = void 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._errored = false;
        this._loop = false;
        this._state = GET_INFO;
      }
      /**
       * Implements `Writable.prototype._write()`.
       *
       * @param {Buffer} chunk The chunk of data to write
       * @param {String} encoding The character encoding of `chunk`
       * @param {Function} cb Callback
       * @private
       */
      _write(chunk, encoding, cb) {
        if (this._opcode === 8 && this._state == GET_INFO) return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      /**
       * Consumes `n` bytes from the buffered data.
       *
       * @param {Number} n The number of bytes to consume
       * @return {Buffer} The consumed bytes
       * @private
       */
      consume(n) {
        this._bufferedBytes -= n;
        if (n === this._buffers[0].length) return this._buffers.shift();
        if (n < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = new FastBuffer(
            buf.buffer,
            buf.byteOffset + n,
            buf.length - n
          );
          return new FastBuffer(buf.buffer, buf.byteOffset, n);
        }
        const dst = Buffer.allocUnsafe(n);
        do {
          const buf = this._buffers[0];
          const offset = dst.length - n;
          if (n >= buf.length) {
            dst.set(this._buffers.shift(), offset);
          } else {
            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
            this._buffers[0] = new FastBuffer(
              buf.buffer,
              buf.byteOffset + n,
              buf.length - n
            );
          }
          n -= buf.length;
        } while (n > 0);
        return dst;
      }
      /**
       * Starts the parsing loop.
       *
       * @param {Function} cb Callback
       * @private
       */
      startLoop(cb) {
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              this.getInfo(cb);
              break;
            case GET_PAYLOAD_LENGTH_16:
              this.getPayloadLength16(cb);
              break;
            case GET_PAYLOAD_LENGTH_64:
              this.getPayloadLength64(cb);
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              this.getData(cb);
              break;
            case INFLATING:
            case DEFER_EVENT:
              this._loop = false;
              return;
          }
        } while (this._loop);
        if (!this._errored) cb();
      }
      /**
       * Reads the first two bytes of a frame.
       *
       * @param {Function} cb Callback
       * @private
       */
      getInfo(cb) {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 48) !== 0) {
          const error = this.createError(
            RangeError,
            "RSV2 and RSV3 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_2_3"
          );
          cb(error);
          return;
        }
        const compressed = (buf[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
          const error = this.createError(
            RangeError,
            "RSV1 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_1"
          );
          cb(error);
          return;
        }
        this._fin = (buf[0] & 128) === 128;
        this._opcode = buf[0] & 15;
        this._payloadLength = buf[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            const error = this.createError(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
            cb(error);
            return;
          }
          if (!this._fragmented) {
            const error = this.createError(
              RangeError,
              "invalid opcode 0",
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
            cb(error);
            return;
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            const error = this.createError(
              RangeError,
              `invalid opcode ${this._opcode}`,
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
            cb(error);
            return;
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            const error = this.createError(
              RangeError,
              "FIN must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_FIN"
            );
            cb(error);
            return;
          }
          if (compressed) {
            const error = this.createError(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
            cb(error);
            return;
          }
          if (
            this._payloadLength > 125 ||
            (this._opcode === 8 && this._payloadLength === 1)
          ) {
            const error = this.createError(
              RangeError,
              `invalid payload length ${this._payloadLength}`,
              true,
              1002,
              "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
            );
            cb(error);
            return;
          }
        } else {
          const error = this.createError(
            RangeError,
            `invalid opcode ${this._opcode}`,
            true,
            1002,
            "WS_ERR_INVALID_OPCODE"
          );
          cb(error);
          return;
        }
        if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
        this._masked = (buf[1] & 128) === 128;
        if (this._isServer) {
          if (!this._masked) {
            const error = this.createError(
              RangeError,
              "MASK must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_MASK"
            );
            cb(error);
            return;
          }
        } else if (this._masked) {
          const error = this.createError(
            RangeError,
            "MASK must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_MASK"
          );
          cb(error);
          return;
        }
        if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127)
          this._state = GET_PAYLOAD_LENGTH_64;
        else this.haveLength(cb);
      }
      /**
       * Gets extended payload length (7+16).
       *
       * @param {Function} cb Callback
       * @private
       */
      getPayloadLength16(cb) {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        this.haveLength(cb);
      }
      /**
       * Gets extended payload length (7+64).
       *
       * @param {Function} cb Callback
       * @private
       */
      getPayloadLength64(cb) {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          const error = this.createError(
            RangeError,
            "Unsupported WebSocket frame: payload length > 2^53 - 1",
            false,
            1009,
            "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH"
          );
          cb(error);
          return;
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        this.haveLength(cb);
      }
      /**
       * Payload length has been read.
       *
       * @param {Function} cb Callback
       * @private
       */
      haveLength(cb) {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (
            this._totalPayloadLength > this._maxPayload &&
            this._maxPayload > 0
          ) {
            const error = this.createError(
              RangeError,
              "Max payload size exceeded",
              false,
              1009,
              "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
            );
            cb(error);
            return;
          }
        }
        if (this._masked) this._state = GET_MASK;
        else this._state = GET_DATA;
      }
      /**
       * Reads mask bytes.
       *
       * @private
       */
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      /**
       * Reads data bytes.
       *
       * @param {Function} cb Callback
       * @private
       */
      getData(cb) {
        let data = EMPTY_BUFFER;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data = this.consume(this._payloadLength);
          if (
            this._masked &&
            (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !==
              0
          ) {
            unmask(data, this._mask);
          }
        }
        if (this._opcode > 7) {
          this.controlMessage(data, cb);
          return;
        }
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data, cb);
          return;
        }
        if (data.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data);
        }
        this.dataMessage(cb);
      }
      /**
       * Decompresses data.
       *
       * @param {Buffer} data Compressed data
       * @param {Function} cb Callback
       * @private
       */
      decompress(data, cb) {
        const perMessageDeflate =
          this._extensions[PerMessageDeflate.extensionName];
        perMessageDeflate.decompress(data, this._fin, (err, buf) => {
          if (err) return cb(err);
          if (buf.length) {
            this._messageLength += buf.length;
            if (
              this._messageLength > this._maxPayload &&
              this._maxPayload > 0
            ) {
              const error = this.createError(
                RangeError,
                "Max payload size exceeded",
                false,
                1009,
                "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
              );
              cb(error);
              return;
            }
            this._fragments.push(buf);
          }
          this.dataMessage(cb);
          if (this._state === GET_INFO) this.startLoop(cb);
        });
      }
      /**
       * Handles a data message.
       *
       * @param {Function} cb Callback
       * @private
       */
      dataMessage(cb) {
        if (!this._fin) {
          this._state = GET_INFO;
          return;
        }
        const messageLength = this._messageLength;
        const fragments = this._fragments;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragmented = 0;
        this._fragments = [];
        if (this._opcode === 2) {
          let data;
          if (this._binaryType === "nodebuffer") {
            data = concat(fragments, messageLength);
          } else if (this._binaryType === "arraybuffer") {
            data = toArrayBuffer(concat(fragments, messageLength));
          } else if (this._binaryType === "blob") {
            data = new Blob(fragments);
          } else {
            data = fragments;
          }
          if (this._allowSynchronousEvents) {
            this.emit("message", data, true);
            this._state = GET_INFO;
          } else {
            this._state = DEFER_EVENT;
            setImmediate(() => {
              this.emit("message", data, true);
              this._state = GET_INFO;
              this.startLoop(cb);
            });
          }
        } else {
          const buf = concat(fragments, messageLength);
          if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
            const error = this.createError(
              Error,
              "invalid UTF-8 sequence",
              true,
              1007,
              "WS_ERR_INVALID_UTF8"
            );
            cb(error);
            return;
          }
          if (this._state === INFLATING || this._allowSynchronousEvents) {
            this.emit("message", buf, false);
            this._state = GET_INFO;
          } else {
            this._state = DEFER_EVENT;
            setImmediate(() => {
              this.emit("message", buf, false);
              this._state = GET_INFO;
              this.startLoop(cb);
            });
          }
        }
      }
      /**
       * Handles a control message.
       *
       * @param {Buffer} data Data to handle
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      controlMessage(data, cb) {
        if (this._opcode === 8) {
          if (data.length === 0) {
            this._loop = false;
            this.emit("conclude", 1005, EMPTY_BUFFER);
            this.end();
          } else {
            const code = data.readUInt16BE(0);
            if (!isValidStatusCode(code)) {
              const error = this.createError(
                RangeError,
                `invalid status code ${code}`,
                true,
                1002,
                "WS_ERR_INVALID_CLOSE_CODE"
              );
              cb(error);
              return;
            }
            const buf = new FastBuffer(
              data.buffer,
              data.byteOffset + 2,
              data.length - 2
            );
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              const error = this.createError(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
              cb(error);
              return;
            }
            this._loop = false;
            this.emit("conclude", code, buf);
            this.end();
          }
          this._state = GET_INFO;
          return;
        }
        if (this._allowSynchronousEvents) {
          this.emit(this._opcode === 9 ? "ping" : "pong", data);
          this._state = GET_INFO;
        } else {
          this._state = DEFER_EVENT;
          setImmediate(() => {
            this.emit(this._opcode === 9 ? "ping" : "pong", data);
            this._state = GET_INFO;
            this.startLoop(cb);
          });
        }
      }
      /**
       * Builds an error object.
       *
       * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
       * @param {String} message The error message
       * @param {Boolean} prefix Specifies whether or not to add a default prefix to
       *     `message`
       * @param {Number} statusCode The status code
       * @param {String} errorCode The exposed error code
       * @return {(Error|RangeError)} The error
       * @private
       */
      createError(ErrorCtor, message, prefix, statusCode, errorCode) {
        this._loop = false;
        this._errored = true;
        const err = new ErrorCtor(
          prefix ? `Invalid WebSocket frame: ${message}` : message
        );
        Error.captureStackTrace(err, this.createError);
        err.code = errorCode;
        err[kStatusCode] = statusCode;
        return err;
      }
    };
    module2.exports = Receiver;
  },
});

// node_modules/ws/lib/sender.js
var require_sender = __commonJS({
  "node_modules/ws/lib/sender.js"(exports2, module2) {
    "use strict";
    var { Duplex } = require("stream");
    var { randomFillSync } = require("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var { EMPTY_BUFFER, kWebSocket, NOOP } = require_constants2();
    var { isBlob, isValidStatusCode } = require_validation();
    var { mask: applyMask, toBuffer } = require_buffer_util();
    var kByteLength = Symbol("kByteLength");
    var maskBuffer = Buffer.alloc(4);
    var RANDOM_POOL_SIZE = 8 * 1024;
    var randomPool;
    var randomPoolPointer = RANDOM_POOL_SIZE;
    var DEFAULT = 0;
    var DEFLATING = 1;
    var GET_BLOB_DATA = 2;
    var Sender = class _Sender {
      /**
       * Creates a Sender instance.
       *
       * @param {Duplex} socket The connection socket
       * @param {Object} [extensions] An object containing the negotiated extensions
       * @param {Function} [generateMask] The function used to generate the masking
       *     key
       */
      constructor(socket, extensions, generateMask) {
        this._extensions = extensions || {};
        if (generateMask) {
          this._generateMask = generateMask;
          this._maskBuffer = Buffer.alloc(4);
        }
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._queue = [];
        this._state = DEFAULT;
        this.onerror = NOOP;
        this[kWebSocket] = void 0;
      }
      /**
       * Frames a piece of data according to the HyBi WebSocket protocol.
       *
       * @param {(Buffer|String)} data The data to frame
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @return {(Buffer|String)[]} The framed data
       * @public
       */
      static frame(data, options) {
        let mask;
        let merge = false;
        let offset = 2;
        let skipMasking = false;
        if (options.mask) {
          mask = options.maskBuffer || maskBuffer;
          if (options.generateMask) {
            options.generateMask(mask);
          } else {
            if (randomPoolPointer === RANDOM_POOL_SIZE) {
              if (randomPool === void 0) {
                randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
              }
              randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
              randomPoolPointer = 0;
            }
            mask[0] = randomPool[randomPoolPointer++];
            mask[1] = randomPool[randomPoolPointer++];
            mask[2] = randomPool[randomPoolPointer++];
            mask[3] = randomPool[randomPoolPointer++];
          }
          skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
          offset = 6;
        }
        let dataLength;
        if (typeof data === "string") {
          if (
            (!options.mask || skipMasking) &&
            options[kByteLength] !== void 0
          ) {
            dataLength = options[kByteLength];
          } else {
            data = Buffer.from(data);
            dataLength = data.length;
          }
        } else {
          dataLength = data.length;
          merge = options.mask && options.readOnly && !skipMasking;
        }
        let payloadLength = dataLength;
        if (dataLength >= 65536) {
          offset += 8;
          payloadLength = 127;
        } else if (dataLength > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);
        target[0] = options.fin ? options.opcode | 128 : options.opcode;
        if (options.rsv1) target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(dataLength, 2);
        } else if (payloadLength === 127) {
          target[2] = target[3] = 0;
          target.writeUIntBE(dataLength, 4, 6);
        }
        if (!options.mask) return [target, data];
        target[1] |= 128;
        target[offset - 4] = mask[0];
        target[offset - 3] = mask[1];
        target[offset - 2] = mask[2];
        target[offset - 1] = mask[3];
        if (skipMasking) return [target, data];
        if (merge) {
          applyMask(data, mask, target, offset, dataLength);
          return [target];
        }
        applyMask(data, mask, data, 0, dataLength);
        return [target, data];
      }
      /**
       * Sends a close message to the other peer.
       *
       * @param {Number} [code] The status code component of the body
       * @param {(String|Buffer)} [data] The message component of the body
       * @param {Boolean} [mask=false] Specifies whether or not to mask the message
       * @param {Function} [cb] Callback
       * @public
       */
      close(code, data, mask, cb) {
        let buf;
        if (code === void 0) {
          buf = EMPTY_BUFFER;
        } else if (typeof code !== "number" || !isValidStatusCode(code)) {
          throw new TypeError(
            "First argument must be a valid error code number"
          );
        } else if (data === void 0 || !data.length) {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          const length = Buffer.byteLength(data);
          if (length > 123) {
            throw new RangeError(
              "The message must not be greater than 123 bytes"
            );
          }
          buf = Buffer.allocUnsafe(2 + length);
          buf.writeUInt16BE(code, 0);
          if (typeof data === "string") {
            buf.write(data, 2);
          } else {
            buf.set(data, 2);
          }
        }
        const options = {
          [kByteLength]: buf.length,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 8,
          readOnly: false,
          rsv1: false,
        };
        if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, buf, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(buf, options), cb);
        }
      }
      /**
       * Sends a ping message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      ping(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else if (isBlob(data)) {
          byteLength = data.size;
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError(
            "The data size must not be greater than 125 bytes"
          );
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 9,
          readOnly,
          rsv1: false,
        };
        if (isBlob(data)) {
          if (this._state !== DEFAULT) {
            this.enqueue([this.getBlobData, data, false, options, cb]);
          } else {
            this.getBlobData(data, false, options, cb);
          }
        } else if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(data, options), cb);
        }
      }
      /**
       * Sends a pong message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      pong(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else if (isBlob(data)) {
          byteLength = data.size;
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError(
            "The data size must not be greater than 125 bytes"
          );
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 10,
          readOnly,
          rsv1: false,
        };
        if (isBlob(data)) {
          if (this._state !== DEFAULT) {
            this.enqueue([this.getBlobData, data, false, options, cb]);
          } else {
            this.getBlobData(data, false, options, cb);
          }
        } else if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(data, options), cb);
        }
      }
      /**
       * Sends a data message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Object} options Options object
       * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
       *     or text
       * @param {Boolean} [options.compress=false] Specifies whether or not to
       *     compress `data`
       * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Function} [cb] Callback
       * @public
       */
      send(data, options, cb) {
        const perMessageDeflate =
          this._extensions[PerMessageDeflate.extensionName];
        let opcode = options.binary ? 2 : 1;
        let rsv1 = options.compress;
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else if (isBlob(data)) {
          byteLength = data.size;
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (this._firstFragment) {
          this._firstFragment = false;
          if (
            rsv1 &&
            perMessageDeflate &&
            perMessageDeflate.params[
              perMessageDeflate._isServer
                ? "server_no_context_takeover"
                : "client_no_context_takeover"
            ]
          ) {
            rsv1 = byteLength >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options.fin) this._firstFragment = true;
        const opts = {
          [kByteLength]: byteLength,
          fin: options.fin,
          generateMask: this._generateMask,
          mask: options.mask,
          maskBuffer: this._maskBuffer,
          opcode,
          readOnly,
          rsv1,
        };
        if (isBlob(data)) {
          if (this._state !== DEFAULT) {
            this.enqueue([this.getBlobData, data, this._compress, opts, cb]);
          } else {
            this.getBlobData(data, this._compress, opts, cb);
          }
        } else if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, data, this._compress, opts, cb]);
        } else {
          this.dispatch(data, this._compress, opts, cb);
        }
      }
      /**
       * Gets the contents of a blob as binary data.
       *
       * @param {Blob} blob The blob
       * @param {Boolean} [compress=false] Specifies whether or not to compress
       *     the data
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @param {Function} [cb] Callback
       * @private
       */
      getBlobData(blob, compress, options, cb) {
        this._bufferedBytes += options[kByteLength];
        this._state = GET_BLOB_DATA;
        blob
          .arrayBuffer()
          .then((arrayBuffer) => {
            if (this._socket.destroyed) {
              const err = new Error(
                "The socket was closed while the blob was being read"
              );
              process.nextTick(callCallbacks, this, err, cb);
              return;
            }
            this._bufferedBytes -= options[kByteLength];
            const data = toBuffer(arrayBuffer);
            if (!compress) {
              this._state = DEFAULT;
              this.sendFrame(_Sender.frame(data, options), cb);
              this.dequeue();
            } else {
              this.dispatch(data, compress, options, cb);
            }
          })
          .catch((err) => {
            process.nextTick(onError, this, err, cb);
          });
      }
      /**
       * Dispatches a message.
       *
       * @param {(Buffer|String)} data The message to send
       * @param {Boolean} [compress=false] Specifies whether or not to compress
       *     `data`
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @param {Function} [cb] Callback
       * @private
       */
      dispatch(data, compress, options, cb) {
        if (!compress) {
          this.sendFrame(_Sender.frame(data, options), cb);
          return;
        }
        const perMessageDeflate =
          this._extensions[PerMessageDeflate.extensionName];
        this._bufferedBytes += options[kByteLength];
        this._state = DEFLATING;
        perMessageDeflate.compress(data, options.fin, (_, buf) => {
          if (this._socket.destroyed) {
            const err = new Error(
              "The socket was closed while data was being compressed"
            );
            callCallbacks(this, err, cb);
            return;
          }
          this._bufferedBytes -= options[kByteLength];
          this._state = DEFAULT;
          options.readOnly = false;
          this.sendFrame(_Sender.frame(buf, options), cb);
          this.dequeue();
        });
      }
      /**
       * Executes queued send operations.
       *
       * @private
       */
      dequeue() {
        while (this._state === DEFAULT && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[3][kByteLength];
          Reflect.apply(params[0], this, params.slice(1));
        }
      }
      /**
       * Enqueues a send operation.
       *
       * @param {Array} params Send operation parameters.
       * @private
       */
      enqueue(params) {
        this._bufferedBytes += params[3][kByteLength];
        this._queue.push(params);
      }
      /**
       * Sends a frame.
       *
       * @param {(Buffer | String)[]} list The frame to send
       * @param {Function} [cb] Callback
       * @private
       */
      sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.cork();
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list[0], cb);
        }
      }
    };
    module2.exports = Sender;
    function callCallbacks(sender, err, cb) {
      if (typeof cb === "function") cb(err);
      for (let i = 0; i < sender._queue.length; i++) {
        const params = sender._queue[i];
        const callback = params[params.length - 1];
        if (typeof callback === "function") callback(err);
      }
    }
    function onError(sender, err, cb) {
      callCallbacks(sender, err, cb);
      sender.onerror(err);
    }
  },
});

// node_modules/ws/lib/event-target.js
var require_event_target = __commonJS({
  "node_modules/ws/lib/event-target.js"(exports2, module2) {
    "use strict";
    var { kForOnEventAttribute, kListener } = require_constants2();
    var kCode = Symbol("kCode");
    var kData = Symbol("kData");
    var kError = Symbol("kError");
    var kMessage = Symbol("kMessage");
    var kReason = Symbol("kReason");
    var kTarget = Symbol("kTarget");
    var kType = Symbol("kType");
    var kWasClean = Symbol("kWasClean");
    var Event = class {
      /**
       * Create a new `Event`.
       *
       * @param {String} type The name of the event
       * @throws {TypeError} If the `type` argument is not specified
       */
      constructor(type) {
        this[kTarget] = null;
        this[kType] = type;
      }
      /**
       * @type {*}
       */
      get target() {
        return this[kTarget];
      }
      /**
       * @type {String}
       */
      get type() {
        return this[kType];
      }
    };
    Object.defineProperty(Event.prototype, "target", { enumerable: true });
    Object.defineProperty(Event.prototype, "type", { enumerable: true });
    var CloseEvent = class extends Event {
      /**
       * Create a new `CloseEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {Number} [options.code=0] The status code explaining why the
       *     connection was closed
       * @param {String} [options.reason=''] A human-readable string explaining why
       *     the connection was closed
       * @param {Boolean} [options.wasClean=false] Indicates whether or not the
       *     connection was cleanly closed
       */
      constructor(type, options = {}) {
        super(type);
        this[kCode] = options.code === void 0 ? 0 : options.code;
        this[kReason] = options.reason === void 0 ? "" : options.reason;
        this[kWasClean] =
          options.wasClean === void 0 ? false : options.wasClean;
      }
      /**
       * @type {Number}
       */
      get code() {
        return this[kCode];
      }
      /**
       * @type {String}
       */
      get reason() {
        return this[kReason];
      }
      /**
       * @type {Boolean}
       */
      get wasClean() {
        return this[kWasClean];
      }
    };
    Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "wasClean", {
      enumerable: true,
    });
    var ErrorEvent = class extends Event {
      /**
       * Create a new `ErrorEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.error=null] The error that generated this event
       * @param {String} [options.message=''] The error message
       */
      constructor(type, options = {}) {
        super(type);
        this[kError] = options.error === void 0 ? null : options.error;
        this[kMessage] = options.message === void 0 ? "" : options.message;
      }
      /**
       * @type {*}
       */
      get error() {
        return this[kError];
      }
      /**
       * @type {String}
       */
      get message() {
        return this[kMessage];
      }
    };
    Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
    Object.defineProperty(ErrorEvent.prototype, "message", {
      enumerable: true,
    });
    var MessageEvent = class extends Event {
      /**
       * Create a new `MessageEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.data=null] The message content
       */
      constructor(type, options = {}) {
        super(type);
        this[kData] = options.data === void 0 ? null : options.data;
      }
      /**
       * @type {*}
       */
      get data() {
        return this[kData];
      }
    };
    Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
    var EventTarget = {
      /**
       * Register an event listener.
       *
       * @param {String} type A string representing the event type to listen for
       * @param {(Function|Object)} handler The listener to add
       * @param {Object} [options] An options object specifies characteristics about
       *     the event listener
       * @param {Boolean} [options.once=false] A `Boolean` indicating that the
       *     listener should be invoked at most once after being added. If `true`,
       *     the listener would be automatically removed when invoked.
       * @public
       */
      addEventListener(type, handler, options = {}) {
        for (const listener of this.listeners(type)) {
          if (
            !options[kForOnEventAttribute] &&
            listener[kListener] === handler &&
            !listener[kForOnEventAttribute]
          ) {
            return;
          }
        }
        let wrapper;
        if (type === "message") {
          wrapper = function onMessage(data, isBinary) {
            const event = new MessageEvent("message", {
              data: isBinary ? data : data.toString(),
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "close") {
          wrapper = function onClose(code, message) {
            const event = new CloseEvent("close", {
              code,
              reason: message.toString(),
              wasClean: this._closeFrameReceived && this._closeFrameSent,
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "error") {
          wrapper = function onError(error) {
            const event = new ErrorEvent("error", {
              error,
              message: error.message,
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "open") {
          wrapper = function onOpen() {
            const event = new Event("open");
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else {
          return;
        }
        wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
        wrapper[kListener] = handler;
        if (options.once) {
          this.once(type, wrapper);
        } else {
          this.on(type, wrapper);
        }
      },
      /**
       * Remove an event listener.
       *
       * @param {String} type A string representing the event type to remove
       * @param {(Function|Object)} handler The listener to remove
       * @public
       */
      removeEventListener(type, handler) {
        for (const listener of this.listeners(type)) {
          if (
            listener[kListener] === handler &&
            !listener[kForOnEventAttribute]
          ) {
            this.removeListener(type, listener);
            break;
          }
        }
      },
    };
    module2.exports = {
      CloseEvent,
      ErrorEvent,
      Event,
      EventTarget,
      MessageEvent,
    };
    function callListener(listener, thisArg, event) {
      if (typeof listener === "object" && listener.handleEvent) {
        listener.handleEvent.call(listener, event);
      } else {
        listener.call(thisArg, event);
      }
    }
  },
});

// node_modules/ws/lib/extension.js
var require_extension = __commonJS({
  "node_modules/ws/lib/extension.js"(exports2, module2) {
    "use strict";
    var { tokenChars } = require_validation();
    function push(dest, name, elem) {
      if (dest[name] === void 0) dest[name] = [elem];
      else dest[name].push(elem);
    }
    function parse(header) {
      const offers = /* @__PURE__ */ Object.create(null);
      let params = /* @__PURE__ */ Object.create(null);
      let mustUnescape = false;
      let isEscaping = false;
      let inQuotes = false;
      let extensionName;
      let paramName;
      let start = -1;
      let code = -1;
      let end = -1;
      let i = 0;
      for (; i < header.length; i++) {
        code = header.charCodeAt(i);
        if (extensionName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1) start = i;
          } else if (i !== 0 && (code === 32 || code === 9)) {
            if (end === -1 && start !== -1) end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1) end = i;
            const name = header.slice(start, end);
            if (code === 44) {
              push(offers, name, params);
              params = /* @__PURE__ */ Object.create(null);
            } else {
              extensionName = name;
            }
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (paramName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1) start = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1) end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1) end = i;
            push(params, header.slice(start, end), true);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            start = end = -1;
          } else if (code === 61 && start !== -1 && end === -1) {
            paramName = header.slice(start, i);
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else {
          if (isEscaping) {
            if (tokenChars[code] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (start === -1) start = i;
            else if (!mustUnescape) mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars[code] === 1) {
              if (start === -1) start = i;
            } else if (code === 34 && start !== -1) {
              inQuotes = false;
              end = i;
            } else if (code === 92) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
          } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
            inQuotes = true;
          } else if (end === -1 && tokenChars[code] === 1) {
            if (start === -1) start = i;
          } else if (start !== -1 && (code === 32 || code === 9)) {
            if (end === -1) end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1) end = i;
            let value = header.slice(start, end);
            if (mustUnescape) {
              value = value.replace(/\\/g, "");
              mustUnescape = false;
            }
            push(params, paramName, value);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            paramName = void 0;
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        }
      }
      if (start === -1 || inQuotes || code === 32 || code === 9) {
        throw new SyntaxError("Unexpected end of input");
      }
      if (end === -1) end = i;
      const token = header.slice(start, end);
      if (extensionName === void 0) {
        push(offers, token, params);
      } else {
        if (paramName === void 0) {
          push(params, token, true);
        } else if (mustUnescape) {
          push(params, paramName, token.replace(/\\/g, ""));
        } else {
          push(params, paramName, token);
        }
        push(offers, extensionName, params);
      }
      return offers;
    }
    function format(extensions) {
      return Object.keys(extensions)
        .map((extension) => {
          let configurations = extensions[extension];
          if (!Array.isArray(configurations)) configurations = [configurations];
          return configurations
            .map((params) => {
              return [extension]
                .concat(
                  Object.keys(params).map((k) => {
                    let values = params[k];
                    if (!Array.isArray(values)) values = [values];
                    return values
                      .map((v) => (v === true ? k : `${k}=${v}`))
                      .join("; ");
                  })
                )
                .join("; ");
            })
            .join(", ");
        })
        .join(", ");
    }
    module2.exports = { format, parse };
  },
});

// node_modules/ws/lib/websocket.js
var require_websocket = __commonJS({
  "node_modules/ws/lib/websocket.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var https = require("https");
    var http = require("http");
    var net = require("net");
    var tls = require("tls");
    var { randomBytes, createHash } = require("crypto");
    var { Duplex, Readable } = require("stream");
    var { URL } = require("url");
    var PerMessageDeflate = require_permessage_deflate();
    var Receiver = require_receiver();
    var Sender = require_sender();
    var { isBlob } = require_validation();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      GUID,
      kForOnEventAttribute,
      kListener,
      kStatusCode,
      kWebSocket,
      NOOP,
    } = require_constants2();
    var {
      EventTarget: { addEventListener, removeEventListener },
    } = require_event_target();
    var { format, parse } = require_extension();
    var { toBuffer } = require_buffer_util();
    var closeTimeout = 30 * 1e3;
    var kAborted = Symbol("kAborted");
    var protocolVersions = [8, 13];
    var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
    var WebSocket = class _WebSocket extends EventEmitter {
      /**
       * Create a new `WebSocket`.
       *
       * @param {(String|URL)} address The URL to which to connect
       * @param {(String|String[])} [protocols] The subprotocols
       * @param {Object} [options] Connection options
       */
      constructor(address, protocols, options) {
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = EMPTY_BUFFER;
        this._closeTimer = null;
        this._errorEmitted = false;
        this._extensions = {};
        this._paused = false;
        this._protocol = "";
        this._readyState = _WebSocket.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;
          if (protocols === void 0) {
            protocols = [];
          } else if (!Array.isArray(protocols)) {
            if (typeof protocols === "object" && protocols !== null) {
              options = protocols;
              protocols = [];
            } else {
              protocols = [protocols];
            }
          }
          initAsClient(this, address, protocols, options);
        } else {
          this._autoPong = options.autoPong;
          this._isServer = true;
        }
      }
      /**
       * For historical reasons, the custom "nodebuffer" type is used by the default
       * instead of "blob".
       *
       * @type {String}
       */
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type) {
        if (!BINARY_TYPES.includes(type)) return;
        this._binaryType = type;
        if (this._receiver) this._receiver._binaryType = type;
      }
      /**
       * @type {Number}
       */
      get bufferedAmount() {
        if (!this._socket) return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      /**
       * @type {String}
       */
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      /**
       * @type {Boolean}
       */
      get isPaused() {
        return this._paused;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onclose() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onerror() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onopen() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onmessage() {
        return null;
      }
      /**
       * @type {String}
       */
      get protocol() {
        return this._protocol;
      }
      /**
       * @type {Number}
       */
      get readyState() {
        return this._readyState;
      }
      /**
       * @type {String}
       */
      get url() {
        return this._url;
      }
      /**
       * Set up the socket and the internal resources.
       *
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Object} options Options object
       * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Number} [options.maxPayload=0] The maximum allowed message size
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @private
       */
      setSocket(socket, head, options) {
        const receiver = new Receiver({
          allowSynchronousEvents: options.allowSynchronousEvents,
          binaryType: this.binaryType,
          extensions: this._extensions,
          isServer: this._isServer,
          maxPayload: options.maxPayload,
          skipUTF8Validation: options.skipUTF8Validation,
        });
        const sender = new Sender(
          socket,
          this._extensions,
          options.generateMask
        );
        this._receiver = receiver;
        this._sender = sender;
        this._socket = socket;
        receiver[kWebSocket] = this;
        sender[kWebSocket] = this;
        socket[kWebSocket] = this;
        receiver.on("conclude", receiverOnConclude);
        receiver.on("drain", receiverOnDrain);
        receiver.on("error", receiverOnError);
        receiver.on("message", receiverOnMessage);
        receiver.on("ping", receiverOnPing);
        receiver.on("pong", receiverOnPong);
        sender.onerror = senderOnError;
        if (socket.setTimeout) socket.setTimeout(0);
        if (socket.setNoDelay) socket.setNoDelay();
        if (head.length > 0) socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError);
        this._readyState = _WebSocket.OPEN;
        this.emit("open");
      }
      /**
       * Emit the `'close'` event.
       *
       * @private
       */
      emitClose() {
        if (!this._socket) {
          this._readyState = _WebSocket.CLOSED;
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate.extensionName]) {
          this._extensions[PerMessageDeflate.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = _WebSocket.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
      }
      /**
       * Start a closing handshake.
       *
       *          +----------+   +-----------+   +----------+
       *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
       *    |     +----------+   +-----------+   +----------+     |
       *          +----------+   +-----------+         |
       * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
       *          +----------+   +-----------+   |
       *    |           |                        |   +---+        |
       *                +------------------------+-->|fin| - - - -
       *    |         +---+                      |   +---+
       *     - - - - -|fin|<---------------------+
       *              +---+
       *
       * @param {Number} [code] Status code explaining why the connection is closing
       * @param {(String|Buffer)} [data] The reason why the connection is
       *     closing
       * @public
       */
      close(code, data) {
        if (this.readyState === _WebSocket.CLOSED) return;
        if (this.readyState === _WebSocket.CONNECTING) {
          const msg =
            "WebSocket was closed before the connection was established";
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this.readyState === _WebSocket.CLOSING) {
          if (
            this._closeFrameSent &&
            (this._closeFrameReceived ||
              this._receiver._writableState.errorEmitted)
          ) {
            this._socket.end();
          }
          return;
        }
        this._readyState = _WebSocket.CLOSING;
        this._sender.close(code, data, !this._isServer, (err) => {
          if (err) return;
          this._closeFrameSent = true;
          if (
            this._closeFrameReceived ||
            this._receiver._writableState.errorEmitted
          ) {
            this._socket.end();
          }
        });
        setCloseTimer(this);
      }
      /**
       * Pause the socket.
       *
       * @public
       */
      pause() {
        if (
          this.readyState === _WebSocket.CONNECTING ||
          this.readyState === _WebSocket.CLOSED
        ) {
          return;
        }
        this._paused = true;
        this._socket.pause();
      }
      /**
       * Send a ping.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the ping is sent
       * @public
       */
      ping(data, mask, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number") data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0) mask = !this._isServer;
        this._sender.ping(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Send a pong.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the pong is sent
       * @public
       */
      pong(data, mask, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number") data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0) mask = !this._isServer;
        this._sender.pong(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Resume the socket.
       *
       * @public
       */
      resume() {
        if (
          this.readyState === _WebSocket.CONNECTING ||
          this.readyState === _WebSocket.CLOSED
        ) {
          return;
        }
        this._paused = false;
        if (!this._receiver._writableState.needDrain) this._socket.resume();
      }
      /**
       * Send a data message.
       *
       * @param {*} data The message to send
       * @param {Object} [options] Options object
       * @param {Boolean} [options.binary] Specifies whether `data` is binary or
       *     text
       * @param {Boolean} [options.compress] Specifies whether or not to compress
       *     `data`
       * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when data is written out
       * @public
       */
      send(data, options, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        if (typeof data === "number") data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        const opts = {
          binary: typeof data !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true,
          ...options,
        };
        if (!this._extensions[PerMessageDeflate.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data || EMPTY_BUFFER, opts, cb);
      }
      /**
       * Forcibly close the connection.
       *
       * @public
       */
      terminate() {
        if (this.readyState === _WebSocket.CLOSED) return;
        if (this.readyState === _WebSocket.CONNECTING) {
          const msg =
            "WebSocket was closed before the connection was established";
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this._socket) {
          this._readyState = _WebSocket.CLOSING;
          this._socket.destroy();
        }
      }
    };
    Object.defineProperty(WebSocket, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING"),
    });
    Object.defineProperty(WebSocket.prototype, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING"),
    });
    Object.defineProperty(WebSocket, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN"),
    });
    Object.defineProperty(WebSocket.prototype, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN"),
    });
    Object.defineProperty(WebSocket, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING"),
    });
    Object.defineProperty(WebSocket.prototype, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING"),
    });
    Object.defineProperty(WebSocket, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED"),
    });
    Object.defineProperty(WebSocket.prototype, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED"),
    });
    [
      "binaryType",
      "bufferedAmount",
      "extensions",
      "isPaused",
      "protocol",
      "readyState",
      "url",
    ].forEach((property) => {
      Object.defineProperty(WebSocket.prototype, property, {
        enumerable: true,
      });
    });
    ["open", "error", "close", "message"].forEach((method) => {
      Object.defineProperty(WebSocket.prototype, `on${method}`, {
        enumerable: true,
        get() {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute]) return listener[kListener];
          }
          return null;
        },
        set(handler) {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute]) {
              this.removeListener(method, listener);
              break;
            }
          }
          if (typeof handler !== "function") return;
          this.addEventListener(method, handler, {
            [kForOnEventAttribute]: true,
          });
        },
      });
    });
    WebSocket.prototype.addEventListener = addEventListener;
    WebSocket.prototype.removeEventListener = removeEventListener;
    module2.exports = WebSocket;
    function initAsClient(websocket, address, protocols, options) {
      const opts = {
        allowSynchronousEvents: true,
        autoPong: true,
        protocolVersion: protocolVersions[1],
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: true,
        followRedirects: false,
        maxRedirects: 10,
        ...options,
        socketPath: void 0,
        hostname: void 0,
        protocol: void 0,
        timeout: void 0,
        method: "GET",
        host: void 0,
        path: void 0,
        port: void 0,
      };
      websocket._autoPong = opts.autoPong;
      if (!protocolVersions.includes(opts.protocolVersion)) {
        throw new RangeError(
          `Unsupported protocol version: ${
            opts.protocolVersion
          } (supported versions: ${protocolVersions.join(", ")})`
        );
      }
      let parsedUrl;
      if (address instanceof URL) {
        parsedUrl = address;
      } else {
        try {
          parsedUrl = new URL(address);
        } catch (e) {
          throw new SyntaxError(`Invalid URL: ${address}`);
        }
      }
      if (parsedUrl.protocol === "http:") {
        parsedUrl.protocol = "ws:";
      } else if (parsedUrl.protocol === "https:") {
        parsedUrl.protocol = "wss:";
      }
      websocket._url = parsedUrl.href;
      const isSecure = parsedUrl.protocol === "wss:";
      const isIpcUrl = parsedUrl.protocol === "ws+unix:";
      let invalidUrlMessage;
      if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
        invalidUrlMessage = `The URL's protocol must be one of "ws:", "wss:", "http:", "https:", or "ws+unix:"`;
      } else if (isIpcUrl && !parsedUrl.pathname) {
        invalidUrlMessage = "The URL's pathname is empty";
      } else if (parsedUrl.hash) {
        invalidUrlMessage = "The URL contains a fragment identifier";
      }
      if (invalidUrlMessage) {
        const err = new SyntaxError(invalidUrlMessage);
        if (websocket._redirects === 0) {
          throw err;
        } else {
          emitErrorAndClose(websocket, err);
          return;
        }
      }
      const defaultPort = isSecure ? 443 : 80;
      const key = randomBytes(16).toString("base64");
      const request = isSecure ? https.request : http.request;
      const protocolSet = /* @__PURE__ */ new Set();
      let perMessageDeflate;
      opts.createConnection =
        opts.createConnection || (isSecure ? tlsConnect : netConnect);
      opts.defaultPort = opts.defaultPort || defaultPort;
      opts.port = parsedUrl.port || defaultPort;
      opts.host = parsedUrl.hostname.startsWith("[")
        ? parsedUrl.hostname.slice(1, -1)
        : parsedUrl.hostname;
      opts.headers = {
        ...opts.headers,
        "Sec-WebSocket-Version": opts.protocolVersion,
        "Sec-WebSocket-Key": key,
        Connection: "Upgrade",
        Upgrade: "websocket",
      };
      opts.path = parsedUrl.pathname + parsedUrl.search;
      opts.timeout = opts.handshakeTimeout;
      if (opts.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate(
          opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
          false,
          opts.maxPayload
        );
        opts.headers["Sec-WebSocket-Extensions"] = format({
          [PerMessageDeflate.extensionName]: perMessageDeflate.offer(),
        });
      }
      if (protocols.length) {
        for (const protocol of protocols) {
          if (
            typeof protocol !== "string" ||
            !subprotocolRegex.test(protocol) ||
            protocolSet.has(protocol)
          ) {
            throw new SyntaxError(
              "An invalid or duplicated subprotocol was specified"
            );
          }
          protocolSet.add(protocol);
        }
        opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
      }
      if (opts.origin) {
        if (opts.protocolVersion < 13) {
          opts.headers["Sec-WebSocket-Origin"] = opts.origin;
        } else {
          opts.headers.Origin = opts.origin;
        }
      }
      if (parsedUrl.username || parsedUrl.password) {
        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }
      if (isIpcUrl) {
        const parts = opts.path.split(":");
        opts.socketPath = parts[0];
        opts.path = parts[1];
      }
      let req;
      if (opts.followRedirects) {
        if (websocket._redirects === 0) {
          websocket._originalIpc = isIpcUrl;
          websocket._originalSecure = isSecure;
          websocket._originalHostOrSocketPath = isIpcUrl
            ? opts.socketPath
            : parsedUrl.host;
          const headers = options && options.headers;
          options = { ...options, headers: {} };
          if (headers) {
            for (const [key2, value] of Object.entries(headers)) {
              options.headers[key2.toLowerCase()] = value;
            }
          }
        } else if (websocket.listenerCount("redirect") === 0) {
          const isSameHost = isIpcUrl
            ? websocket._originalIpc
              ? opts.socketPath === websocket._originalHostOrSocketPath
              : false
            : websocket._originalIpc
            ? false
            : parsedUrl.host === websocket._originalHostOrSocketPath;
          if (!isSameHost || (websocket._originalSecure && !isSecure)) {
            delete opts.headers.authorization;
            delete opts.headers.cookie;
            if (!isSameHost) delete opts.headers.host;
            opts.auth = void 0;
          }
        }
        if (opts.auth && !options.headers.authorization) {
          options.headers.authorization =
            "Basic " + Buffer.from(opts.auth).toString("base64");
        }
        req = websocket._req = request(opts);
        if (websocket._redirects) {
          websocket.emit("redirect", websocket.url, req);
        }
      } else {
        req = websocket._req = request(opts);
      }
      if (opts.timeout) {
        req.on("timeout", () => {
          abortHandshake(websocket, req, "Opening handshake has timed out");
        });
      }
      req.on("error", (err) => {
        if (req === null || req[kAborted]) return;
        req = websocket._req = null;
        emitErrorAndClose(websocket, err);
      });
      req.on("response", (res) => {
        const location = res.headers.location;
        const statusCode = res.statusCode;
        if (
          location &&
          opts.followRedirects &&
          statusCode >= 300 &&
          statusCode < 400
        ) {
          if (++websocket._redirects > opts.maxRedirects) {
            abortHandshake(websocket, req, "Maximum redirects exceeded");
            return;
          }
          req.abort();
          let addr;
          try {
            addr = new URL(location, address);
          } catch (e) {
            const err = new SyntaxError(`Invalid URL: ${location}`);
            emitErrorAndClose(websocket, err);
            return;
          }
          initAsClient(websocket, addr, protocols, options);
        } else if (!websocket.emit("unexpected-response", req, res)) {
          abortHandshake(
            websocket,
            req,
            `Unexpected server response: ${res.statusCode}`
          );
        }
      });
      req.on("upgrade", (res, socket, head) => {
        websocket.emit("upgrade", res);
        if (websocket.readyState !== WebSocket.CONNECTING) return;
        req = websocket._req = null;
        const upgrade = res.headers.upgrade;
        if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
          abortHandshake(websocket, socket, "Invalid Upgrade header");
          return;
        }
        const digest = createHash("sha1")
          .update(key + GUID)
          .digest("base64");
        if (res.headers["sec-websocket-accept"] !== digest) {
          abortHandshake(
            websocket,
            socket,
            "Invalid Sec-WebSocket-Accept header"
          );
          return;
        }
        const serverProt = res.headers["sec-websocket-protocol"];
        let protError;
        if (serverProt !== void 0) {
          if (!protocolSet.size) {
            protError = "Server sent a subprotocol but none was requested";
          } else if (!protocolSet.has(serverProt)) {
            protError = "Server sent an invalid subprotocol";
          }
        } else if (protocolSet.size) {
          protError = "Server sent no subprotocol";
        }
        if (protError) {
          abortHandshake(websocket, socket, protError);
          return;
        }
        if (serverProt) websocket._protocol = serverProt;
        const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
        if (secWebSocketExtensions !== void 0) {
          if (!perMessageDeflate) {
            const message =
              "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          let extensions;
          try {
            extensions = parse(secWebSocketExtensions);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          const extensionNames = Object.keys(extensions);
          if (
            extensionNames.length !== 1 ||
            extensionNames[0] !== PerMessageDeflate.extensionName
          ) {
            const message =
              "Server indicated an extension that was not requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          try {
            perMessageDeflate.accept(
              extensions[PerMessageDeflate.extensionName]
            );
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          websocket._extensions[PerMessageDeflate.extensionName] =
            perMessageDeflate;
        }
        websocket.setSocket(socket, head, {
          allowSynchronousEvents: opts.allowSynchronousEvents,
          generateMask: opts.generateMask,
          maxPayload: opts.maxPayload,
          skipUTF8Validation: opts.skipUTF8Validation,
        });
      });
      if (opts.finishRequest) {
        opts.finishRequest(req, websocket);
      } else {
        req.end();
      }
    }
    function emitErrorAndClose(websocket, err) {
      websocket._readyState = WebSocket.CLOSING;
      websocket._errorEmitted = true;
      websocket.emit("error", err);
      websocket.emitClose();
    }
    function netConnect(options) {
      options.path = options.socketPath;
      return net.connect(options);
    }
    function tlsConnect(options) {
      options.path = void 0;
      if (!options.servername && options.servername !== "") {
        options.servername = net.isIP(options.host) ? "" : options.host;
      }
      return tls.connect(options);
    }
    function abortHandshake(websocket, stream, message) {
      websocket._readyState = WebSocket.CLOSING;
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshake);
      if (stream.setHeader) {
        stream[kAborted] = true;
        stream.abort();
        if (stream.socket && !stream.socket.destroyed) {
          stream.socket.destroy();
        }
        process.nextTick(emitErrorAndClose, websocket, err);
      } else {
        stream.destroy(err);
        stream.once("error", websocket.emit.bind(websocket, "error"));
        stream.once("close", websocket.emitClose.bind(websocket));
      }
    }
    function sendAfterClose(websocket, data, cb) {
      if (data) {
        const length = isBlob(data) ? data.size : toBuffer(data).length;
        if (websocket._socket) websocket._sender._bufferedBytes += length;
        else websocket._bufferedAmount += length;
      }
      if (cb) {
        const err = new Error(
          `WebSocket is not open: readyState ${websocket.readyState} (${
            readyStates[websocket.readyState]
          })`
        );
        process.nextTick(cb, err);
      }
    }
    function receiverOnConclude(code, reason) {
      const websocket = this[kWebSocket];
      websocket._closeFrameReceived = true;
      websocket._closeMessage = reason;
      websocket._closeCode = code;
      if (websocket._socket[kWebSocket] === void 0) return;
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      if (code === 1005) websocket.close();
      else websocket.close(code, reason);
    }
    function receiverOnDrain() {
      const websocket = this[kWebSocket];
      if (!websocket.isPaused) websocket._socket.resume();
    }
    function receiverOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket._socket[kWebSocket] !== void 0) {
        websocket._socket.removeListener("data", socketOnData);
        process.nextTick(resume, websocket._socket);
        websocket.close(err[kStatusCode]);
      }
      if (!websocket._errorEmitted) {
        websocket._errorEmitted = true;
        websocket.emit("error", err);
      }
    }
    function receiverOnFinish() {
      this[kWebSocket].emitClose();
    }
    function receiverOnMessage(data, isBinary) {
      this[kWebSocket].emit("message", data, isBinary);
    }
    function receiverOnPing(data) {
      const websocket = this[kWebSocket];
      if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);
      websocket.emit("ping", data);
    }
    function receiverOnPong(data) {
      this[kWebSocket].emit("pong", data);
    }
    function resume(stream) {
      stream.resume();
    }
    function senderOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket.readyState === WebSocket.CLOSED) return;
      if (websocket.readyState === WebSocket.OPEN) {
        websocket._readyState = WebSocket.CLOSING;
        setCloseTimer(websocket);
      }
      this._socket.end();
      if (!websocket._errorEmitted) {
        websocket._errorEmitted = true;
        websocket.emit("error", err);
      }
    }
    function setCloseTimer(websocket) {
      websocket._closeTimer = setTimeout(
        websocket._socket.destroy.bind(websocket._socket),
        closeTimeout
      );
    }
    function socketOnClose() {
      const websocket = this[kWebSocket];
      this.removeListener("close", socketOnClose);
      this.removeListener("data", socketOnData);
      this.removeListener("end", socketOnEnd);
      websocket._readyState = WebSocket.CLOSING;
      let chunk;
      if (
        !this._readableState.endEmitted &&
        !websocket._closeFrameReceived &&
        !websocket._receiver._writableState.errorEmitted &&
        (chunk = websocket._socket.read()) !== null
      ) {
        websocket._receiver.write(chunk);
      }
      websocket._receiver.end();
      this[kWebSocket] = void 0;
      clearTimeout(websocket._closeTimer);
      if (
        websocket._receiver._writableState.finished ||
        websocket._receiver._writableState.errorEmitted
      ) {
        websocket.emitClose();
      } else {
        websocket._receiver.on("error", receiverOnFinish);
        websocket._receiver.on("finish", receiverOnFinish);
      }
    }
    function socketOnData(chunk) {
      if (!this[kWebSocket]._receiver.write(chunk)) {
        this.pause();
      }
    }
    function socketOnEnd() {
      const websocket = this[kWebSocket];
      websocket._readyState = WebSocket.CLOSING;
      websocket._receiver.end();
      this.end();
    }
    function socketOnError() {
      const websocket = this[kWebSocket];
      this.removeListener("error", socketOnError);
      this.on("error", NOOP);
      if (websocket) {
        websocket._readyState = WebSocket.CLOSING;
        this.destroy();
      }
    }
  },
});

// node_modules/ws/lib/stream.js
var require_stream = __commonJS({
  "node_modules/ws/lib/stream.js"(exports2, module2) {
    "use strict";
    var WebSocket = require_websocket();
    var { Duplex } = require("stream");
    function emitClose(stream) {
      stream.emit("close");
    }
    function duplexOnEnd() {
      if (!this.destroyed && this._writableState.finished) {
        this.destroy();
      }
    }
    function duplexOnError(err) {
      this.removeListener("error", duplexOnError);
      this.destroy();
      if (this.listenerCount("error") === 0) {
        this.emit("error", err);
      }
    }
    function createWebSocketStream(ws, options) {
      let terminateOnDestroy = true;
      const duplex = new Duplex({
        ...options,
        autoDestroy: false,
        emitClose: false,
        objectMode: false,
        writableObjectMode: false,
      });
      ws.on("message", function message(msg, isBinary) {
        const data =
          !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
        if (!duplex.push(data)) ws.pause();
      });
      ws.once("error", function error(err) {
        if (duplex.destroyed) return;
        terminateOnDestroy = false;
        duplex.destroy(err);
      });
      ws.once("close", function close() {
        if (duplex.destroyed) return;
        duplex.push(null);
      });
      duplex._destroy = function (err, callback) {
        if (ws.readyState === ws.CLOSED) {
          callback(err);
          process.nextTick(emitClose, duplex);
          return;
        }
        let called = false;
        ws.once("error", function error(err2) {
          called = true;
          callback(err2);
        });
        ws.once("close", function close() {
          if (!called) callback(err);
          process.nextTick(emitClose, duplex);
        });
        if (terminateOnDestroy) ws.terminate();
      };
      duplex._final = function (callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._final(callback);
          });
          return;
        }
        if (ws._socket === null) return;
        if (ws._socket._writableState.finished) {
          callback();
          if (duplex._readableState.endEmitted) duplex.destroy();
        } else {
          ws._socket.once("finish", function finish() {
            callback();
          });
          ws.close();
        }
      };
      duplex._read = function () {
        if (ws.isPaused) ws.resume();
      };
      duplex._write = function (chunk, encoding, callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._write(chunk, encoding, callback);
          });
          return;
        }
        ws.send(chunk, callback);
      };
      duplex.on("end", duplexOnEnd);
      duplex.on("error", duplexOnError);
      return duplex;
    }
    module2.exports = createWebSocketStream;
  },
});

// node_modules/ws/lib/subprotocol.js
var require_subprotocol = __commonJS({
  "node_modules/ws/lib/subprotocol.js"(exports2, module2) {
    "use strict";
    var { tokenChars } = require_validation();
    function parse(header) {
      const protocols = /* @__PURE__ */ new Set();
      let start = -1;
      let end = -1;
      let i = 0;
      for (i; i < header.length; i++) {
        const code = header.charCodeAt(i);
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1) start = i;
        } else if (i !== 0 && (code === 32 || code === 9)) {
          if (end === -1 && start !== -1) end = i;
        } else if (code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1) end = i;
          const protocol2 = header.slice(start, end);
          if (protocols.has(protocol2)) {
            throw new SyntaxError(
              `The "${protocol2}" subprotocol is duplicated`
            );
          }
          protocols.add(protocol2);
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      }
      if (start === -1 || end !== -1) {
        throw new SyntaxError("Unexpected end of input");
      }
      const protocol = header.slice(start, i);
      if (protocols.has(protocol)) {
        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
      }
      protocols.add(protocol);
      return protocols;
    }
    module2.exports = { parse };
  },
});

// node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS({
  "node_modules/ws/lib/websocket-server.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var http = require("http");
    var { Duplex } = require("stream");
    var { createHash } = require("crypto");
    var extension = require_extension();
    var PerMessageDeflate = require_permessage_deflate();
    var subprotocol = require_subprotocol();
    var WebSocket = require_websocket();
    var { GUID, kWebSocket } = require_constants2();
    var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    var RUNNING = 0;
    var CLOSING = 1;
    var CLOSED = 2;
    var WebSocketServer = class extends EventEmitter {
      /**
       * Create a `WebSocketServer` instance.
       *
       * @param {Object} options Configuration options
       * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {Boolean} [options.autoPong=true] Specifies whether or not to
       *     automatically send a pong in response to a ping
       * @param {Number} [options.backlog=511] The maximum length of the queue of
       *     pending connections
       * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
       *     track clients
       * @param {Function} [options.handleProtocols] A hook to handle protocols
       * @param {String} [options.host] The hostname where to bind the server
       * @param {Number} [options.maxPayload=104857600] The maximum allowed message
       *     size
       * @param {Boolean} [options.noServer=false] Enable no server mode
       * @param {String} [options.path] Accept only connections matching this path
       * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
       *     permessage-deflate
       * @param {Number} [options.port] The port where to bind the server
       * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
       *     server to use
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @param {Function} [options.verifyClient] A hook to reject connections
       * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
       *     class to use. It must be the `WebSocket` class or class that extends it
       * @param {Function} [callback] A listener for the `listening` event
       */
      constructor(options, callback) {
        super();
        options = {
          allowSynchronousEvents: true,
          autoPong: true,
          maxPayload: 100 * 1024 * 1024,
          skipUTF8Validation: false,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          verifyClient: null,
          noServer: false,
          backlog: null,
          // use default (511 as implemented in net.js)
          server: null,
          host: null,
          path: null,
          port: null,
          WebSocket,
          ...options,
        };
        if (
          (options.port == null && !options.server && !options.noServer) ||
          (options.port != null && (options.server || options.noServer)) ||
          (options.server && options.noServer)
        ) {
          throw new TypeError(
            'One and only one of the "port", "server", or "noServer" options must be specified'
          );
        }
        if (options.port != null) {
          this._server = http.createServer((req, res) => {
            const body = http.STATUS_CODES[426];
            res.writeHead(426, {
              "Content-Length": body.length,
              "Content-Type": "text/plain",
            });
            res.end(body);
          });
          this._server.listen(
            options.port,
            options.host,
            options.backlog,
            callback
          );
        } else if (options.server) {
          this._server = options.server;
        }
        if (this._server) {
          const emitConnection = this.emit.bind(this, "connection");
          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: (req, socket, head) => {
              this.handleUpgrade(req, socket, head, emitConnection);
            },
          });
        }
        if (options.perMessageDeflate === true) options.perMessageDeflate = {};
        if (options.clientTracking) {
          this.clients = /* @__PURE__ */ new Set();
          this._shouldEmitClose = false;
        }
        this.options = options;
        this._state = RUNNING;
      }
      /**
       * Returns the bound address, the address family name, and port of the server
       * as reported by the operating system if listening on an IP socket.
       * If the server is listening on a pipe or UNIX domain socket, the name is
       * returned as a string.
       *
       * @return {(Object|String|null)} The address of the server
       * @public
       */
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server) return null;
        return this._server.address();
      }
      /**
       * Stop the server from accepting new connections and emit the `'close'` event
       * when all existing connections are closed.
       *
       * @param {Function} [cb] A one-time listener for the `'close'` event
       * @public
       */
      close(cb) {
        if (this._state === CLOSED) {
          if (cb) {
            this.once("close", () => {
              cb(new Error("The server is not running"));
            });
          }
          process.nextTick(emitClose, this);
          return;
        }
        if (cb) this.once("close", cb);
        if (this._state === CLOSING) return;
        this._state = CLOSING;
        if (this.options.noServer || this.options.server) {
          if (this._server) {
            this._removeListeners();
            this._removeListeners = this._server = null;
          }
          if (this.clients) {
            if (!this.clients.size) {
              process.nextTick(emitClose, this);
            } else {
              this._shouldEmitClose = true;
            }
          } else {
            process.nextTick(emitClose, this);
          }
        } else {
          const server = this._server;
          this._removeListeners();
          this._removeListeners = this._server = null;
          server.close(() => {
            emitClose(this);
          });
        }
      }
      /**
       * See if a given request should be handled by this server instance.
       *
       * @param {http.IncomingMessage} req Request object to inspect
       * @return {Boolean} `true` if the request is valid, else `false`
       * @public
       */
      shouldHandle(req) {
        if (this.options.path) {
          const index = req.url.indexOf("?");
          const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
          if (pathname !== this.options.path) return false;
        }
        return true;
      }
      /**
       * Handle a HTTP Upgrade request.
       *
       * @param {http.IncomingMessage} req The request object
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @public
       */
      handleUpgrade(req, socket, head, cb) {
        socket.on("error", socketOnError);
        const key = req.headers["sec-websocket-key"];
        const upgrade = req.headers.upgrade;
        const version = +req.headers["sec-websocket-version"];
        if (req.method !== "GET") {
          const message = "Invalid HTTP method";
          abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
          return;
        }
        if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
          const message = "Invalid Upgrade header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (key === void 0 || !keyRegex.test(key)) {
          const message = "Missing or invalid Sec-WebSocket-Key header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (version !== 13 && version !== 8) {
          const message = "Missing or invalid Sec-WebSocket-Version header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message, {
            "Sec-WebSocket-Version": "13, 8",
          });
          return;
        }
        if (!this.shouldHandle(req)) {
          abortHandshake(socket, 400);
          return;
        }
        const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
        let protocols = /* @__PURE__ */ new Set();
        if (secWebSocketProtocol !== void 0) {
          try {
            protocols = subprotocol.parse(secWebSocketProtocol);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Protocol header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
        const extensions = {};
        if (
          this.options.perMessageDeflate &&
          secWebSocketExtensions !== void 0
        ) {
          const perMessageDeflate = new PerMessageDeflate(
            this.options.perMessageDeflate,
            true,
            this.options.maxPayload
          );
          try {
            const offers = extension.parse(secWebSocketExtensions);
            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            const message =
              "Invalid or unacceptable Sec-WebSocket-Extensions header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        if (this.options.verifyClient) {
          const info = {
            origin:
              req.headers[
                `${version === 8 ? "sec-websocket-origin" : "origin"}`
              ],
            secure: !!(req.socket.authorized || req.socket.encrypted),
            req,
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(
              info,
              (verified, code, message, headers) => {
                if (!verified) {
                  return abortHandshake(socket, code || 401, message, headers);
                }
                this.completeUpgrade(
                  extensions,
                  key,
                  protocols,
                  req,
                  socket,
                  head,
                  cb
                );
              }
            );
            return;
          }
          if (!this.options.verifyClient(info))
            return abortHandshake(socket, 401);
        }
        this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
      }
      /**
       * Upgrade the connection to WebSocket.
       *
       * @param {Object} extensions The accepted extensions
       * @param {String} key The value of the `Sec-WebSocket-Key` header
       * @param {Set} protocols The subprotocols
       * @param {http.IncomingMessage} req The request object
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @throws {Error} If called more than once with the same socket
       * @private
       */
      completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
        if (!socket.readable || !socket.writable) return socket.destroy();
        if (socket[kWebSocket]) {
          throw new Error(
            "server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration"
          );
        }
        if (this._state > RUNNING) return abortHandshake(socket, 503);
        const digest = createHash("sha1")
          .update(key + GUID)
          .digest("base64");
        const headers = [
          "HTTP/1.1 101 Switching Protocols",
          "Upgrade: websocket",
          "Connection: Upgrade",
          `Sec-WebSocket-Accept: ${digest}`,
        ];
        const ws = new this.options.WebSocket(null, void 0, this.options);
        if (protocols.size) {
          const protocol = this.options.handleProtocols
            ? this.options.handleProtocols(protocols, req)
            : protocols.values().next().value;
          if (protocol) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
            ws._protocol = protocol;
          }
        }
        if (extensions[PerMessageDeflate.extensionName]) {
          const params = extensions[PerMessageDeflate.extensionName].params;
          const value = extension.format({
            [PerMessageDeflate.extensionName]: [params],
          });
          headers.push(`Sec-WebSocket-Extensions: ${value}`);
          ws._extensions = extensions;
        }
        this.emit("headers", headers, req);
        socket.write(headers.concat("\r\n").join("\r\n"));
        socket.removeListener("error", socketOnError);
        ws.setSocket(socket, head, {
          allowSynchronousEvents: this.options.allowSynchronousEvents,
          maxPayload: this.options.maxPayload,
          skipUTF8Validation: this.options.skipUTF8Validation,
        });
        if (this.clients) {
          this.clients.add(ws);
          ws.on("close", () => {
            this.clients.delete(ws);
            if (this._shouldEmitClose && !this.clients.size) {
              process.nextTick(emitClose, this);
            }
          });
        }
        cb(ws, req);
      }
    };
    module2.exports = WebSocketServer;
    function addListeners(server, map) {
      for (const event of Object.keys(map)) server.on(event, map[event]);
      return function removeListeners() {
        for (const event of Object.keys(map)) {
          server.removeListener(event, map[event]);
        }
      };
    }
    function emitClose(server) {
      server._state = CLOSED;
      server.emit("close");
    }
    function socketOnError() {
      this.destroy();
    }
    function abortHandshake(socket, code, message, headers) {
      message = message || http.STATUS_CODES[code];
      headers = {
        Connection: "close",
        "Content-Type": "text/html",
        "Content-Length": Buffer.byteLength(message),
        ...headers,
      };
      socket.once("finish", socket.destroy);
      socket.end(
        `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r
` +
          Object.keys(headers)
            .map((h) => `${h}: ${headers[h]}`)
            .join("\r\n") +
          "\r\n\r\n" +
          message
      );
    }
    function abortHandshakeOrEmitwsClientError(
      server,
      req,
      socket,
      code,
      message,
      headers
    ) {
      if (server.listenerCount("wsClientError")) {
        const err = new Error(message);
        Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
        server.emit("wsClientError", err, socket, req);
      } else {
        abortHandshake(socket, code, message, headers);
      }
    }
  },
});

// node_modules/ws/index.js
var require_ws = __commonJS({
  "node_modules/ws/index.js"(exports2, module2) {
    "use strict";
    var WebSocket = require_websocket();
    WebSocket.createWebSocketStream = require_stream();
    WebSocket.Server = require_websocket_server();
    WebSocket.Receiver = require_receiver();
    WebSocket.Sender = require_sender();
    WebSocket.WebSocket = WebSocket;
    WebSocket.WebSocketServer = WebSocket.Server;
    module2.exports = WebSocket;
  },
});

// node_modules/@xrplf/isomorphic/dist/ws/index.js
var require_ws2 = __commonJS({
  "node_modules/@xrplf/isomorphic/dist/ws/index.js"(exports2) {
    "use strict";
    var __importDefault =
      (exports2 && exports2.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ws_1 = __importDefault(require_ws());
    var Socket = class extends ws_1.default {
      constructor(...args) {
        super(args[0], args[1], args[2]);
        this.setMaxListeners(Infinity);
      }
    };
    exports2.default = Socket;
  },
});

// node_modules/xrpl/dist/npm/client/ConnectionManager.js
var require_ConnectionManager = __commonJS({
  "node_modules/xrpl/dist/npm/client/ConnectionManager.js"(exports2) {
    "use strict";
    var __awaiter =
      (exports2 && exports2.__awaiter) ||
      function (thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P
            ? value
            : new P(function (resolve) {
                resolve(value);
              });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done
              ? resolve(result.value)
              : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ConnectionManager = class {
      constructor() {
        this.promisesAwaitingConnection = [];
      }
      resolveAllAwaiting() {
        this.promisesAwaitingConnection.map(({ resolve }) => resolve());
        this.promisesAwaitingConnection = [];
      }
      rejectAllAwaiting(error) {
        this.promisesAwaitingConnection.map(({ reject }) => reject(error));
        this.promisesAwaitingConnection = [];
      }
      awaitConnection() {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            this.promisesAwaitingConnection.push({ resolve, reject });
          });
        });
      }
    };
    exports2.default = ConnectionManager;
  },
});

// node_modules/xrpl/dist/npm/client/ExponentialBackoff.js
var require_ExponentialBackoff = __commonJS({
  "node_modules/xrpl/dist/npm/client/ExponentialBackoff.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var DEFAULT_MIN = 100;
    var DEFAULT_MAX = 1e3;
    var ExponentialBackoff = class {
      constructor(opts = {}) {
        var _a, _b;
        this.factor = 2;
        this.numAttempts = 0;
        this.ms = (_a = opts.min) !== null && _a !== void 0 ? _a : DEFAULT_MIN;
        this.max = (_b = opts.max) !== null && _b !== void 0 ? _b : DEFAULT_MAX;
      }
      get attempts() {
        return this.numAttempts;
      }
      duration() {
        const ms = this.ms * Math.pow(this.factor, this.numAttempts);
        this.numAttempts += 1;
        return Math.floor(Math.min(ms, this.max));
      }
      reset() {
        this.numAttempts = 0;
      }
    };
    exports2.default = ExponentialBackoff;
  },
});

// node_modules/xrpl/dist/npm/client/RequestManager.js
var require_RequestManager = __commonJS({
  "node_modules/xrpl/dist/npm/client/RequestManager.js"(exports2) {
    "use strict";
    var __awaiter =
      (exports2 && exports2.__awaiter) ||
      function (thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P
            ? value
            : new P(function (resolve) {
                resolve(value);
              });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done
              ? resolve(result.value)
              : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var errors_1 = require_errors();
    var RequestManager = class {
      constructor() {
        this.nextId = 0;
        this.promisesAwaitingResponse = /* @__PURE__ */ new Map();
      }
      addPromise(newId, timer) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            this.promisesAwaitingResponse.set(newId, {
              resolve,
              reject,
              timer,
            });
          });
        });
      }
      resolve(id, response) {
        const promise = this.promisesAwaitingResponse.get(id);
        if (promise == null) {
          throw new errors_1.XrplError(`No existing promise with id ${id}`, {
            type: "resolve",
            response,
          });
        }
        clearTimeout(promise.timer);
        promise.resolve(response);
        this.deletePromise(id);
      }
      reject(id, error) {
        const promise = this.promisesAwaitingResponse.get(id);
        if (promise == null) {
          throw new errors_1.XrplError(`No existing promise with id ${id}`, {
            type: "reject",
            error,
          });
        }
        clearTimeout(promise.timer);
        promise.reject(error);
        this.deletePromise(id);
      }
      rejectAll(error) {
        this.promisesAwaitingResponse.forEach((_promise, id, _map) => {
          this.reject(id, error);
          this.deletePromise(id);
        });
      }
      createRequest(request, timeout) {
        let newId;
        if (request.id == null) {
          newId = this.nextId;
          this.nextId += 1;
        } else {
          newId = request.id;
        }
        const newRequest = JSON.stringify(
          Object.assign(Object.assign({}, request), { id: newId })
        );
        const timer = setTimeout(() => {
          this.reject(
            newId,
            new errors_1.TimeoutError(
              `Timeout for request: ${JSON.stringify(
                request
              )} with id ${newId}`,
              request
            )
          );
        }, timeout);
        if (timer.unref) {
          timer.unref();
        }
        if (this.promisesAwaitingResponse.has(newId)) {
          clearTimeout(timer);
          throw new errors_1.XrplError(
            `Response with id '${newId}' is already pending`,
            request
          );
        }
        const newPromise = new Promise((resolve, reject) => {
          this.promisesAwaitingResponse.set(newId, {
            resolve,
            reject,
            timer,
          });
        });
        return [newId, newRequest, newPromise];
      }
      handleResponse(response) {
        var _a, _b;
        if (
          response.id == null ||
          !(typeof response.id === "string" || typeof response.id === "number")
        ) {
          throw new errors_1.ResponseFormatError(
            "valid id not found in response",
            response
          );
        }
        if (!this.promisesAwaitingResponse.has(response.id)) {
          return;
        }
        if (response.status == null) {
          const error = new errors_1.ResponseFormatError(
            "Response has no status"
          );
          this.reject(response.id, error);
        }
        if (response.status === "error") {
          const errorResponse = response;
          const error = new errors_1.RippledError(
            (_a = errorResponse.error_message) !== null && _a !== void 0
              ? _a
              : errorResponse.error,
            errorResponse
          );
          this.reject(response.id, error);
          return;
        }
        if (response.status !== "success") {
          const error = new errors_1.ResponseFormatError(
            `unrecognized response.status: ${
              (_b = response.status) !== null && _b !== void 0 ? _b : ""
            }`,
            response
          );
          this.reject(response.id, error);
          return;
        }
        delete response.status;
        this.resolve(response.id, response);
      }
      deletePromise(id) {
        this.promisesAwaitingResponse.delete(id);
      }
    };
    exports2.default = RequestManager;
  },
});

// node_modules/xrpl/dist/npm/client/connection.js
var require_connection = __commonJS({
  "node_modules/xrpl/dist/npm/client/connection.js"(exports2) {
    "use strict";
    var __awaiter =
      (exports2 && exports2.__awaiter) ||
      function (thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P
            ? value
            : new P(function (resolve) {
                resolve(value);
              });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done
              ? resolve(result.value)
              : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
    var __importDefault =
      (exports2 && exports2.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Connection = exports2.INTENTIONAL_DISCONNECT_CODE = void 0;
    var utils_1 = require_utils2();
    var ws_1 = __importDefault(require_ws2());
    var eventemitter3_1 = require_eventemitter3();
    var errors_1 = require_errors();
    var ConnectionManager_1 = __importDefault(require_ConnectionManager());
    var ExponentialBackoff_1 = __importDefault(require_ExponentialBackoff());
    var RequestManager_1 = __importDefault(require_RequestManager());
    var SECONDS_PER_MINUTE = 60;
    var TIMEOUT = 20;
    var CONNECTION_TIMEOUT = 5;
    exports2.INTENTIONAL_DISCONNECT_CODE = 4e3;
    function createWebSocket(url, config) {
      const options = {
        agent: config.agent,
      };
      if (config.headers) {
        options.headers = config.headers;
      }
      if (config.authorization != null) {
        options.headers = Object.assign(Object.assign({}, options.headers), {
          Authorization: `Basic ${btoa(config.authorization)}`,
        });
      }
      const websocketOptions = Object.assign({}, options);
      return new ws_1.default(url, websocketOptions);
    }
    function websocketSendAsync(ws, message) {
      return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
          ws.send(message, (error) => {
            if (error) {
              reject(new errors_1.DisconnectedError(error.message, error));
            } else {
              resolve();
            }
          });
        });
      });
    }
    var Connection = class extends eventemitter3_1.EventEmitter {
      constructor(url, options = {}) {
        super();
        this.ws = null;
        this.reconnectTimeoutID = null;
        this.heartbeatIntervalID = null;
        this.retryConnectionBackoff = new ExponentialBackoff_1.default({
          min: 100,
          max: SECONDS_PER_MINUTE * 1e3,
        });
        this.requestManager = new RequestManager_1.default();
        this.connectionManager = new ConnectionManager_1.default();
        this.trace = () => {};
        this.url = url;
        this.config = Object.assign(
          {
            timeout: TIMEOUT * 1e3,
            connectionTimeout: CONNECTION_TIMEOUT * 1e3,
          },
          options
        );
        if (typeof options.trace === "function") {
          this.trace = options.trace;
        } else if (options.trace) {
          this.trace = console.log;
        }
      }
      get state() {
        return this.ws ? this.ws.readyState : ws_1.default.CLOSED;
      }
      get shouldBeConnected() {
        return this.ws !== null;
      }
      isConnected() {
        return this.state === ws_1.default.OPEN;
      }
      connect() {
        return __awaiter(this, void 0, void 0, function* () {
          if (this.isConnected()) {
            return Promise.resolve();
          }
          if (this.state === ws_1.default.CONNECTING) {
            return this.connectionManager.awaitConnection();
          }
          if (!this.url) {
            return Promise.reject(
              new errors_1.ConnectionError(
                "Cannot connect because no server was specified"
              )
            );
          }
          if (this.ws != null) {
            return Promise.reject(
              new errors_1.XrplError("Websocket connection never cleaned up.", {
                state: this.state,
              })
            );
          }
          const connectionTimeoutID = setTimeout(() => {
            this.onConnectionFailed(
              new errors_1.ConnectionError(
                `Error: connect() timed out after ${this.config.connectionTimeout} ms. If your internet connection is working, the rippled server may be blocked or inaccessible. You can also try setting the 'connectionTimeout' option in the Client constructor.`
              )
            );
          }, this.config.connectionTimeout);
          this.ws = createWebSocket(this.url, this.config);
          if (this.ws == null) {
            throw new errors_1.XrplError("Connect: created null websocket");
          }
          this.ws.on("error", (error) => this.onConnectionFailed(error));
          this.ws.on("error", () => clearTimeout(connectionTimeoutID));
          this.ws.on("close", (reason) => this.onConnectionFailed(reason));
          this.ws.on("close", () => clearTimeout(connectionTimeoutID));
          this.ws.once("open", () => {
            void this.onceOpen(connectionTimeoutID);
          });
          return this.connectionManager.awaitConnection();
        });
      }
      disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
          this.clearHeartbeatInterval();
          if (this.reconnectTimeoutID !== null) {
            clearTimeout(this.reconnectTimeoutID);
            this.reconnectTimeoutID = null;
          }
          if (this.state === ws_1.default.CLOSED) {
            return Promise.resolve(void 0);
          }
          if (this.ws == null) {
            return Promise.resolve(void 0);
          }
          return new Promise((resolve) => {
            if (this.ws == null) {
              resolve(void 0);
            }
            if (this.ws != null) {
              this.ws.once("close", (code) => resolve(code));
            }
            if (this.ws != null && this.state !== ws_1.default.CLOSING) {
              this.ws.close(exports2.INTENTIONAL_DISCONNECT_CODE);
            }
          });
        });
      }
      reconnect() {
        return __awaiter(this, void 0, void 0, function* () {
          this.emit("reconnect");
          yield this.disconnect();
          yield this.connect();
        });
      }
      request(request, timeout) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!this.shouldBeConnected || this.ws == null) {
            throw new errors_1.NotConnectedError(
              JSON.stringify(request),
              request
            );
          }
          const [id, message, responsePromise] =
            this.requestManager.createRequest(
              request,
              timeout !== null && timeout !== void 0
                ? timeout
                : this.config.timeout
            );
          this.trace("send", message);
          websocketSendAsync(this.ws, message).catch((error) => {
            this.requestManager.reject(id, error);
          });
          return responsePromise;
        });
      }
      getUrl() {
        var _a;
        return (_a = this.url) !== null && _a !== void 0 ? _a : "";
      }
      onMessage(message) {
        this.trace("receive", message);
        let data;
        try {
          data = JSON.parse(message);
        } catch (error) {
          if (error instanceof Error) {
            this.emit("error", "badMessage", error.message, message);
          }
          return;
        }
        if (data.type == null && data.error) {
          this.emit("error", data.error, data.error_message, data);
          return;
        }
        if (data.type) {
          this.emit(data.type, data);
        }
        if (data.type === "response") {
          try {
            this.requestManager.handleResponse(data);
          } catch (error) {
            if (error instanceof Error) {
              this.emit("error", "badMessage", error.message, message);
            } else {
              this.emit("error", "badMessage", error, error);
            }
          }
        }
      }
      onceOpen(connectionTimeoutID) {
        return __awaiter(this, void 0, void 0, function* () {
          if (this.ws == null) {
            throw new errors_1.XrplError("onceOpen: ws is null");
          }
          this.ws.removeAllListeners();
          clearTimeout(connectionTimeoutID);
          this.ws.on("message", (message) => this.onMessage(message));
          this.ws.on("error", (error) =>
            this.emit("error", "websocket", error.message, error)
          );
          this.ws.once("close", (code, reason) => {
            if (this.ws == null) {
              throw new errors_1.XrplError("onceClose: ws is null");
            }
            this.clearHeartbeatInterval();
            this.requestManager.rejectAll(
              new errors_1.DisconnectedError(
                `websocket was closed, ${
                  reason
                    ? (0, utils_1.hexToString)((0, utils_1.bytesToHex)(reason))
                    : ""
                }`
              )
            );
            this.ws.removeAllListeners();
            this.ws = null;
            if (code === void 0) {
              const internalErrorCode = 1011;
              this.emit("disconnected", internalErrorCode);
            } else {
              this.emit("disconnected", code);
            }
            if (
              code !== exports2.INTENTIONAL_DISCONNECT_CODE &&
              code !== void 0
            ) {
              this.intentionalDisconnect();
            }
          });
          try {
            this.retryConnectionBackoff.reset();
            this.startHeartbeatInterval();
            this.connectionManager.resolveAllAwaiting();
            this.emit("connected");
          } catch (error) {
            if (error instanceof Error) {
              this.connectionManager.rejectAllAwaiting(error);
              yield this.disconnect().catch(() => {});
            }
          }
        });
      }
      intentionalDisconnect() {
        const retryTimeout = this.retryConnectionBackoff.duration();
        this.trace("reconnect", `Retrying connection in ${retryTimeout}ms.`);
        this.emit("reconnecting", this.retryConnectionBackoff.attempts);
        this.reconnectTimeoutID = setTimeout(() => {
          this.reconnect().catch((error) => {
            this.emit("error", "reconnect", error.message, error);
          });
        }, retryTimeout);
      }
      clearHeartbeatInterval() {
        if (this.heartbeatIntervalID) {
          clearInterval(this.heartbeatIntervalID);
        }
      }
      startHeartbeatInterval() {
        this.clearHeartbeatInterval();
        this.heartbeatIntervalID = setInterval(() => {
          void this.heartbeat();
        }, this.config.timeout);
      }
      heartbeat() {
        return __awaiter(this, void 0, void 0, function* () {
          this.request({ command: "ping" }).catch(() =>
            __awaiter(this, void 0, void 0, function* () {
              return this.reconnect().catch((error) => {
                this.emit("error", "reconnect", error.message, error);
              });
            })
          );
        });
      }
      onConnectionFailed(errorOrCode) {
        if (this.ws) {
          this.ws.removeAllListeners();
          this.ws.on("error", () => {});
          this.ws.close();
          this.ws = null;
        }
        if (typeof errorOrCode === "number") {
          this.connectionManager.rejectAllAwaiting(
            new errors_1.NotConnectedError(
              `Connection failed with code ${errorOrCode}.`,
              {
                code: errorOrCode,
              }
            )
          );
        } else if (
          errorOrCode === null || errorOrCode === void 0
            ? void 0
            : errorOrCode.message
        ) {
          this.connectionManager.rejectAllAwaiting(
            new errors_1.NotConnectedError(errorOrCode.message, errorOrCode)
          );
        } else {
          this.connectionManager.rejectAllAwaiting(
            new errors_1.NotConnectedError("Connection failed.")
          );
        }
      }
    };
    exports2.Connection = Connection;
  },
});

// node_modules/xrpl/dist/npm/client/partialPayment.js
var require_partialPayment = __commonJS({
  "node_modules/xrpl/dist/npm/client/partialPayment.js"(exports2) {
    "use strict";
    var __importDefault =
      (exports2 && exports2.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.handleStreamPartialPayment = exports2.handlePartialPayment =
      void 0;
    var bignumber_js_1 = __importDefault(require_bignumber());
    var ripple_binary_codec_1 = require_dist2();
    var transactions_1 = require_transactions();
    var utils_1 = require_utils5();
    var WARN_PARTIAL_PAYMENT_CODE = 2001;
    function amountsEqual(amt1, amt2) {
      if (typeof amt1 === "string" && typeof amt2 === "string") {
        return amt1 === amt2;
      }
      if (typeof amt1 === "string" || typeof amt2 === "string") {
        return false;
      }
      const aValue = new bignumber_js_1.default(amt1.value);
      const bValue = new bignumber_js_1.default(amt2.value);
      return (
        amt1.currency === amt2.currency &&
        amt1.issuer === amt2.issuer &&
        aValue.isEqualTo(bValue)
      );
    }
    function isPartialPayment(tx, metadata) {
      var _a;
      if (tx == null || metadata == null || tx.TransactionType !== "Payment") {
        return false;
      }
      let meta = metadata;
      if (typeof meta === "string") {
        if (meta === "unavailable") {
          return false;
        }
        meta = (0, ripple_binary_codec_1.decode)(meta);
      }
      const tfPartial =
        typeof tx.Flags === "number"
          ? (0, utils_1.isFlagEnabled)(
              tx.Flags,
              transactions_1.PaymentFlags.tfPartialPayment
            )
          : (_a = tx.Flags) === null || _a === void 0
          ? void 0
          : _a.tfPartialPayment;
      if (!tfPartial) {
        return false;
      }
      const delivered = meta.delivered_amount;
      const amount = tx.Amount;
      if (delivered === void 0) {
        return false;
      }
      return !amountsEqual(delivered, amount);
    }
    function txHasPartialPayment(response) {
      return isPartialPayment(response.result, response.result.meta);
    }
    function txEntryHasPartialPayment(response) {
      return isPartialPayment(
        response.result.tx_json,
        response.result.metadata
      );
    }
    function accountTxHasPartialPayment(response) {
      const { transactions } = response.result;
      const foo = transactions.some((tx) => isPartialPayment(tx.tx, tx.meta));
      return foo;
    }
    function hasPartialPayment(command, response) {
      switch (command) {
        case "tx":
          return txHasPartialPayment(response);
        case "transaction_entry":
          return txEntryHasPartialPayment(response);
        case "account_tx":
          return accountTxHasPartialPayment(response);
        default:
          return false;
      }
    }
    function handlePartialPayment(command, response) {
      var _a;
      if (hasPartialPayment(command, response)) {
        const warnings =
          (_a = response.warnings) !== null && _a !== void 0 ? _a : [];
        const warning = {
          id: WARN_PARTIAL_PAYMENT_CODE,
          message: "This response contains a Partial Payment",
        };
        warnings.push(warning);
        response.warnings = warnings;
      }
    }
    exports2.handlePartialPayment = handlePartialPayment;
    function handleStreamPartialPayment(stream, log) {
      var _a;
      if (isPartialPayment(stream.transaction, stream.meta)) {
        const warnings =
          (_a = stream.warnings) !== null && _a !== void 0 ? _a : [];
        const warning = {
          id: WARN_PARTIAL_PAYMENT_CODE,
          message: "This response contains a Partial Payment",
        };
        warnings.push(warning);
        stream.warnings = warnings;
        log("Partial payment received", JSON.stringify(stream));
      }
    }
    exports2.handleStreamPartialPayment = handleStreamPartialPayment;
  },
});

// node_modules/xrpl/dist/npm/client/index.js
var require_client = __commonJS({
  "node_modules/xrpl/dist/npm/client/index.js"(exports2) {
    "use strict";
    var __awaiter =
      (exports2 && exports2.__awaiter) ||
      function (thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P
            ? value
            : new P(function (resolve) {
                resolve(value);
              });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done
              ? resolve(result.value)
              : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Client = void 0;
    var eventemitter3_1 = require_eventemitter3();
    var errors_1 = require_errors();
    var flags_1 = require_flags();
    var sugar_1 = require_sugar();
    var autofill_1 = require_autofill();
    var balances_1 = require_balances();
    var getOrderbook_1 = require_getOrderbook();
    var utils_1 = require_utils10();
    var Wallet_1 = require_Wallet();
    var fundWallet_1 = require_fundWallet();
    var connection_1 = require_connection();
    var partialPayment_1 = require_partialPayment();
    function getCollectKeyFromCommand(command) {
      switch (command) {
        case "account_channels":
          return "channels";
        case "account_lines":
          return "lines";
        case "account_objects":
          return "account_objects";
        case "account_tx":
          return "transactions";
        case "account_offers":
        case "book_offers":
          return "offers";
        case "ledger_data":
          return "state";
        default:
          return null;
      }
    }
    function clamp(value, min, max) {
      if (min > max) {
        throw new Error("Illegal clamp bounds");
      }
      return Math.min(Math.max(value, min), max);
    }
    var DEFAULT_FEE_CUSHION = 1.2;
    var DEFAULT_MAX_FEE_XRP = "2";
    var MIN_LIMIT = 10;
    var MAX_LIMIT = 400;
    var NORMAL_DISCONNECT_CODE = 1e3;
    var Client = class extends eventemitter3_1.EventEmitter {
      constructor(server, options = {}) {
        var _a, _b;
        super();
        if (
          typeof server !== "string" ||
          !/wss?(?:\+unix)?:\/\//u.exec(server)
        ) {
          throw new errors_1.ValidationError(
            "server URI must start with `wss://`, `ws://`, `wss+unix://`, or `ws+unix://`."
          );
        }
        this.feeCushion =
          (_a = options.feeCushion) !== null && _a !== void 0
            ? _a
            : DEFAULT_FEE_CUSHION;
        this.maxFeeXRP =
          (_b = options.maxFeeXRP) !== null && _b !== void 0
            ? _b
            : DEFAULT_MAX_FEE_XRP;
        this.connection = new connection_1.Connection(server, options);
        this.connection.on("error", (errorCode, errorMessage, data) => {
          this.emit("error", errorCode, errorMessage, data);
        });
        this.connection.on("reconnect", () => {
          this.connection.on("connected", () => this.emit("connected"));
        });
        this.connection.on("disconnected", (code) => {
          let finalCode = code;
          if (finalCode === connection_1.INTENTIONAL_DISCONNECT_CODE) {
            finalCode = NORMAL_DISCONNECT_CODE;
          }
          this.emit("disconnected", finalCode);
        });
        this.connection.on("ledgerClosed", (ledger) => {
          this.emit("ledgerClosed", ledger);
        });
        this.connection.on("transaction", (tx) => {
          (0, partialPayment_1.handleStreamPartialPayment)(
            tx,
            this.connection.trace
          );
          this.emit("transaction", tx);
        });
        this.connection.on("validationReceived", (validation) => {
          this.emit("validationReceived", validation);
        });
        this.connection.on("manifestReceived", (manifest) => {
          this.emit("manifestReceived", manifest);
        });
        this.connection.on("peerStatusChange", (status) => {
          this.emit("peerStatusChange", status);
        });
        this.connection.on("consensusPhase", (consensus) => {
          this.emit("consensusPhase", consensus);
        });
        this.connection.on("path_find", (path) => {
          this.emit("path_find", path);
        });
      }
      get url() {
        return this.connection.getUrl();
      }
      request(req) {
        return __awaiter(this, void 0, void 0, function* () {
          const response = yield this.connection.request(
            Object.assign(Object.assign({}, req), {
              account: req.account
                ? (0, sugar_1.ensureClassicAddress)(req.account)
                : void 0,
            })
          );
          (0, partialPayment_1.handlePartialPayment)(req.command, response);
          return response;
        });
      }
      requestNextPage(req, resp) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!resp.result.marker) {
            return Promise.reject(
              new errors_1.NotFoundError("response does not have a next page")
            );
          }
          const nextPageRequest = Object.assign(Object.assign({}, req), {
            marker: resp.result.marker,
          });
          return this.request(nextPageRequest);
        });
      }
      on(eventName, listener) {
        return super.on(eventName, listener);
      }
      requestAll(request, collect) {
        return __awaiter(this, void 0, void 0, function* () {
          const collectKey =
            collect !== null && collect !== void 0
              ? collect
              : getCollectKeyFromCommand(request.command);
          if (!collectKey) {
            throw new errors_1.ValidationError(
              `no collect key for command ${request.command}`
            );
          }
          const countTo = request.limit == null ? Infinity : request.limit;
          let count = 0;
          let marker = request.marker;
          const results = [];
          do {
            const countRemaining = clamp(countTo - count, MIN_LIMIT, MAX_LIMIT);
            const repeatProps = Object.assign(Object.assign({}, request), {
              limit: countRemaining,
              marker,
            });
            const singleResponse = yield this.connection.request(repeatProps);
            const singleResult = singleResponse.result;
            if (!(collectKey in singleResult)) {
              throw new errors_1.XrplError(`${collectKey} not in result`);
            }
            const collectedData = singleResult[collectKey];
            marker = singleResult.marker;
            results.push(singleResponse);
            if (Array.isArray(collectedData)) {
              count += collectedData.length;
            }
          } while (Boolean(marker) && count < countTo);
          return results;
        });
      }
      getServerInfo() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          try {
            const response = yield this.request({
              command: "server_info",
            });
            this.networkID =
              (_a = response.result.info.network_id) !== null && _a !== void 0
                ? _a
                : void 0;
            this.buildVersion = response.result.info.build_version;
          } catch (error) {
            console.error(error);
          }
        });
      }
      connect() {
        return __awaiter(this, void 0, void 0, function* () {
          return this.connection.connect().then(() =>
            __awaiter(this, void 0, void 0, function* () {
              yield this.getServerInfo();
              this.emit("connected");
            })
          );
        });
      }
      disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.connection.disconnect();
        });
      }
      isConnected() {
        return this.connection.isConnected();
      }
      autofill(transaction, signersCount) {
        return __awaiter(this, void 0, void 0, function* () {
          const tx = Object.assign({}, transaction);
          (0, autofill_1.setValidAddresses)(tx);
          (0, flags_1.setTransactionFlagsToNumber)(tx);
          const promises = [];
          if (tx.NetworkID == null) {
            tx.NetworkID = (0, autofill_1.txNeedsNetworkID)(this)
              ? this.networkID
              : void 0;
          }
          if (tx.Sequence == null) {
            promises.push((0, autofill_1.setNextValidSequenceNumber)(this, tx));
          }
          if (tx.Fee == null) {
            promises.push(
              (0, autofill_1.calculateFeePerTransactionType)(
                this,
                tx,
                signersCount
              )
            );
          }
          if (tx.LastLedgerSequence == null) {
            promises.push(
              (0, autofill_1.setLatestValidatedLedgerSequence)(this, tx)
            );
          }
          if (tx.TransactionType === "AccountDelete") {
            promises.push((0, autofill_1.checkAccountDeleteBlockers)(this, tx));
          }
          return Promise.all(promises).then(() => tx);
        });
      }
      submit(transaction, opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const signedTx = yield (0, sugar_1.getSignedTx)(
            this,
            transaction,
            opts
          );
          return (0,
          sugar_1.submitRequest)(this, signedTx, opts === null || opts === void 0 ? void 0 : opts.failHard);
        });
      }
      submitAndWait(transaction, opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const signedTx = yield (0, sugar_1.getSignedTx)(
            this,
            transaction,
            opts
          );
          const lastLedger = (0, sugar_1.getLastLedgerSequence)(signedTx);
          if (lastLedger == null) {
            throw new errors_1.ValidationError(
              "Transaction must contain a LastLedgerSequence value for reliable submission."
            );
          }
          const response = yield (0, sugar_1.submitRequest)(
            this,
            signedTx,
            opts === null || opts === void 0 ? void 0 : opts.failHard
          );
          const txHash = utils_1.hashes.hashSignedTx(signedTx);
          return (0,
          sugar_1.waitForFinalTransactionOutcome)(this, txHash, lastLedger, response.result.engine_result);
        });
      }
      prepareTransaction(transaction, signersCount) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.autofill(transaction, signersCount);
        });
      }
      getXrpBalance(address, options = {}) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          const xrpRequest = {
            command: "account_info",
            account: address,
            ledger_index:
              (_a = options.ledger_index) !== null && _a !== void 0
                ? _a
                : "validated",
            ledger_hash: options.ledger_hash,
          };
          const response = yield this.request(xrpRequest);
          return (0, utils_1.dropsToXrp)(response.result.account_data.Balance);
        });
      }
      getBalances(address, options = {}) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          const balances = [];
          let xrpPromise = Promise.resolve(0);
          if (!options.peer) {
            xrpPromise = this.getXrpBalance(address, {
              ledger_hash: options.ledger_hash,
              ledger_index: options.ledger_index,
            });
          }
          const linesRequest = {
            command: "account_lines",
            account: address,
            ledger_index:
              (_a = options.ledger_index) !== null && _a !== void 0
                ? _a
                : "validated",
            ledger_hash: options.ledger_hash,
            peer: options.peer,
            limit: options.limit,
          };
          const linesPromise = this.requestAll(linesRequest);
          yield Promise.all([xrpPromise, linesPromise]).then(
            ([xrpBalance, linesResponses]) => {
              const accountLinesBalance = linesResponses.flatMap((response) =>
                (0, balances_1.formatBalances)(response.result.lines)
              );
              if (xrpBalance !== 0) {
                balances.push({
                  currency: "XRP",
                  value: xrpBalance.toString(),
                });
              }
              balances.push(...accountLinesBalance);
            }
          );
          return balances.slice(0, options.limit);
        });
      }
      getOrderbook(currency1, currency2, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          (0, getOrderbook_1.validateOrderbookOptions)(options);
          const request = (0, getOrderbook_1.createBookOffersRequest)(
            currency1,
            currency2,
            options
          );
          const directOfferResults = yield (0, getOrderbook_1.requestAllOffers)(
            this,
            request
          );
          const reverseOfferResults = yield (0,
          getOrderbook_1.requestAllOffers)(
            this,
            (0, getOrderbook_1.reverseRequest)(request)
          );
          const directOffers = (0, getOrderbook_1.extractOffers)(
            directOfferResults
          );
          const reverseOffers = (0, getOrderbook_1.extractOffers)(
            reverseOfferResults
          );
          const orders = (0, getOrderbook_1.combineOrders)(
            directOffers,
            reverseOffers
          );
          const { buy, sell } = (0, getOrderbook_1.separateBuySellOrders)(
            orders
          );
          return {
            buy: (0, getOrderbook_1.sortAndLimitOffers)(buy, options.limit),
            sell: (0, getOrderbook_1.sortAndLimitOffers)(sell, options.limit),
          };
        });
      }
      getLedgerIndex() {
        return __awaiter(this, void 0, void 0, function* () {
          const ledgerResponse = yield this.request({
            command: "ledger",
            ledger_index: "validated",
          });
          return ledgerResponse.result.ledger_index;
        });
      }
      fundWallet(wallet, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!this.isConnected()) {
            throw new errors_1.RippledError(
              "Client not connected, cannot call faucet"
            );
          }
          const existingWallet = Boolean(wallet);
          const walletToFund =
            wallet && (0, utils_1.isValidClassicAddress)(wallet.classicAddress)
              ? wallet
              : Wallet_1.Wallet.generate();
          const postBody = {
            destination: walletToFund.classicAddress,
            xrpAmount: options.amount,
            usageContext: options.usageContext,
            userAgent: "xrpl.js",
          };
          let startingBalance = 0;
          if (existingWallet) {
            try {
              startingBalance = Number(
                yield this.getXrpBalance(walletToFund.classicAddress)
              );
            } catch (_a) {}
          }
          return (0,
          fundWallet_1.requestFunding)(options, this, startingBalance, walletToFund, postBody);
        });
      }
    };
    exports2.Client = Client;
  },
});

// node_modules/xrpl/dist/npm/models/ledger/Amendments.js
var require_Amendments = __commonJS({
  "node_modules/xrpl/dist/npm/models/ledger/Amendments.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AMENDMENTS_ID = void 0;
    exports2.AMENDMENTS_ID =
      "7DB0788C020F02780A673DC74757F23823FA3014C1866E72CC4CD8B226CD6EF4";
  },
});

// node_modules/xrpl/dist/npm/models/ledger/FeeSettings.js
var require_FeeSettings = __commonJS({
  "node_modules/xrpl/dist/npm/models/ledger/FeeSettings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FEE_SETTINGS_ID = void 0;
    exports2.FEE_SETTINGS_ID =
      "4BC50C9B0D8515D3EAAE1E74B29A95804346C491EE1A95BF25E4AAB854A6A651";
  },
});

// node_modules/xrpl/dist/npm/models/ledger/NegativeUNL.js
var require_NegativeUNL = __commonJS({
  "node_modules/xrpl/dist/npm/models/ledger/NegativeUNL.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NEGATIVE_UNL_ID = void 0;
    exports2.NEGATIVE_UNL_ID =
      "2E8A59AA9D3B5B186B0B9E0F62E6C02587CA74A4D778938E957B6357D364B244";
  },
});

// node_modules/xrpl/dist/npm/models/ledger/RippleState.js
var require_RippleState = __commonJS({
  "node_modules/xrpl/dist/npm/models/ledger/RippleState.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RippleStateFlags = void 0;
    var RippleStateFlags;
    (function (RippleStateFlags2) {
      RippleStateFlags2[(RippleStateFlags2["lsfLowReserve"] = 65536)] =
        "lsfLowReserve";
      RippleStateFlags2[(RippleStateFlags2["lsfHighReserve"] = 131072)] =
        "lsfHighReserve";
      RippleStateFlags2[(RippleStateFlags2["lsfLowAuth"] = 262144)] =
        "lsfLowAuth";
      RippleStateFlags2[(RippleStateFlags2["lsfHighAuth"] = 524288)] =
        "lsfHighAuth";
      RippleStateFlags2[(RippleStateFlags2["lsfLowNoRipple"] = 1048576)] =
        "lsfLowNoRipple";
      RippleStateFlags2[(RippleStateFlags2["lsfHighNoRipple"] = 2097152)] =
        "lsfHighNoRipple";
      RippleStateFlags2[(RippleStateFlags2["lsfLowFreeze"] = 4194304)] =
        "lsfLowFreeze";
      RippleStateFlags2[(RippleStateFlags2["lsfHighFreeze"] = 8388608)] =
        "lsfHighFreeze";
      RippleStateFlags2[(RippleStateFlags2["lsfAMMNode"] = 16777216)] =
        "lsfAMMNode";
    })(RippleStateFlags || (exports2.RippleStateFlags = RippleStateFlags = {}));
  },
});

// node_modules/xrpl/dist/npm/models/ledger/SignerList.js
var require_SignerList = __commonJS({
  "node_modules/xrpl/dist/npm/models/ledger/SignerList.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SignerListFlags = void 0;
    var SignerListFlags;
    (function (SignerListFlags2) {
      SignerListFlags2[(SignerListFlags2["lsfOneOwnerCount"] = 65536)] =
        "lsfOneOwnerCount";
    })(SignerListFlags || (exports2.SignerListFlags = SignerListFlags = {}));
  },
});

// node_modules/xrpl/dist/npm/models/ledger/index.js
var require_ledger = __commonJS({
  "node_modules/xrpl/dist/npm/models/ledger/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SignerListFlags =
      exports2.RippleStateFlags =
      exports2.OfferFlags =
      exports2.NEGATIVE_UNL_ID =
      exports2.FEE_SETTINGS_ID =
      exports2.AMENDMENTS_ID =
      exports2.AccountRootFlags =
        void 0;
    var AccountRoot_1 = require_AccountRoot();
    Object.defineProperty(exports2, "AccountRootFlags", {
      enumerable: true,
      get: function () {
        return AccountRoot_1.AccountRootFlags;
      },
    });
    var Amendments_1 = require_Amendments();
    Object.defineProperty(exports2, "AMENDMENTS_ID", {
      enumerable: true,
      get: function () {
        return Amendments_1.AMENDMENTS_ID;
      },
    });
    var FeeSettings_1 = require_FeeSettings();
    Object.defineProperty(exports2, "FEE_SETTINGS_ID", {
      enumerable: true,
      get: function () {
        return FeeSettings_1.FEE_SETTINGS_ID;
      },
    });
    var NegativeUNL_1 = require_NegativeUNL();
    Object.defineProperty(exports2, "NEGATIVE_UNL_ID", {
      enumerable: true,
      get: function () {
        return NegativeUNL_1.NEGATIVE_UNL_ID;
      },
    });
    var Offer_1 = require_Offer();
    Object.defineProperty(exports2, "OfferFlags", {
      enumerable: true,
      get: function () {
        return Offer_1.OfferFlags;
      },
    });
    var RippleState_1 = require_RippleState();
    Object.defineProperty(exports2, "RippleStateFlags", {
      enumerable: true,
      get: function () {
        return RippleState_1.RippleStateFlags;
      },
    });
    var SignerList_1 = require_SignerList();
    Object.defineProperty(exports2, "SignerListFlags", {
      enumerable: true,
      get: function () {
        return SignerList_1.SignerListFlags;
      },
    });
  },
});

// node_modules/xrpl/dist/npm/models/methods/index.js
var require_methods = __commonJS({
  "node_modules/xrpl/dist/npm/models/methods/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  },
});

// node_modules/xrpl/dist/npm/models/common/index.js
var require_common2 = __commonJS({
  "node_modules/xrpl/dist/npm/models/common/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  },
});

// node_modules/xrpl/dist/npm/models/index.js
var require_models = __commonJS({
  "node_modules/xrpl/dist/npm/models/index.js"(exports2) {
    "use strict";
    var __createBinding =
      (exports2 && exports2.__createBinding) ||
      (Object.create
        ? function (o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);
            if (
              !desc ||
              ("get" in desc
                ? !m.__esModule
                : desc.writable || desc.configurable)
            ) {
              desc = {
                enumerable: true,
                get: function () {
                  return m[k];
                },
              };
            }
            Object.defineProperty(o, k2, desc);
          }
        : function (o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            o[k2] = m[k];
          });
    var __setModuleDefault =
      (exports2 && exports2.__setModuleDefault) ||
      (Object.create
        ? function (o, v) {
            Object.defineProperty(o, "default", { enumerable: true, value: v });
          }
        : function (o, v) {
            o["default"] = v;
          });
    var __importStar =
      (exports2 && exports2.__importStar) ||
      function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    var __exportStar =
      (exports2 && exports2.__exportStar) ||
      function (m, exports3) {
        for (var p in m)
          if (
            p !== "default" &&
            !Object.prototype.hasOwnProperty.call(exports3, p)
          )
            __createBinding(exports3, m, p);
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseAccountRootFlags =
      exports2.setTransactionFlagsToNumber =
      exports2.LedgerEntry =
        void 0;
    exports2.LedgerEntry = __importStar(require_ledger());
    var flags_1 = require_flags();
    Object.defineProperty(exports2, "setTransactionFlagsToNumber", {
      enumerable: true,
      get: function () {
        return flags_1.setTransactionFlagsToNumber;
      },
    });
    Object.defineProperty(exports2, "parseAccountRootFlags", {
      enumerable: true,
      get: function () {
        return flags_1.parseAccountRootFlags;
      },
    });
    __exportStar(require_methods(), exports2);
    __exportStar(require_transactions(), exports2);
    __exportStar(require_common2(), exports2);
  },
});

// node_modules/@xrplf/secret-numbers/dist/utils/index.js
var require_utils12 = __commonJS({
  "node_modules/@xrplf/secret-numbers/dist/utils/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseSecretString =
      exports2.checkChecksum =
      exports2.calculateChecksum =
      exports2.secretToEntropy =
      exports2.entropyToSecret =
      exports2.randomSecret =
      exports2.randomEntropy =
        void 0;
    var utils_1 = require_utils2();
    function randomEntropy() {
      return (0, utils_1.randomBytes)(16);
    }
    exports2.randomEntropy = randomEntropy;
    function calculateChecksum(position, value) {
      return (value * (position * 2 + 1)) % 9;
    }
    exports2.calculateChecksum = calculateChecksum;
    function checkChecksum(position, value, checksum) {
      let normalizedChecksum;
      let normalizedValue;
      if (typeof value === "string") {
        if (value.length !== 6) {
          throw new Error("value must have a length of 6");
        }
        normalizedChecksum = parseInt(value.slice(5), 10);
        normalizedValue = parseInt(value.slice(0, 5), 10);
      } else {
        if (typeof checksum !== "number") {
          throw new Error("checksum must be a number when value is a number");
        }
        normalizedChecksum = checksum;
        normalizedValue = value;
      }
      return (normalizedValue * (position * 2 + 1)) % 9 === normalizedChecksum;
    }
    exports2.checkChecksum = checkChecksum;
    function entropyToSecret(entropy) {
      const len = new Array(Math.ceil(entropy.length / 2));
      const chunks = Array.from(len, (_a, chunk) => {
        const buffChunk = entropy.slice(chunk * 2, (chunk + 1) * 2);
        const no = parseInt((0, utils_1.bytesToHex)(buffChunk), 16);
        const fill = "0".repeat(5 - String(no).length);
        return fill + String(no) + String(calculateChecksum(chunk, no));
      });
      if (chunks.length !== 8) {
        throw new Error("Chucks must have 8 digits");
      }
      return chunks;
    }
    exports2.entropyToSecret = entropyToSecret;
    function randomSecret() {
      return entropyToSecret(randomEntropy());
    }
    exports2.randomSecret = randomSecret;
    function secretToEntropy(secret) {
      return (0, utils_1.concat)(
        secret.map((chunk, i) => {
          const no = Number(chunk.slice(0, 5));
          const checksum = Number(chunk.slice(5));
          if (chunk.length !== 6) {
            throw new Error("Invalid secret: number invalid");
          }
          if (!checkChecksum(i, no, checksum)) {
            throw new Error("Invalid secret part: checksum invalid");
          }
          const hex = `0000${no.toString(16)}`.slice(-4);
          return (0, utils_1.hexToBytes)(hex);
        })
      );
    }
    exports2.secretToEntropy = secretToEntropy;
    function parseSecretString(secret) {
      const normalizedSecret = secret.replace(/[^0-9]/gu, "");
      if (normalizedSecret.length !== 48) {
        throw new Error(
          "Invalid secret string (should contain 8 blocks of 6 digits"
        );
      }
      return Array.from(new Array(8), (_a, index) => {
        return normalizedSecret.slice(index * 6, (index + 1) * 6);
      });
    }
    exports2.parseSecretString = parseSecretString;
  },
});

// node_modules/@xrplf/secret-numbers/dist/schema/Account.js
var require_Account = __commonJS({
  "node_modules/@xrplf/secret-numbers/dist/schema/Account.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Account = void 0;
    var ripple_keypairs_1 = require_dist3();
    var utils_1 = require_utils12();
    var Account = class {
      constructor(secretNumbers) {
        this._account = {
          familySeed: "",
          address: "",
          keypair: {
            publicKey: "",
            privateKey: "",
          },
        };
        if (typeof secretNumbers === "string") {
          this._secret = (0, utils_1.parseSecretString)(secretNumbers);
        } else if (Array.isArray(secretNumbers)) {
          this._secret = secretNumbers;
        } else if (secretNumbers instanceof Uint8Array) {
          this._secret = (0, utils_1.entropyToSecret)(secretNumbers);
        } else {
          this._secret = (0, utils_1.randomSecret)();
        }
        validateLengths(this._secret);
        this.derive();
      }
      getSecret() {
        return this._secret;
      }
      getSecretString() {
        return this._secret.join(" ");
      }
      getAddress() {
        return this._account.address;
      }
      getFamilySeed() {
        return this._account.familySeed;
      }
      getKeypair() {
        return this._account.keypair;
      }
      toString() {
        return this.getSecretString();
      }
      derive() {
        try {
          const entropy = (0, utils_1.secretToEntropy)(this._secret);
          this._account.familySeed = (0, ripple_keypairs_1.generateSeed)({
            entropy,
          });
          this._account.keypair = (0, ripple_keypairs_1.deriveKeypair)(
            this._account.familySeed
          );
          this._account.address = (0, ripple_keypairs_1.deriveAddress)(
            this._account.keypair.publicKey
          );
        } catch (error) {
          let message = "Unknown Error";
          if (error instanceof Error) {
            message = error.message;
          }
          throw new Error(message);
        }
      }
    };
    exports2.Account = Account;
    function validateLengths(secretNumbers) {
      if (secretNumbers.length !== 8) {
        throw new Error("Secret must have 8 numbers");
      }
      secretNumbers.forEach((num) => {
        if (num.length !== 6) {
          throw new Error("Each secret number must be 6 digits");
        }
      });
    }
  },
});

// node_modules/@xrplf/secret-numbers/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/@xrplf/secret-numbers/dist/index.js"(exports2) {
    "use strict";
    var __createBinding =
      (exports2 && exports2.__createBinding) ||
      (Object.create
        ? function (o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);
            if (
              !desc ||
              ("get" in desc
                ? !m.__esModule
                : desc.writable || desc.configurable)
            ) {
              desc = {
                enumerable: true,
                get: function () {
                  return m[k];
                },
              };
            }
            Object.defineProperty(o, k2, desc);
          }
        : function (o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            o[k2] = m[k];
          });
    var __exportStar =
      (exports2 && exports2.__exportStar) ||
      function (m, exports3) {
        for (var p in m)
          if (
            p !== "default" &&
            !Object.prototype.hasOwnProperty.call(exports3, p)
          )
            __createBinding(exports3, m, p);
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_Account(), exports2);
    __exportStar(require_utils12(), exports2);
  },
});

// node_modules/xrpl/dist/npm/Wallet/walletFromSecretNumbers.js
var require_walletFromSecretNumbers = __commonJS({
  "node_modules/xrpl/dist/npm/Wallet/walletFromSecretNumbers.js"(exports2) {
    "use strict";
    var __importDefault =
      (exports2 && exports2.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.walletFromSecretNumbers = void 0;
    var secret_numbers_1 = require_dist4();
    var ECDSA_1 = __importDefault(require_ECDSA());
    var _1 = require_Wallet();
    function walletFromSecretNumbers(secretNumbers, opts) {
      var _a;
      const secret = new secret_numbers_1.Account(
        secretNumbers
      ).getFamilySeed();
      const updatedOpts = {
        masterAddress: void 0,
        algorithm: void 0,
      };
      if (opts === void 0) {
        updatedOpts.algorithm = ECDSA_1.default.secp256k1;
      } else {
        updatedOpts.masterAddress = opts.masterAddress;
        updatedOpts.algorithm =
          (_a = opts.algorithm) !== null && _a !== void 0
            ? _a
            : ECDSA_1.default.secp256k1;
      }
      return _1.Wallet.fromSecret(secret, updatedOpts);
    }
    exports2.walletFromSecretNumbers = walletFromSecretNumbers;
  },
});

// node_modules/xrpl/dist/npm/index.js
var require_npm = __commonJS({
  "node_modules/xrpl/dist/npm/index.js"(exports2) {
    "use strict";
    var __createBinding =
      (exports2 && exports2.__createBinding) ||
      (Object.create
        ? function (o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);
            if (
              !desc ||
              ("get" in desc
                ? !m.__esModule
                : desc.writable || desc.configurable)
            ) {
              desc = {
                enumerable: true,
                get: function () {
                  return m[k];
                },
              };
            }
            Object.defineProperty(o, k2, desc);
          }
        : function (o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            o[k2] = m[k];
          });
    var __exportStar =
      (exports2 && exports2.__exportStar) ||
      function (m, exports3) {
        for (var p in m)
          if (
            p !== "default" &&
            !Object.prototype.hasOwnProperty.call(exports3, p)
          )
            __createBinding(exports3, m, p);
      };
    var __importDefault =
      (exports2 && exports2.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.rfc1751MnemonicToKey =
      exports2.keyToRFC1751Mnemonic =
      exports2.walletFromSecretNumbers =
      exports2.Wallet =
      exports2.ECDSA =
      exports2.Client =
        void 0;
    var client_1 = require_client();
    Object.defineProperty(exports2, "Client", {
      enumerable: true,
      get: function () {
        return client_1.Client;
      },
    });
    __exportStar(require_models(), exports2);
    __exportStar(require_utils10(), exports2);
    var ECDSA_1 = require_ECDSA();
    Object.defineProperty(exports2, "ECDSA", {
      enumerable: true,
      get: function () {
        return __importDefault(ECDSA_1).default;
      },
    });
    __exportStar(require_errors(), exports2);
    var Wallet_1 = require_Wallet();
    Object.defineProperty(exports2, "Wallet", {
      enumerable: true,
      get: function () {
        return Wallet_1.Wallet;
      },
    });
    var walletFromSecretNumbers_1 = require_walletFromSecretNumbers();
    Object.defineProperty(exports2, "walletFromSecretNumbers", {
      enumerable: true,
      get: function () {
        return walletFromSecretNumbers_1.walletFromSecretNumbers;
      },
    });
    var rfc1751_1 = require_rfc1751();
    Object.defineProperty(exports2, "keyToRFC1751Mnemonic", {
      enumerable: true,
      get: function () {
        return rfc1751_1.keyToRFC1751Mnemonic;
      },
    });
    Object.defineProperty(exports2, "rfc1751MnemonicToKey", {
      enumerable: true,
      get: function () {
        return rfc1751_1.rfc1751MnemonicToKey;
      },
    });
    __exportStar(require_signer(), exports2);
  },
});

// index.js
var import_xrpl2 = __toESM(require_npm(), 1);

// src/cli.js
var NETWORKS = {
  mainnet1:
    "wss://sparkling-winter-wind.xrp-mainnet.quiknode.pro/8c9ff2d4ce407cd3f6a0b3ba5484963ee5cad831/",
  mainnet2: "wss://xrplcluster.com/",
  testnet: "wss://s.altnet.rippletest.net:51233",
};

var HEX_CURRENCY_REGEX = /^[A-F0-9]{40}$/i;
var ASCII_PRINTABLE_REGEX = /^[\x20-\x7E]+$/;
var THREE_CHAR_CODE_REGEX = /^[A-Z0-9]{3}$/;
function parseArguments() {
  const args = process.argv.slice(2);
  const parsed = {
    issuerSecret: null,
    holderSecret: null,
    holderAddress: null,
    currencyCode: null,
    currencyDisplay: null,
    currencyIsHex: false,
    amount: null,
    limit: null,
    freeze: false,
    network: NETWORKS.testnet,
    verbose: false,
  };
  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    const value = args[i + 1];
    switch (arg) {
      case "--issuer-secret":
        parsed.issuerSecret = value;
        i++;
        break;
      case "--holder-secret":
        parsed.holderSecret = value;
        i++;
        break;
      case "--holder-address":
        parsed.holderAddress = value;
        i++;
        break;
      case "--currency-code":
        parsed.currencyCode = value;
        i++;
        break;
      case "--amount":
        parsed.amount = value;
        i++;
        break;
      case "--limit":
        parsed.limit = value;
        i++;
        break;
      case "--freeze":
        parsed.freeze = value === "true";
        i++;
        break;
      case "--network":
        const networkKey = value?.toLowerCase();
        parsed.network = NETWORKS[networkKey] || NETWORKS.testnet;
        i++;
        break;
      case "--verbose":
        parsed.verbose = true;
        break;
      case "--help":
      case "-h":
        printHelp();
        process.exit(0);
      default:
        if (arg.startsWith("--")) {
          console.error(`Unknown argument: ${arg}`);
          printHelp();
          process.exit(1);
        }
    }
  }
  return parsed;
}
function validateInputs(args) {
  const errors = [];
  if (!args.issuerSecret) {
    errors.push("--issuer-secret is required");
  }
  if (!args.holderSecret) {
    errors.push("--holder-secret is required");
  }
  if (!args.currencyCode) {
    errors.push("--currency-code is required");
  } else {
    try {
      const { normalized, display, isHex } = normalizeCurrencyCode(
        args.currencyCode
      );
      args.currencyCode = normalized;
      args.currencyDisplay = display;
      args.currencyIsHex = isHex;
    } catch (currencyError) {
      errors.push(currencyError.message);
    }
  }
  if (!args.amount) {
    errors.push("--amount is required");
  } else if (isNaN(parseFloat(args.amount)) || parseFloat(args.amount) <= 0) {
    errors.push("--amount must be a positive number");
  }
  if (!args.limit) {
    errors.push("--limit is required");
  } else if (isNaN(parseFloat(args.limit)) || parseFloat(args.limit) <= 0) {
    errors.push("--limit must be a positive number");
  }
  if (
    args.amount &&
    args.limit &&
    parseFloat(args.amount) > parseFloat(args.limit)
  ) {
    errors.push("--amount cannot exceed --limit");
  }
  if (errors.length > 0) {
    console.error("\nValidation Errors:");
    errors.forEach((err) => console.error(`  - ${err}`));
    console.error("");
    printHelp();
    process.exit(1);
  }
}
function normalizeCurrencyCode(codeInput) {
  const trimmed = (codeInput ?? "").trim();
  if (!trimmed) {
    throw new Error("--currency-code cannot be empty");
  }
  if (HEX_CURRENCY_REGEX.test(trimmed)) {
    return {
      normalized: trimmed.toUpperCase(),
      display: trimmed.toUpperCase(),
      isHex: true,
    };
  }
  if (!ASCII_PRINTABLE_REGEX.test(trimmed)) {
    throw new Error("--currency-code must contain printable ASCII characters");
  }
  const upper = trimmed.toUpperCase();
  if (THREE_CHAR_CODE_REGEX.test(upper)) {
    return {
      normalized: upper,
      display: upper,
      isHex: false,
    };
  }
  if (upper.length > 20) {
    throw new Error(
      "--currency-code custom names must be 20 characters or fewer before encoding"
    );
  }
  let hex = "";
  for (const char of upper) {
    hex += char.charCodeAt(0).toString(16).padStart(2, "0");
  }
  const normalizedHex = hex.toUpperCase().padEnd(40, "0");
  return {
    normalized: normalizedHex,
    display: trimmed,
    isHex: true,
  };
}
function printHelp() {
  console.log(`
XRPL Token Issuer - CLI Tool

USAGE:
  node index.js [OPTIONS]

REQUIRED OPTIONS:
  --issuer-secret <seed>      Issuer's private key (seed format)
  --holder-secret <seed>      Holder's private key (seed format) 
  --holder-address rXXXXXXXXXXXXXXXXXXXXXXXXXXXX   (mutually exclusive with --holder-secret)
  --currency-code <code>      3-character currency code (e.g., USD, EUR, BTC)
  --amount <number>           Amount of tokens to issue
  --limit <number>            Trust limit (maximum holder can hold)

OPTIONAL OPTIONS:
  --freeze <true|false>       Enable trustline freeze (default: false)
  --network <name>            Network: testnet, devnet, mainnet (default: testnet)
  --verbose                   Enable detailed transaction logging
  --help, -h                  Show this help message

NOTES:
  \u2022 Currency code accepts either:
      - 3 alphanumeric characters (e.g., USD, BTC)
      - 1-20 printable characters that will be encoded to 40-hex bytes
      - A 40-character hex string (pre-encoded XRPL currency code)
  \u2022 Trust limit must be greater than or equal to the issued amount

EXAMPLES:
  # Issue 1000 USD tokens on testnet
  node index.js \\
    --issuer-secret sEdT... \\
    --holder-secret sEdS... \\
    --currency-code USD \\
    --amount 1000 \\
    --limit 10000

  # Issue tokens with freeze enabled
  node index.js \\
    --issuer-secret sEdT... \\
    --holder-secret sEdS... \\
    --currency-code BTC \\
    --amount 5 \\
    --limit 100 \\
    --freeze true \\
    --verbose

  # Issue tokens with a custom name encoded to hex
  node index.js \\
    --issuer-secret sEdT... \\
    --holder-secret sEdS... \\
    --currency-code XPONETN \\
    --amount 100_000 \\
    --limit 200_000

SECURITY WARNING:
  Never share or commit your private keys!
  Use this tool carefully, especially on mainnet.
  
  `);
}

// src/transactions.js
var import_xrpl = __toESM(require_npm(), 1);

// src/utils.js
var COLORS = {
  reset: "\x1B[0m",
  red: "\x1B[31m",
  green: "\x1B[32m",
  yellow: "\x1B[33m",
  blue: "\x1B[34m",
  cyan: "\x1B[36m",
};
var logger = {
  info: (message) => {
    console.log(`${COLORS.blue}[INFO]${COLORS.reset} ${message}`);
  },
  success: (message) => {
    console.log(`${COLORS.green}[SUCCESS]${COLORS.reset} ${message}`);
  },
  error: (message) => {
    console.error(`${COLORS.red}[ERROR]${COLORS.reset} ${message}`);
  },
  warn: (message) => {
    console.warn(`${COLORS.yellow}[WARN]${COLORS.reset} ${message}`);
  },
  debug: (message) => {
    console.log(`${COLORS.cyan}[DEBUG]${COLORS.reset} ${message}`);
  },
};

// src/transactions.js
async function createTrustline({
  client,
  holderWallet, // nullable
  holderAddress,
  issuerAddress,
  currencyCode,
  limit,
}) {
  const currencyHex = toCurrencyHex(currencyCode);

  // Helper: check whether a line already exists from holder -> issuer for this currency
  async function trustlineExists() {
    const resp = await client.request({
      command: "account_lines",
      account: holderAddress,
      peer: issuerAddress,
    });
    const lines = resp.result?.lines || [];
    return lines.some((l) => (l.currency || "").toUpperCase() === currencyHex);
  }

  if (!holderWallet) {
    // Issue-only mode: we cannot create the holder's TrustSet without their key.
    const exists = await trustlineExists();
    if (!exists) {
      throw new Error(
        `Trustline not found/authorized: holder ${holderAddress} -> issuer ${issuerAddress} for ${currencyHex}. ` +
          `Have the investor sign a TrustSet first (Crossmark/Xumm/Xaman).`
      );
    }
    return { mode: "verified" };
  }

  // Classic mode: we can sign as the holder and create the line if missing.
  const already = await trustlineExists();
  if (already) return { mode: "verified" };

  const tx = {
    TransactionType: "TrustSet",
    Account: holderWallet.address,
    LimitAmount: {
      currency: currencyHex,
      issuer: issuerAddress,
      value: String(limit),
    },
    // Add Flags here if you need them, e.g. tfSetNoRipple, tfSetAuth, etc.
    // Flags: 0x00020000 // tfSetNoRipple (example)
  };

  const prepared = await client.autofill(tx);
  const signed = holderWallet.sign(prepared);
  const result = await client.submitAndWait(signed.tx_blob);

  // Optional: sanity check the line now exists
  const ok = await trustlineExists();
  if (!ok) {
    throw new Error(
      "Trustline submission succeeded but verification failed. Check ledger state."
    );
  }

  return { mode: "created", txResult: result };
}

async function issueTokens(
  client,
  issuerWallet,
  holderAddress,
  currencyCode,
  amount,
  verbose = false
) {
  try {
    const payment = {
      TransactionType: "Payment",
      Account: issuerWallet.address,
      Destination: holderClassic, // <-- important
      Amount: {
        currency: currencyHex,
        issuer: issuerWallet.address,
        value: String(args.amount),
      },
    };
    if (verbose) {
      logger.debug("Payment Transaction:");
      logger.debug(JSON.stringify(payment, null, 2));
    }
    const prepared = await client.autofill(payment);
    const signed = issuerWallet.sign(prepared);
    if (verbose) {
      logger.debug("Signed Transaction:");
      logger.debug(JSON.stringify(signed, null, 2));
    }
    const result = await client.submitAndWait(signed.tx_blob);
    if (result.result.meta.TransactionResult !== "tesSUCCESS") {
      throw new Error(
        `Payment failed: ${result.result.meta.TransactionResult}`
      );
    }
    return {
      hash: result.result.hash,
      result: result.result.meta.TransactionResult,
    };
  } catch (error) {
    throw new Error(`Failed to issue tokens: ${error.message}`);
  }
}
async function freezeTrustline({
  client,
  issuerWallet,
  holderAddress,
  currencyCode,
  freeze = true,
}) {
  const currencyHex = toCurrencyHex(currencyCode);
  const TF_SET_FREEZE = 0x00100000;
  const TF_CLEAR_FREEZE = 0x00200000;

  const tx = {
    TransactionType: "TrustSet",
    Account: issuerWallet.address,
    Flags: freeze ? TF_SET_FREEZE : TF_CLEAR_FREEZE,
    // IMPORTANT: when the ISSUER freezes, LimitAmount.issuer = HOLDER address
    LimitAmount: {
      currency: currencyHex,
      issuer: holderAddress,
      value: "0",
    },
  };

  const prepared = await client.autofill(tx);
  const signed = issuerWallet.sign(prepared);
  return client.submitAndWait(signed.tx_blob);
}

/* --------- helpers ---------- */

/**
 * Convert 320 ASCII currency to 160-bit hex (padded), or pass through 40-hex.
 * @param {string} code
 * @returns {string} 40-hex uppercase
 */
function toCurrencyHex(code) {
  const hex40 = /^[A-Fa-f0-9]{40}$/;
  if (hex40.test(code)) return code.toUpperCase();
  const buf = Buffer.alloc(20); // 160-bit
  Buffer.from(String(code), "utf8").copy(buf);
  return buf.toString("hex").toUpperCase();
}
// index.js
async function main() {
  try {
    const args = parseArguments();
    if (args.holderSecret && args.holderAddress) {
      throw new Error("Provide only one: --holder-secret OR --holder-address");
    }
    if (!args.holderSecret && !args.holderAddress) {
      throw new Error(
        "Missing investor credential: pass --holder-secret or --holder-address"
      );
    }
    const issuerOnly = !!args.holderAddress && !args.holderSecret;
    if (!issuerOnly && !args.limit) {
      throw new Error(
        "Missing --limit (needed when creating trustline in classic mode)"
      );
    }

    validateInputs(args);
    const currencyLabel = args.currencyDisplay ?? args.currencyCode;
    logger.info("=".repeat(60));
    logger.info("XRPL Token Issuer");
    logger.info("=".repeat(60));
    logger.info(`Network: ${args.network}`);
    logger.info(`Currency Code: ${currencyLabel}`);
    if (args.currencyIsHex && args.currencyDisplay) {
      logger.info(`Normalized Hex Code: ${args.currencyCode}`);
    }
    logger.info(`Amount to Issue: ${args.amount}`);
    logger.info(`Trust Limit: ${args.limit}`);
    logger.info(`Freeze Enabled: ${args.freeze ? "Yes" : "No"}`);
    logger.info("=".repeat(60));
    logger.info("\n[1/4] Connecting to XRPL network...");
    const client = new import_xrpl2.default.Client(args.network);
    await client.connect();
    logger.success(`Connected to ${args.network}`);
    /*const issuerWallet = import_xrpl2.default.Wallet.fromSeed(
      args.issuerSecret
    );
    logger.info(`Issuer Address: ${issuerWallet.address}`);
    const holderWallet = holderSecret
      ? xrpl.Wallet.fromSeed(holderSecret)
      : null;
    const holderClassic = holderWallet ? holderWallet.address : holderAddress;

    if (!holderClassic) {
      throw new Error("Provide either holderSecret OR holderAddress");
    }*/

    //logger.info(`Holder Address: ${holderWallet}`);
    //logger.info(`Holder Classic: ${holderClassic}`);
    const issuerWallet = xrpl.Wallet.fromSeed(args.issuerSecret);
    const holderWallet = args.holderSecret
      ? xrpl.Wallet.fromSeed(args.holderSecret)
      : null;
    const holderClassic = holderWallet
      ? holderWallet.address
      : args.holderAddress;

    if (!holderClassic)
      throw new Error("Provide either holderSecret or holderAddress");

    logger.info(`Issuer Address: ${issuerWallet.address}`);
    logger.info(`Holder Classic: ${holderClassic}`);

if (holderWallet) logger.info("[2/4] Creating trustline...");
else logger.info("[2/4] Verifying trustline exists...");
    await createTrustline({
      client,
      holderWallet, // can be null
      holderAddress: holderClassic,
      issuerAddress: issuerWallet.address,
      currencyCode: args.currencyCode,
      limit: args.limit, // ignored in issuer-only mode
    });

    logger.success(`Trustline created! Hash: ${trustResult.hash}`);
    logger.info(`Explorer: https://testnet.xrpl.org/transactions/${trustResult.hash}
`);
    logger.info("[3/4] Issuing tokens...");
    const issueResult = await issueTokens(
      client,
      issuerWallet,
      holderWallet.address,
      args.currencyCode,
      args.amount,
      args.verbose
    );
    logger.success(`Tokens issued! Hash: ${issueResult.hash}`);
    logger.info(`Explorer: https://testnet.xrpl.org/transactions/${issueResult.hash}
`);
      if (args.freeze === true || args.freeze === "true") {
         logger.info("[4/4] Applying trustline freeze...");
        await freezeTrustline({
          client,
          issuerWallet,
          holderAddress: holderClassic, // <-- important
          currencyCode: args.currencyCode,
          freeze: true,
        });
      }
      logger.success(`Trustline frozen! Hash: ${freezeResult.hash}`);
      logger.info(`Explorer: https://testnet.xrpl.org/transactions/${freezeResult.hash}
`);
    } else {
      logger.info("[4/4] Skipping freeze (not enabled)\n");
    }
    await client.disconnect();
    logger.info("=".repeat(60));
    logger.success("All operations completed successfully!");
    logger.info("=".repeat(60));
  } catch (error) {
    logger.error(`
Error: ${error.message}`);
    if (error.data) {
      logger.error(`Details: ${JSON.stringify(error.data, null, 2)}`);
    }
    process.exit(1);
  }
}
main();
/*! Bundled license information:

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/base/lib/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/utils.js:
@noble/curves/abstract/modular.js:
@noble/curves/abstract/curve.js:
@noble/curves/abstract/weierstrass.js:
@noble/curves/_shortw_utils.js:
@noble/curves/secp256k1.js:
@noble/curves/abstract/edwards.js:
@noble/curves/abstract/montgomery.js:
@noble/curves/ed25519.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/bip32/lib/index.js:
  (*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) *)

@scure/bip39/index.js:
  (*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) *)
*/
